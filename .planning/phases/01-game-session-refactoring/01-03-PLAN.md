---
phase: 01-game-session-refactoring
plan: 03
type: execute
---

<objective>
Extract state history and debug functionality (~360 lines) from GameSession into focused classes.

Purpose: Time travel debugging (getStateAtAction, getStateDiff) and debug deck manipulation are distinct developer tools. Extracting them clarifies GameSession's core responsibility.

Output: New `state-history.ts` and `debug-controller.ts` files, GameSession delegating to them.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-game-session-refactoring/01-01-SUMMARY.md
@.planning/phases/01-game-session-refactoring/01-02-SUMMARY.md
@packages/session/src/game-session.ts
@packages/session/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StateHistory class</name>
  <files>packages/session/src/state-history.ts</files>
  <action>
Create StateHistory class to encapsulate time travel and undo functionality.

Extract from GameSession:
- getStateAtAction() (lines 446-488) - replay to specific action index
- getStateDiff() (lines 494-596) - compute element diff between states
- getActionTraces() (lines 602-656) - debug action availability
- undoToTurnStart() (lines 795-865) - undo current turn
- rewindToAction() (lines 872-936) - rewind to arbitrary point

StateHistory needs:
- Constructor taking: GameClass, storedState reference, runner reference
- Callbacks for: replaceRunner(), save(), broadcast()
- Access to storedState.actionHistory, gameType, playerCount, playerNames, seed, gameOptions

Methods that modify state (undoToTurnStart, rewindToAction) need to:
- Create new GameRunner via replay
- Call replaceRunner callback to update GameSession's runner
- Call save/broadcast callbacks

Note: getActionTraces uses buildActionTraces from utils.ts - keep that import.
Note: undoToTurnStart uses computeUndoInfo from utils.ts - keep that import.
  </action>
  <verify>npx tsc --noEmit in packages/session compiles without errors</verify>
  <done>StateHistory class exists with time travel and undo methods, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 2: Create DebugController class</name>
  <files>packages/session/src/debug-controller.ts</files>
  <action>
Create DebugController class for debug deck manipulation commands.

Extract from GameSession (lines 938-1017):
- executeDebugCommand()
- moveCardToTop()
- reorderCard()
- transferCard()
- shuffleDeck()

DebugController needs:
- Constructor taking: runner reference, broadcast callback
- Access to runner.game for executeCommand

These methods use executeCommand from @boardsmith/engine - keep that import.
All methods call broadcast() after successful command execution.

This is a simple extraction - methods are self-contained.
  </action>
  <verify>npx tsc --noEmit in packages/session compiles without errors</verify>
  <done>DebugController class exists with debug manipulation methods, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 3: Wire into GameSession</name>
  <files>packages/session/src/game-session.ts</files>
  <action>
Update GameSession to use StateHistory and DebugController:

1. Add #stateHistory: StateHistory field
2. Add #debugController: DebugController field
3. Initialize both in constructor
4. Also initialize in restore() factory

Replace implementations with delegations:
- getStateAtAction() -> this.#stateHistory.getStateAtAction(...)
- getStateDiff() -> this.#stateHistory.getStateDiff(...)
- getActionTraces() -> this.#stateHistory.getActionTraces(...)
- undoToTurnStart() -> this.#stateHistory.undoToTurnStart(...)
- rewindToAction() -> this.#stateHistory.rewindToAction(...)
- executeDebugCommand() -> this.#debugController.executeDebugCommand(...)
- moveCardToTop() -> this.#debugController.moveCardToTop(...)
- reorderCard() -> this.#debugController.reorderCard(...)
- transferCard() -> this.#debugController.transferCard(...)
- shuffleDeck() -> this.#debugController.shuffleDeck(...)

After reloadWithCurrentRules(), update handlers with new runner reference.
After undoToTurnStart/rewindToAction succeed, GameSession's #runner is replaced via callback.
  </action>
  <verify>npm test in packages/session - all existing tests pass</verify>
  <done>GameSession delegates to StateHistory and DebugController, all tests pass, GameSession reduced by ~360 more lines</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` in packages/session succeeds
- [ ] `npm test` in packages/session passes all tests
- [ ] StateHistory.ts exists (~280 lines)
- [ ] DebugController.ts exists (~80 lines)
- [ ] GameSession.ts reduced by ~360 lines from plan 01-02 state
- [ ] No changes to public API signatures
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- State history and debug logic fully extracted
- Existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/01-game-session-refactoring/01-03-SUMMARY.md`
</output>
