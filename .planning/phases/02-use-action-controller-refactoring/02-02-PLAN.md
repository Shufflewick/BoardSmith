---
phase: 02-use-action-controller-refactoring
plan: 02
type: execute
---

<objective>
Extract selection state management into useSelectionState composable.

Purpose: Isolate selection-related state and methods into a focused composable, reducing useActionController complexity by ~400 lines.
Output: Working useSelectionState.ts composable with useActionController delegating to it.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-use-action-controller-refactoring/02-ANALYSIS.md
@.planning/phases/02-use-action-controller-refactoring/02-01-SUMMARY.md

# Target files
@packages/ui/src/composables/useActionController.ts

# Phase 1 patterns for reference
@packages/session/src/selection-handler.ts
@packages/session/src/pending-action-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSelectionState composable</name>
  <files>packages/ui/src/composables/useSelectionState.ts</files>
  <action>
Create useSelectionState.ts with:

**Options interface:**
```typescript
interface UseSelectionStateOptions {
  currentArgs: Ref<Record<string, unknown>>;
  actionSnapshot: Ref<ActionStateSnapshot | null>;
  currentActionMeta: ComputedRef<ActionMetadata | undefined>;
  getAutoFill: () => boolean;
  onSelectionFilled?: (name: string, value: unknown) => void;
}
```

**Extract from useActionController:**
- State: (uses shared refs passed in)
- Helper functions:
  - findDisplayForValue
  - getChoices
  - getCurrentChoices
  - getValidElements
  - selectionNeedsInput
  - validateSelection
- Methods:
  - fill (non-repeating part only)
  - skip
  - clear
  - getCollectedSelection
  - getCollectedSelections
- Computed:
  - currentSelection (needs enrichValidElements helper)
  - isReady

**Pattern:** Composable receives shared refs from parent, operates on them, returns methods and computed values. Similar to Phase 1 callback pattern but with Vue reactivity.

**Do NOT extract:**
- Types (keep in useActionController for public API)
- repeatingState handling (complex, keep in parent)
- fetchChoicesForSelection (requires server communication)

Return type:
```typescript
interface UseSelectionStateReturn {
  currentSelection: ComputedRef<SelectionMetadata | null>;
  validElements: ComputedRef<ValidElement[]>;
  isReady: ComputedRef<boolean>;
  fill: (name: string, value: unknown) => ValidationResult;
  skip: (name: string) => void;
  clear: (name: string) => void;
  getChoices: (selection: SelectionMetadata) => Array<{value: unknown; display: string}>;
  getCurrentChoices: () => Array<{value: unknown; display: string}>;
  getValidElements: (selection: SelectionMetadata) => ValidElement[];
  getCollectedSelection: (name: string) => CollectedSelection | undefined;
  getCollectedSelections: () => Array<CollectedSelection & { name: string }>;
}
```
  </action>
  <verify>File created, no TypeScript errors in isolation</verify>
  <done>useSelectionState.ts exists with all extracted functions</done>
</task>

<task type="auto">
  <name>Task 2: Wire useSelectionState into useActionController</name>
  <files>packages/ui/src/composables/useActionController.ts</files>
  <action>
Integrate useSelectionState:

1. Import useSelectionState
2. Create instance after state setup:
   ```typescript
   const selectionState = useSelectionState({
     currentArgs,
     actionSnapshot,
     currentActionMeta,
     getAutoFill,
   });
   ```
3. Remove extracted functions from useActionController body
4. Use selectionState methods/computed values where they were used
5. Update fill() to:
   - Check for repeating selection first
   - Delegate to selectionState.fill() for non-repeating
   - Handle fetchChoicesForSelection for next selection
6. Expose selectionState properties in return object

Keep the public API unchanged - same return type signature.

**Critical:** The async fill() in useActionController wraps the sync selectionState.fill() and adds:
- Repeating selection handling
- fetchChoicesForSelection for next selection
- Auto-fill check after fetch
  </action>
  <verify>npm run build passes, npm test passes for useActionController tests</verify>
  <done>useActionController uses useSelectionState, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add architecture comment to useActionController</name>
  <files>packages/ui/src/composables/useActionController.ts</files>
  <action>
Add architecture comment after the opening docblock (before imports):

```typescript
/**
 * ARCHITECTURE
 *
 * useActionController is composed of focused composables:
 * - useSelectionState: Selection validation, choice resolution, collected values
 * - (future) useFollowUp: FollowUp action chaining
 * - (future) useActionExecution: Server communication, execution state
 *
 * This composable orchestrates the others and handles:
 * - Action start/cancel lifecycle
 * - Repeating selection state machine
 * - Server choice fetching
 * - Auto-fill/auto-execute watchers
 */
```

This documents the decomposition pattern for future maintainers.
  </action>
  <verify>Comment present at top of file</verify>
  <done>Architecture documentation added</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] useSelectionState.ts created with extracted code
- [ ] useActionController imports and uses useSelectionState
- [ ] `npm run build` passes without errors
- [ ] `npm test packages/ui` passes all tests
- [ ] Public API unchanged (same exports, same return type)
</verification>

<success_criteria>

- useSelectionState composable extracted
- useActionController delegating to it
- All 442 tests pass
- Build succeeds
- Architecture comment added
</success_criteria>

<output>
After completion, create `.planning/phases/02-use-action-controller-refactoring/02-02-SUMMARY.md`
</output>
