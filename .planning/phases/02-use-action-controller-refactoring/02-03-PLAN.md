---
phase: 02-use-action-controller-refactoring
plan: 03
type: execute
---

<objective>
Extract followUp handling logic into useFollowUp composable.

Purpose: Isolate followUp action chaining logic into a focused composable, reducing useActionController complexity by ~250 lines.
Output: Working useFollowUp.ts composable with useActionController delegating to it.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-use-action-controller-refactoring/02-ANALYSIS.md
@.planning/phases/02-use-action-controller-refactoring/02-02-SUMMARY.md

# Target files
@packages/ui/src/composables/useActionController.ts
@packages/ui/src/composables/useSelectionState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFollowUp composable</name>
  <files>packages/ui/src/composables/useFollowUp.ts</files>
  <action>
Create useFollowUp.ts with:

**Options interface:**
```typescript
interface UseFollowUpOptions {
  currentAction: Ref<string | null>;
  currentArgs: Ref<Record<string, unknown>>;
  actionSnapshot: Ref<ActionStateSnapshot | null>;
  getActionMetadata: (name: string) => ActionMetadata | undefined;
  getAutoFill: () => boolean;
  isExecuting: Ref<boolean>;
  clearArgs: () => void;
  clearAdvancedState: () => void;
  fetchChoicesForSelection: (name: string) => Promise<void>;
  selectionState: UseSelectionStateReturn;
}
```

**Extract from useActionController:**
- State:
  - pendingFollowUp ref
- Helper functions:
  - getDisplayFromValue (for followUp display extraction)
- Methods:
  - startFollowUp (full implementation)
  - getNextSelection (needed by startFollowUp for auto-fill chaining)

**Return type:**
```typescript
interface UseFollowUpReturn {
  pendingFollowUp: Ref<boolean>;
  startFollowUp: (
    actionName: string,
    initialArgs?: Record<string, unknown>,
    providedMetadata?: ActionMetadata,
    displayOverrides?: Record<string, string>
  ) => Promise<void>;
  scheduleFollowUp: (followUp: FollowUpAction) => void;
}
```

**Add scheduleFollowUp method:**
```typescript
function scheduleFollowUp(followUp: FollowUpAction): void {
  pendingFollowUp.value = true;
  setTimeout(async () => {
    try {
      await startFollowUp(
        followUp.action,
        followUp.args ?? {},
        followUp.metadata,
        followUp.display
      );
    } finally {
      pendingFollowUp.value = false;
    }
  }, 0);
}
```

This consolidates the setTimeout pattern used in execute() and executeCurrentAction().
  </action>
  <verify>File created, no TypeScript errors in isolation</verify>
  <done>useFollowUp.ts exists with all extracted functions</done>
</task>

<task type="auto">
  <name>Task 2: Wire useFollowUp into useActionController</name>
  <files>packages/ui/src/composables/useActionController.ts</files>
  <action>
Integrate useFollowUp:

1. Import useFollowUp
2. Create instance after selectionState setup:
   ```typescript
   const followUpState = useFollowUp({
     currentAction,
     currentArgs,
     actionSnapshot,
     getActionMetadata,
     getAutoFill,
     isExecuting,
     clearArgs,
     clearAdvancedState,
     fetchChoicesForSelection,
     selectionState,
   });
   ```
3. Remove extracted functions from useActionController body:
   - pendingFollowUp ref (now from followUpState)
   - getDisplayFromValue
   - startFollowUp
   - getNextSelection (moved to useFollowUp, may need to export for reuse)
4. Update execute() and executeCurrentAction():
   - Replace setTimeout + startFollowUp with followUpState.scheduleFollowUp(result.followUp)
   - Remove pendingFollowUp.value = true (now in scheduleFollowUp)
5. Expose followUpState properties in return object

**Critical:** Keep the suppressNextWatcherFetch flag in useActionController since it coordinates between start/startFollowUp and the watcher.

Update architecture comment to reflect useFollowUp extraction.
  </action>
  <verify>npm run build passes, npm test passes for useActionController tests</verify>
  <done>useActionController uses useFollowUp, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] useFollowUp.ts created with extracted code
- [ ] useActionController imports and uses useFollowUp
- [ ] `npm run build` passes without errors
- [ ] `npm test packages/ui` passes all tests
- [ ] followUp functionality works (test with followUp action if available)
</verification>

<success_criteria>

- useFollowUp composable extracted
- useActionController delegating to it
- All tests pass
- Build succeeds
- Architecture comment updated
</success_criteria>

<output>
After completion, create `.planning/phases/02-use-action-controller-refactoring/02-03-SUMMARY.md`
</output>
