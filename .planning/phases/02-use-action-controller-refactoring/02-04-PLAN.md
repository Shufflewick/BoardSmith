---
phase: 02-use-action-controller-refactoring
plan: 04
type: execute
---

<objective>
Extract action execution state and verify complete refactoring.

Purpose: Complete the composable decomposition by extracting execution logic, then verify the entire refactoring.
Output: Working useActionExecution.ts composable, verified complete refactoring.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-use-action-controller-refactoring/02-ANALYSIS.md
@.planning/phases/02-use-action-controller-refactoring/02-03-SUMMARY.md

# Target files
@packages/ui/src/composables/useActionController.ts
@packages/ui/src/composables/useSelectionState.ts
@packages/ui/src/composables/useFollowUp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useActionExecution composable</name>
  <files>packages/ui/src/composables/useActionExecution.ts</files>
  <action>
Create useActionExecution.ts with:

**Options interface:**
```typescript
interface UseActionExecutionOptions {
  sendAction: (actionName: string, args: Record<string, unknown>) => Promise<ActionResult>;
  currentAction: Ref<string | null>;
  currentArgs: Ref<Record<string, unknown>>;
  actionSnapshot: Ref<ActionStateSnapshot | null>;
  getActionMetadata: (name: string) => ActionMetadata | undefined;
  getAutoFill: () => boolean;
  selectionState: UseSelectionStateReturn;
  followUpState: UseFollowUpReturn;
  clearArgs: () => void;
  clearAdvancedState: () => void;
}
```

**Extract from useActionController:**
- State:
  - isExecuting ref
  - lastError ref
- Helper functions:
  - buildServerArgs
- Methods:
  - execute
  - executeCurrentAction

**Return type:**
```typescript
interface UseActionExecutionReturn {
  isExecuting: Ref<boolean>;
  lastError: Ref<string | null>;
  execute: (actionName: string, args?: Record<string, unknown>) => Promise<ActionResult>;
  executeCurrentAction: () => Promise<ActionResult>;
}
```

**Key changes in execute/executeCurrentAction:**
- Use followUpState.scheduleFollowUp instead of inline setTimeout
- Use buildServerArgs() from this composable
- isMyTurn check stays in useActionController (it's a top-level guard)
  </action>
  <verify>File created, no TypeScript errors in isolation</verify>
  <done>useActionExecution.ts exists with all extracted functions</done>
</task>

<task type="auto">
  <name>Task 2: Wire useActionExecution into useActionController</name>
  <files>packages/ui/src/composables/useActionController.ts</files>
  <action>
Integrate useActionExecution:

1. Import useActionExecution
2. Create instance after followUpState setup:
   ```typescript
   const executionState = useActionExecution({
     sendAction,
     currentAction,
     currentArgs,
     actionSnapshot,
     getActionMetadata,
     getAutoFill,
     selectionState,
     followUpState,
     clearArgs,
     clearAdvancedState,
   });
   ```
3. Remove extracted functions from useActionController body:
   - isExecuting ref (now from executionState)
   - lastError ref (now from executionState)
   - buildServerArgs
   - execute
   - executeCurrentAction
4. Update auto-execute watcher to use executionState.executeCurrentAction
5. Wrap execute to add isMyTurn check (keep at top level):
   ```typescript
   async function execute(actionName: string, args?: Record<string, unknown>) {
     if (!isMyTurn.value) {
       return { success: false, error: 'Not your turn' };
     }
     return executionState.execute(actionName, args);
   }
   ```
6. Expose executionState properties in return object

Update architecture comment to reflect all three extractions.
  </action>
  <verify>npm run build passes, npm test passes for useActionController tests</verify>
  <done>useActionController uses useActionExecution, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify line counts</name>
  <files>N/A</files>
  <action>
Run full verification:

1. Run all tests: `npm test`
2. Run build: `npm run build`
3. Count lines in each file:
   - useActionController.ts (target: ~800 lines, was 1,807)
   - useSelectionState.ts (~400 lines)
   - useFollowUp.ts (~250 lines)
   - useActionExecution.ts (~300 lines)

Document final line counts.
  </action>
  <verify>All tests pass, build succeeds, line counts documented</verify>
  <done>Full test suite passes, line counts recorded</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete useActionController refactoring into 4 composables</what-built>
  <how-to-verify>
    1. Run: npm test (all 442+ tests should pass)
    2. Run: npm run build (should succeed)
    3. Review: packages/ui/src/composables/ directory structure
    4. Verify: useActionController.ts reduced from 1,807 lines
    5. Confirm: Public API unchanged (exports match original)
  </how-to-verify>
  <resume-signal>Type "approved" to complete phase, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] useActionExecution.ts created with extracted code
- [ ] useActionController imports and uses all three composables
- [ ] `npm run build` passes without errors
- [ ] `npm test` passes all tests (full suite)
- [ ] Line count targets met (useActionController < 1000 lines)
- [ ] Human verified the refactoring
</verification>

<success_criteria>

- All three composables extracted
- useActionController orchestrates them
- All tests pass
- Build succeeds
- Line count reduction achieved
- Human approved
- Phase 2 complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-use-action-controller-refactoring/02-04-SUMMARY.md` with:
- Final line counts for all files
- Comparison to original (1,807 lines)
- Phase completion status
</output>
