---
phase: 05-type-safety
plan: 01
type: execute
---

<objective>
Fix the `as any` type assertion in choice validation within useActionController.

Purpose: Eliminate type bypass that could hide bugs when validating choice selections.
Output: Type-safe choice validation using proper type guards.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./05-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/CONCERNS.md

@packages/ui/src/composables/useActionController.ts
@packages/ui/src/composables/useActionControllerTypes.ts

**The Issue:**
In `useActionController.ts:373`, the code validates that a user's selection value is valid:
```typescript
if (typeof c.value === 'object' && c.value !== null) {
  return (c.value as any).value === value || (c.value as any).id === value;
}
```

The `ChoiceWithRefs.value` is typed as `unknown`, and the code needs to check if it has `.value` or `.id` properties. The `as any` bypasses TypeScript safety.

**Solution:**
Create a type guard to safely check for `.value` or `.id` properties on the choice value object.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type guard for choice value matching</name>
  <files>packages/ui/src/composables/useActionController.ts</files>
  <action>
Add a type guard function near the validateChoice function (around line 350) that safely checks if an unknown value has a `.value` or `.id` property:

```typescript
/** Type guard for values that may have an id property */
function hasId(obj: unknown): obj is { id: unknown } {
  return typeof obj === 'object' && obj !== null && 'id' in obj;
}

/** Type guard for values that may have a value property */
function hasValue(obj: unknown): obj is { value: unknown } {
  return typeof obj === 'object' && obj !== null && 'value' in obj;
}
```

Then update line 373 to use the type guards:
```typescript
if (typeof c.value === 'object' && c.value !== null) {
  return (hasValue(c.value) && c.value.value === value) ||
         (hasId(c.value) && c.value.id === value);
}
```

This eliminates the `as any` while preserving the exact same behavior.
  </action>
  <verify>npm run build passes without TypeScript errors</verify>
  <done>No `as any` in validateChoice function, TypeScript compiles cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Verify existing tests still pass</name>
  <files>packages/ui/tests/useActionController.test.ts</files>
  <action>
Run the useActionController test suite to confirm the type guard change doesn't break any existing behavior.

This is a pure type-level refactoring - the runtime behavior is identical. The tests should all pass unchanged.
  </action>
  <verify>npm run test -- packages/ui/tests/useActionController passes</verify>
  <done>All existing tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run test -- packages/ui/tests/useActionController` passes
- [ ] No `as any` in useActionController.ts near line 373
- [ ] Grep for remaining `as any` in useActionController.ts shows only the expected removals
</verification>

<success_criteria>

- Type guards added for safe property checking
- `as any` removed from validateChoice function
- All tests pass
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-type-safety/05-01-SUMMARY.md`
</output>
