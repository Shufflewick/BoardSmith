---
phase: 06-error-handling
plan: 02
type: execute
---

<objective>
Add JSON.parse error handling to SqliteStorageAdapter.load() to prevent server crashes from corrupted database state.

Purpose: CRITICAL - Corrupted database state currently crashes the server. This adds defensive error handling.
Output: load() returns null and logs error instead of throwing on corrupted JSON.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./06-02-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md

# Source file
@packages/server/src/stores/sqlite-storage.ts

**From CONCERNS.md:**
- Risk: Corrupted database state could crash server
- File: `packages/server/src/stores/sqlite-storage.ts:39`
- Code: `return row ? JSON.parse(row.state_json) : null;`
- Recommendations: Wrap in try/catch, return null or throw descriptive error

**Design decision:**
Return null on parse error (not throw) because:
1. The interface already returns `StoredGameState | null`
2. A corrupted game should fail gracefully, not crash the server
3. The caller can handle null (game doesn't exist) vs throwing (server error)
4. Logging the error preserves debugging information
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add try/catch around JSON.parse in load()</name>
  <files>packages/server/src/stores/sqlite-storage.ts</files>
  <action>
Wrap the JSON.parse call in a try/catch block. On parse error, log the error with gameId context and return null.

Change the load() method from:
```typescript
async load(): Promise<StoredGameState | null> {
  const row = this.#loadStmt.get(this.#gameId) as { state_json: string } | undefined;
  return row ? JSON.parse(row.state_json) : null;
}
```

To:
```typescript
async load(): Promise<StoredGameState | null> {
  const row = this.#loadStmt.get(this.#gameId) as { state_json: string } | undefined;
  if (!row) return null;

  try {
    return JSON.parse(row.state_json);
  } catch (e) {
    console.error(`Failed to parse game state for ${this.#gameId}:`, e);
    return null;
  }
}
```

This uses early return for the null case (per CLAUDE.md preference) and logs with gameId context for debugging.
  </action>
  <verify>grep -A6 "async load" packages/server/src/stores/sqlite-storage.ts | grep -E "(try|catch|console.error)"</verify>
  <done>load() has try/catch around JSON.parse with error logging and returns null on failure</done>
</task>

<task type="auto">
  <name>Task 2: Verify build passes</name>
  <files>packages/server/</files>
  <action>Build the server package to ensure the change compiles correctly. The server package may not have unit tests, but the build should pass.</action>
  <verify>npm run build --workspace=packages/server</verify>
  <done>Server package builds without errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] JSON.parse is wrapped in try/catch
- [ ] Error is logged with gameId for context
- [ ] Returns null on parse failure (not throwing)
- [ ] Build passes
</verification>

<success_criteria>

- Corrupted game state no longer crashes the server
- Errors are logged with sufficient context to debug
- Return type contract (null | StoredGameState) is honored
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-handling/06-02-SUMMARY.md`
</output>
