---
phase: 12-player-in-tree
plan: 01
type: execute
---

<objective>
Make Player extend GameElement so players are part of the searchable game tree.

Purpose: Fix the "player data in two worlds" problem - players will be searchable via `game.all(Player)` like any other element.
Output: Player class extends GameElement, PlayerCollection removed, all engine code updated.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key files:**
@packages/engine/src/player/player.ts
@packages/engine/src/element/game.ts
@packages/engine/src/element/game-element.ts

**Background:**
From MERC post-mortem: Players live in `Game.players[]` (separate collection) while game elements live in the tree. UI code searching the tree can't find player data, forcing:
- Duplicated data (copying playerColor to PlayerArea)
- Inconsistent fallbacks
- Silent failures

**Design decision:** Remove PlayerCollection entirely. All player access via `game.all(Player)`.

**Breaking changes:**
- Player constructor signature changes (extends GameElement)
- `game.players` removed
- All `new Player()` becomes `game.create(Player, ...)`
- Custom Player classes must update their constructors
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make Player extend GameElement</name>
  <files>packages/engine/src/player/player.ts</files>
  <action>
Transform Player to extend GameElement:

1. Change `class Player<G extends Game = Game>` to `class Player<G extends Game = any, P extends Player = any> extends GameElement<G, P>`

2. Replace constructor:
   - OLD: `constructor(position: number, name: string) { this.position = position; this.name = name; }`
   - NEW: `constructor(ctx: Partial<ElementContext>) { super(ctx); }` - position/name set via attributes

3. Change `readonly position: number` to just `position!: number` (set as attribute during creation)

4. Remove `game!: G` (inherited from GameElement)

5. Keep methods that still make sense:
   - `isCurrent()`, `setCurrent()` - still needed
   - `allMy()`, `my()`, `has()` - still work (use this.game)
   - `toJSON()` - adapt for GameElement serialization
   - `isFirstPlayer` getter - keep

6. Remove `toString()` - inherited from GameElement

7. DELETE the entire `PlayerCollection` class (lines 99-444) - no longer needed

8. Update exports in player.ts - only export `Player`

Static properties to add to Player:
- `static isGameElement = true` (if not inherited properly)
- Override `unserializableAttributes` if needed
  </action>
  <verify>TypeScript compiles player.ts without errors (may have downstream errors)</verify>
  <done>Player extends GameElement, PlayerCollection deleted, constructor accepts ElementContext</done>
</task>

<task type="auto">
  <name>Task 2: Update Game class for new Player model</name>
  <files>packages/engine/src/element/game.ts</files>
  <action>
Update Game class to create Players as GameElements:

1. Remove `players: PlayerCollection<P> = new PlayerCollection<P>();` property

2. Remove import of `PlayerCollection` from player.ts

3. Update constructor player creation (around line 358-369):
   - OLD:
     ```
     for (let i = 0; i < options.playerCount; i++) {
       const name = options.playerNames?.[i] ?? `Player ${i + 1}`;
       const player = this.createPlayer(i + 1, name);
       player.game = this as unknown as Game;
       this.players.add(player as P);
     }
     if (this.players.length > 0) {
       this.players.setCurrent(1);
     }
     ```
   - NEW:
     ```
     for (let i = 0; i < options.playerCount; i++) {
       const playerName = options.playerNames?.[i] ?? `Player ${i + 1}`;
       const player = this.create(Player, playerName, { position: i + 1 }) as P;
       if (i === 0) player.setCurrent(true);
     }
     ```

4. Remove `createPlayer()` factory method (around line 461-463) - no longer needed

5. Remove `firstPlayer` getter (around line 246-248) - use `game.first(Player, p => p.position === 1)` instead

6. Update `unserializableAttributes` - remove 'players' from list

7. Update `_safeProperties` - remove 'players' from Set

8. Add convenience getter for current player:
   ```typescript
   get currentPlayer(): P | undefined {
     return this.first(Player, p => p.isCurrent()) as P | undefined;
   }
   ```
  </action>
  <verify>TypeScript compiles game.ts without errors (may have downstream errors)</verify>
  <done>Game creates Players via this.create(), no PlayerCollection, convenience getters added</done>
</task>

<task type="auto">
  <name>Task 3: Update engine exports and fix compilation</name>
  <files>packages/engine/src/index.ts, packages/engine/src/player/index.ts</files>
  <action>
Update exports and fix any remaining compilation errors in engine package:

1. Update packages/engine/src/player/index.ts:
   - Remove `PlayerCollection` export
   - Keep `Player` export

2. Update packages/engine/src/index.ts:
   - Remove `PlayerCollection` from exports
   - Ensure `Player` is still exported

3. Run `pnpm build` in packages/engine and fix any remaining type errors:
   - Check flow/engine.ts for `game.players` usage
   - Check flow/turn-order.ts for player iteration patterns
   - Check utils/serializer.ts for player serialization
   - Check command/executor.ts for player access

4. For each `game.players` reference found, update to new pattern:
   - `game.players.all()` → `game.all(Player)`
   - `game.players.get(n)` → `game.first(Player, p => p.position === n)`
   - `game.players.current` → `game.currentPlayer` (new getter)
   - `game.players.setCurrent(p)` → `p.setCurrent(true)` (manually clear old current first)
   - `game.players.length` → `game.all(Player).length`
   - `game.players.forEach(...)` → `game.all(Player).forEach(...)`
   - `game.players.next()` → implement rotation logic inline or add helper
  </action>
  <verify>pnpm build in packages/engine succeeds with no errors</verify>
  <done>Engine package compiles, all exports updated, no PlayerCollection references remain</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` in packages/engine succeeds
- [ ] Player extends GameElement
- [ ] PlayerCollection is deleted
- [ ] No references to `game.players` in engine package
- [ ] Player can be found via `game.all(Player)`
</verification>

<success_criteria>

- Player class extends GameElement
- PlayerCollection class removed
- Game.players property removed
- Engine package compiles without errors
- Players are direct children of Game in tree
</success_criteria>

<output>
After completion, create `.planning/phases/12-player-in-tree/12-01-SUMMARY.md`:

# Phase 12 Plan 01: Player Extends GameElement Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `packages/engine/src/player/player.ts` - Player extends GameElement
- `packages/engine/src/element/game.ts` - Updated player creation
- [Other files]

## Decisions Made
[Key decisions]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 12-02-PLAN.md (update game implementations and tests)
</output>
