---
phase: 12-player-in-tree
plan: 02
type: execute
---

<objective>
Update all game implementations and their custom Player classes for the new Player-as-GameElement model.

Purpose: Migrate all game code to use the new player access patterns.
Output: All games compile and use `game.all(Player)` instead of `game.players`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-player-in-tree/12-01-SUMMARY.md

**Prior work:** Plan 12-01 made Player extend GameElement and removed PlayerCollection.

**Games with custom Player classes to update:**
- packages/games/hex/rules/src/elements.ts - HexPlayer
- packages/games/checkers/rules/src/elements.ts - CheckersPlayer
- packages/games/cribbage/rules/src/elements.ts - CribbagePlayer
- packages/games/go-fish/rules/src/elements.ts - GoFishPlayer
- packages/games/polyhedral-potions/rules/src/elements.ts - PolyPotionsPlayer
- packages/games/floss-bitties/src/rules/elements.ts - FlossBittiesPlayer
- packages/games/demoActionPanel/rules/src/elements.ts - TestPlayer
- packages/games/demoComplexUiInteractions/src/rules/game.ts - DemoPlayer

**Pattern for updating custom Player classes:**
OLD:
```typescript
export class HexPlayer extends Player {
  stonesPlaced: number = 0;
  constructor(position: number, name: string) {
    super(position, name);
  }
}
```

NEW:
```typescript
export class HexPlayer extends Player {
  stonesPlaced: number = 0;
  // No constructor needed - attributes set via create()
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update all custom Player classes</name>
  <files>
packages/games/hex/rules/src/elements.ts,
packages/games/checkers/rules/src/elements.ts,
packages/games/cribbage/rules/src/elements.ts,
packages/games/go-fish/rules/src/elements.ts,
packages/games/polyhedral-potions/rules/src/elements.ts,
packages/games/floss-bitties/src/rules/elements.ts,
packages/games/demoActionPanel/rules/src/elements.ts,
packages/games/demoComplexUiInteractions/src/rules/game.ts
  </files>
  <action>
For each custom Player class:

1. Remove constructor if it only calls super(position, name) - not needed anymore
2. Keep custom properties as class fields with defaults
3. If constructor did other initialization, move to a setup pattern or initialize via attributes

Example transformations:

HexPlayer (packages/games/hex/rules/src/elements.ts):
- Remove constructor (only called super)
- Keep `stonesPlaced: number = 0` field

CheckersPlayer (packages/games/checkers/rules/src/elements.ts):
- Remove constructor
- Keep custom properties

CribbagePlayer (packages/games/cribbage/rules/src/elements.ts):
- Remove constructor
- Keep custom properties

And so on for each game.
  </action>
  <verify>Each modified file has no TypeScript errors</verify>
  <done>All custom Player classes updated, no constructors calling super(position, name)</done>
</task>

<task type="auto">
  <name>Task 2: Update game.players references in all games</name>
  <files>
packages/games/*/rules/src/*.ts,
packages/games/*/src/rules/*.ts
  </files>
  <action>
Search and update all `game.players` references in game code:

```bash
grep -r "game\.players" packages/games/ --include="*.ts"
grep -r "this\.players" packages/games/ --include="*.ts"
```

For each reference, apply the migration pattern:
- `game.players.all()` → `game.all(Player)` (import Player if needed)
- `game.players.get(n)` → `game.first(Player, p => p.position === n)`
- `game.players.current` → `game.currentPlayer` or `game.first(Player, p => p.isCurrent())`
- `game.players.setCurrent(p)` → update current tracking (clear old, set new)
- `game.players.length` → `game.all(Player).length`
- `game.players.forEach(fn)` → `game.all(Player).forEach(fn)`
- `for (const p of game.players)` → `for (const p of game.all(Player))`
- `game.players.others()` → `game.all(Player).filter(p => p !== currentPlayer)`
- `game.players.next()` → implement rotation inline
- `game.players.nextAfter(p)` → implement rotation inline
- `game.players.inOrderFrom(n)` → implement inline

**Turn rotation helper pattern:**
```typescript
// Old: game.players.next()
// New:
const players = game.all(Player);
const currentIdx = players.findIndex(p => p.isCurrent());
const nextPlayer = players[(currentIdx + 1) % players.length];
```
  </action>
  <verify>No "game.players" or "this.players" references remain in packages/games/</verify>
  <done>All game code migrated to new player access patterns</done>
</task>

<task type="auto">
  <name>Task 3: Remove createPlayer overrides from games</name>
  <files>
packages/games/*/rules/src/game.ts,
packages/games/*/src/rules/game.ts
  </files>
  <action>
Remove `createPlayer()` method overrides from game classes.

Games that override createPlayer to return custom Player type:
```bash
grep -r "createPlayer" packages/games/ --include="*.ts"
```

For each game with createPlayer override:
1. Remove the createPlayer method entirely
2. Update the game constructor or setup to create players using:
   `this.create(CustomPlayer, playerName, { position: i + 1 })`

If games were using createPlayer to set custom attributes, move that to setup() or the create() call.

Example:
OLD (in game.ts):
```typescript
protected override createPlayer(position: number, name: string): HexPlayer {
  return new HexPlayer(position, name);
}
```

NEW: Delete the method. Players created automatically by Game base class using Player base type. If custom Player type needed, override in setup:
```typescript
setup() {
  // Replace default players with custom type
  // (or modify Game base to support custom Player class)
}
```

Actually, we need to handle custom Player types. The Game base class needs a way to know which Player class to create. Options:
1. Static property on Game class specifying Player class
2. Override in setup to replace players
3. Keep createPlayer but change signature

**Recommended:** Add static property to Game subclasses:
```typescript
class HexGame extends Game<HexGame, HexPlayer> {
  static PlayerClass = HexPlayer;
}
```

Then Game base uses `this.constructor.PlayerClass || Player` when creating players.

Update Game base class in this task if this pattern is chosen, or document alternative approach.
  </action>
  <verify>pnpm build succeeds for all game packages</verify>
  <done>createPlayer overrides removed, custom Player types handled via static property or alternative</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All custom Player classes updated (no position/name constructors)
- [ ] No `game.players` references in packages/games/
- [ ] No `createPlayer` overrides in game classes
- [ ] `pnpm build` succeeds for all game packages
</verification>

<success_criteria>

- All 8 custom Player classes updated
- All game code uses `game.all(Player)` pattern
- No createPlayer overrides remain
- All game packages compile
</success_criteria>

<output>
After completion, create `.planning/phases/12-player-in-tree/12-02-SUMMARY.md`:

# Phase 12 Plan 02: Game Implementations Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [List of game files modified]

## Decisions Made
[Key decisions about custom Player type handling]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 12-03-PLAN.md (update tests and supporting packages)
</output>
