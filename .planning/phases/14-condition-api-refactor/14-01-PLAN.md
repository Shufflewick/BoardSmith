---
phase: 14-condition-api-refactor
plan: 01
type: execute
---

<objective>
Add object-based condition API types and update Action builder to support labeled conditions.

Purpose: Enable detailed automatic tracing by making condition labels structurally required.
Output: New condition types and updated Action.condition() supporting both old and new formats.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Relevant source files:
@packages/engine/src/action/types.ts
@packages/engine/src/action/action-builder.ts

**Current API (no labels, optional tracer):**
```typescript
.condition((ctx) => ctx.player.hand.count() > 0)
```

**New API (labels required, automatic tracing):**
```typescript
.condition({
  'has cards in hand': (ctx) => ctx.player.hand.count() > 0,
  'is current player': (ctx) => ctx.player === ctx.game.currentPlayer
})
```

**Constraint:** Must maintain backward compatibility with function-based conditions
(Phase 15 will migrate all games to new format).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add object-based condition types to types.ts</name>
  <files>packages/engine/src/action/types.ts</files>
  <action>
Add new types for object-based conditions:

1. Add `ConditionPredicate` type alias for the function signature:
   ```typescript
   export type ConditionPredicate = (context: ActionContext) => boolean;
   ```

2. Add `ObjectCondition` type for labeled conditions:
   ```typescript
   /** Object-based condition where keys are labels and values are predicates */
   export type ObjectCondition = Record<string, ConditionPredicate>;
   ```

3. Add `ConditionConfig` union type for both old and new formats:
   ```typescript
   /**
    * Condition configuration - supports both legacy function and new object format.
    * Object format is preferred for automatic debugging support.
    */
   export type ConditionConfig = ConditionPredicate | ObjectCondition;
   ```

4. Update `ActionDefinition.condition` type from:
   ```typescript
   condition?: (context: ActionContext, tracer?: ConditionTracer) => boolean;
   ```
   to:
   ```typescript
   condition?: ConditionConfig;
   ```

Note: Remove the tracer parameter since tracing is now automatic with object conditions.
The ConditionTracer import can stay for now (removed in Plan 02).
  </action>
  <verify>
Run `npm run build` in packages/engine - should compile without errors.
Check that existing condition type usages don't break (ActionExecutor will be updated in Plan 02).
  </verify>
  <done>
types.ts has ConditionPredicate, ObjectCondition, ConditionConfig types.
ActionDefinition.condition accepts both function and object formats.
Package builds successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Action.condition() to support both formats</name>
  <files>packages/engine/src/action/action-builder.ts</files>
  <action>
Update the `condition()` method in the Action builder class:

1. Update the method signature to accept ConditionConfig:
   ```typescript
   /**
    * Add a condition for when this action is available.
    *
    * Supports two formats:
    * - **Function (legacy):** `condition((ctx) => boolean)` - No debug labels
    * - **Object (preferred):** `condition({ 'label': (ctx) => boolean })` - Auto-traced labels
    *
    * Object format provides automatic detailed debugging. Each key becomes a label
    * shown in debug output when the condition fails.
    *
    * @example
    * ```typescript
    * // Legacy format (still works, but no debug labels)
    * .condition((ctx) => ctx.player.hand.count() > 0)
    *
    * // Object format (preferred - enables automatic tracing)
    * .condition({
    *   'has cards in hand': (ctx) => ctx.player.hand.count() > 0,
    *   'is active player': (ctx) => ctx.player === ctx.game.activePlayer
    * })
    * ```
    */
   condition(config: ConditionConfig): this {
     this.definition.condition = config;
     return this;
   }
   ```

2. Add import for ConditionConfig type at top of file:
   ```typescript
   import type {
     // ... existing imports
     ConditionConfig,
   } from './types.js';
   ```

The builder just stores the config - ActionExecutor handles evaluation in Plan 02.
  </action>
  <verify>
Run `npm run build` in packages/engine - should compile without errors.
Verify both usages work in TypeScript (function and object).
  </verify>
  <done>
Action.condition() accepts both ConditionPredicate functions and ObjectCondition objects.
JSDoc documents both formats with examples.
Package builds successfully.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build -w packages/engine` succeeds without errors
- [ ] types.ts exports ConditionPredicate, ObjectCondition, ConditionConfig
- [ ] Action.condition() accepts both function and object formats
- [ ] JSDoc provides clear examples of both formats
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- Object-based condition API is defined and Action builder supports it
</success_criteria>

<output>
After completion, create `.planning/phases/14-condition-api-refactor/14-01-SUMMARY.md`:

# Phase 14 Plan 01: Condition API Types Summary

**[One-liner summarizing what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `packages/engine/src/action/types.ts` - Added ConditionPredicate, ObjectCondition, ConditionConfig types
- `packages/engine/src/action/action-builder.ts` - Updated condition() to accept new types

## Decisions Made

[Any decisions or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 14-02-PLAN.md (ActionExecutor auto-tracing + ConditionTracer removal)
</output>
