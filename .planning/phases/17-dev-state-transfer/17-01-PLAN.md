---
phase: 17-dev-state-transfer
plan: 01
type: execute
---

<objective>
Implement dev state transfer to bypass replay during HMR, directly transferring game state to new class definitions.

Purpose: Make HMR reliable for 90% of code changes by avoiding replay entirely. Stored properties transfer as-is, getters automatically recompute with new logic.

Output: `dev-state.ts` with capture/restore functions, `reloadWithCurrentRules()` updated to use dev transfer in dev mode.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@/Users/jtsmith/.claude/plans/starry-percolating-crown.md

**Key source files:**
@packages/session/src/game-session.ts (reloadWithCurrentRules at ~line 669)
@packages/engine/src/element/game.ts (toJSON, settings, persistentMap)
@packages/engine/src/element/game-element.ts (toJSON, serializeValue)
@packages/runtime/src/runner.ts (GameRunner, start, performAction)
@packages/engine/src/utils/snapshot.ts (createSnapshot pattern)
@packages/engine/src/utils/serializer.ts (serialize/deserialize utilities)

**Design principle:** Pit of success
- Stored properties (regular fields) → transferred directly via toJSON
- Derived properties (getters) → automatically recompute with new code (excluded from toJSON)
- No special hooks or annotations required

**Key insight from exploration:**
- `toJSON()` already excludes getters (they're not "own enumerable properties")
- `settings` object persists all PersistentMap data
- Flow state is available via `runner.getFlowState()`
- Element tree can be reconstructed from ElementJSON
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dev-state.ts with capture/restore functions</name>
  <files>packages/engine/src/utils/dev-state.ts</files>
  <action>
Create new file with:

1. `DevSnapshot` interface:
   - `elements`: Complete element tree as ElementJSON (from game.toJSON())
   - `flowPosition`: FlowPosition from flow engine
   - `randomState`: Current random generator state (for continued determinism)
   - `timestamp`: When snapshot was taken
   - `classRegistry`: Map of className to registered element classes

2. `captureDevState(game: Game, runner: GameRunner): DevSnapshot`:
   - Call `game.toJSON()` to get full element tree (includes settings, phase, messages)
   - Get flow position from runner's flow engine
   - Capture random state from game.random
   - Return DevSnapshot

3. `restoreDevState(snapshot: DevSnapshot, GameClass: typeof Game, options): Game`:
   - Create new Game instance with GameClass
   - Recursively recreate element tree from snapshot.elements
   - Restore all properties from ElementJSON.attributes
   - Restore visibility settings
   - Restore flow position
   - Restore random state
   - Return reconstructed game

Key considerations:
- Use `game._ctx.classRegistry` to find element classes by name
- Element IDs should be preserved (not regenerated)
- Parent-child relationships from children array
- Getters will automatically use new code (they're not in attributes)

Do NOT try to restore action history - that's the whole point (bypass replay).
  </action>
  <verify>
    - File exists at packages/engine/src/utils/dev-state.ts
    - TypeScript compiles: `pnpm build` in packages/engine
    - Types are exported from package
  </verify>
  <done>
    - DevSnapshot interface defined
    - captureDevState() captures element tree, flow position, random state
    - restoreDevState() recreates game from snapshot with new classes
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate dev state transfer into reloadWithCurrentRules</name>
  <files>packages/session/src/game-session.ts</files>
  <action>
Modify `reloadWithCurrentRules()` to use dev state transfer:

1. Add import for dev-state utilities

2. Before creating new runner:
   - Capture current state: `const snapshot = captureDevState(this.#runner.game, this.#runner)`

3. Replace replay with state transfer:
   - Instead of `GameRunner.replay(options, actionHistory)`
   - Create new runner with `new GameRunner(options)`
   - Call `restoreDevState(snapshot, definition.gameClass, ...)`
   - Initialize flow engine to restored position

4. Add console logging:
   ```
   [HMR] ✓ State transferred (12 elements)
   [HMR] ✓ Getters will use new logic
   [HMR] Reload complete
   ```

5. Keep the existing replay path as fallback for non-dev or if restore fails:
   - Check `process.env.NODE_ENV === 'development'` or similar flag
   - If dev transfer fails, log warning and fall back to replay

Do NOT remove the existing replay logic - keep it as fallback.
  </action>
  <verify>
    - `pnpm build` succeeds in packages/session
    - Run existing tests: `pnpm test` - all should pass
    - Manual test: start dev server, make a code change, verify game state preserved
  </verify>
  <done>
    - reloadWithCurrentRules uses dev state transfer in dev mode
    - Console shows HMR success messages
    - Fallback to replay if transfer fails
    - All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Add basic tests for dev state transfer</name>
  <files>packages/engine/src/utils/dev-state.test.ts</files>
  <action>
Create tests that verify:

1. `captureDevState` captures element tree correctly:
   - Create a test game with some elements
   - Capture state
   - Verify snapshot has elements, flowPosition, timestamp

2. `restoreDevState` recreates game correctly:
   - Capture state from game A
   - Restore to new game B with same GameClass
   - Verify element count matches
   - Verify stored properties match
   - Verify element IDs preserved

3. Getters recompute with new logic:
   - Create game with element that has a getter
   - Capture state
   - Mock: change what the getter would return (can't actually change class mid-test, but verify getter is NOT in snapshot attributes)

4. Round-trip preserves state:
   - Create game, perform some actions
   - Capture → restore
   - Verify game state matches original

Use existing test utilities from @boardsmith/testing.
  </action>
  <verify>
    - `pnpm test` passes in packages/engine
    - Tests cover capture, restore, round-trip
  </verify>
  <done>
    - Test file created
    - All tests pass
    - Coverage of core capture/restore functionality
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pnpm build` succeeds across all packages
- [ ] `pnpm test` passes (all 442+ tests)
- [ ] New dev-state.ts has captureDevState and restoreDevState
- [ ] reloadWithCurrentRules uses dev transfer (with replay fallback)
- [ ] Console logging shows HMR status
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Dev state transfer works for basic cases
- Replay fallback still functional
</success_criteria>

<output>
After completion, create `.planning/phases/17-dev-state-transfer/17-01-SUMMARY.md`:

# Phase 17 Plan 01: Dev State Transfer Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `packages/engine/src/utils/dev-state.ts` - Capture/restore functions
- `packages/session/src/game-session.ts` - HMR integration
- `packages/engine/src/utils/dev-state.test.ts` - Tests

## Decisions Made

[Key decisions and rationale]

## Issues Encountered

[Problems and resolutions]

## Next Step

Phase 17 complete, ready for Phase 18 (validation-layer)
</output>
