---
phase: 19-dev-checkpoints
plan: 01
type: execute
---

<objective>
Fast recovery via auto-checkpoints when HMR fails.

Purpose: When dev state transfer fails and replay is needed, checkpoints provide intermediate restore points so only a subset of actions need replay instead of all actions from the beginning. This makes HMR recovery fast even for games with 100+ actions.

Output:
- DevCheckpoint interface and checkpoint management in dev-state.ts
- CheckpointManager class in new checkpoint-manager.ts
- Integration into GameSession HMR fallback path
- Tests for checkpoint capture, restore, and replay
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-dev-state-transfer/17-01-SUMMARY.md
@.planning/phases/18-validation-layer/18-01-SUMMARY.md

**Tech stack available:**
- Dev state transfer: captureDevState, restoreDevState, validateDevSnapshot
- State history: replay infrastructure in state-history.ts
- GameRunner.replay() for partial action replay

**Established patterns:**
- DevSnapshot interface for capturing game state
- Dual-path HMR: dev transfer primary, replay fallback
- ValidationResult with structured errors

**Key files:**
@packages/engine/src/utils/dev-state.ts
@packages/session/src/game-session.ts
@packages/session/src/state-history.ts
@packages/engine/tests/dev-state.test.ts

**Constraining decisions:**
- Phase 17: Dev state transfer captures stored properties, getters recompute
- Phase 18: Validation happens before restore attempt
- Phase 18: Flow position recovery truncates to valid prefix

**Goal:**
Replace full replay fallback with checkpoint-based partial replay.
- Current flow: HMR fails → replay ALL actions (slow for long games)
- Target flow: HMR fails → restore from nearest checkpoint → replay only recent actions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkpoint types and functions in dev-state.ts</name>
  <files>packages/engine/src/utils/dev-state.ts, packages/engine/src/utils/index.ts, packages/engine/src/index.ts</files>
  <action>
Add checkpoint infrastructure to dev-state.ts:

1. Add DevCheckpoint interface (extends DevSnapshot):
```typescript
export interface DevCheckpoint extends DevSnapshot {
  /** Action index at which this checkpoint was taken */
  actionIndex: number;
  /** Actions from 0 to actionIndex (for validation) */
  actionCount: number;
}
```

2. Add createCheckpoint function that captures state plus action index:
```typescript
export function createCheckpoint<G extends Game>(
  game: G,
  actionIndex: number
): DevCheckpoint {
  const snapshot = captureDevState(game);
  return {
    ...snapshot,
    actionIndex,
    actionCount: actionIndex,
  };
}
```

3. Add restoreFromCheckpoint function that restores snapshot + replays remaining actions:
```typescript
export function restoreFromCheckpoint<G extends Game>(
  checkpoint: DevCheckpoint,
  GameClass: new (options: GameOptions) => G,
  options: RestoreDevStateOptions,
  remainingActions: SerializedAction[]
): { game: G; actionsReplayed: number } {
  // Restore from checkpoint snapshot
  const game = restoreDevState(checkpoint, GameClass, options);

  // Replay remaining actions
  let replayed = 0;
  for (const action of remainingActions) {
    // ... replay each action
    replayed++;
  }

  return { game, actionsReplayed: replayed };
}
```

4. Export new types and functions from index files.

Note: Actions need to be replayed via the game's action executor. Look at how GameRunner.replay works and follow that pattern for the action replay loop.
  </action>
  <verify>TypeScript compiles without errors: `cd packages/engine && npm run build`</verify>
  <done>DevCheckpoint interface exists, createCheckpoint and restoreFromCheckpoint functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Create CheckpointManager class</name>
  <files>packages/session/src/checkpoint-manager.ts, packages/session/src/index.ts</files>
  <action>
Create a new CheckpointManager class that manages checkpoint lifecycle:

```typescript
/**
 * CheckpointManager - Auto-checkpoint management for HMR recovery.
 *
 * Creates periodic checkpoints during gameplay so that when HMR fails,
 * recovery can restore from the nearest checkpoint and replay only
 * recent actions instead of all actions from the beginning.
 *
 * Dev-only: checkpoints are kept in memory, not persisted.
 */
export class CheckpointManager<G extends Game = Game> {
  /** Checkpoints stored in memory, keyed by action index */
  #checkpoints: Map<number, DevCheckpoint> = new Map();

  /** How often to create checkpoints (every N actions) */
  #interval: number;

  /** Maximum number of checkpoints to keep (rolling window) */
  #maxCheckpoints: number;

  constructor(options?: { interval?: number; maxCheckpoints?: number }) {
    // Default: checkpoint every 10 actions, keep last 5 checkpoints
    this.#interval = options?.interval ?? 10;
    this.#maxCheckpoints = options?.maxCheckpoints ?? 5;
  }

  /**
   * Check if a checkpoint should be created at this action index.
   * Called after each action completes.
   */
  shouldCheckpoint(actionIndex: number): boolean {
    return actionIndex > 0 && actionIndex % this.#interval === 0;
  }

  /**
   * Create and store a checkpoint.
   */
  capture(game: G, actionIndex: number): void {
    const checkpoint = createCheckpoint(game, actionIndex);
    this.#checkpoints.set(actionIndex, checkpoint);

    // Prune old checkpoints if over limit
    this.#pruneOldCheckpoints();

    console.log(`[HMR] Checkpoint saved at action ${actionIndex}`);
  }

  /**
   * Find the nearest checkpoint at or before the given action index.
   * Returns undefined if no suitable checkpoint exists.
   */
  findNearest(targetActionIndex: number): DevCheckpoint | undefined {
    let best: DevCheckpoint | undefined;
    let bestIndex = -1;

    for (const [index, checkpoint] of this.#checkpoints) {
      if (index <= targetActionIndex && index > bestIndex) {
        best = checkpoint;
        bestIndex = index;
      }
    }

    return best;
  }

  /**
   * Clear all checkpoints (e.g., after undo that invalidates them).
   */
  clear(): void {
    this.#checkpoints.clear();
  }

  /**
   * Clear checkpoints after a certain action index (e.g., after rewind).
   */
  clearAfter(actionIndex: number): void {
    for (const [index] of this.#checkpoints) {
      if (index > actionIndex) {
        this.#checkpoints.delete(index);
      }
    }
  }

  /** Remove oldest checkpoints if over limit */
  #pruneOldCheckpoints(): void {
    if (this.#checkpoints.size <= this.#maxCheckpoints) return;

    const sorted = [...this.#checkpoints.keys()].sort((a, b) => a - b);
    const toRemove = sorted.slice(0, sorted.length - this.#maxCheckpoints);

    for (const index of toRemove) {
      this.#checkpoints.delete(index);
    }
  }
}
```

Export from session index.
  </action>
  <verify>`cd packages/session && npm run build` succeeds</verify>
  <done>CheckpointManager class exists with capture, findNearest, clear, clearAfter methods</done>
</task>

<task type="auto">
  <name>Task 3: Integrate CheckpointManager into GameSession</name>
  <files>packages/session/src/game-session.ts</files>
  <action>
Integrate CheckpointManager into GameSession:

1. Add private field:
```typescript
#checkpointManager?: CheckpointManager<G>;
```

2. Initialize in constructor (dev mode only):
```typescript
// In constructor, after other initialization
if (process.env.NODE_ENV !== 'production') {
  this.#checkpointManager = new CheckpointManager();
}
```

3. Add checkpoint capture after successful action in performAction():
```typescript
// After updating storedState.actionHistory
if (this.#checkpointManager?.shouldCheckpoint(this.#storedState.actionHistory.length)) {
  this.#checkpointManager.capture(this.#runner.game, this.#storedState.actionHistory.length);
}
```

4. Update #reloadWithDevTransfer fallback path to use checkpoint recovery:
```typescript
// In the catch block where we fall back to replay
// Instead of:
// console.warn(`[HMR] ⚠️ Dev state transfer failed, falling back to replay...`)
// return null;

// Do:
if (this.#checkpointManager) {
  const checkpoint = this.#checkpointManager.findNearest(this.#storedState.actionHistory.length);
  if (checkpoint) {
    console.log(`[HMR] Found checkpoint at action ${checkpoint.actionIndex}, replaying ${this.#storedState.actionHistory.length - checkpoint.actionIndex} actions`);
    const newRunner = this.#reloadFromCheckpoint(checkpoint, definition);
    if (newRunner) return newRunner;
  }
}
// Fall through to full replay if no checkpoint or checkpoint restore fails
```

5. Add new method #reloadFromCheckpoint:
```typescript
#reloadFromCheckpoint(checkpoint: DevCheckpoint, definition: GameDefinition): GameRunner<G> | null {
  try {
    // Build class registry
    const classRegistry = new Map<string, any>();
    classRegistry.set(definition.gameClass.name, definition.gameClass);
    for (const [name, cls] of this.#runner.game._ctx.classRegistry) {
      if (!classRegistry.has(name)) {
        classRegistry.set(name, cls);
      }
    }

    // Validate checkpoint snapshot with new classes
    const validation = validateDevSnapshot(checkpoint, classRegistry);
    if (!validation.valid) {
      console.warn('[HMR] Checkpoint validation failed, falling back to full replay');
      return null;
    }

    // Restore from checkpoint
    const restoredGame = restoreDevState(
      checkpoint,
      definition.gameClass as GameClass<G>,
      {
        gameOptions: {
          playerCount: this.#storedState.playerCount,
          playerNames: this.#storedState.playerNames,
          seed: this.#storedState.seed,
          ...this.#storedState.gameOptions,
        },
        classRegistry,
      }
    );

    // Create runner with restored game
    const newRunner = new GameRunner<G>({
      GameClass: definition.gameClass as GameClass<G>,
      gameType: this.#storedState.gameType,
      gameOptions: {
        playerCount: this.#storedState.playerCount,
        playerNames: this.#storedState.playerNames,
        seed: this.#storedState.seed,
        ...this.#storedState.gameOptions,
      },
    });

    // @ts-expect-error - Accessing readonly for HMR
    newRunner.game = restoredGame;

    // Copy action history up to checkpoint
    newRunner.actionHistory.push(...this.#storedState.actionHistory.slice(0, checkpoint.actionIndex));

    // Replay remaining actions
    const remainingActions = this.#storedState.actionHistory.slice(checkpoint.actionIndex);
    for (const action of remainingActions) {
      const result = newRunner.performAction(action.name, action.player, action.args);
      if (!result.success) {
        console.warn(`[HMR] Action replay failed at ${action.name}, falling back to full replay`);
        return null;
      }
    }

    console.log(
      `[HMR] ✓ Restored from checkpoint (action ${checkpoint.actionIndex})\n` +
      `[HMR] ✓ Replayed ${remainingActions.length} actions\n` +
      `[HMR] Reload complete`
    );

    return newRunner;
  } catch (error) {
    console.warn('[HMR] Checkpoint restore failed:', error);
    return null;
  }
}
```

6. Clear checkpoints after undo/rewind in state-history integration:
```typescript
// In undoToTurnStart callback or after rewindToAction
this.#checkpointManager?.clearAfter(targetActionIndex);
```
  </action>
  <verify>`cd packages/session && npm run build` succeeds, manual test of HMR with checkpoints</verify>
  <done>GameSession creates checkpoints every 10 actions, uses them for fast HMR recovery</done>
</task>

<task type="auto">
  <name>Task 4: Add tests for checkpoint functionality</name>
  <files>packages/engine/tests/dev-state.test.ts, packages/session/tests/checkpoint-manager.test.ts</files>
  <action>
Add comprehensive tests:

1. In dev-state.test.ts, add tests for createCheckpoint and restoreFromCheckpoint:
```typescript
describe('Checkpoints', () => {
  it('should create checkpoint with action index', () => {
    const game = new TestGame({ playerCount: 2 });
    game.setup();

    const checkpoint = createCheckpoint(game, 5);

    expect(checkpoint.actionIndex).toBe(5);
    expect(checkpoint.actionCount).toBe(5);
    expect(checkpoint.elements).toBeDefined();
  });

  it('should restore from checkpoint and replay actions', () => {
    // Test that restore + replay produces same state as full replay
    // ...
  });
});
```

2. Create new test file packages/session/tests/checkpoint-manager.test.ts:
```typescript
describe('CheckpointManager', () => {
  it('should capture checkpoints at configured interval', () => {
    const manager = new CheckpointManager({ interval: 5 });

    expect(manager.shouldCheckpoint(0)).toBe(false);
    expect(manager.shouldCheckpoint(4)).toBe(false);
    expect(manager.shouldCheckpoint(5)).toBe(true);
    expect(manager.shouldCheckpoint(10)).toBe(true);
  });

  it('should find nearest checkpoint', () => {
    // Create manager, add checkpoints at 10, 20, 30
    // findNearest(25) should return checkpoint at 20
    // ...
  });

  it('should prune old checkpoints over limit', () => {
    const manager = new CheckpointManager({ interval: 5, maxCheckpoints: 3 });
    // Add 5 checkpoints, verify only 3 remain (newest)
    // ...
  });

  it('should clear checkpoints after index', () => {
    // Add checkpoints, clearAfter(15), verify checkpoints > 15 removed
    // ...
  });
});
```
  </action>
  <verify>`cd packages/engine && npm test` and `cd packages/session && npm test` pass</verify>
  <done>Tests cover checkpoint creation, restore, manager interval logic, pruning, and clearAfter</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds in both packages/engine and packages/session
- [ ] `npm test` passes all tests in both packages
- [ ] No TypeScript errors
- [ ] Console shows checkpoint creation during gameplay (dev mode)
- [ ] When HMR fails, checkpoint recovery is attempted before full replay
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Checkpoints are auto-created every 10 actions in dev mode
- HMR fallback uses nearest checkpoint for partial replay
- Tests cover checkpoint lifecycle and recovery path
</success_criteria>

<output>
After completion, create `.planning/phases/19-dev-checkpoints/19-01-SUMMARY.md`:

# Phase 19 Plan 01: Dev Checkpoints Summary

**[One-liner: what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase complete. v0.8 HMR Reliability milestone complete.
</output>
