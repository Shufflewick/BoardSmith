---
phase: 24-game-type-detection
plan: 01
type: execute
---

<objective>
Add game type detection to the introspector by analyzing win condition patterns.

Purpose: Enable automatic categorization of games (connection, capture, racing, collection) so the AI trainer can apply type-specific zero-config heuristics without manual configuration.
Output: Extended GameStructure with GameType enum and WinConditionInfo, populated by analyzing game class patterns.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-verification/23-01-SUMMARY.md

# Key source files
@packages/ai-trainer/src/types.ts
@packages/ai-trainer/src/introspector.ts

# Reference game implementations showing win condition patterns
@packages/games/hex/rules/src/game.ts
@packages/games/checkers/rules/src/game.ts
@packages/games/cribbage/rules/src/game.ts
@packages/games/go-fish/rules/src/game.ts

**Tech stack available:** TypeScript 5.7, Vitest
**Established patterns:** Introspector discovers structure via runtime analysis with intentional `as any` for dynamic property access

**Constraining decisions:**
- Phase 23: Parallel training works correctly, train-ai respects paths.rules config
- v0.9: AI trainer infrastructure is stable and tested

**Game type categories to detect:**
- **connection**: Win by forming path between edges (Hex)
- **capture**: Win by capturing/blocking all opponent pieces (Checkers)
- **racing**: Win by reaching target score first (Cribbage)
- **collection**: Win by collecting most of something (Go Fish)
- **territory**: Win by controlling most area (future: Go)
- **elimination**: Win when opponents eliminated (future)
- **unknown**: Fallback when pattern not detected
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GameType enum and WinConditionInfo to types.ts</name>
  <files>packages/ai-trainer/src/types.ts</files>
  <action>
Add the following types to types.ts:

1. GameType enum with values: 'connection' | 'capture' | 'racing' | 'collection' | 'territory' | 'elimination' | 'unknown'

2. WinConditionInfo interface:
   - gameType: GameType
   - confidence: number (0-1, how confident the detection is)
   - indicators: string[] (what patterns led to this classification)
   - scoreBased: boolean (win condition involves score threshold)
   - eliminationBased: boolean (win condition involves removing opponent pieces/options)
   - connectionBased: boolean (win condition involves forming paths)
   - collectionBased: boolean (win condition involves collecting sets)

3. Extend GameStructure interface to include:
   - winConditionInfo: WinConditionInfo

4. Extend SerializableGameStructure to include winConditionInfo (it's already serializable since it only has primitive types)

Keep existing types unchanged. Add new types after existing interfaces.
  </action>
  <verify>npx tsc --noEmit passes with no errors in packages/ai-trainer</verify>
  <done>GameType enum and WinConditionInfo interface exist in types.ts, GameStructure includes winConditionInfo field</done>
</task>

<task type="auto">
  <name>Task 2: Implement win condition analysis in introspector.ts</name>
  <files>packages/ai-trainer/src/introspector.ts</files>
  <action>
Add a new function `analyzeWinConditions(game: Game, structure: GameStructure): WinConditionInfo` that detects game type by examining:

1. **Score-based detection (racing games)**:
   - Check if any player has numeric properties like 'score', 'points', 'total'
   - Check if isFinished() correlates with score thresholds
   - Indicator: "Player has score property" or "Target score detected"

2. **Elimination-based detection (capture games)**:
   - Check if there are owned elements that can be removed
   - Check if isFinished() correlates with one player having no pieces/moves
   - Indicator: "Owned pieces can be captured" or "Win when opponent has no moves"

3. **Collection-based detection (collection games)**:
   - Check if player has 'bookCount', 'sets', 'collections' properties
   - Check if game tracks total collected items
   - Indicator: "Player tracks collection count"

4. **Connection-based detection (connection games)**:
   - Check for hex grid (isHex) or regular grid with path-checking potential
   - Check for 'winner' property set based on path completion
   - Indicator: "Hex grid detected" or "Path-based win condition"

5. **Territory-based detection** (placeholder for future):
   - Check for area control mechanics
   - Indicator: "Area ownership mechanics"

Detection logic:
- Run all detectors, collect indicators
- Score each type based on indicator count and specificity
- Return highest-confidence type, or 'unknown' if no strong signals
- Confidence = (matching indicators) / (total possible indicators for that type)

Call `analyzeWinConditions()` from `introspectGame()` and include result in returned GameStructure.

Export analyzeWinConditions for testing.
  </action>
  <verify>
1. npx tsc --noEmit passes
2. Create a simple test: import introspectGame from dist, call on HexGame, verify winConditionInfo.gameType === 'connection'
  </verify>
  <done>
- analyzeWinConditions function exists and is exported
- introspectGame returns GameStructure with populated winConditionInfo
- Hex detected as 'connection', Checkers as 'capture', Cribbage as 'racing', Go Fish as 'collection'
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in packages/ai-trainer
- [ ] `npm run typecheck` passes across monorepo
- [ ] Manual test: introspect each game type and verify correct classification
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- GameStructure.winConditionInfo populated for all game types
- Detection confidence > 0.5 for known game types
</success_criteria>

<output>
After completion, create `.planning/phases/24-game-type-detection/24-01-SUMMARY.md`
</output>
