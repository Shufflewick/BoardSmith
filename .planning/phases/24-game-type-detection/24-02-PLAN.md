---
phase: 24-game-type-detection
plan: 02
type: execute
---

<objective>
Add type-specific zero-config heuristic features based on detected game type.

Purpose: Provide meaningful Tier 1 AI features that work automatically based on game classification, without requiring game-specific configuration.
Output: New feature templates in feature-templates.ts that generate type-appropriate candidate features, integrated with generateCandidateFeatures().
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-game-type-detection/24-01-SUMMARY.md

# Key source files
@packages/ai-trainer/src/types.ts
@packages/ai-trainer/src/feature-templates.ts
@packages/ai-trainer/src/introspector.ts

**Depends on:** Plan 24-01 (GameType detection in GameStructure)

**Tech stack available:** TypeScript 5.7, Vitest
**Established patterns:** Feature templates generate CandidateFeature[] based on GameStructure analysis

**Type-specific features to add:**

**Connection games (Hex):**
- Edge proximity: pieces closer to target edge
- Path potential: connectivity toward goal edges
- Center influence: control of central hexes (blocking opponent paths)
- Bridge patterns: pieces that connect groups

**Capture games (Checkers):**
- Piece advantage: more pieces than opponent
- King advantage: more promoted pieces
- Mobility: more available moves
- Safety: pieces that can't be captured

**Racing games (Cribbage):**
- Score lead: higher score than opponent
- Score threshold: approaching win condition
- Score momentum: recent scoring rate

**Collection games (Go Fish):**
- Collection lead: more sets/books than opponent
- Collection progress: cards toward completing sets
- Resource advantage: more cards in hand
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connection game feature templates</name>
  <files>packages/ai-trainer/src/feature-templates.ts</files>
  <action>
Add new feature templates for connection games. These should only generate features when structure.winConditionInfo.gameType === 'connection'.

Add after existing templates:

1. **edge-proximity** template:
   - For hex grids: measure average distance to target edge
   - Feature: "Player pieces are closer to goal edge than opponent"
   - Evaluator: Compare average q or r coordinate (depending on player) to opponent

2. **center-influence** template (connection variant):
   - Feature: "Player controls more center hexes" (blocking paths)
   - More valuable in connection games than generic center-control
   - Higher weight suggestion in description

3. **connectivity-groups** template:
   - Feature: "Player has fewer disconnected groups" (more connected = closer to winning)
   - Evaluator: Count distinct groups of adjacent pieces for each player
   - This requires a simple flood-fill/union-find on the hex grid

Add helper function `countConnectedGroups(game: Game, className: string, player: Player): number` that:
- Finds all pieces of className owned by player
- Uses flood-fill to count distinct connected components
- For hex grids, adjacency is the 6 hex neighbors

Add requires check: `{ gameType: 'connection' }` to each template.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Connection game templates exist, only generate when gameType === 'connection'</done>
</task>

<task type="auto">
  <name>Task 2: Add capture, racing, and collection game features</name>
  <files>packages/ai-trainer/src/feature-templates.ts</files>
  <action>
Add feature templates for the remaining game types:

**Capture games (gameType === 'capture'):**

1. **mobility-advantage** template:
   - Feature: "Player has more available moves than opponent"
   - Note: This is expensive to compute, add description noting it's a heuristic
   - Simpler proxy: count pieces that aren't blocked

2. **piece-safety** template:
   - Feature: "Player has pieces that cannot be immediately captured"
   - Proxy: pieces on edges or backed by friendly pieces

3. **promotion-progress** template:
   - Feature: "Player pieces are closer to promotion row"
   - For checkers: advancement toward king row

**Racing games (gameType === 'racing'):**

1. **score-momentum** template:
   - Feature: "Player scored more recently" (approximation)
   - Use existing player-score-lead but with tighter thresholds

2. **win-proximity** template:
   - Feature: "Player is within N points of winning"
   - Thresholds: 10, 20, 50 points from target

**Collection games (gameType === 'collection'):**

1. **collection-progress** template:
   - Feature: "Player has partial sets" (cards toward books)
   - Proxy: count cards in hand (more cards = more potential)

2. **resource-advantage** template:
   - Feature: "Player has more cards/resources in hand"

Add requires check with appropriate gameType to each template.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Capture, racing, and collection templates exist with proper gameType guards</done>
</task>

<task type="auto">
  <name>Task 3: Integrate type-based feature generation</name>
  <files>packages/ai-trainer/src/feature-templates.ts</files>
  <action>
Update the feature generation system to use game type:

1. Add `gameType` to the `requires` interface on FeatureTemplate:
   ```typescript
   requires: {
     // ... existing fields
     gameType?: GameType | GameType[];  // Only generate for these game types
   };
   ```

2. Update `generateCandidateFeatures()` function (or create it if it doesn't exist as a single entry point):
   - Accept GameStructure as parameter
   - For each template, check if gameType requirement is satisfied
   - If template.requires.gameType is set, only include if structure.winConditionInfo.gameType matches
   - If template.requires.gameType is not set, include for all game types (backwards compatible)

3. Export a convenience function `generateFeaturesForGame(game: Game): CandidateFeature[]` that:
   - Calls introspectGame(game)
   - Calls generateCandidateFeatures(structure)
   - Returns the combined feature list

This ensures:
- Generic features (element counts, player scores) work for all games
- Type-specific features only appear for appropriate game types
- No manual configuration needed - fully zero-config
  </action>
  <verify>
1. npx tsc --noEmit passes
2. npm run build succeeds in packages/ai-trainer
3. Manual test: generateFeaturesForGame on Hex should include connection features but not capture features
  </verify>
  <done>
- Feature templates have gameType requirements
- generateCandidateFeatures filters by game type
- generateFeaturesForGame provides zero-config entry point
- Hex gets connection features, Checkers gets capture features, etc.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in packages/ai-trainer
- [ ] `npm run typecheck` passes across monorepo
- [ ] generateFeaturesForGame(hexGame) includes edge-proximity, connectivity-groups features
- [ ] generateFeaturesForGame(checkersGame) includes mobility-advantage, piece-safety features
- [ ] generateFeaturesForGame(cribbageGame) includes win-proximity features
- [ ] Generic features (element counts) still present for all game types
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Type-specific features generated based on detected game type
- No manual configuration required - fully zero-config Tier 1 AI
- Phase 24 complete
</success_criteria>

<output>
After completion, create `.planning/phases/24-game-type-detection/24-02-SUMMARY.md`
</output>
