---
phase: 25-structural-features
plan: 01
type: execute
domain: ai
---

<objective>
Add graph-based path analysis features for connection games (Hex).

Purpose: The current Hex AI is nearly useless (51.5% vs random) because it lacks features that measure "progress toward winning". Connection games need path-distance features - how many more stones to complete the winning path?

Output: New feature templates that evaluate shortest-path-to-goal and related connectivity metrics for connection games.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-game-type-detection/24-01-SUMMARY.md
@.planning/phases/24-game-type-detection/24-02-SUMMARY.md

**Prior work (Phase 24):**
- GameType detection identifies connection games via hex grid + winner property
- countConnectedGroups() exists in feature-templates.ts using flood-fill BFS
- Connection game templates exist: edge-proximity, center-influence, connectivity-groups
- Problem: These don't measure "how close to winning" - just static board positions

**Key files:**
@packages/ai-trainer/src/feature-templates.ts - Has countConnectedGroups(), HEX_DIRECTIONS
@packages/ai-trainer/src/introspector.ts - Has analyzeWinConditions(), GameStructure
@packages/ai-trainer/src/types.ts - Has GameType, GameStructure, CandidateFeature

**Game context (Hex):**
@packages/games/hex/rules/src/elements.ts - Cell has isRedStartEdge/isRedGoalEdge, Board has checkWin()
@packages/games/hex/rules/src/game.ts - Red connects r=0 to r=size-1, Blue connects q=0 to q=size-1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add shortest path analysis utility for hex grids</name>
  <files>packages/ai-trainer/src/feature-templates.ts</files>
  <action>
Add a function `computeShortestPathLength(game, className, player, boardSize)` that:
1. Uses modified Dijkstra/BFS to find shortest path from player's start edge to goal edge
2. Path costs: friendly cell = 0, empty cell = 1, enemy cell = Infinity
3. Returns the minimum number of empty cells needed to complete a winning path
4. If already connected (path length = 0), return 0. If blocked (Infinity), return a large number (e.g., boardSize * 2)

The function should:
- Detect player's axis: player 0 (position 1) uses r-axis (r=0 to r=size-1), player 1 (position 2) uses q-axis (q=0 to q=size-1)
- Start from all cells on start edge (r=0 or q=0 depending on player)
- Find shortest path to any cell on goal edge
- Use priority queue or sorted iteration for Dijkstra's algorithm

Place this near the existing `countConnectedGroups()` function in the CONNECTION GAME EVALUATORS section.

AVOID: Don't import external graph libraries - use a simple inline priority queue (array sorted by distance). BoardSmith has a no-new-dependencies constraint.
  </action>
  <verify>The function should be exported and callable. TypeScript compilation: `cd packages/ai-trainer && npx tsc --noEmit`</verify>
  <done>Function exists, compiles without errors, uses Dijkstra-like shortest path algorithm with proper edge costs</done>
</task>

<task type="auto">
  <name>Task 2: Add path-distance feature templates</name>
  <files>packages/ai-trainer/src/feature-templates.ts</files>
  <action>
Add new feature templates to FEATURE_TEMPLATES array for connection games:

1. **path-distance-advantage** (category: 'comparison', requires: gameType: 'connection')
   - Description: "Player needs fewer stones to win than opponent"
   - Evaluate: Compare shortest path lengths - return true if my path < opponent's path
   - This is the key feature for connection game AI

2. **near-win-connection** (category: 'boolean', requires: gameType: 'connection')
   - Description: "Player is within N stones of winning (path length <= N)"
   - Generate features for thresholds: 1, 2, 3
   - Critical for late-game evaluation

3. **path-blocked** (category: 'boolean', requires: gameType: 'connection')
   - Description: "Opponent's path is completely blocked (infinite path length)"
   - This is nearly a win condition - should have very high weight

Add these templates after the existing connectivity-groups template.

Use the computeShortestPathLength() function from Task 1 in the evaluators.
  </action>
  <verify>
Run TypeScript check: `cd packages/ai-trainer && npx tsc --noEmit`
Verify templates are added to FEATURE_TEMPLATES array
  </verify>
  <done>
- 3 new feature templates exist in FEATURE_TEMPLATES
- Templates properly filter by gameType: 'connection'
- Evaluators use computeShortestPathLength() function
- TypeScript compilation passes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd packages/ai-trainer && npx tsc --noEmit` passes
- [ ] `npm run build -w packages/ai-trainer` passes
- [ ] computeShortestPathLength() function is exported
- [ ] 3 new feature templates exist for connection games
- [ ] All tests pass: `npm test -w packages/ai-trainer`
</verification>

<success_criteria>

- computeShortestPathLength() utility added with Dijkstra-based path analysis
- 3 new feature templates for connection games: path-distance-advantage, near-win-connection, path-blocked
- All TypeScript compilation passes
- All existing tests pass
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/25-structural-features/25-01-SUMMARY.md`
</output>
