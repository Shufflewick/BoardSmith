---
phase: 25-structural-features
plan: 02
type: execute
domain: ai
---

<objective>
Add threat detection and piece safety features for capture games (Checkers).

Purpose: While Checkers has hand-coded AI objectives, the auto-trainer can't generate threat-based features. Capture games need to evaluate piece vulnerability - which pieces can be captured next turn?

Output: New feature templates that evaluate piece safety, threats, and defensive positioning for capture games.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-structural-features/25-01-SUMMARY.md

**Prior work (Phase 24):**
- GameType detection identifies capture games via owned spatial pieces + capture-like property names
- Capture game templates exist: mobility-advantage, piece-safety, promotion-progress
- Problem: piece-safety just counts edge pieces, doesn't detect actual threatened pieces

**Key files:**
@packages/ai-trainer/src/feature-templates.ts - Has capture game section, uses row/column for positioning
@packages/ai-trainer/src/introspector.ts - Has ElementTypeInfo with hasOwnership, isSpatial
@packages/ai-trainer/src/types.ts - Has GameStructure

**Game context (Checkers):**
@packages/games/checkers/rules/src/elements.ts - CheckerPiece has isKing, Square has row/column
@packages/games/checkers/rules/src/ai.ts - Hand-coded objectives include capture-available, back-row-defense
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add diagonal threat analysis utilities</name>
  <files>packages/ai-trainer/src/feature-templates.ts</files>
  <action>
Add utility functions for capture game threat detection:

1. **getAdjacentDiagonals(row, col, totalRows, totalCols)**: Returns array of {row, col} for the 4 diagonal neighbors (NE, NW, SE, SW) that are within bounds.

2. **countThreatenedPieces(game, className, player, opponent, totalRows, totalCols)**:
   - For each of player's pieces, check if it can be captured
   - Capture detection: enemy piece diagonal-adjacent AND the opposite diagonal is empty (jump landing spot)
   - Return count of player's pieces that are threatened
   - Handle board bounds properly

3. **countDefendedPieces(game, className, player, totalRows, totalCols)**:
   - A piece is "defended" if an adjacent diagonal has a friendly piece
   - Defended pieces are harder to capture (opponent loses piece if they capture)
   - Return count of player's pieces that are defended

Place these in the CAPTURE GAME EVALUATORS section after the existing evaluators.

Note: This is a simplified heuristic - real capture logic in Checkers is more complex (king movement, multi-jumps). This provides a reasonable approximation for AI training without needing access to game-specific move generation.
  </action>
  <verify>TypeScript compilation: `cd packages/ai-trainer && npx tsc --noEmit`</verify>
  <done>3 utility functions exist, compile without errors, handle board bounds correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add threat-based feature templates</name>
  <files>packages/ai-trainer/src/feature-templates.ts</files>
  <action>
Add new feature templates to FEATURE_TEMPLATES array for capture games:

1. **threat-advantage** (category: 'comparison', requires: gameType: 'capture')
   - Description: "Opponent has more threatened pieces than player"
   - Evaluate: countThreatenedPieces(opponent) > countThreatenedPieces(player)
   - Having fewer threatened pieces is good

2. **defense-advantage** (category: 'comparison', requires: gameType: 'capture')
   - Description: "Player has more defended pieces than opponent"
   - Evaluate: countDefendedPieces(player) > countDefendedPieces(opponent)
   - Better defensive positioning

3. **no-threats** (category: 'boolean', requires: gameType: 'capture')
   - Description: "Player has no threatened pieces"
   - Evaluate: countThreatenedPieces(player) === 0
   - Safe position

4. **threat-ratio** (category: 'ratio', requires: gameType: 'capture')
   - Description: "Player's pieces are mostly defended (>50%)"
   - Evaluate: countDefendedPieces(player) > (total pieces / 2)
   - Good defensive structure

Add these templates after the existing promotion-progress template.

Use the utility functions from Task 1 in the evaluators. Get board dimensions from structure.spatialInfo.dimensions.
  </action>
  <verify>
Run TypeScript check: `cd packages/ai-trainer && npx tsc --noEmit`
Verify templates are added to FEATURE_TEMPLATES array
  </verify>
  <done>
- 4 new feature templates exist in FEATURE_TEMPLATES
- Templates properly filter by gameType: 'capture'
- Evaluators use the threat utility functions
- TypeScript compilation passes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd packages/ai-trainer && npx tsc --noEmit` passes
- [ ] `npm run build -w packages/ai-trainer` passes
- [ ] 3 utility functions added: getAdjacentDiagonals, countThreatenedPieces, countDefendedPieces
- [ ] 4 new feature templates exist for capture games
- [ ] All tests pass: `npm test -w packages/ai-trainer`
</verification>

<success_criteria>

- Diagonal threat analysis utilities added
- 4 new feature templates for capture games: threat-advantage, defense-advantage, no-threats, threat-ratio
- All TypeScript compilation passes
- All existing tests pass
- No new dependencies added
- Phase 25 complete
</success_criteria>

<output>
After completion, create `.planning/phases/25-structural-features/25-02-SUMMARY.md`
</output>
