---
phase: 28.1-mcts-performance
plan: 01
type: execute
---

<objective>
Add command undo infrastructure to the engine layer, enabling efficient state rollback without full reconstruction.

Purpose: Game restoration is the #1 MCTS bottleneck (60-70% of time). Commands ARE invertible - MOVE has source/dest, SET_ATTRIBUTE can store old value. By making commands undoable, MCTS can apply/unapply moves instead of reconstructing from scratch.

Output: `undoCommand()` function in engine, inverse command generation, and Game.undoLastCommand() method.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@packages/engine/src/command/types.ts
@packages/engine/src/command/executor.ts
@packages/engine/src/element/game.ts

**Key insight from analysis:**
Commands are already structured for event sourcing. Each command type has enough information to generate its inverse:
- MOVE: inverse is MOVE back to original parent (need to capture sourceId)
- SET_ATTRIBUTE: inverse is SET_ATTRIBUTE with old value (need to capture)
- SHUFFLE: NOT invertible (use snapshot checkpoint before shuffle)
- CREATE: inverse is REMOVE (need to capture created element ID)
- Others follow similar patterns

**Constraints:**
- Must not break existing command replay
- Must be transparent (no changes to game code)
- Handle non-invertible commands gracefully (SHUFFLE)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add inverse command types and generation</name>
  <files>packages/engine/src/command/types.ts, packages/engine/src/command/inverse.ts</files>
  <action>
Create packages/engine/src/command/inverse.ts with:

1. InverseCommand type that wraps a GameCommand with undo info
2. generateInverse(game, command) function that:
   - For MOVE: captures current parent ID before move, returns inverse MOVE
   - For SET_ATTRIBUTE: captures current value before set, returns inverse SET_ATTRIBUTE
   - For CREATE: returns REMOVE with the created element ID
   - For CREATE_MANY: returns array of REMOVEs
   - For REMOVE: captures full element state, returns CREATE
   - For SHUFFLE: returns null (not invertible)
   - For SET_VISIBILITY/ADD_VISIBLE_TO: capture current state
   - For MESSAGE: return null (not invertible, doesn't affect game state meaningfully)
   - For START_GAME/END_GAME: return inverse transition
   - For SET_ORDER/REORDER_CHILD: capture current state

Export function: createInverseCommand(game: Game, command: GameCommand): GameCommand | null

DO NOT modify existing command types. The inverse is just another GameCommand.

Avoid:
- Adding properties to existing types (breaks serialization)
- Complex state capture (keep it minimal)
  </action>
  <verify>TypeScript compiles with no errors</verify>
  <done>inverse.ts exports createInverseCommand function that handles all command types</done>
</task>

<task type="auto">
  <name>Task 2: Add undoCommand executor function</name>
  <files>packages/engine/src/command/executor.ts, packages/engine/src/command/index.ts</files>
  <action>
Add to executor.ts:

```typescript
export function undoCommand(game: Game, command: GameCommand): CommandResult
```

This function:
1. Calls createInverseCommand to get the inverse
2. If inverse is null, returns { success: false, error: 'Command not invertible' }
3. Executes the inverse command (but does NOT add to history)
4. Returns result

Export undoCommand from index.ts.

Key insight: The inverse command is just a regular command. executeCommand already knows how to run all command types. We're not adding new execution logic.

Avoid:
- Modifying commandHistory during undo (caller controls that)
- Adding try/catch around the inverse execution (let errors propagate)
  </action>
  <verify>TypeScript compiles, `undoCommand` exported from @boardsmith/engine</verify>
  <done>undoCommand function exists and handles all invertible command types</done>
</task>

<task type="auto">
  <name>Task 3: Add Game.undoLastCommand() method with tests</name>
  <files>packages/engine/src/element/game.ts, packages/engine/src/index.ts, packages/testing/tests/command-undo.test.ts</files>
  <action>
Add to Game class:

```typescript
/**
 * Undo the last command in history.
 * Returns false if history is empty or last command is not invertible.
 *
 * @internal Used by MCTS for efficient state rollback
 */
undoLastCommand(): boolean {
  if (this.commandHistory.length === 0) return false;
  const lastCommand = this.commandHistory[this.commandHistory.length - 1];
  const result = undoCommand(this, lastCommand);
  if (result.success) {
    this.commandHistory.pop();
  }
  return result.success;
}

/**
 * Undo multiple commands from history.
 * Stops and returns false if any command is not invertible.
 *
 * @internal Used by MCTS for efficient state rollback
 */
undoCommands(count: number): boolean {
  for (let i = 0; i < count; i++) {
    if (!this.undoLastCommand()) return false;
  }
  return true;
}
```

Create packages/testing/tests/command-undo.test.ts with tests:
1. MOVE undo (piece moves back)
2. SET_ATTRIBUTE undo (value restored)
3. CREATE undo (element removed)
4. Multiple undo (several commands reversed in order)
5. Non-invertible command returns false

Use TestGame from testing package.

Avoid:
- Testing SHUFFLE undo (it's not invertible)
- Complex multi-step scenarios (keep tests focused)
  </action>
  <verify>pnpm test --filter=@boardsmith/testing command-undo passes all tests</verify>
  <done>Game.undoLastCommand() and undoCommands() work correctly, 5+ tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds without errors
- [ ] `pnpm test` passes all existing tests (no regressions)
- [ ] New command-undo tests pass
- [ ] undoCommand exported from @boardsmith/engine
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Game.undoLastCommand() correctly reverses MOVE, SET_ATTRIBUTE, CREATE commands
- Non-invertible commands (SHUFFLE) return false gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/28.1-mcts-performance/28.1-01-SUMMARY.md`
</output>
