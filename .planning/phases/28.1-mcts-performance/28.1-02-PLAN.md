---
phase: 28.1-mcts-performance
plan: 02
type: execute
---

<objective>
Convert MCTS from snapshot-based state management to incremental undo-based state management.

Purpose: Currently, MCTS reconstructs the entire game from scratch for every node expansion and playout. With command undo, we can maintain a single game instance and apply/undo moves as we traverse the tree. This eliminates the 60-70% overhead of full reconstruction.

Output: MCTSBot uses Game.undoCommands() for state rollback instead of restoreGame().
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28.1-mcts-performance/28.1-01-PLAN.md (or SUMMARY if complete)
@packages/ai/src/mcts-bot.ts
@packages/ai/src/types.ts

**Current flow (from analysis):**
1. play() captures root snapshot
2. select() traverses tree using UCT
3. expand() calls restoreGame(node.snapshot) → FULL RECONSTRUCTION
4. playout() reuses game OR calls restoreGame() → SOMETIMES RECONSTRUCTION
5. Each iteration: 1-2 full reconstructions

**New flow:**
1. play() keeps reference to live game
2. Tree nodes track "moves from root" path instead of snapshots
3. select() applies moves to game as it descends
4. expand() applies one more move, creates child
5. playout() continues from current state
6. backpropagate() undoes moves to return to root state

**Key challenge:** Flow state. Commands only cover element state, not flow engine state.
**Solution:** Store flow state snapshots in nodes (small), undo commands for element state.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add path-based node structure</name>
  <files>packages/ai/src/types.ts</files>
  <action>
Update MCTSNode interface to support path-based traversal:

```typescript
export interface MCTSNode {
  /** Flow state at this node (small, kept as snapshot) */
  flowState: FlowState;
  /** Parent node (null for root) */
  parent: MCTSNode | null;
  /** Move that led to this node from parent */
  parentMove: BotMove | null;
  /** Number of commands executed to reach this state from parent */
  commandCount: number;
  /** Child nodes that have been explored */
  children: MCTSNode[];
  /** Moves that haven't been tried yet */
  untriedMoves: BotMove[];
  /** Number of times this node has been visited */
  visits: number;
  /** Cumulative value (wins) from this node */
  value: number;
  /** Which player is to move at this node */
  currentPlayer: number;
}
```

Key changes:
- REMOVE snapshot field (no longer needed per-node)
- ADD commandCount: number of commands this move generated
- Keep flowState (flow state is small, ~1KB vs ~50KB for full snapshot)

Avoid:
- Breaking the interface (add new field, keep others)
- Actually, DO break it - snapshot was 95% of node memory
  </action>
  <verify>TypeScript compiles</verify>
  <done>MCTSNode has commandCount, no snapshot</done>
</task>

<task type="auto">
  <name>Task 2: Implement incremental state MCTS</name>
  <files>packages/ai/src/mcts-bot.ts</files>
  <action>
Refactor MCTSBot to use incremental state management:

1. Add instance variable to track live game during search:
   ```typescript
   private searchGame: G | null = null;
   private rootCommandCount: number = 0;
   ```

2. Modify play():
   - Clone game ONCE at start (or use the passed-in game directly)
   - Store initial commandHistory length as rootCommandCount
   - After search, game should be back at root state

3. Modify select():
   - As we descend, apply each node's parentMove to searchGame
   - Track total commands applied

4. Modify expand():
   - Apply move to searchGame (already at correct state from select)
   - Record how many commands the move generated (commandCount = new - old)
   - Create child node with commandCount
   - Return child and searchGame (already positioned)

5. Modify playout():
   - Use searchGame directly (no restore needed!)
   - Play random moves
   - Return evaluation

6. Modify backpropagate():
   - After playout, undo commands to return to node state
   - As we backpropagate up, undo each node's commands
   - After full backprop, game should be at root state

7. Add helper methods:
   ```typescript
   private applyPathToNode(node: MCTSNode): void {
     const path = this.getPathFromRoot(node);
     for (const n of path) {
       if (n.parentMove) {
         const player = this.getCurrentPlayerFromFlowState(n.parent!.flowState);
         this.searchGame!.continueFlow(n.parentMove.action, n.parentMove.args, player);
       }
     }
   }

   private getPathFromRoot(node: MCTSNode): MCTSNode[] {
     const path: MCTSNode[] = [];
     let current: MCTSNode | null = node;
     while (current && current.parent) {
       path.unshift(current);
       current = current.parent;
     }
     return path;
   }

   private undoToRoot(): void {
     const totalCommands = this.searchGame!.commandHistory.length - this.rootCommandCount;
     this.searchGame!.undoCommands(totalCommands);
   }
   ```

Avoid:
- Modifying the original this.game (use searchGame)
- Keeping snapshots (the whole point is to remove them)
- Complex undo tracking (just use commandHistory length)
  </action>
  <verify>TypeScript compiles</verify>
  <done>MCTSBot uses incremental state, no restoreGame() calls in hot path</done>
</task>

<task type="auto">
  <name>Task 3: Handle non-invertible commands (SHUFFLE) gracefully</name>
  <files>packages/ai/src/mcts-bot.ts</files>
  <action>
Add fallback for when undo fails (e.g., if action triggered SHUFFLE):

1. Before playout, capture commandHistory length
2. After playout, attempt undoCommands(n)
3. If undo fails (returns false):
   - Fall back to full reconstruction for this branch
   - Log warning (debug only)
   - Still works, just slower for that path

Add to MCTSBot:
```typescript
private recoverFromUndoFailure(targetCommandCount: number): void {
  // Undo failed - some command wasn't invertible
  // Restore game from scratch (fallback to old behavior)
  const snapshot = createSnapshot(this.game, this.gameType, this.actionHistory, this.seed);
  const game = this.restoreGame(snapshot);
  if (game) {
    this.searchGame = game as G;
  }
}
```

This ensures the bot ALWAYS works, even if games use SHUFFLE.
Most games don't shuffle mid-turn, so this fallback rarely triggers.

Avoid:
- Making undo failures crash the bot
- Silently returning wrong results
  </action>
  <verify>TypeScript compiles, bot works even with games that use SHUFFLE</verify>
  <done>SHUFFLE and other non-invertible commands handled gracefully</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds without errors
- [ ] `pnpm test` passes all existing tests
- [ ] MCTSBot.play() returns valid moves for Hex (connection game)
- [ ] MCTSBot.play() returns valid moves for Go Fish (collection game with shuffling)
- [ ] Memory usage significantly reduced (no per-node snapshots)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- MCTS search uses single game instance with apply/undo
- Non-invertible commands trigger graceful fallback
- Bot produces valid moves for all game types
</success_criteria>

<output>
After completion, create `.planning/phases/28.1-mcts-performance/28.1-02-SUMMARY.md`
</output>
