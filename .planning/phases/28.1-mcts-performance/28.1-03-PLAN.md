---
phase: 28.1-mcts-performance
plan: 03
type: execute
---

<objective>
Add move caching and transposition tables to MCTS to avoid redundant computation.

Purpose: Move enumeration happens at every node (15-20% of time). Position evaluation happens repeatedly for identical states reached via different move orders. Caching both provides significant speedup.

Output: Move cache per-node, transposition table for evaluated positions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28.1-mcts-performance/28.1-02-PLAN.md (or SUMMARY if complete)
@packages/ai/src/mcts-bot.ts
@packages/ai/src/types.ts

**Move caching insight:**
Currently, enumerateMoves() is called:
- Once at root to get initial moves
- Once per expand() to get new node's moves
- Once per playout step to get random move options

Moves at a node NEVER change (same position = same legal moves).
Cache moves when computed, reuse on subsequent visits.

**Transposition table insight:**
Different move orders can reach same position:
- A then B vs B then A (if independent)
- In games like Hex, this is common

If we've evaluated position X before, reuse that value.
Need fast position hashing (command history is one option).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add move caching per node</name>
  <files>packages/ai/src/types.ts, packages/ai/src/mcts-bot.ts</files>
  <action>
1. Update MCTSNode to cache all moves:
   ```typescript
   export interface MCTSNode {
     // ... existing fields ...
     /** All legal moves at this position (cached) */
     allMoves: BotMove[];
   }
   ```

2. Modify createNode() to accept allMoves parameter

3. Modify expand():
   - After applying move, enumerate moves for new position ONCE
   - Store in child.allMoves
   - Child's untriedMoves starts as copy of allMoves

4. Modify playout():
   - For each position, enumerate moves ONCE per unique position
   - If we return to a position (unlikely in playout), reuse cached

Actually, for playout we don't cache (random play, transient).
Caching is for the tree structure.

Key insight: When selecting untried move in expand(), we're removing from untriedMoves which is a subset of allMoves. This is already correct.

The optimization is: don't re-enumerate when visiting a node multiple times.
Currently, nodes store untriedMoves but we re-enumerate when needed.

Actually, looking at code more carefully: we enumerate at createNode time and store in untriedMoves. The issue is in enumerateMovesFromSnapshot which creates a game just to enumerate.

Main fix: Make sure we enumerate moves ONCE per node, store them, never re-enumerate.

Verify current code to ensure this is already the case or fix it.

Avoid:
- Caching across search iterations (clear between play() calls)
- Unbounded cache growth (nodes already limit this)
  </action>
  <verify>TypeScript compiles, no duplicate enumerateMoves calls per node</verify>
  <done>Moves enumerated once per node, cached in allMoves</done>
</task>

<task type="auto">
  <name>Task 2: Add transposition table for evaluations</name>
  <files>packages/ai/src/mcts-bot.ts, packages/ai/src/types.ts</files>
  <action>
Add transposition table to cache position evaluations:

1. Add to MCTSBot:
   ```typescript
   private transpositionTable: Map<string, { value: number; visits: number }> = new Map();
   ```

2. Add position hashing function:
   ```typescript
   private hashPosition(game: Game): string {
     // Use sorted command history as hash
     // Commands uniquely identify position
     const commands = game.commandHistory;
     return commands.map(c => JSON.stringify(c)).join('|');
   }
   ```

   This is deterministic: same commands = same position.
   For efficiency, could use hash of the string, but Map handles long keys fine.

3. Modify playout evaluation:
   - Before evaluating, check transposition table
   - If hit with sufficient visits, return cached value
   - After evaluating, store in table

   ```typescript
   private evaluateWithCache(game: Game, flowState: FlowState): number {
     const hash = this.hashPosition(game);
     const cached = this.transpositionTable.get(hash);
     if (cached && cached.visits >= 3) {
       // Enough confidence in this value
       return cached.value;
     }
     const value = this.evaluateTerminalFromGame(game, flowState);
     // Update cache with running average
     if (cached) {
       const newVisits = cached.visits + 1;
       const newValue = (cached.value * cached.visits + value) / newVisits;
       this.transpositionTable.set(hash, { value: newValue, visits: newVisits });
     } else {
       this.transpositionTable.set(hash, { value, visits: 1 });
     }
     return value;
   }
   ```

4. Clear transposition table at start of play() (fresh search)

5. Add config option to enable/disable:
   ```typescript
   export interface BotConfig {
     // ... existing ...
     /** Enable transposition table caching. Default: true */
     useTranspositionTable?: boolean;
   }
   ```

Avoid:
- Caching incomplete game evaluations with low confidence
- Keeping table between play() calls (stale data)
- Complex hash functions (JSON is slow but correct; optimize later if needed)
  </action>
  <verify>TypeScript compiles</verify>
  <done>Transposition table caches evaluated positions, configurable</done>
</task>

<task type="auto">
  <name>Task 3: Benchmark and verify correctness</name>
  <files>packages/ai/tests/mcts-cache.test.ts</files>
  <action>
Create test file to verify caching works correctly:

1. Test that cached evaluation matches fresh evaluation:
   ```typescript
   test('transposition table returns consistent values', async () => {
     // Create position, evaluate, clear cache, evaluate again
     // Values should match (within tolerance for objectives)
   });
   ```

2. Test that move caching doesn't affect move selection:
   ```typescript
   test('cached moves match fresh enumeration', () => {
     // Enumerate moves at position
     // Visit node again, verify same moves available
   });
   ```

3. Performance test (can be skipped in CI):
   ```typescript
   test.skip('transposition table reduces evaluation calls', async () => {
     // Count evaluation calls with and without table
     // Should see reduction when table enabled
   });
   ```

Use Hex or a simple game for testing.

Avoid:
- Flaky timing tests
- Tests that depend on exact iteration counts
  </action>
  <verify>pnpm test --filter=@boardsmith/ai mcts-cache passes</verify>
  <done>Cache correctness verified with tests</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds without errors
- [ ] `pnpm test` passes all existing tests
- [ ] New mcts-cache tests pass
- [ ] MCTS produces valid moves with caching enabled
- [ ] No memory leaks (tables cleared between searches)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Move caching prevents redundant enumeration
- Transposition table caches evaluations
- Caching can be disabled via config
</success_criteria>

<output>
After completion, create `.planning/phases/28.1-mcts-performance/28.1-03-SUMMARY.md`
</output>
