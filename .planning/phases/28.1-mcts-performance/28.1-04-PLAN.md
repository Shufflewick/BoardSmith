---
phase: 28.1-mcts-performance
plan: 04
type: execute
---

<objective>
Add parallel MCTS using Web Workers for browser multi-core utilization.

Purpose: Modern devices have 4-8+ cores. Serial MCTS uses only one. Root parallelization (multiple independent trees) is simple to implement and provides near-linear speedup. The browser needs Web Workers (different from Node worker_threads used in ai-trainer).

Output: MCTSBot can run parallel searches in browser via Web Workers, merging results for stronger play.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28.1-mcts-performance/28.1-03-PLAN.md (or SUMMARY if complete)
@packages/ai/src/mcts-bot.ts
@packages/ai/src/types.ts
@packages/ai-trainer/src/parallel-trainer.ts (reference for worker pattern)

**Root Parallelization Strategy:**
1. Launch N workers, each with copy of game state
2. Each worker runs independent MCTS search (different seed)
3. After timeout/iterations, collect root children from all workers
4. Merge by summing visits/values for same moves
5. Select move with highest total visits

This is the simplest parallel MCTS:
- No tree synchronization needed
- Workers are independent
- Merge is straightforward
- Near-linear speedup

**Web Worker considerations:**
- Workers run in separate threads
- Can't share memory (must serialize game state)
- Use postMessage for communication
- Need worker script file (bundled separately)

**Architecture:**
- packages/ai/src/mcts-worker.ts - Worker script
- packages/ai/src/parallel-mcts.ts - Coordinator
- MCTSBot gains parallelPlay() method
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCTS worker script</name>
  <files>packages/ai/src/mcts-worker.ts</files>
  <action>
Create Web Worker script for parallel MCTS:

```typescript
// mcts-worker.ts - Web Worker for parallel MCTS

import type { BotMove, BotConfig, MCTSNode } from './types.js';

interface WorkerInput {
  type: 'search';
  gameState: {
    className: string;
    settings: Record<string, unknown>;
    commandHistory: unknown[];
    actionHistory: unknown[];
    seed?: string;
  };
  playerIndex: number;
  config: BotConfig;
  workerSeed: string; // Different seed per worker for diversity
}

interface WorkerOutput {
  type: 'result';
  rootChildren: Array<{
    move: BotMove;
    visits: number;
    value: number;
  }>;
}

// Worker receives game state, runs MCTS, returns root children
self.onmessage = async (event: MessageEvent<WorkerInput>) => {
  const { gameState, playerIndex, config, workerSeed } = event.data;

  // Reconstruct game (workers can't share objects)
  // This requires the GameClass to be available - needs module import
  // For now, this is a stub showing the interface

  // Run MCTS with worker-specific seed
  const workerConfig = { ...config, seed: workerSeed };

  // After search, extract root children info
  const rootChildren: WorkerOutput['rootChildren'] = [];
  // ... populate from search results ...

  self.postMessage({ type: 'result', rootChildren } as WorkerOutput);
};
```

Key insight: Workers need to import the GameClass. This requires dynamic import or bundling.

For v1, use a simpler approach:
- Worker receives serialized game state (JSON)
- Worker imports MCTSBot dynamically
- Worker returns aggregated move statistics

The challenge is: workers can't import arbitrary game classes.
Solution: Game module path passed to worker, dynamic import like ai-trainer does.

Actually, looking at ai-trainer pattern, this is complex because it uses Node worker_threads with file:// URLs. Browser Web Workers work differently.

Simpler alternative for browser:
- Inline worker using Blob URL
- Pass GameClass constructor via structured clone (won't work - functions aren't cloneable)

Best approach for browser:
- MCTSBot stays serial (it's already async with yields)
- For browser, add multiple independent searches in same thread, interleaved
- True parallelization in browser requires game bundling changes

Let me revise this task to be more feasible:

REVISED: For this phase, implement "virtual parallelization" - run multiple independent searches sequentially but with different seeds, merge results. This provides diversity benefit (weaker than true parallelism but still improvement).

```typescript
// packages/ai/src/parallel-mcts.ts
export async function parallelPlay(
  game: Game,
  GameClass: GameClass,
  gameType: string,
  playerIndex: number,
  actionHistory: SerializedAction[],
  config: BotConfig,
  parallelCount: number = 4
): Promise<BotMove> {
  const results: Map<string, { visits: number; value: number; move: BotMove }> = new Map();

  for (let i = 0; i < parallelCount; i++) {
    const bot = new MCTSBot(
      game,
      GameClass,
      gameType,
      playerIndex,
      actionHistory,
      { ...config, seed: `${config.seed ?? 'default'}-${i}`, iterations: Math.floor(config.iterations / parallelCount) },
    );
    const move = await bot.play();
    // Can't get internal stats easily, so just count votes
    const key = JSON.stringify(move);
    const existing = results.get(key);
    if (existing) {
      existing.visits++;
    } else {
      results.set(key, { visits: 1, value: 0, move });
    }
  }

  // Return move with most votes
  let best: BotMove | null = null;
  let bestVotes = 0;
  for (const { visits, move } of results.values()) {
    if (visits > bestVotes) {
      bestVotes = visits;
      best = move;
    }
  }

  return best!;
}
```

This is "ensemble" MCTS - multiple independent searches vote on best move.
  </action>
  <verify>TypeScript compiles</verify>
  <done>parallelPlay function runs multiple MCTS searches with different seeds</done>
</task>

<task type="auto">
  <name>Task 2: Integrate parallel mode into MCTSBot</name>
  <files>packages/ai/src/mcts-bot.ts, packages/ai/src/types.ts</files>
  <action>
Add parallel configuration to MCTSBot:

1. Add to BotConfig:
   ```typescript
   /** Number of parallel searches (ensemble). Default: 1 */
   parallel?: number;
   ```

2. Modify play() to support ensemble mode:
   ```typescript
   async play(): Promise<BotMove> {
     if (this.config.parallel && this.config.parallel > 1) {
       return this.playParallel();
     }
     return this.playSingle();
   }

   private async playSingle(): Promise<BotMove> {
     // Existing play() logic
   }

   private async playParallel(): Promise<BotMove> {
     const parallelCount = this.config.parallel!;
     const iterationsPerSearch = Math.floor(this.config.iterations / parallelCount);

     // Run multiple searches, aggregate by move
     const moveVotes = new Map<string, { count: number; move: BotMove }>();

     for (let i = 0; i < parallelCount; i++) {
       // Create sub-bot with unique seed
       const subConfig = {
         ...this.config,
         seed: `${this.seed ?? 'default'}-parallel-${i}`,
         iterations: iterationsPerSearch,
         parallel: 1, // Don't recurse
       };

       // Note: This reuses same game instance which is fine for read-only root state
       const subBot = new MCTSBot(
         this.game,
         this.GameClass,
         this.gameType,
         this.playerIndex,
         this.actionHistory,
         subConfig,
         { objectives: this.objectives } as AIConfig
       );

       const move = await subBot.playSingle();
       const key = JSON.stringify(move);
       const existing = moveVotes.get(key);
       if (existing) {
         existing.count++;
       } else {
         moveVotes.set(key, { count: 1, move });
       }
     }

     // Return move with most votes
     let best: BotMove | null = null;
     let bestCount = 0;
     for (const { count, move } of moveVotes.values()) {
       if (count > bestCount) {
         bestCount = count;
         best = move;
       }
     }

     return best!;
   }
   ```

3. Update DIFFICULTY_PRESETS to optionally include parallel:
   ```typescript
   hard: { iterations: 500, playoutDepth: 0, timeout: 2000, parallel: 2 },
   ```

Avoid:
- True Web Worker parallelism (too complex for this phase)
- Modifying game state between parallel searches
  </action>
  <verify>TypeScript compiles, parallel: 2 produces valid moves</verify>
  <done>MCTSBot supports parallel ensemble mode via config.parallel</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Parallel ensemble MCTS with different seeds, voting on best move</what-built>
  <how-to-verify>
    1. Start dev server: `cd packages/games/hex && pnpm dev`
    2. Open browser, start a game against AI
    3. Set AI to hard difficulty (which enables parallel: 2)
    4. Play a few moves, verify AI responds reasonably
    5. Check browser console for any errors
    6. Verify AI doesn't hang or timeout excessively
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds without errors
- [ ] `pnpm test` passes all existing tests
- [ ] MCTSBot with parallel: 2 produces valid moves
- [ ] No performance regression for parallel: 1 (default)
</verification>

<success_criteria>

- All tasks completed
- Human verification approved
- Parallel ensemble mode works (multiple seeds, voting)
- Hard difficulty uses parallel by default
- No crashes or hangs in browser
</success_criteria>

<output>
After completion, create `.planning/phases/28.1-mcts-performance/28.1-04-SUMMARY.md` with:

# Phase 28.1 Plan 04: Parallel MCTS Summary

**Implemented ensemble MCTS with seed diversity for stronger play**

## Accomplishments
- Added config.parallel option for ensemble mode
- Multiple independent searches with different seeds vote on best move
- Hard difficulty preset enables parallel by default

## Note on True Parallelism
True Web Worker parallelism was deferred due to complexity:
- Workers can't share GameClass references
- Would require game bundling changes
- Ensemble mode provides diversity benefit with simpler implementation

Future work could add proper Web Worker parallelism if browser perf is critical.
</output>
