---
phase: 30-threat-response
plan: 01
type: execute
---

<objective>
Force AI to consider defensive moves when opponent has immediate winning threats.

Purpose: Address the limitation found in Phase 29 - AI plays well against itself but fails to block obvious human strategies because MCTS explores moves uniformly rather than prioritizing urgent defensive responses.

Output: MCTS bot that detects opponent threats and ensures blocking moves are explored early in the search tree.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./30-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-playout-lookahead/29-01-SUMMARY.md

# Key files:
@packages/ai/src/types.ts
@packages/ai/src/mcts-bot.ts
@packages/games/hex/rules/src/ai.ts

# Context from Phase 29:
- playoutDepth=3 improved AI vs AI win distribution (40%→57.5% P1)
- But AI still fails to block obvious straight-line human strategies
- The issue: objectives affect evaluation, not move selection

# Design insight:
The `opponent-near-win` objective (weight -6) penalizes positions where opponent is close to winning, but this only affects playout evaluation AFTER random simulation. The UCT formula explores moves uniformly, so the AI might not find blocking moves before iteration budget runs out.

# Solution approach:
Add optional `threatResponseMoves` hook to AIConfig that returns "must-consider" moves when opponent has immediate threats. MCTS prioritizes these moves in untriedMoves, ensuring they get explored early.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add threatResponseMoves to AIConfig and integrate into MCTSBot</name>
  <files>packages/ai/src/types.ts, packages/ai/src/mcts-bot.ts</files>
  <action>
1. In types.ts, add to AIConfig interface:
   ```typescript
   threatResponseMoves?: (game: Game, playerIndex: number, availableMoves: BotMove[]) => BotMove[];
   ```
   This optional function receives the game state, which player the bot is, and available moves. Returns a subset of moves that MUST be considered first (blocking moves when opponent threatens to win).

2. In mcts-bot.ts:
   - Store threatResponseMoves in constructor (from aiConfig)
   - In playSingle(), after enumerating moves, call threatResponseMoves if provided
   - If threat moves returned, reorder untriedMoves to put threat moves FIRST
   - This ensures MCTS explores blocking moves early before budget exhausts

Implementation note: Only affects root node move ordering. Child nodes use normal UCT exploration since we only need to ensure blocking moves get explored at all, not that they dominate the entire tree.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit -p packages/ai`</verify>
  <done>AIConfig has threatResponseMoves field, MCTSBot respects it at root node</done>
</task>

<task type="auto">
  <name>Task 2: Implement getHexThreatResponseMoves in Hex ai.ts</name>
  <files>packages/games/hex/rules/src/ai.ts</files>
  <action>
1. Add `getHexThreatResponseMoves` function that:
   - Computes opponent's shortest path distance (reuse computeShortestPathLength)
   - If opponent path ≤ 2 (near win), identifies cells along their shortest path
   - Returns moves that place stones in those blocking cells
   - Returns empty array if no immediate threat

2. Export function so it can be used in AI config

Implementation detail: To find blocking cells, find all cells on any shortest path from opponent's start edge to goal edge where cost = 1 (empty cells opponent needs). These are the cells that block the opponent if filled.

Pattern: Filter availableMoves to only those whose args reference blocking cell IDs.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit -p packages/games/hex/rules`</verify>
  <done>getHexThreatResponseMoves returns blocking moves when opponent path ≤ 2</done>
</task>

<task type="auto">
  <name>Task 3: Wire up threat response in Hex and benchmark</name>
  <files>packages/games/hex/rules/src/index.ts</files>
  <action>
1. In Hex index.ts, update the AI config export to include threatResponseMoves:
   ```typescript
   export const aiConfig: AIConfig = {
     objectives: getHexObjectives,
     threatResponseMoves: getHexThreatResponseMoves,
   };
   ```

2. Run benchmark comparing against Phase 29 baseline:
   - Use same test script pattern as Phase 29
   - Run 40+ AI vs AI games
   - Measure: win rate distribution, avg moves/game, avg time/game
   - Success: No regression in AI vs AI play (still ~57% P1)
   - Note: Main improvement is against human players (harder to measure automatically)
  </action>
  <verify>
Run benchmark: `cd packages/ai-trainer && npx tsx scripts/test-benchmark.ts 2>&1 | head -20`
Compare results to Phase 29 baseline (57.5% P1 win rate, 38 moves/game, 1.81s/game)
  </verify>
  <done>Hex uses threat response, benchmark shows no regression</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build -w packages/ai` succeeds
- [ ] `npm run build -w packages/games` succeeds (includes hex)
- [ ] Benchmark runs without errors
- [ ] AI vs AI performance not regressed from Phase 29
</verification>

<success_criteria>
- threatResponseMoves added to AIConfig interface
- MCTSBot prioritizes threat response moves at root node
- Hex game provides getHexThreatResponseMoves implementation
- Benchmark shows no regression from Phase 29 baseline
- AI now considers blocking moves when opponent is near winning
</success_criteria>

<output>
After completion, create `.planning/phases/30-threat-response/30-01-SUMMARY.md`:

# Phase 30-01: Threat Response Summary

**[One-liner describing outcome]**

## Accomplishments
- Added threatResponseMoves hook to AIConfig
- Implemented blocking move detection for Hex
- Benchmark results vs Phase 29 baseline

## Files Created/Modified
- `packages/ai/src/types.ts` - Added threatResponseMoves to AIConfig
- `packages/ai/src/mcts-bot.ts` - Integrated threat response at root node
- `packages/games/hex/rules/src/ai.ts` - Added getHexThreatResponseMoves
- `packages/games/hex/rules/src/index.ts` - Wired up threat response config

## Benchmark Results
[Compare to Phase 29: P1 57.5%, 38 moves, 1.81s]

## Next Step
Ready for Phase 31: trajectory-objectives
</output>
