---
phase: 32-move-ordering
plan: 01
type: execute
---

<objective>
Add move ordering hook to MCTS so promising moves are explored before random ones.

Purpose: Improve MCTS efficiency by exploring moves near opponent's pieces and recent activity first, finding good moves faster with fewer iterations.
Output: Working move ordering system with Hex implementation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/30-threat-response/30-01-SUMMARY.md
@.planning/phases/31-trajectory-objectives/31-01-SUMMARY.md

@packages/ai/src/types.ts
@packages/ai/src/mcts-bot.ts
@packages/games/hex/rules/src/ai.ts
@packages/games/hex/rules/src/index.ts

**Prior decisions:**
- Phase 30: threatResponseMoves only affects root node with urgent blocking
- Phase 30: Full BotAIConfig flows through session layer for extensibility
- Pattern established: Game-specific hooks via AIConfig (objectives, threatResponseMoves, playoutPolicy)

**Current behavior:**
- MCTS randomly selects from untriedMoves during expansion (line 346-347 in mcts-bot.ts)
- No heuristic ordering - all moves equally likely to be explored first
- threatResponseMoves only triggers when opponent near winning

**Phase 32 goal:**
- Add general move ordering that applies to ALL expansion, not just urgent threat cases
- Moves near opponent pieces/recent activity explored first
- This helps MCTS find good moves faster with same iteration count
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add moveOrdering hook to AIConfig and MCTSBot</name>
  <files>packages/ai/src/types.ts, packages/ai/src/mcts-bot.ts</files>
  <action>
1. In types.ts, add moveOrdering to AIConfig interface:
   ```typescript
   /**
    * Optional function to order moves by heuristic value for exploration.
    * Returns moves sorted by priority (highest first) to explore promising moves early.
    * Unlike threatResponseMoves (which forces specific moves), this is soft ordering:
    * MCTS still explores all moves, just in a better order.
    *
    * Typical ordering heuristics:
    * - Moves near opponent's recent pieces (contest territory)
    * - Moves adjacent to own stones (connectivity)
    * - Moves in central regions (early game)
    *
    * @param game - Current game state
    * @param playerIndex - Which player the bot is (1-indexed position)
    * @param moves - Available moves to order
    * @returns Moves sorted by priority (explore first â†’ last)
    */
   moveOrdering?: (game: Game, playerIndex: number, moves: BotMove[]) => BotMove[];
   ```

2. In mcts-bot.ts:
   - Add moveOrdering to constructor and store as private field (line ~40, ~70)
   - Modify createNode() to order untriedMoves if moveOrdering is available:
     - If moveOrdering exists, call it on allMoves and use result for untriedMoves
     - Otherwise, keep current behavior (copy allMoves directly)
   - The ordering affects exploration priority: first items in untriedMoves are tried first

3. Change the EXPAND phase to pick from FRONT of untriedMoves instead of random:
   - Line 346-347 currently: `const idx = Math.floor(this.rng() * node.untriedMoves.length);`
   - Change to: `const idx = 0;` (always pick first)
   - This makes ordering meaningful - sorted moves are tried in order
   - Comment explaining: "Pick first untried move (ordering determined at node creation)"
  </action>
  <verify>TypeScript compiles without errors: `pnpm build --filter @boardsmith/ai`</verify>
  <done>moveOrdering hook in AIConfig, MCTSBot uses ordering during expansion</done>
</task>

<task type="auto">
  <name>Task 2: Implement getHexMoveOrdering in Hex AI</name>
  <files>packages/games/hex/rules/src/ai.ts, packages/games/hex/rules/src/index.ts</files>
  <action>
1. In ai.ts, add getHexMoveOrdering function:
   ```typescript
   /**
    * Order moves for MCTS exploration.
    * Prioritizes:
    * 1. Moves adjacent to opponent's most recent stone (contest recent activity)
    * 2. Moves adjacent to own stones (build connectivity)
    * 3. Moves in central region (strategic positioning)
    * 4. Other moves (lower priority)
    *
    * @param game - Current game state
    * @param playerIndex - Which player the bot is
    * @param moves - Available moves to order
    * @returns Moves sorted by exploration priority
    */
   export function getHexMoveOrdering(
     game: Game,
     playerIndex: number,
     moves: BotMove[]
   ): BotMove[] {
     // Implementation:
     // 1. Find opponent's most recent stone (last placed)
     //    - Track via stone count or look at most recently added
     //    - For simplicity: find all opponent stones, assume most recent is highest id
     // 2. Score each move:
     //    - +10 if adjacent to opponent's most recent stone
     //    - +5 if adjacent to any opponent stone
     //    - +3 if adjacent to own stone
     //    - +2 if in center quarter of board
     //    - +1 base score
     // 3. Sort moves by score descending
     // 4. Return sorted array
   }
   ```

2. Use existing HEX_DIRECTIONS and cell lookup patterns from other functions in ai.ts.

3. In index.ts, add moveOrdering to the game definition's ai config:
   ```typescript
   ai: {
     objectives: getHexObjectives,
     threatResponseMoves: getHexThreatResponseMoves,
     playoutPolicy: getHexPlayoutPolicy,
     moveOrdering: getHexMoveOrdering,  // NEW
   }
   ```

4. DON'T forget to import getHexMoveOrdering in index.ts.
  </action>
  <verify>
1. TypeScript compiles: `pnpm build --filter hex-rules`
2. Manual check: Run `pnpm test --filter hex-rules` to ensure no test regressions
  </verify>
  <done>Hex has game-specific move ordering, wired into game definition</done>
</task>

<task type="auto">
  <name>Task 3: Run benchmark and verify improvement</name>
  <files>N/A (verification only)</files>
  <action>
1. Run Hex AI benchmark (40 games) to measure impact:
   ```bash
   cd packages/ai-trainer
   npx tsx scripts/test-benchmark.ts --game hex --iterations 50 --games 40
   ```

2. Compare with Phase 30/31 baseline:
   - Phase 29 baseline: 57.5% P1 win rate, 38 moves/game, 1.81s/game
   - Phase 30: No regression confirmed

3. Expected outcome:
   - Faster convergence (similar or better win distribution with same iterations)
   - Or: improved win rate if ordering helps find better moves
   - Game length/response time should remain similar

4. If benchmark shows regression:
   - Check if ordering is accidentally filtering moves (it shouldn't)
   - Verify untriedMoves still contains all moves, just reordered

5. Record results in summary.
  </action>
  <verify>Benchmark runs without errors, results recorded</verify>
  <done>Benchmark confirms move ordering doesn't regress and ideally improves AI quality</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pnpm build` succeeds without errors
- [ ] `pnpm test --filter @boardsmith/ai` passes all tests
- [ ] `pnpm test --filter hex-rules` passes all tests
- [ ] moveOrdering hook is documented in AIConfig interface
- [ ] Hex uses moveOrdering in game definition
- [ ] Benchmark results recorded (no regression)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- MCTS uses move ordering when hook provided
- Hex AI has game-specific move ordering
- No performance regression in benchmarks
</success_criteria>

<output>
After completion, create `.planning/phases/32-move-ordering/32-01-SUMMARY.md`:

# Phase 32 Plan 01: Move Ordering Summary

**[Substantive one-liner - what shipped]**

## Performance

- **Duration:** X min
- **Tasks:** 3
- **Files modified:** N

## Accomplishments
- Added moveOrdering hook to AIConfig
- MCTS uses ordering for expansion (explores high-priority moves first)
- Hex AI implements game-specific ordering

## Task Commits

1. **Task 1:** feat(32-01): add moveOrdering hook to AIConfig
2. **Task 2:** feat(32-01): implement Hex move ordering
3. **Task 3:** (verification only)

## Files Created/Modified
- packages/ai/src/types.ts
- packages/ai/src/mcts-bot.ts
- packages/games/hex/rules/src/ai.ts
- packages/games/hex/rules/src/index.ts

## Benchmark Results
[Record actual benchmark results]

## Issues Encountered
[Any problems and resolutions]

## Next Phase Readiness
Ready for Phase 33: RAVE (Rapid Action Value Estimation)
</output>
