---
phase: 34-gradient-objectives
plan: 01
type: execute
---

<objective>
Change objectives from boolean checkers to numeric (0.0-1.0) for finer-grained position evaluation.

Purpose: Boolean objectives lose information. "3 cells ahead" vs "1 cell ahead" both return true for `path-distance-advantage`, but 3-ahead should score higher. Gradient values preserve this information.

Output: Objective interface uses numeric checker, Hex objectives return gradient values, MCTS evaluation sums weighted gradient contributions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phase:**
@.planning/phases/33-rave/33-01-SUMMARY.md

**Key files:**
@packages/ai/src/types.ts
@packages/ai/src/mcts-bot.ts
@packages/games/hex/rules/src/ai.ts

**Established patterns:**
- RAVE/AMAF heuristic
- Path-based evaluation for Hex
- Shortest path Dijkstra algorithm
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Objective interface to numeric checker</name>
  <files>packages/ai/src/types.ts</files>
  <action>
Change Objective interface:
- `checker: (game: Game, playerIndex: number) => number` (was boolean)
- Add JSDoc: "Returns 0.0 to 1.0 where 0=not achieved, 1=fully achieved, values between for partial achievement"
- Weight interpretation stays the same: positive = good, negative = bad

This is a breaking change but only affects internal code (Hex AI).
  </action>
  <verify>npx tsc --noEmit shows type errors in mcts-bot.ts and ai.ts (expected - will fix in subsequent tasks)</verify>
  <done>Objective.checker returns number, JSDoc documents [0,1] range</done>
</task>

<task type="auto">
  <name>Task 2: Update MCTS evaluation to use numeric objectives</name>
  <files>packages/ai/src/mcts-bot.ts</files>
  <action>
In evaluateTerminalFromGame (around line 1154):

OLD:
```typescript
if (obj.checker(game, this.playerIndex)) {
  totalScore += obj.weight;
}
```

NEW:
```typescript
const achieved = obj.checker(game, this.playerIndex);
totalScore += obj.weight * achieved;
```

Update the score range calculation:
- maxPossibleScore = sum of positive weights (unchanged - assumes checker returns 1.0)
- minPossibleScore = sum of negative weights (unchanged - assumes checker returns 1.0)
- This is correct because max/min are bounds, not expected values

Remove the `matched: string[]` debug tracking since it was designed for boolean checkers. The normalized score in [0.1, 0.9] stays the same.
  </action>
  <verify>npx tsc --noEmit shows only errors in ai.ts (Hex objectives)</verify>
  <done>Evaluation multiplies weight by gradient value, compiles without changes to Hex</done>
</task>

<task type="auto">
  <name>Task 3: Convert Hex objectives to gradient values</name>
  <files>packages/games/hex/rules/src/ai.ts</files>
  <action>
Convert each objective checker from boolean to [0,1] gradient:

**path-distance-advantage** (weight: 10):
```typescript
// Before: return myPath < theirPath
// After: gradient based on relative path lengths
const advantage = theirPath - myPath;
const maxAdvantage = hexGame.boardSize; // maximum possible advantage
return Math.max(0, Math.min(1, (advantage + maxAdvantage) / (2 * maxAdvantage)));
// Result: 0.5 = tied, 1.0 = max advantage, 0.0 = max disadvantage
```

**near-win objectives** (within-1, within-2, within-3):
```typescript
// Before: return pathLength <= threshold
// After: gradient inversely proportional to path length
const maxPath = hexGame.boardSize;
return Math.max(0, 1 - pathLength / maxPath);
// Result: 1.0 = won, 0.0 = boardSize away, linear in between
```

**opponent-path-blocked** (weight: 9):
```typescript
// Before: return opponentPath === Infinity
// After: gradient based on how blocked opponent is
if (opponentPath === Infinity) return 1.0;
const maxPath = hexGame.boardSize;
return Math.min(1, opponentPath / maxPath);
// Result: 1.0 = blocked, 0.0 = opponent at edge
```

**opponent-near-win** (weight: -6):
```typescript
// Before: return opponentPath <= 2
// After: gradient inversely proportional to opponent path
const maxPath = hexGame.boardSize;
return Math.max(0, 1 - opponentPath / maxPath);
// Result: 1.0 = opponent won, 0.0 = opponent far from winning
// Negative weight makes high values bad for us
```

**fewer-groups** (weight: 2):
```typescript
// Before: return myGroups < theirGroups
// After: gradient based on relative group counts
if (myGroups === 0 && theirGroups === 0) return 0.5;
if (myGroups === 0) return 0.0;
if (theirGroups === 0) return 1.0;
return theirGroups / (myGroups + theirGroups);
// Result: 1.0 = opponent has many groups, 0.0 = we have many groups
```

**single-group** (weight: 1):
```typescript
// Before: return stoneCount > 0 && groups === 1
// After: gradient based on consolidation
if (stoneCount === 0) return 0.0;
return 1 / groups; // 1.0 for single group, 0.5 for two, etc.
```

Key principle: gradient should be MONOTONIC with the quality measure. Higher gradient = better position for that objective.
  </action>
  <verify>npx tsc --noEmit passes, pnpm run test passes</verify>
  <done>All Hex objectives return [0,1] gradients, types compile, tests pass</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` passes (no type errors)
- [ ] `pnpm run test` passes (all unit tests)
- [ ] Benchmark Hex AI: 40+ games, verify reasonable win rates and game lengths
</verification>

<success_criteria>

- Objective.checker returns number in [0,1] range
- MCTS evaluation uses gradient multiplication
- Hex objectives return meaningful gradients (not just 0/1)
- All tests pass
- Benchmark shows similar or improved play quality
</success_criteria>

<output>
After completion, create `.planning/phases/34-gradient-objectives/34-01-SUMMARY.md`:

# Phase 34 Plan 01: Gradient Objectives Summary

**[Substantive one-liner]**

## Accomplishments

- Updated Objective interface to numeric checker
- Modified MCTS evaluation to multiply weight by gradient
- Converted Hex objectives to [0,1] gradients

## Files Created/Modified

- `packages/ai/src/types.ts` - Objective.checker returns number
- `packages/ai/src/mcts-bot.ts` - Gradient-based evaluation
- `packages/games/hex/rules/src/ai.ts` - Gradient objective implementations

## Decisions Made

[Gradient formulas chosen and rationale]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Phase 35: Dynamic UCT
</output>
