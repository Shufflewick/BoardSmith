---
phase: 36-proof-number-search
plan: 01
type: execute
domain: ai
---

<objective>
Add Proof Number Search (PNS) infrastructure to MCTS for detecting forced wins and losses.

Purpose: Enable MCTS to identify and leverage proven/disproven game positions, avoiding tactical traps that random playouts miss.
Output: MCTSNode with proof/disproof numbers, UCT-PN selection formula, proof number propagation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-dynamic-uct/35-01-SUMMARY.md
@.planning/phases/33-rave/33-01-SUMMARY.md
@packages/ai/src/types.ts
@packages/ai/src/mcts-bot.ts

**Tech stack available:** TypeScript, MCTS with UCT-RAVE, transposition tables, RAVE
**Established patterns:** AIConfig hooks, BotConfig options, cached values per move

**Research summary (PN-MCTS paper: https://arxiv.org/html/2303.09449v4):**
- Proof/disproof numbers track how many leaves need expansion to prove/disprove a position
- Winning nodes: pn=0, dpn=∞; Lost/drawn nodes: pn=∞, dpn=0; Unknown leaves: pn=1, dpn=1
- OR nodes (player to move): pn = min(children), dpn = sum(children)
- AND nodes (opponent to move): pn = sum(children), dpn = min(children)
- UCT-PN: Rank nodes by proof number, blend ranking into UCB formula
- FSU variant achieved 93-96% win rate against vanilla MCTS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add proof number fields to types and MCTSNode</name>
  <files>packages/ai/src/types.ts</files>
  <action>
Add to BotConfig:
- `usePNS?: boolean` - Enable Proof Number Search (default: true)
- `pnWeight?: number` - Weight for proof number ranking in UCB formula (default: 0.5, range 0-1)

Add to MCTSNode interface:
- `proofNumber: number` - Leaves needed to prove this subtree (lower = easier to prove win)
- `disproofNumber: number` - Leaves needed to disprove (lower = easier to prove loss)
- `isProven: boolean` - True if this subtree is solved as a win
- `isDisproven: boolean` - True if this subtree is solved as a loss/draw

NOTE: Keep existing fields intact. The proof numbers supplement, not replace, existing UCT statistics.
  </action>
  <verify>TypeScript compiles: `cd packages/ai && npx tsc --noEmit`</verify>
  <done>MCTSNode has proofNumber, disproofNumber, isProven, isDisproven fields. BotConfig has usePNS and pnWeight options.</done>
</task>

<task type="auto">
  <name>Task 2: Initialize proof numbers in createNode and implement propagation</name>
  <files>packages/ai/src/mcts-bot.ts</files>
  <action>
1. In createNode(), initialize proof numbers for new nodes:
   - Leaf nodes (terminal or unexpanded): pn=1, dpn=1, isProven=false, isDisproven=false
   - If flowState.complete: Check winners to set proven/disproven status
     - If bot wins: pn=0, dpn=Infinity, isProven=true
     - If bot loses/draws: pn=Infinity, dpn=0, isDisproven=true

2. Add updateProofNumbers(node) helper that propagates proof numbers up from children:
   - Use perspective-aware propagation:
     - If node.currentPlayer === this.playerIndex (bot's turn, OR node):
       pn = min(child.pn), dpn = sum(child.dpn)
     - Else (opponent's turn, AND node):
       pn = sum(child.pn), dpn = min(child.dpn)
   - Mark isProven if pn === 0, isDisproven if dpn === 0

3. Call updateProofNumbers in backpropagateWithUndo for each node as we walk up the tree (before undoing moves, after updating visits/value).

NOTE: Use Math.min with infinity checks. Sum of any Infinity is Infinity. Min of 0 and anything is 0.
  </action>
  <verify>Run `pnpm test packages/ai` - all existing tests pass</verify>
  <done>Proof numbers initialize correctly and propagate up tree during backpropagation.</done>
</task>

<task type="auto">
  <name>Task 3: Implement UCT-PN selection formula</name>
  <files>packages/ai/src/mcts-bot.ts</files>
  <action>
Modify selectChild() to incorporate proof number ranking when this.config.usePNS !== false:

1. Compute proof number rank for each child:
   - Rank by (dis)proof number depending on perspective:
     - Bot's turn: rank by proof number (lower = better, closer to proving win)
     - Opponent's turn: rank by disproof number (lower = better for opponent)
   - Normalize rank to [0, 1]: `pnRank = 1 - (rank / maxRank)` where higher is better

2. Blend into UCT-RAVE score:
   ```
   score = (1 - pnWeight) * uctRaveScore + pnWeight * pnRank
   ```
   Use this.config.pnWeight ?? 0.5

3. Skip proven/disproven children with visits > 5 (solver enhancement):
   - Don't select isProven children when it's opponent's turn (opponent won't help us)
   - Don't select isDisproven children when it's our turn (avoid known losses)
   - Allow selection if visits < 5 to confirm solver result

This ensures MCTS focuses exploration on uncertain positions while still proving/disproving efficiently.
  </action>
  <verify>Run `pnpm test packages/ai` - all existing tests pass</verify>
  <done>selectChild uses UCT-PN formula blending proof numbers with UCT-RAVE. Proven/disproven subtrees excluded from selection.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm test packages/ai` - all tests pass
- [ ] `cd packages/ai && npx tsc --noEmit` - no type errors
- [ ] `pnpm build` - builds successfully
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Proof numbers propagate correctly through tree
- UCT-PN selection prefers promising paths
- Proven/disproven subtrees handled correctly
</success_criteria>

<output>
After completion, create `.planning/phases/36-proof-number-search/36-01-SUMMARY.md`
</output>
