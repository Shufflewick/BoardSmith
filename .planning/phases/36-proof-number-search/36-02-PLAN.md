---
phase: 36-proof-number-search
plan: 02
type: execute
domain: ai
---

<objective>
Complete PN-MCTS integration with final move selection and benchmark against vanilla MCTS.

Purpose: Leverage proven positions in move selection and validate PN-MCTS improves play quality.
Output: Complete PN-MCTS implementation, benchmark results showing improvement.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/36-proof-number-search/36-01-SUMMARY.md
@packages/ai/src/types.ts
@packages/ai/src/mcts-bot.ts
@packages/games/hex/rules/src/ai.ts

**Depends on:** 36-01 (proof number infrastructure)

**Research context:**
- PN-MCTS uses proof status in final move selection, not just exploration
- If any child is proven (pn=0), select it immediately (guaranteed win)
- If all children are disproven, select least-visited (delay inevitable loss)
- Benchmark protocol: AI vs AI games, measure win rate and game quality
</context>

<tasks>

<task type="auto">
  <name>Task 1: Use proof status in final move selection</name>
  <files>packages/ai/src/mcts-bot.ts</files>
  <action>
Modify the move selection logic at end of playSingle() (currently selects child with most visits):

1. If usePNS enabled, check for proven wins first:
   ```typescript
   // Look for proven win (guaranteed victory)
   const provenWin = root.children.find(c => c.isProven && c.visits >= 5);
   if (provenWin) return provenWin.parentMove!;
   ```

2. If all children are disproven, select the one with most visits (delay the inevitable):
   ```typescript
   const allDisproven = root.children.every(c => c.isDisproven);
   if (allDisproven) {
     // Select most-visited to delay loss (might find opponent mistake)
     const best = root.children.reduce((a, b) => a.visits > b.visits ? a : b);
     return best.parentMove!;
   }
   ```

3. Otherwise, fall back to existing logic (most visits) but among non-disproven children:
   ```typescript
   const validChildren = root.children.filter(c => !c.isDisproven || c.visits < 5);
   if (validChildren.length === 0) {
     // All disproven - use most visited
     const best = root.children.reduce((a, b) => a.visits > b.visits ? a : b);
     return best.parentMove!;
   }
   const best = validChildren.reduce((a, b) => a.visits > b.visits ? a : b);
   return best.parentMove!;
   ```

NOTE: The visits >= 5 threshold ensures we don't trust proof status from too few samples.
  </action>
  <verify>Run `pnpm test packages/ai` - all tests pass</verify>
  <done>Final move selection prioritizes proven wins, avoids disproven losses, falls back to visits.</done>
</task>

<task type="auto">
  <name>Task 2: Add logging for proof number debugging</name>
  <files>packages/ai/src/mcts-bot.ts</files>
  <action>
Add optional debug logging for proof number analysis (enabled by config.debug):

1. Add to BotConfig in types.ts: `debug?: boolean`

2. At end of playSingle(), if this.config.debug:
   ```typescript
   if (this.config.debug) {
     const proven = root.children.filter(c => c.isProven).length;
     const disproven = root.children.filter(c => c.isDisproven).length;
     const unknown = root.children.length - proven - disproven;
     console.log(`[MCTS] Move selection: ${proven} proven, ${disproven} disproven, ${unknown} unknown of ${root.children.length} children`);
     if (proven > 0) {
       console.log(`[MCTS] Selecting proven win!`);
     }
   }
   ```

This helps diagnose whether proof numbers are working correctly in practice.
  </action>
  <verify>Run `pnpm test packages/ai` - all tests pass</verify>
  <done>Debug logging shows proof number statistics when enabled.</done>
</task>

<task type="auto">
  <name>Task 3: Benchmark PN-MCTS vs vanilla MCTS on Hex</name>
  <files>packages/ai-trainer/scripts/test-benchmark.ts</files>
  <action>
Create or update benchmark script to compare PN-MCTS vs vanilla MCTS:

1. Run 40 games with PN-MCTS enabled (usePNS: true)
2. Run 40 games with PN-MCTS disabled (usePNS: false)
3. Compare:
   - P1/P2 win rates
   - Average game length
   - Average move time

Use hard difficulty (500 iterations) on default 11x11 Hex board.

Expected: PN-MCTS should show improvement in:
- Fewer blunders (detecting forced losses earlier)
- More decisive wins (detecting forced wins)
- Similar or better move times (avoiding exploration of proven/disproven subtrees)

Document results in summary.
  </action>
  <verify>Run benchmark: `cd packages/ai-trainer && npx tsx scripts/test-benchmark.ts`</verify>
  <done>Benchmark results documented showing PN-MCTS performance vs vanilla MCTS.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm test packages/ai` - all tests pass
- [ ] `pnpm build` - builds successfully
- [ ] Benchmark shows PN-MCTS performance data
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Final move selection uses proof status correctly
- Benchmark results documented
- PN-MCTS shows measurable improvement or theoretical benefit
</success_criteria>

<output>
After completion, create `.planning/phases/36-proof-number-search/36-02-SUMMARY.md` with:
- Implementation details
- Benchmark results table
- Observations on proof number effectiveness
</output>
