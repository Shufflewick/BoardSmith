---
phase: 59-core-animation-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/element/game.ts
autonomous: true

must_haves:
  truths:
    - "Game can emit animation events with type, data, and optional group"
    - "Each event has a unique ID (monotonically increasing) and timestamp"
    - "Events accumulate in buffer until acknowledged"
    - "Acknowledging up to an ID clears consumed events"
  artifacts:
    - path: "src/engine/element/game.ts"
      provides: "AnimationEvent type, EmitAnimationEventOptions type, emitAnimationEvent(), pendingAnimationEvents getter, acknowledgeAnimationEvents()"
      contains: "AnimationEvent"
  key_links:
    - from: "emitAnimationEvent"
      to: "_animationEvents buffer"
      via: "push to array"
      pattern: "this\\._animationEvents\\.push"
    - from: "acknowledgeAnimationEvents"
      to: "_animationEvents buffer"
      via: "filter or splice"
      pattern: "this\\._animationEvents"
---

<objective>
Add animation event types and core API to the Game class.

Purpose: Enable game logic to emit animation events that UI can play back asynchronously (soft continuation pattern). Events are UI hints stored in a buffer, not state mutations.

Output: Game class with `emitAnimationEvent()`, `pendingAnimationEvents`, and `acknowledgeAnimationEvents()` methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-core-animation-events/59-RESEARCH.md

# Existing code patterns
@src/engine/element/game.ts (lines 260-280 for similar state patterns, lines 2264-2277 for toJSON pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add animation event types and private state</name>
  <files>src/engine/element/game.ts</files>
  <action>
Add the AnimationEvent and EmitAnimationEventOptions interfaces near the top of game.ts (after GamePhase type, around line 127):

```typescript
/**
 * Animation event emitted during game execution.
 * These are UI hints, NOT state mutations. They flow through the session
 * layer to UI consumers who play them back asynchronously.
 */
export interface AnimationEvent {
  /** Unique ID for acknowledgment (monotonically increasing) */
  id: number;
  /** Event type (e.g., 'combat', 'score', 'cardFlip') */
  type: string;
  /** Event-specific data payload (must be JSON-serializable) */
  data: Record<string, unknown>;
  /** Timestamp when event was emitted */
  timestamp: number;
  /** Optional group ID for batching related events */
  group?: string;
}

/**
 * Options for emitting an animation event
 */
export interface EmitAnimationEventOptions {
  /** Group ID for batching related events (e.g., all combat events in a turn) */
  group?: string;
}
```

Add private state to the Game class (after the existing private fields around line 291):

```typescript
/** Animation events buffer (for UI playback) */
private _animationEvents: AnimationEvent[] = [];

/** Animation event sequence counter (for unique IDs) */
private _animationEventSeq: number = 0;
```

Update the `_safeProperties` Set (around line 294-300) to include animation event fields:
- Add `'_animationEvents'` and `'_animationEventSeq'` to the Set

Update `unserializableAttributes` (around line 303-313):
- Do NOT add animation events here - they SHOULD serialize (unlike commandHistory which doesn't)
  </action>
  <verify>
TypeScript compilation succeeds: `npx tsc --noEmit`
  </verify>
  <done>
AnimationEvent and EmitAnimationEventOptions types exported from game.ts. Game class has private `_animationEvents` array and `_animationEventSeq` counter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add animation event public API</name>
  <files>src/engine/element/game.ts</files>
  <action>
Add the animation event public methods to the Game class. Place them in a new section after the Message System section (around line 2255), following the existing comment pattern:

```typescript
// ============================================
// Animation Events
// ============================================

/**
 * Emit an animation event for UI playback.
 *
 * Animation events are UI hints that flow through the session layer to UI
 * consumers. They do NOT mutate game state - the game continues immediately
 * while UI plays back events asynchronously (soft continuation pattern).
 *
 * @param type - Event type identifier (e.g., 'combat', 'score', 'cardFlip')
 * @param data - Event-specific data payload (must be JSON-serializable - use element IDs, not references)
 * @param options - Optional configuration including group ID for batching
 * @returns The created animation event (for reference, though usually not needed)
 *
 * @example
 * ```typescript
 * // Emit a combat animation event
 * this.emitAnimationEvent('combat', {
 *   attackerId: attacker.id,
 *   defenderId: defender.id,
 *   damage: 5,
 *   outcome: 'hit'
 * });
 *
 * // Emit grouped events (e.g., all combat in a single action)
 * this.emitAnimationEvent('attack', { ... }, { group: `combat-${turnNumber}` });
 * this.emitAnimationEvent('damage', { ... }, { group: `combat-${turnNumber}` });
 * this.emitAnimationEvent('death', { ... }, { group: `combat-${turnNumber}` });
 * ```
 */
emitAnimationEvent(
  type: string,
  data: Record<string, unknown>,
  options?: EmitAnimationEventOptions
): AnimationEvent {
  const event: AnimationEvent = {
    id: ++this._animationEventSeq,
    type,
    data: { ...data }, // Shallow copy to prevent external mutation
    timestamp: Date.now(),
    ...(options?.group && { group: options.group }),
  };
  this._animationEvents.push(event);
  return event;
}

/**
 * Get animation events that have not yet been acknowledged.
 *
 * UI consumers read this to get events to play back. Events remain in the
 * buffer until explicitly acknowledged via `acknowledgeAnimationEvents()`.
 *
 * @returns Array of pending animation events (copy - modifications don't affect buffer)
 */
get pendingAnimationEvents(): AnimationEvent[] {
  return [...this._animationEvents];
}

/**
 * Acknowledge animation events up to (and including) the given ID.
 *
 * Call this after UI has finished playing back events. Events with ID <= upToId
 * are removed from the buffer. Safe to call with any ID value - events that
 * don't exist or have already been acknowledged are simply ignored.
 *
 * @param upToId - Acknowledge all events with ID <= this value
 *
 * @example
 * ```typescript
 * // After playing back events
 * const events = game.pendingAnimationEvents;
 * await playAnimations(events);
 * if (events.length > 0) {
 *   game.acknowledgeAnimationEvents(events[events.length - 1].id);
 * }
 * ```
 */
acknowledgeAnimationEvents(upToId: number): void {
  this._animationEvents = this._animationEvents.filter(e => e.id > upToId);
}
```

Export AnimationEvent and EmitAnimationEventOptions from the module (add to exports at top if needed, or they're auto-exported via the interface definitions).
  </action>
  <verify>
TypeScript compilation succeeds: `npx tsc --noEmit`
  </verify>
  <done>
Game class has `emitAnimationEvent(type, data, options?)` method, `pendingAnimationEvents` getter, and `acknowledgeAnimationEvents(upToId)` method. All methods have JSDoc documentation.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` succeeds
2. Types are exported: AnimationEvent, EmitAnimationEventOptions
3. Game class has animation event methods visible in autocomplete
</verification>

<success_criteria>
- AnimationEvent interface has: id (number), type (string), data (Record), timestamp (number), group? (string)
- emitAnimationEvent returns AnimationEvent with auto-incremented id
- pendingAnimationEvents returns copy of buffer
- acknowledgeAnimationEvents removes events with id <= upToId
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/59-core-animation-events/59-01-SUMMARY.md`
</output>
