---
phase: 59-core-animation-events
plan: 02
type: execute
wave: 2
depends_on: ["59-01"]
files_modified:
  - src/engine/element/game.ts
  - src/engine/element/animation-events.test.ts
autonomous: true

must_haves:
  truths:
    - "Animation buffer survives serialize/restore round-trip"
    - "Animation event sequence counter restores correctly (no duplicate IDs after restore)"
    - "Empty animation buffer does not clutter serialized state"
  artifacts:
    - path: "src/engine/element/game.ts"
      provides: "toJSON includes animationEvents and animationEventSeq, restoreGame restores them"
      contains: "animationEvents"
    - path: "src/engine/element/animation-events.test.ts"
      provides: "Comprehensive unit tests for animation event system"
      contains: "emitAnimationEvent"
  key_links:
    - from: "toJSON"
      to: "animationEvents"
      via: "conditional spread"
      pattern: "animationEvents.*this\\._animationEvents"
    - from: "restoreGame"
      to: "_animationEvents"
      via: "restore from json"
      pattern: "json\\.animationEvents"
---

<objective>
Add serialization support and comprehensive tests for the animation event system.

Purpose: Ensure animation events survive checkpoint/restore cycles (critical for replay and reconnection) and verify all edge cases work correctly.

Output: Animation buffer serializes with game state, restores correctly including sequence counter. Full test coverage of emit/acknowledge/serialize cycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-core-animation-events/59-RESEARCH.md
@.planning/phases/59-core-animation-events/59-01-SUMMARY.md

# Existing serialization patterns
@src/engine/element/game.ts (lines 2264-2277 for toJSON, lines 2414-2455 for restoreGame)
@src/engine/utils/snapshot.test.ts (test patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add animation event serialization</name>
  <files>src/engine/element/game.ts</files>
  <action>
Update the `toJSON()` method (around line 2264) to include animation events conditionally:

1. Update the return type to include optional animation event fields:
```typescript
override toJSON(): ElementJSON & {
  phase: GamePhase;
  isFinished: boolean;
  messages: Array<{ text: string; data?: Record<string, unknown> }>;
  settings: Record<string, unknown>;
  animationEvents?: AnimationEvent[];
  animationEventSeq?: number;
}
```

2. In the return statement, use conditional spread to only include if there are events:
```typescript
return {
  ...super.toJSON(),
  phase: this.phase,
  isFinished: this.isFinished(),
  messages: this.messages,
  settings: this.settings,
  // Only include animation events if buffer is non-empty (avoid cluttering empty snapshots)
  ...(this._animationEvents.length > 0 && {
    animationEvents: this._animationEvents,
    animationEventSeq: this._animationEventSeq,
  }),
};
```

Update the `restoreGame()` static method (around line 2414) to restore animation events:

After `game.settings = json.settings;` (around line 2437), add:
```typescript
// Restore animation events if present
if (json.animationEvents) {
  game._animationEvents = [...json.animationEvents];
  game._animationEventSeq = json.animationEventSeq ?? 0;
}
```

Note: The private fields need to be accessed. Since restoreGame is a static method on Game class, it has access to private members of Game instances. If TypeScript complains, you may need to cast or use a protected accessor pattern.
  </action>
  <verify>
TypeScript compilation succeeds: `npx tsc --noEmit`
  </verify>
  <done>
toJSON() includes animationEvents and animationEventSeq when buffer is non-empty. restoreGame() restores animation events and sequence counter from JSON.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add animation event unit tests</name>
  <files>src/engine/element/animation-events.test.ts</files>
  <action>
Create a new test file `src/engine/element/animation-events.test.ts` with comprehensive tests:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { Game, AnimationEvent } from './game.js';
import { Player } from '../player/player.js';

class TestGame extends Game<TestGame, Player> {}

describe('Animation Events', () => {
  let game: TestGame;

  beforeEach(() => {
    game = new TestGame({ playerCount: 2, seed: 'test' });
  });

  describe('emitAnimationEvent', () => {
    it('should emit an event with unique ID', () => {
      const event = game.emitAnimationEvent('combat', { damage: 5 });

      expect(event.id).toBe(1);
      expect(event.type).toBe('combat');
      expect(event.data).toEqual({ damage: 5 });
      expect(event.timestamp).toBeGreaterThan(0);
    });

    it('should assign monotonically increasing IDs', () => {
      const event1 = game.emitAnimationEvent('combat', {});
      const event2 = game.emitAnimationEvent('score', {});
      const event3 = game.emitAnimationEvent('move', {});

      expect(event1.id).toBe(1);
      expect(event2.id).toBe(2);
      expect(event3.id).toBe(3);
    });

    it('should include optional group', () => {
      const event = game.emitAnimationEvent('combat', { damage: 5 }, { group: 'turn-1' });

      expect(event.group).toBe('turn-1');
    });

    it('should not include group when not provided', () => {
      const event = game.emitAnimationEvent('combat', { damage: 5 });

      expect(event.group).toBeUndefined();
    });

    it('should shallow copy data to prevent external mutation', () => {
      const data = { value: 1 };
      const event = game.emitAnimationEvent('test', data);

      data.value = 999;
      expect(event.data.value).toBe(1);
    });
  });

  describe('pendingAnimationEvents', () => {
    it('should return empty array when no events', () => {
      expect(game.pendingAnimationEvents).toEqual([]);
    });

    it('should return all emitted events', () => {
      game.emitAnimationEvent('a', {});
      game.emitAnimationEvent('b', {});
      game.emitAnimationEvent('c', {});

      const pending = game.pendingAnimationEvents;
      expect(pending).toHaveLength(3);
      expect(pending.map(e => e.type)).toEqual(['a', 'b', 'c']);
    });

    it('should return a copy (not affect internal buffer)', () => {
      game.emitAnimationEvent('test', {});

      const pending = game.pendingAnimationEvents;
      pending.push({ id: 999, type: 'fake', data: {}, timestamp: 0 });

      expect(game.pendingAnimationEvents).toHaveLength(1);
    });
  });

  describe('acknowledgeAnimationEvents', () => {
    it('should clear events up to given ID', () => {
      game.emitAnimationEvent('a', {});
      game.emitAnimationEvent('b', {});
      game.emitAnimationEvent('c', {});

      game.acknowledgeAnimationEvents(2);

      const pending = game.pendingAnimationEvents;
      expect(pending).toHaveLength(1);
      expect(pending[0].type).toBe('c');
    });

    it('should be safe with ID higher than any event', () => {
      game.emitAnimationEvent('a', {});
      game.emitAnimationEvent('b', {});

      game.acknowledgeAnimationEvents(999);

      expect(game.pendingAnimationEvents).toHaveLength(0);
    });

    it('should be safe with ID of zero (no-op)', () => {
      game.emitAnimationEvent('a', {});
      game.emitAnimationEvent('b', {});

      game.acknowledgeAnimationEvents(0);

      expect(game.pendingAnimationEvents).toHaveLength(2);
    });

    it('should be idempotent', () => {
      game.emitAnimationEvent('a', {});
      game.emitAnimationEvent('b', {});

      game.acknowledgeAnimationEvents(1);
      game.acknowledgeAnimationEvents(1);
      game.acknowledgeAnimationEvents(1);

      expect(game.pendingAnimationEvents).toHaveLength(1);
    });
  });

  describe('serialization', () => {
    it('should serialize animation events in toJSON', () => {
      game.emitAnimationEvent('combat', { damage: 5 });
      game.emitAnimationEvent('score', { points: 10 }, { group: 'turn-1' });

      const json = game.toJSON();

      expect(json.animationEvents).toHaveLength(2);
      expect(json.animationEventSeq).toBe(2);
      expect(json.animationEvents![0].type).toBe('combat');
      expect(json.animationEvents![1].group).toBe('turn-1');
    });

    it('should not include animation events when buffer is empty', () => {
      const json = game.toJSON();

      expect(json.animationEvents).toBeUndefined();
      expect(json.animationEventSeq).toBeUndefined();
    });

    it('should restore animation events from JSON', () => {
      game.emitAnimationEvent('combat', { damage: 5 });
      game.emitAnimationEvent('score', { points: 10 });

      const json = game.toJSON();
      const restored = Game.restoreGame(json, TestGame, new Map());

      const pending = restored.pendingAnimationEvents;
      expect(pending).toHaveLength(2);
      expect(pending[0].type).toBe('combat');
      expect(pending[1].type).toBe('score');
    });

    it('should restore sequence counter (no duplicate IDs after restore)', () => {
      game.emitAnimationEvent('a', {});
      game.emitAnimationEvent('b', {});

      const json = game.toJSON();
      const restored = Game.restoreGame(json, TestGame, new Map());

      // New events should continue from where we left off
      const newEvent = restored.emitAnimationEvent('c', {});
      expect(newEvent.id).toBe(3);
    });

    it('should handle restore with no animation events', () => {
      const json = game.toJSON();
      const restored = Game.restoreGame(json, TestGame, new Map());

      expect(restored.pendingAnimationEvents).toEqual([]);

      // Should start fresh
      const event = restored.emitAnimationEvent('test', {});
      expect(event.id).toBe(1);
    });

    it('should preserve events after partial acknowledgment and restore', () => {
      game.emitAnimationEvent('a', {});
      game.emitAnimationEvent('b', {});
      game.emitAnimationEvent('c', {});
      game.acknowledgeAnimationEvents(1);

      const json = game.toJSON();
      const restored = Game.restoreGame(json, TestGame, new Map());

      const pending = restored.pendingAnimationEvents;
      expect(pending).toHaveLength(2);
      expect(pending.map(e => e.type)).toEqual(['b', 'c']);
    });
  });
});
```
  </action>
  <verify>
Run tests: `npm test -- src/engine/element/animation-events.test.ts`

All tests should pass:
- emitAnimationEvent tests (5 tests)
- pendingAnimationEvents tests (3 tests)
- acknowledgeAnimationEvents tests (4 tests)
- serialization tests (6 tests)
  </verify>
  <done>
All 18 animation event tests pass. Tests cover: emit with unique IDs, monotonic sequence, optional group, data copying, pending getter returns copy, acknowledge clears correctly, acknowledge edge cases, serialization includes events, empty buffer not serialized, restore preserves events, restore preserves sequence counter.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` succeeds
2. `npm test -- src/engine/element/animation-events.test.ts` - all tests pass
3. `npm test` - no regressions in existing tests
</verification>

<success_criteria>
- toJSON() includes animationEvents and animationEventSeq only when buffer non-empty
- restoreGame() restores both _animationEvents and _animationEventSeq
- All 18 unit tests pass
- No regressions in existing engine tests
</success_criteria>

<output>
After completion, create `.planning/phases/59-core-animation-events/59-02-SUMMARY.md`
</output>
