---
phase: 60-session-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/index.ts
  - src/session/types.ts
  - src/session/utils.ts
  - src/session/game-session.ts
  - src/session/index.ts
autonomous: true

must_haves:
  truths:
    - "PlayerGameState includes animationEvents array from game buffer"
    - "PlayerGameState includes lastAnimationEventId for acknowledgment tracking"
    - "GameSession.acknowledgeAnimations(playerSeat, upToId) clears events"
    - "Session snapshots preserve animation event buffer"
  artifacts:
    - path: "src/engine/index.ts"
      provides: "AnimationEvent type export"
      contains: "AnimationEvent"
    - path: "src/session/types.ts"
      provides: "PlayerGameState with animation fields"
      contains: "animationEvents"
    - path: "src/session/utils.ts"
      provides: "buildPlayerState includes animation events"
      contains: "pendingAnimationEvents"
    - path: "src/session/game-session.ts"
      provides: "acknowledgeAnimations method"
      contains: "acknowledgeAnimations"
  key_links:
    - from: "src/session/utils.ts"
      to: "game.pendingAnimationEvents"
      via: "getter call in buildPlayerState"
      pattern: "runner\\.game\\.pendingAnimationEvents"
    - from: "src/session/game-session.ts"
      to: "game.acknowledgeAnimationEvents"
      via: "delegation from session method"
      pattern: "acknowledgeAnimationEvents\\(upToId\\)"
---

<objective>
Expose animation events from Game layer to Session layer for UI consumption.

Purpose: Enable UI consumers to receive animation events via PlayerGameState and acknowledge them via GameSession, bridging the Phase 59 engine implementation to the session API that clients use.

Output: PlayerGameState with animationEvents/lastAnimationEventId fields, GameSession.acknowledgeAnimations() method, AnimationEvent type exported for external use.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-session-integration/60-RESEARCH.md

# Phase 59 completed the Game-level animation event API:
# - game.emitAnimationEvent(type, data, options?)
# - game.pendingAnimationEvents getter (returns copy)
# - game.acknowledgeAnimationEvents(upToId)
# - Serialization via toJSON/restoreGame

# Current code references:
@src/engine/index.ts
@src/session/types.ts
@src/session/utils.ts
@src/session/game-session.ts
@src/session/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export AnimationEvent type from engine</name>
  <files>src/engine/index.ts</files>
  <action>
Add AnimationEvent and EmitAnimationEventOptions type exports from engine/index.ts.

In the type exports section (around line 23-37), add:

```typescript
export type {
  // ... existing types ...
  AnimationEvent,
  EmitAnimationEventOptions,
} from './element/index.js';
```

This makes the types available for the session layer and external consumers. The types are already defined in game.ts and exported from element/index.ts.

NOTE: Verify the types are actually exported from element/index.ts first. If not, add the re-export there too.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors.
Grep for "AnimationEvent" in engine/index.ts to confirm export present.
  </verify>
  <done>AnimationEvent and EmitAnimationEventOptions types are exported from src/engine/index.ts and available for import by session layer.</done>
</task>

<task type="auto">
  <name>Task 2: Add animation fields to PlayerGameState</name>
  <files>src/session/types.ts</files>
  <action>
Add animation event fields to the PlayerGameState interface.

1. Import AnimationEvent type at top of file:
```typescript
import type { FlowState, SerializedAction, Game, AnimationEvent } from '../engine/index.js';
```

2. Add to PlayerGameState interface (around line 398-416):
```typescript
export interface PlayerGameState {
  // ... existing fields ...

  /** Animation events pending playback (from game buffer). Only present when events exist. */
  animationEvents?: AnimationEvent[];

  /** ID of the last animation event, for acknowledgment convenience. Only present when events exist. */
  lastAnimationEventId?: number;
}
```

Design notes from research:
- Optional fields: Only included when buffer is non-empty (clean JSON)
- Array copy: Events are already copied by game.pendingAnimationEvents getter
- lastAnimationEventId: Convenience so UI doesn't need to compute events[events.length - 1].id
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors.
Grep for "animationEvents" in types.ts to confirm field present.
  </verify>
  <done>PlayerGameState interface includes optional animationEvents and lastAnimationEventId fields typed correctly.</done>
</task>

<task type="auto">
  <name>Task 3: Include animation events in buildPlayerState</name>
  <files>src/session/utils.ts</files>
  <action>
Modify buildPlayerState() to include animation events from the game buffer.

1. In buildPlayerState() function (around line 346), after building the base state object (around line 406-416), add animation events BEFORE the return statement:

```typescript
  // Include animation events if any are pending
  const animationEvents = runner.game.pendingAnimationEvents;
  if (animationEvents.length > 0) {
    state.animationEvents = animationEvents;
    state.lastAnimationEventId = animationEvents[animationEvents.length - 1].id;
  }

  return state;
```

This should go AFTER the customDebug block (around line 428-432) and BEFORE the final `return state;`.

Key design decisions:
- Only add fields when buffer is non-empty (avoids cluttering JSON with empty arrays)
- Use game.pendingAnimationEvents getter which already returns a copy
- Set lastAnimationEventId to final event's ID for UI convenience
- Spectators (position 0) also receive events - they're watching and should see animations
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors.
Grep for "pendingAnimationEvents" in utils.ts to confirm integration.
  </verify>
  <done>buildPlayerState() includes animationEvents and lastAnimationEventId in returned PlayerGameState when buffer is non-empty.</done>
</task>

<task type="auto">
  <name>Task 4: Add acknowledgeAnimations to GameSession</name>
  <files>src/session/game-session.ts</files>
  <action>
Add acknowledgeAnimations() method to GameSession class.

1. Add the method in the State Methods section (after getHistory around line 569), or create a new section "Animation Methods":

```typescript
// ============================================
// Animation Methods
// ============================================

/**
 * Acknowledge animation events for a player up to a given ID.
 *
 * This is NOT a game action - it doesn't modify game state or action history.
 * It's session-level bookkeeping for UI playback tracking.
 *
 * The playerSeat parameter is included for future multi-client support
 * (tracking per-client acknowledgment), but currently all clients share
 * the same game buffer.
 *
 * @param playerSeat - Player seat acknowledging events (1-indexed)
 * @param upToId - Acknowledge all events with ID <= this value
 */
acknowledgeAnimations(playerSeat: number, upToId: number): void {
  // Delegate to game's acknowledge method
  this.#runner.game.acknowledgeAnimationEvents(upToId);

  // Broadcast updated state to all clients
  // This ensures all clients see the events have been consumed
  this.broadcast();
}
```

Design decisions from research:
- playerSeat: For future-proofing per-client tracking, currently ignored (single buffer)
- NOT async: No persistence needed (events just removed from memory buffer)
- Broadcasts: All clients get updated state showing events consumed
- No validation of playerSeat: Being permissive since acknowledgment is UI bookkeeping

NOTE: Do NOT make this an action or add it to action history - acknowledgment is NOT a game state mutation.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors.
Grep for "acknowledgeAnimations" in game-session.ts to confirm method present.
  </verify>
  <done>GameSession.acknowledgeAnimations(playerSeat, upToId) method exists and delegates to game.acknowledgeAnimationEvents().</done>
</task>

<task type="auto">
  <name>Task 5: Write unit tests for session integration</name>
  <files>src/session/animation-events.test.ts</files>
  <action>
Create comprehensive unit tests for session-level animation event integration.

Create new test file src/session/animation-events.test.ts:

```typescript
import { describe, test, expect, beforeEach } from 'vitest';
import { Game, Player } from '../engine/index.js';
import { GameRunner } from '../runtime/index.js';
import { GameSession } from './game-session.js';
import { buildPlayerState } from './utils.js';

// Minimal test game that can emit animation events
class TestGame extends Game {
  declare players: Player[];

  registerElements() {
    this.registerClasses(Player);
  }

  setupBoard() {
    this.players.createMany(2, Player, ['Alice', 'Bob']);
  }
}

describe('Session Animation Events', () => {
  let session: GameSession<TestGame>;

  beforeEach(() => {
    session = GameSession.create({
      gameType: 'test',
      GameClass: TestGame,
      playerCount: 2,
      playerNames: ['Alice', 'Bob'],
    });
  });

  describe('PlayerGameState animation fields', () => {
    test('animationEvents is undefined when buffer is empty', () => {
      const state = session.buildPlayerState(1);
      expect(state.animationEvents).toBeUndefined();
      expect(state.lastAnimationEventId).toBeUndefined();
    });

    test('animationEvents contains pending events', () => {
      session.runner.game.emitAnimationEvent('attack', { damage: 5 });
      session.runner.game.emitAnimationEvent('heal', { amount: 3 });

      const state = session.buildPlayerState(1);
      expect(state.animationEvents).toHaveLength(2);
      expect(state.animationEvents![0].type).toBe('attack');
      expect(state.animationEvents![1].type).toBe('heal');
    });

    test('lastAnimationEventId is ID of final event', () => {
      session.runner.game.emitAnimationEvent('attack', { damage: 5 });
      const event2 = session.runner.game.emitAnimationEvent('heal', { amount: 3 });

      const state = session.buildPlayerState(1);
      expect(state.lastAnimationEventId).toBe(event2.id);
    });

    test('spectators receive animation events', () => {
      session.runner.game.emitAnimationEvent('attack', { damage: 5 });

      const spectatorState = session.buildPlayerState(0);
      expect(spectatorState.animationEvents).toHaveLength(1);
      expect(spectatorState.animationEvents![0].type).toBe('attack');
    });
  });

  describe('acknowledgeAnimations', () => {
    test('clears acknowledged events from state', () => {
      const event1 = session.runner.game.emitAnimationEvent('attack', { damage: 5 });
      session.runner.game.emitAnimationEvent('heal', { amount: 3 });

      // Acknowledge first event only
      session.acknowledgeAnimations(1, event1.id);

      const state = session.buildPlayerState(1);
      expect(state.animationEvents).toHaveLength(1);
      expect(state.animationEvents![0].type).toBe('heal');
    });

    test('acknowledging all events clears buffer', () => {
      session.runner.game.emitAnimationEvent('attack', { damage: 5 });
      const event2 = session.runner.game.emitAnimationEvent('heal', { amount: 3 });

      session.acknowledgeAnimations(1, event2.id);

      const state = session.buildPlayerState(1);
      expect(state.animationEvents).toBeUndefined();
      expect(state.lastAnimationEventId).toBeUndefined();
    });

    test('idempotent - repeated acknowledgment is safe', () => {
      const event = session.runner.game.emitAnimationEvent('attack', { damage: 5 });

      session.acknowledgeAnimations(1, event.id);
      session.acknowledgeAnimations(1, event.id); // Second call

      const state = session.buildPlayerState(1);
      expect(state.animationEvents).toBeUndefined();
    });
  });

  describe('snapshot serialization (SES-04)', () => {
    test('animation events survive session restore', () => {
      // Emit events in original session
      session.runner.game.emitAnimationEvent('attack', { damage: 5 });
      session.runner.game.emitAnimationEvent('heal', { amount: 3 });

      // Get stored state and restore
      const storedState = session.storedState;
      const restoredSession = GameSession.restore(storedState, TestGame);

      // Check events are present in restored session
      const state = restoredSession.buildPlayerState(1);
      expect(state.animationEvents).toHaveLength(2);
      expect(state.animationEvents![0].type).toBe('attack');
      expect(state.animationEvents![1].type).toBe('heal');
    });

    test('restored session can acknowledge events', () => {
      // Emit event and get its ID
      const event = session.runner.game.emitAnimationEvent('attack', { damage: 5 });

      // Restore session
      const storedState = session.storedState;
      const restoredSession = GameSession.restore(storedState, TestGame);

      // Acknowledge in restored session
      restoredSession.acknowledgeAnimations(1, event.id);

      const state = restoredSession.buildPlayerState(1);
      expect(state.animationEvents).toBeUndefined();
    });
  });
});
```

This covers:
- SES-01: animationEvents in PlayerGameState
- SES-02: lastAnimationEventId in PlayerGameState
- SES-03: acknowledgeAnimations method
- SES-04: Snapshot serialization (via GameSession.restore)
  </action>
  <verify>
Run `npx vitest run src/session/animation-events.test.ts` - all tests should pass.
  </verify>
  <done>Unit tests pass covering all SES-01 through SES-04 requirements.</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` - no errors
2. Unit tests: `npx vitest run src/session/animation-events.test.ts` - all pass
3. Existing tests: `npx vitest run` - all existing tests still pass
4. Type export: `grep -n "AnimationEvent" src/engine/index.ts` shows export
5. PlayerGameState: `grep -n "animationEvents" src/session/types.ts` shows field
6. buildPlayerState: `grep -n "pendingAnimationEvents" src/session/utils.ts` shows integration
7. GameSession: `grep -n "acknowledgeAnimations" src/session/game-session.ts` shows method
</verification>

<success_criteria>
- [ ] AnimationEvent type exported from src/engine/index.ts
- [ ] PlayerGameState has optional animationEvents and lastAnimationEventId fields
- [ ] buildPlayerState() includes animation events when buffer non-empty
- [ ] GameSession.acknowledgeAnimations() method exists and delegates correctly
- [ ] Unit tests pass covering all SES requirements
- [ ] Existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/60-session-integration/60-SUMMARY.md` using the summary template.

Document:
- Implementation approach (thin plumbing from game to session)
- Key decisions (optional fields, spectator inclusion, broadcast on acknowledge)
- Files modified
- Test coverage
</output>
