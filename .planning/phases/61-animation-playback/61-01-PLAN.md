---
phase: 61-animation-playback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/composables/useAnimationEvents.ts
  - src/ui/composables/useAnimationEvents.test.ts
  - src/ui/index.ts
autonomous: true

must_haves:
  truths:
    - "Game boards can register handlers for animation event types"
    - "Handlers return Promises that control animation timing"
    - "isAnimating ref correctly reflects when animations are playing"
    - "skipAll() method bypasses remaining animations and acknowledges them"
    - "paused ref enables pause/resume control of animation playback"
  artifacts:
    - path: "src/ui/composables/useAnimationEvents.ts"
      provides: "Animation event playback composable"
      exports: ["createAnimationEvents", "provideAnimationEvents", "useAnimationEvents", "ANIMATION_EVENTS_KEY"]
    - path: "src/ui/composables/useAnimationEvents.test.ts"
      provides: "Comprehensive unit tests"
      min_lines: 150
    - path: "src/ui/index.ts"
      provides: "Public API exports"
      contains: "useAnimationEvents"
  key_links:
    - from: "useAnimationEvents.ts"
      to: "PlayerGameState.animationEvents"
      via: "watch() on events getter"
      pattern: "watch.*events"
    - from: "useAnimationEvents.ts"
      to: "GameSession.acknowledgeAnimations"
      via: "acknowledge callback option"
      pattern: "acknowledge.*upToId"
---

<objective>
Create the `useAnimationEvents` composable for sequential animation playback

Purpose: Enable game UIs to register handlers for animation events and play them back with Promise-based timing control. This is the UI-side consumer of the animation event system established in Phases 59-60.

Output: A Vue composable that:
- Accepts handler registration by event type
- Processes events sequentially using Promise chains
- Exposes `isAnimating`, `paused`, `skipAll()`, `pendingCount` for UI control
- Uses provide/inject for component tree access (following `useBoardInteraction` pattern)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-animation-playback/61-RESEARCH.md
@.planning/phases/60-session-integration/60-01-SUMMARY.md
@src/ui/composables/useBoardInteraction.ts
@src/session/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAnimationEvents composable</name>
  <files>src/ui/composables/useAnimationEvents.ts</files>
  <action>
Create `src/ui/composables/useAnimationEvents.ts` implementing the animation event playback composable.

**Structure (following useBoardInteraction.ts pattern):**

1. **Types and interfaces:**
```typescript
import { ref, watch, type Ref, type InjectionKey, provide, inject } from 'vue';
import type { AnimationEvent } from '../../engine/index.js';

export interface AnimationHandler {
  (event: AnimationEvent): Promise<void>;
}

export interface UseAnimationEventsOptions {
  /** Getter that returns animation events from PlayerGameState */
  events: () => AnimationEvent[] | undefined;
  /** Callback to acknowledge events (calls session.acknowledgeAnimations) */
  acknowledge: (upToId: number) => void;
  /** Default delay for events without handlers (ms, default: 0) */
  defaultDuration?: number;
}

export interface UseAnimationEventsReturn {
  /** Register a handler for an event type. Returns unregister function. */
  registerHandler: (eventType: string, handler: AnimationHandler) => () => void;
  /** Whether animations are currently playing */
  isAnimating: Ref<boolean>;
  /** Whether playback is paused */
  paused: Ref<boolean>;
  /** Skip all remaining animations in the queue */
  skipAll: () => void;
  /** Number of pending events (for UI indicators) */
  pendingCount: Ref<number>;
}
```

2. **Injection key and provide/inject functions:**
```typescript
export const ANIMATION_EVENTS_KEY: InjectionKey<UseAnimationEventsReturn> = Symbol('animationEvents');

export function provideAnimationEvents(instance: UseAnimationEventsReturn): void {
  provide(ANIMATION_EVENTS_KEY, instance);
}

export function useAnimationEvents(): UseAnimationEventsReturn | undefined {
  return inject(ANIMATION_EVENTS_KEY);
}
```

3. **createAnimationEvents factory function:**
- Handler registry: `Map<string, AnimationHandler>`
- Internal queue: `AnimationEvent[]`
- Reactive state: `isAnimating`, `paused`, `pendingCount` refs
- Track `lastProcessedId` to avoid re-processing events
- `unpauseResolve` for pause/resume synchronization

**processQueue() logic (async):**
- Guard against re-entry with `isProcessing` flag
- Set `isAnimating.value = true`
- Loop while queue has events and `!skipRequested`:
  - If paused, await unpause Promise
  - Shift event from queue
  - Update `pendingCount`
  - Get handler from registry
  - If handler exists: try/catch await handler(event), log errors but continue
  - Else if defaultDuration: await delay
  - Update `lastProcessedId = event.id`
- After loop: call `acknowledge(lastProcessedId)` if any events processed
- Finally: reset flags, set `isAnimating = false`

**skipAll() logic:**
- If queue has events, acknowledge the last event ID
- Clear queue
- Set `skipRequested = true`
- Update `pendingCount = 0`
- Resolve any pending unpause Promise (to exit paused state)

**Watch for new events:**
- `watch(() => options.events(), (events) => { ... }, { immediate: true })`
- Filter events where `id > lastProcessedId`
- Push new events to queue
- Update pendingCount
- Call processQueue() (non-blocking)

**Watch for pause state changes:**
- When `paused` becomes false and `unpauseResolve` exists, resolve it

**registerHandler(eventType, handler):**
- Add to Map
- Return cleanup function that removes from Map

**Anti-patterns to avoid (from research):**
- DO NOT process events in parallel - MUST be sequential
- DO NOT block on missing handlers - skip with optional delay
- DO NOT throw errors from handlers - catch and continue
- DO ensure skipAll acknowledges all events (prevents replay on reconnect)
- DO track lastProcessedId to prevent re-processing on state updates
  </action>
  <verify>
File exists and TypeScript compiles: `npx tsc --noEmit src/ui/composables/useAnimationEvents.ts`
  </verify>
  <done>
useAnimationEvents.ts exports createAnimationEvents, provideAnimationEvents, useAnimationEvents, ANIMATION_EVENTS_KEY
  </done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive unit tests</name>
  <files>src/ui/composables/useAnimationEvents.test.ts</files>
  <action>
Create `src/ui/composables/useAnimationEvents.test.ts` with comprehensive tests.

**Test structure:**

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ref, nextTick } from 'vue';
import { createAnimationEvents, type UseAnimationEventsReturn } from './useAnimationEvents.js';
import type { AnimationEvent } from '../../engine/index.js';
```

**Helper to create test events:**
```typescript
function createEvent(id: number, type: string, data: Record<string, unknown> = {}): AnimationEvent {
  return { id, type, data, timestamp: Date.now() };
}
```

**Test groups:**

1. **Handler registration:**
   - Registers handler for event type
   - Returns unregister function that removes handler
   - Multiple handlers for different types work independently

2. **Sequential processing:**
   - Processes events in order
   - Waits for handler Promise before next event
   - Handler errors don't stop subsequent events
   - Events without handlers are skipped (with optional delay)

3. **isAnimating state:**
   - false when no events
   - true during processing
   - false after all events processed
   - true when paused mid-processing

4. **skipAll:**
   - Clears pending events
   - Acknowledges all pending event IDs
   - Stops processing immediately
   - Works when paused (resumes and clears)

5. **paused state:**
   - Pausing stops processing at current event
   - Resuming continues from where it stopped
   - Events still queue while paused
   - skipAll works while paused

6. **pendingCount:**
   - Updates as events are added
   - Decrements as events are processed
   - Zero after skipAll
   - Includes currently-processing event

7. **Event deduplication:**
   - Does not re-process events with same ID
   - Only queues events with id > lastProcessedId
   - Handles events arriving during processing

8. **Acknowledgment:**
   - Calls acknowledge after processing batch
   - Passes correct upToId (last processed)
   - skipAll acknowledges remaining events
   - Does not acknowledge if no events processed

**Test pattern for async processing:**
```typescript
it('processes events sequentially', async () => {
  const acknowledge = vi.fn();
  const events = ref<AnimationEvent[]>([]);
  const order: number[] = [];

  const result = createAnimationEvents({
    events: () => events.value,
    acknowledge,
  });

  result.registerHandler('test', async (event) => {
    await new Promise(r => setTimeout(r, 10));
    order.push(event.id);
  });

  events.value = [createEvent(1, 'test'), createEvent(2, 'test')];
  await nextTick();

  // Wait for processing to complete
  await vi.waitFor(() => expect(result.isAnimating.value).toBe(false));

  expect(order).toEqual([1, 2]);
  expect(acknowledge).toHaveBeenCalledWith(2);
});
```
  </action>
  <verify>
Tests pass: `npm test -- --run src/ui/composables/useAnimationEvents.test.ts`
  </verify>
  <done>
At least 15 tests covering all requirements UI-01 through UI-05
  </done>
</task>

<task type="auto">
  <name>Task 3: Export from UI package</name>
  <files>src/ui/index.ts</files>
  <action>
Add exports to `src/ui/index.ts` for the new composable.

Add after the existing animation composables section (around line 119):

```typescript
// Animation event playback (sequential handler-based playback)
export {
  createAnimationEvents,
  provideAnimationEvents,
  useAnimationEvents,
  ANIMATION_EVENTS_KEY,
  type AnimationHandler,
  type UseAnimationEventsOptions,
  type UseAnimationEventsReturn,
} from './composables/useAnimationEvents.js';
```

Also re-export `AnimationEvent` type from engine for convenience (add near the color utilities re-export at the bottom):

```typescript
// Re-export animation event types from engine for convenience
export type { AnimationEvent, EmitAnimationEventOptions } from '../engine/index.js';
```
  </action>
  <verify>
TypeScript compiles with exports: `npx tsc --noEmit src/ui/index.ts`
  </verify>
  <done>
useAnimationEvents, createAnimationEvents, provideAnimationEvents, ANIMATION_EVENTS_KEY, and AnimationEvent exported from boardsmith/ui
  </done>
</task>

</tasks>

<verification>
1. **TypeScript compilation:**
   - `npx tsc --noEmit` passes

2. **Unit tests:**
   - `npm test -- --run src/ui/composables/useAnimationEvents.test.ts` - all tests pass

3. **All UI tests:**
   - `npm test -- --run src/ui` - no regressions

4. **Exports work:**
   - `import { useAnimationEvents, createAnimationEvents, AnimationEvent } from './src/ui/index.js'` resolves

5. **Requirements coverage:**
   - UI-01: registerHandler() method exists and works
   - UI-02: Handlers return Promises, tests verify sequential await
   - UI-03: isAnimating ref updates correctly
   - UI-04: skipAll() clears queue and acknowledges
   - UI-05: paused ref controls playback
</verification>

<success_criteria>
- useAnimationEvents composable created with full API
- Comprehensive test coverage (15+ tests)
- Exported from src/ui/index.ts
- All TypeScript compilation passes
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/61-animation-playback/61-01-SUMMARY.md`
</output>
