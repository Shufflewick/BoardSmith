---
phase: 62-actioncontroller-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/composables/useActionControllerTypes.ts
  - src/ui/composables/useActionController.ts
  - src/ui/composables/useAutoAnimations.ts
  - src/ui/components/auto-ui/ActionPanel.vue
autonomous: true

must_haves:
  truths:
    - "useActionController returns animationsPending computed that reflects animation state"
    - "useActionController returns showActionPanel that gates on turn and animations"
    - "useAutoAnimations accepts eventHandlers option for handler registration"
    - "ActionPanel shows pending state and skip button when animations playing"
  artifacts:
    - path: "src/ui/composables/useActionControllerTypes.ts"
      provides: "animationEvents option and return type additions"
      contains: "animationsPending"
    - path: "src/ui/composables/useActionController.ts"
      provides: "Animation gating computed properties"
      contains: "showActionPanel"
    - path: "src/ui/composables/useAutoAnimations.ts"
      provides: "eventHandlers option for declarative handler registration"
      contains: "eventHandlers"
    - path: "src/ui/components/auto-ui/ActionPanel.vue"
      provides: "Animation-gated action UI"
      contains: "animationsPending"
  key_links:
    - from: "src/ui/composables/useActionController.ts"
      to: "UseAnimationEventsReturn"
      via: "type-only import for animationEvents option"
      pattern: "animationEvents\\?.*isAnimating"
    - from: "src/ui/composables/useAutoAnimations.ts"
      to: "AnimationHandler"
      via: "type import for eventHandlers"
      pattern: "eventHandlers.*AnimationHandler"
---

<objective>
Wire animation events into ActionController and AutoAnimations for animation-gated action execution.

Purpose: The ActionPanel needs to wait for animations to complete before showing new decisions to users. This follows the "soft continuation" pattern where game state advances immediately but UI gates on animation completion.

Output:
- useActionController with animationsPending and showActionPanel computed properties
- useAutoAnimations with eventHandlers option for declarative handler registration
- ActionPanel that shows "animations pending" state with skip button
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-actioncontroller-integration/62-RESEARCH.md
@.planning/phases/61-animation-playback/61-01-SUMMARY.md
@src/ui/composables/useAnimationEvents.ts
@src/ui/composables/useActionControllerTypes.ts
@src/ui/composables/useActionController.ts
@src/ui/composables/useAutoAnimations.ts
@src/ui/components/auto-ui/ActionPanel.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add animation gating to useActionController</name>
  <files>
    src/ui/composables/useActionControllerTypes.ts
    src/ui/composables/useActionController.ts
  </files>
  <action>
    Add animation event integration to useActionController:

    **In useActionControllerTypes.ts:**
    1. Add type-only import: `import type { UseAnimationEventsReturn } from './useAnimationEvents.js';`
    2. Add to UseActionControllerOptions interface:
       ```typescript
       /**
        * Animation events instance for animation-gated action panel.
        * When provided, animationsPending and showActionPanel become functional.
        * If not provided, animationsPending is always false and showActionPanel equals isMyTurn.
        */
       animationEvents?: UseAnimationEventsReturn;
       ```
    3. Add to UseActionControllerReturn interface:
       ```typescript
       /**
        * Whether animations are currently pending/playing.
        * True when animationEvents.isAnimating is true.
        * Always false if animationEvents not provided.
        */
       animationsPending: ComputedRef<boolean>;

       /**
        * Whether to show the action panel to the user.
        * True when: isMyTurn && !animationsPending && !pendingFollowUp
        * Use this to gate ActionPanel visibility/interactivity.
        */
       showActionPanel: ComputedRef<boolean>;
       ```

    **In useActionController.ts:**
    1. Add computed properties inside useActionController function (after existing computed properties like isMyTurn, before return):
       ```typescript
       // Animation gating - gates action panel on animation completion
       const animationsPending = computed((): boolean => {
         return options.animationEvents?.isAnimating.value ?? false;
       });

       const showActionPanel = computed((): boolean => {
         // Show when:
         // 1. It's my turn
         // 2. No animations pending
         // 3. No followUp action pending
         return isMyTurn.value && !animationsPending.value && !pendingFollowUp.value;
       });
       ```
    2. Add both to the return object

    **Critical:** Use type-only import for UseAnimationEventsReturn to avoid circular dependencies. The controller accepts the instance as an option, doesn't create it.
  </action>
  <verify>
    - `npm run typecheck` passes
    - Types show animationsPending and showActionPanel on UseActionControllerReturn
    - No circular dependency errors
  </verify>
  <done>
    - useActionController accepts optional animationEvents option
    - animationsPending reflects animation state (false when not provided)
    - showActionPanel gates on isMyTurn AND !animationsPending AND !pendingFollowUp
  </done>
</task>

<task type="auto">
  <name>Task 2: Add eventHandlers option to useAutoAnimations</name>
  <files>
    src/ui/composables/useAutoAnimations.ts
  </files>
  <action>
    Add eventHandlers option to useAutoAnimations for declarative handler registration:

    1. Add type imports at top:
       ```typescript
       import type { AnimationHandler, UseAnimationEventsReturn } from './useAnimationEvents.js';
       ```

    2. Add to AutoAnimationsOptions interface:
       ```typescript
       /**
        * Event handlers to register with animation events.
        * Keys are event types, values are handler functions.
        * Handlers are registered when composable is created.
        *
        * @example
        * ```typescript
        * eventHandlers: {
        *   cardMove: async (event) => {
        *     await flyCard(event.data.cardId, event.data.from, event.data.to);
        *   },
        *   combat: async (event) => {
        *     await showExplosion(event.data.position);
        *   },
        * }
        * ```
        */
       eventHandlers?: Record<string, AnimationHandler>;

       /**
        * Animation events instance. Required when using eventHandlers.
        * Pass the instance from createAnimationEvents().
        */
       animationEvents?: UseAnimationEventsReturn;
       ```

    3. In useAutoAnimations function body, after existing setup, add handler registration:
       ```typescript
       // Register animation event handlers if provided
       if (options.eventHandlers && options.animationEvents) {
         for (const [eventType, handler] of Object.entries(options.eventHandlers)) {
           options.animationEvents.registerHandler(eventType, handler);
         }
       }
       ```

    Note: Handler cleanup is handled by the animation events composable when it's disposed. The registration returns a cleanup function but we don't need to track it since the animation events instance manages its own lifecycle.
  </action>
  <verify>
    - `npm run typecheck` passes
    - AutoAnimationsOptions shows eventHandlers and animationEvents options
  </verify>
  <done>
    - useAutoAnimations accepts eventHandlers option
    - Handlers are registered with animationEvents when both options provided
    - Type definitions document the feature
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ActionPanel for animation gating</name>
  <files>
    src/ui/components/auto-ui/ActionPanel.vue
  </files>
  <action>
    Update ActionPanel.vue to gate on animations:

    1. Add import for animation events:
       ```typescript
       import { useAnimationEvents } from '../../composables/useAnimationEvents.js';
       ```

    2. After actionController injection, add:
       ```typescript
       // Animation events for skip functionality (optional - may not be provided)
       const animationEvents = useAnimationEvents();
       ```

    3. Add computed properties using the controller's gating:
       ```typescript
       // Animation gating from controller
       const animationsPending = computed(() => actionController.animationsPending.value);
       const showActionPanel = computed(() => actionController.showActionPanel.value);

       // Skip handler
       function skipAnimations(): void {
         animationEvents?.skipAll();
       }
       ```

    4. Update the template to gate on animations. Find the main content section and wrap it:

       At the START of the template (before existing v-if conditions):
       ```vue
       <!-- Animations pending indicator -->
       <div v-if="animationsPending" class="action-panel-pending">
         <span class="pending-text">Playing animations...</span>
         <button class="skip-btn" @click="skipAnimations">Skip</button>
       </div>

       <!-- Normal action panel content, gated on showActionPanel -->
       <template v-else-if="showActionPanel">
         <!-- existing template content goes here -->
       </template>

       <!-- Not my turn message (keep existing) -->
       <div v-else class="waiting-message">
         <!-- ... existing waiting message ... -->
       </div>
       ```

       **Important:** The existing template likely has an isMyTurn check at the top level. The new showActionPanel computed already includes isMyTurn, so you need to:
       - Replace the top-level `v-if="isMyTurn"` with `v-else-if="showActionPanel"`
       - Keep the waiting-for-other-player message as the final v-else

    5. Add styles at the bottom of the `<style>` section:
       ```css
       .action-panel-pending {
         display: flex;
         align-items: center;
         justify-content: center;
         gap: 1rem;
         padding: 1rem;
         background: var(--bg-secondary, #f5f5f5);
         border-radius: 0.5rem;
       }

       .pending-text {
         color: var(--text-secondary, #666);
         font-style: italic;
       }

       .skip-btn {
         padding: 0.25rem 0.75rem;
         border: 1px solid var(--border-color, #ccc);
         border-radius: 0.25rem;
         background: var(--bg-primary, #fff);
         cursor: pointer;
         font-size: 0.875rem;
       }

       .skip-btn:hover {
         background: var(--bg-hover, #eee);
       }
       ```

    **Note:** The ActionPanel is large (~2000 lines). Focus only on:
    - Adding the imports and computed properties
    - Wrapping the main content with animation gating
    - Adding the styles

    Do NOT restructure the entire component.
  </action>
  <verify>
    - `npm run typecheck` passes
    - ActionPanel compiles without errors
    - Template has animation pending state with skip button
  </verify>
  <done>
    - ActionPanel shows "Playing animations..." with Skip button when animationsPending
    - Normal action UI shown only when showActionPanel is true
    - Skip button calls animationEvents.skipAll()
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type verification:**
   ```bash
   npm run typecheck
   ```

2. **Build verification:**
   ```bash
   npm run build
   ```

3. **Unit test run:**
   ```bash
   npm test
   ```
   All existing tests should pass. No new tests required for this integration work - the underlying composables (useAnimationEvents) are already tested.

4. **API verification:**
   - UseActionControllerReturn has animationsPending and showActionPanel
   - AutoAnimationsOptions has eventHandlers and animationEvents
   - ActionPanel renders animation pending state

5. **Requirement check:**
   - UI-06: useActionController.animationsPending exists
   - UI-07: useActionController.showActionPanel gates correctly
   - UI-08: useAutoAnimations.eventHandlers option works
   - UI-09: useAnimationEvents already exported (Phase 61)
</verification>

<success_criteria>
- All four requirements (UI-06, UI-07, UI-08, UI-09) are satisfied
- No type errors
- Build succeeds
- Existing tests pass
- ActionPanel shows animation pending state when animations are playing
- ActionPanel shows normal content when showActionPanel is true
- useAutoAnimations can register handlers declaratively
</success_criteria>

<output>
After completion, create `.planning/phases/62-actioncontroller-integration/62-01-SUMMARY.md`
</output>
