---
phase: 65-session-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/session/lobby-manager.ts
  - src/session/types.ts
autonomous: true

must_haves:
  truths:
    - "Player can call updatePlayerOptions({ color: '#hex' }) and receive new color"
    - "Color change rejected with clear error when target color is held by another player"
    - "Player's color persists through disconnect and reconnect"
  artifacts:
    - path: "src/session/lobby-manager.ts"
      provides: "Color conflict validation in updatePlayerOptions and updateSlotPlayerOptions"
      contains: "#validateColorChange"
    - path: "src/session/types.ts"
      provides: "ErrorCode.COLOR_ALREADY_TAKEN"
      contains: "COLOR_ALREADY_TAKEN"
  key_links:
    - from: "updatePlayerOptions"
      to: "#validateColorChange"
      via: "calls validation before merging options"
      pattern: "#validateColorChange.*options\\.color"
    - from: "updateSlotPlayerOptions"
      to: "#validateColorChange"
      via: "calls validation before merging options"
      pattern: "#validateColorChange.*options\\.color"
---

<objective>
Add color conflict validation to the session layer so players can change colors during lobby with proper conflict handling.

Purpose: Players need to be able to select their preferred color in the lobby, but two players cannot have the same color. The session layer must reject color changes when the target color is already taken.

Output:
- Color conflict validation in updatePlayerOptions() and updateSlotPlayerOptions()
- ErrorCode.COLOR_ALREADY_TAKEN for programmatic error handling
- Existing persistence (already in place) continues to work
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/65-session-layer/65-RESEARCH.md
@.planning/phases/64-engine-layer/64-01-SUMMARY.md
@src/session/lobby-manager.ts
@src/session/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ErrorCode.COLOR_ALREADY_TAKEN</name>
  <files>src/session/types.ts</files>
  <action>
Add ErrorCode.COLOR_ALREADY_TAKEN to the ErrorCode enum in src/session/types.ts.

Add it in the "Lobby errors" section after LOBBY_NOT_READY:

```typescript
// Lobby errors
SEAT_ALREADY_CLAIMED = 'SEAT_ALREADY_CLAIMED',
INVALID_SEAT = 'INVALID_SEAT',
NOT_AUTHORIZED = 'NOT_AUTHORIZED',
GAME_ALREADY_STARTED = 'GAME_ALREADY_STARTED',
LOBBY_NOT_READY = 'LOBBY_NOT_READY',
COLOR_ALREADY_TAKEN = 'COLOR_ALREADY_TAKEN',
```

This enables programmatic error handling in clients (switch on errorCode instead of parsing error strings).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ErrorCode.COLOR_ALREADY_TAKEN exists in types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add color conflict validation to LobbyManager</name>
  <files>src/session/lobby-manager.ts</files>
  <action>
Add color conflict validation to LobbyManager in src/session/lobby-manager.ts.

**Step 1: Add #validateColorChange private method**

Add this method in the "Private Methods" section at the bottom of the class:

```typescript
/**
 * Validate that a color change doesn't conflict with another player's color
 *
 * @param seat The seat of the player requesting the change
 * @param targetColor The color they want to change to
 * @returns Validation result with error message if color is taken
 */
#validateColorChange(
  seat: number,
  targetColor: string
): { success: boolean; error?: string } {
  if (!this.#storedState.lobbySlots) {
    return { success: true }; // No lobby, no validation needed
  }

  // Check if target color is already held by another player
  const conflictingSlot = this.#storedState.lobbySlots.find(
    s => s.seat !== seat && s.playerOptions?.color === targetColor
  );

  if (conflictingSlot) {
    return {
      success: false,
      error: `Color ${targetColor} is already taken by ${conflictingSlot.name}`,
    };
  }

  return { success: true };
}
```

**Step 2: Add validation to updatePlayerOptions**

In the `updatePlayerOptions` method, add color validation BEFORE the options merge (after finding the slot, before `slot.playerOptions = {...}`):

```typescript
// Validate color change if color is being updated
if (options.color !== undefined) {
  const colorValidation = this.#validateColorChange(slot.seat, options.color as string);
  if (!colorValidation.success) {
    return { success: false, error: colorValidation.error };
  }
}
```

**Step 3: Add validation to updateSlotPlayerOptions**

In the `updateSlotPlayerOptions` method, add the same color validation BEFORE the options merge (after checking slot exists, before `slot.playerOptions = {...}`):

```typescript
// Validate color change if color is being updated
if (options.color !== undefined) {
  const colorValidation = this.#validateColorChange(slot.seat, options.color as string);
  if (!colorValidation.success) {
    return { success: false, error: colorValidation.error };
  }
}
```

**Key behaviors:**
- Check ALL slots (claimed, AI, open with playerOptions) for conflicts
- Use slot.seat for comparison (not playerId) to handle AI slots correctly
- Return clear error message including the conflicting player's name
- Allow a player to "change" to their current color (no conflict with self)
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Existing tests pass: `npm test`
  </verify>
  <done>
- #validateColorChange private method exists
- updatePlayerOptions calls color validation before merge
- updateSlotPlayerOptions calls color validation before merge
- Changing to an occupied color returns `{ success: false, error: "Color #xxx is already taken by PlayerName" }`
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All existing tests pass: `npm test`
3. Manual verification (optional): Color conflict rejection can be tested in Phase 66 when UI is implemented

Code verification:
- Grep for `COLOR_ALREADY_TAKEN` in types.ts
- Grep for `#validateColorChange` in lobby-manager.ts
- Verify updatePlayerOptions contains color validation call
- Verify updateSlotPlayerOptions contains color validation call
</verification>

<success_criteria>
Requirements satisfied:
- SESS-01: Player can change color via updatePlayerOptions({ color: '#hex' })
- SESS-02: Color change rejected with clear message when target color is occupied
- SESS-03: Color persists (already in place via slot.playerOptions storage)

Observable truths:
1. Player can call updatePlayerOptions with color and receive success
2. Player trying to take an occupied color receives rejection with player name in error
3. Reconnecting player still has their color (via setPlayerConnected preserving slot)
</success_criteria>

<output>
After completion, create `.planning/phases/65-session-layer/65-01-SUMMARY.md`
</output>
