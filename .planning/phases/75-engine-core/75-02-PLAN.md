---
phase: 75-engine-core
plan: 02
type: execute
wave: 2
depends_on: ["75-01"]
files_modified:
  - src/engine/action/action.ts
  - src/engine/action/action.test.ts
  - src/engine/element/game.ts
  - src/ai/mcts-bot.ts
autonomous: true

must_haves:
  truths:
    - "getChoices() returns AnnotatedChoice<unknown>[] for choice, element, and elements selection types"
    - "Disabled items appear in getChoices() results (not filtered out) with their reason string"
    - "hasValidSelectionPath() treats all-disabled as unavailable for required selections"
    - "hasValidSelectionPath() treats all-disabled as still available for optional selections"
    - "validateSelection() rejects disabled items with 'Selection disabled: <reason>' error"
    - "All internal callers of getChoices() compare against .value instead of raw choice"
    - "AI bot filters out disabled choices and extracts .value"
    - "game.getSelectionChoices() returns AnnotatedChoice[]"
    - "Existing test assertions updated to match AnnotatedChoice structure"
  artifacts:
    - path: "src/engine/action/action.ts"
      provides: "Updated getChoices, validateSelection, hasValidSelectionPath, and all internal callers"
      contains: "AnnotatedChoice"
    - path: "src/engine/action/action.test.ts"
      provides: "Tests for disabled behavior and updated existing assertions"
      contains: "disabled"
    - path: "src/engine/element/game.ts"
      provides: "Updated getSelectionChoices return type"
      contains: "AnnotatedChoice"
    - path: "src/ai/mcts-bot.ts"
      provides: "AI bot handles AnnotatedChoice from getSelectionChoices"
      contains: "disabled"
  key_links:
    - from: "src/engine/action/action.ts"
      to: "src/engine/action/types.ts"
      via: "imports AnnotatedChoice type"
      pattern: "import.*AnnotatedChoice"
    - from: "src/engine/action/action.ts getChoices()"
      to: "selection.disabled callback"
      via: "annotates each choice with disabled status"
      pattern: "disabled.*selection.*disabled"
    - from: "src/engine/action/action.ts validateSelection()"
      to: "AnnotatedChoice.disabled"
      via: "checks disabled before accepting selection"
      pattern: "Selection disabled:"
    - from: "src/engine/action/action.ts hasValidSelectionPath()"
      to: "AnnotatedChoice.disabled"
      via: "filters to enabled choices before checking length"
      pattern: "c\\.disabled === false"
    - from: "src/ai/mcts-bot.ts"
      to: "game.getSelectionChoices()"
      via: "filters disabled, extracts .value"
      pattern: "\\.value"
---

<objective>
Update getChoices() to return AnnotatedChoice[], update all internal callers to use .value, implement disabled validation and path checking, update AI bot, and add comprehensive tests.

Purpose: This is the core behavior change -- getChoices() becomes annotated, validation rejects disabled items, path checking only counts enabled items. This fulfills ENG-04, ENG-05, ENG-06.
Output: Updated action.ts with annotated getChoices, disabled-aware validation and path checking; updated game.ts and mcts-bot.ts for the new return type; comprehensive test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/75-engine-core/75-RESEARCH.md
@.planning/phases/75-engine-core/75-01-SUMMARY.md
@docs/plans/2026-02-05-disabled-selections-design.md
@src/engine/action/action.ts
@src/engine/action/action.test.ts
@src/engine/action/types.ts
@src/engine/element/game.ts
@src/ai/mcts-bot.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update getChoices() and all internal callers in ActionExecutor</name>
  <files>src/engine/action/action.ts, src/engine/element/game.ts, src/ai/mcts-bot.ts</files>
  <action>
This is the most impactful change. Every internal caller of getChoices() must be updated. Follow the research document's caller impact analysis exactly.

**Step 1: Import AnnotatedChoice in action.ts**

Add `AnnotatedChoice` to the import from `./types.js`.

**Step 2: Update getChoices() return type and implementation**

Change the method signature from `getChoices(...): unknown[]` to `getChoices(...): AnnotatedChoice<unknown>[]`.

For each selection type case in the switch:

- **`choice` case:** After gathering and filtering choices (existing logic stays the same), instead of `return choices`, annotate each:
  ```typescript
  return choices.map(choice => ({
    value: choice,
    disabled: choiceSel.disabled ? choiceSel.disabled(choice, context) : false,
  }));
  ```

- **`element` case:** After gathering and filtering elements (existing logic stays the same), instead of `return elements`, annotate each:
  ```typescript
  return elements.map(el => ({
    value: el,
    disabled: elementSel.disabled
      ? elementSel.disabled(el as any, context)
      : false,
  }));
  ```

- **`elements` case:** After gathering elements, instead of `return elements`, annotate each:
  ```typescript
  return elements.map(el => ({
    value: el,
    disabled: elementsSel.disabled
      ? elementsSel.disabled(el as any, context)
      : false,
  }));
  ```

- **`text`/`number`/`default` cases:** Return `[]` (already returns `[]`, type is compatible since empty array matches `AnnotatedChoice<unknown>[]`).

**Step 3: Update resolveArgs() (line ~166)**

In the `case 'choice'` branch of resolveArgs, where it calls `this.getChoices(selection, player, resolved)`:
- The returned choices are now `AnnotatedChoice<unknown>[]`
- `smartResolveChoiceValue` is called with these choices -- update it to work with `.value`
- `extractChoiceValue` is called on the result -- this still works since resolvedValue comes from smartResolveChoiceValue which should return the unwrapped value

**Step 4: Update choicesContain() (private method ~line 396)**

This method currently compares `choice` directly. It needs a sibling that compares against `.value`. Create a new private method:

```typescript
/**
 * Check if a value exists in annotated choices (compares against .value)
 */
private annotatedChoicesContain(choices: AnnotatedChoice<unknown>[], value: unknown): boolean {
  return choices.some(choice => this.valuesEqual(choice.value, value));
}
```

Keep the original `choicesContain` for backward compatibility with `processRepeatingStep` internals (or update those too -- see below).

**Step 5: Update trySmartResolveChoice() (~line 411)**

This iterates over `choices` and checks properties like `id`, `value`, `display`. Since choices are now `AnnotatedChoice`, each `choice` is `{ value: T, disabled: ... }`. The iteration needs to check `choice.value` instead of `choice` directly:

```typescript
private trySmartResolveChoice(value: unknown, choices: AnnotatedChoice<unknown>[]): boolean {
  if (typeof value === 'number') {
    for (const choice of choices) {
      const actual = choice.value;
      if (actual && typeof actual === 'object') {
        if ('id' in actual && (actual as { id: number }).id === value) return true;
        if ('value' in actual && (actual as { value: number }).value === value) return true;
      }
    }
  }
  if (typeof value === 'string') {
    const lowerValue = value.toLowerCase();
    for (const choice of choices) {
      const actual = choice.value;
      if (actual && typeof actual === 'object') {
        const obj = actual as Record<string, unknown>;
        const propsToCheck = ['value', 'display', 'name', 'label'];
        for (const prop of propsToCheck) {
          const propValue = obj[prop];
          if (propValue !== undefined) {
            if (propValue === value) return true;
            if (typeof propValue === 'string' && propValue.toLowerCase() === lowerValue) return true;
          }
        }
      } else if (typeof actual === 'string' && actual.toLowerCase() === lowerValue) {
        return true;
      }
    }
  }
  return false;
}
```

**Step 6: Update smartResolveChoiceValue() (~line 465)**

Same pattern as trySmartResolveChoice -- iterate over `choices` and access `.value`:

```typescript
private smartResolveChoiceValue(value: unknown, choices: AnnotatedChoice<unknown>[]): unknown {
  if (typeof value === 'number') {
    for (const choice of choices) {
      const actual = choice.value;
      if (actual && typeof actual === 'object' && 'id' in actual) {
        if ((actual as { id: number }).id === value) return actual;
      }
    }
  }
  if (typeof value === 'string') {
    const lowerValue = value.toLowerCase();
    for (const choice of choices) {
      const actual = choice.value;
      if (actual && typeof actual === 'object') {
        const obj = actual as Record<string, unknown>;
        const propsToCheck = ['value', 'display', 'name', 'label'];
        for (const prop of propsToCheck) {
          const propValue = obj[prop];
          if (propValue !== undefined) {
            if (propValue === value) return actual;
            if (typeof propValue === 'string' && propValue.toLowerCase() === lowerValue) return actual;
          }
        }
      } else if (typeof actual === 'string' && actual.toLowerCase() === lowerValue) {
        return actual;
      }
    }
  }
  return value;
}
```

**Step 7: Update formatValidChoices() (~line 510)**

Choices are now `AnnotatedChoice`. Update to access `.value`:

```typescript
private formatValidChoices(choices: AnnotatedChoice<unknown>[]): string {
  const maxShow = 5;
  const formatted = choices.slice(0, maxShow).map(choice => {
    const actual = choice.value;
    if (actual && typeof actual === 'object') {
      const obj = actual as Record<string, unknown>;
      if (obj.display) return String(obj.display);
      if (obj.name) return String(obj.name);
      if (obj.label) return String(obj.label);
      if ('id' in obj) return `(id: ${obj.id})`;
    }
    return JSON.stringify(actual);
  });
  if (choices.length > maxShow) {
    formatted.push(`... and ${choices.length - maxShow} more`);
  }
  return `[${formatted.join(', ')}]`;
}
```

**Step 8: Update validateSelection() (~line 534)**

This is where disabled rejection happens (ENG-06). After getting annotated choices:

For `choice` and `element` types (the `if (selection.type === 'choice' || selection.type === 'element')` block):

```typescript
const choices = this.getChoices(selection, player, args);

// Check disabled FIRST -- if value matches a disabled item, reject with reason
const disabledMatch = choices.find(c => this.valuesEqual(c.value, value) && c.disabled !== false);
if (disabledMatch) {
  errors.push(`Selection disabled: ${disabledMatch.disabled}`);
  return { valid: false, errors };
}

// Handle multiSelect arrays
if (Array.isArray(value)) {
  for (const v of value) {
    // Check if this specific array item is disabled
    const disabledItem = choices.find(c => this.valuesEqual(c.value, v) && c.disabled !== false);
    if (disabledItem) {
      errors.push(`Selection disabled: ${disabledItem.disabled}`);
      continue;
    }
    if (!this.annotatedChoicesContain(choices, v)) {
      if (selection.type === 'choice' && !this.trySmartResolveChoice(v, choices)) {
        const validChoicesStr = this.formatValidChoices(choices);
        errors.push(`Invalid selection for "${selection.name}": ${JSON.stringify(v)}. Valid choices: ${validChoicesStr}`);
      }
    }
  }
} else if (!this.annotatedChoicesContain(choices, value)) {
  if (selection.type === 'choice' && !this.trySmartResolveChoice(value, choices)) {
    const validChoicesStr = this.formatValidChoices(choices);
    errors.push(`Invalid selection for "${selection.name}": ${JSON.stringify(value)}. Valid choices: ${validChoicesStr}`);
  } else if (selection.type === 'element') {
    errors.push(`Invalid selection for ${selection.name}`);
  }
}
```

For `elements` type: Update the `getChoices` call and add disabled checking. The `validElements` line becomes:
```typescript
const annotatedElements = this.getChoices(selection, player, args);
const validElements = annotatedElements.map(c => c.value) as GameElement[];
```

And add disabled checking before the element validation:
```typescript
// Check if submitted element is disabled
const validateElement = (elem: unknown): string | null => {
  // Check disabled first
  if (elem && typeof elem === 'object' && 'id' in elem) {
    const id = (elem as { id: number }).id;
    const disabledMatch = annotatedElements.find(
      c => c.value && typeof c.value === 'object' && 'id' in c.value && (c.value as { id: number }).id === id && c.disabled !== false
    );
    if (disabledMatch) {
      return `Selection disabled: ${disabledMatch.disabled}`;
    }
  }
  // ... rest of existing validation using validElements/validIds
};
```

**Step 9: Update hasValidSelectionPath() (~lines 962-1058)**

Every place that calls `this.getChoices()` and checks `choices.length === 0` needs to filter to enabled choices first. The pattern for each branch:

```typescript
const annotatedChoices = this.getChoices(selection, player, args);
const enabledChoices = annotatedChoices.filter(c => c.disabled === false);
if (enabledChoices.length === 0) {
  return false;
}
```

When iterating choices for dependent selection paths, iterate over `enabledChoices` and use `choice.value`:

```typescript
for (const choice of enabledChoices) {
  const newArgs = { ...args, [selection.name]: choice.value };
  if (this.hasValidSelectionPath(selections, player, newArgs, index + 1)) {
    return true;
  }
}
```

Apply this pattern to ALL four branches in hasValidSelectionPath():
- `element` type (~line 964): filter to enabled, use `.value` in path args
- `elements` type (~line 986): filter to enabled, use `.value` in path args
- `choice` type with function choices (~line 1010): filter to enabled, use `.value` in path args
- Static choice type (~line 1031): filter to enabled, use `.value` in path args

**Step 10: Update traceSelectionPath() (~line 870)**

The `choices` variable from `getChoices` is now annotated. Update `choiceCount` to use total count (disabled items are still "in the list" for trace purposes):
```typescript
const choices = this.getChoices(selection, player, args);
selTrace.choiceCount = choices.length; // Total including disabled -- already correct
```
No other changes needed in trace -- it shows all items.

**Step 11: Update processRepeatingStep() (~lines 1163, 1174, 1241)**

Three `getChoices` calls here:

Line ~1163: `const currentChoices = this.getChoices(...)` -- now returns annotated. The element validation (`validIds`) needs to use `.value`:
```typescript
const currentChoices = this.getChoices(selection, player, context.args);

if (isElementSelection) {
  const elementId = value as number;
  const validIds = currentChoices.map((c) => (c.value as any).id);
  if (!validIds.includes(elementId)) {
    ...
  }
  // Also check if the selected element is disabled
  const disabledMatch = currentChoices.find(
    c => (c.value as any).id === elementId && c.disabled !== false
  );
  if (disabledMatch) {
    return { done: false, error: `Selection disabled: ${disabledMatch.disabled}` };
  }
} else if (!this.annotatedChoicesContain(currentChoices, value)) {
  // Also check disabled for non-element choices
  const disabledMatch = currentChoices.find(c => this.valuesEqual(c.value, value) && c.disabled !== false);
  if (disabledMatch) {
    return { done: false, error: `Selection disabled: ${disabledMatch.disabled}` };
  }
  return { done: false, error: `Invalid choice: ${JSON.stringify(value)}`, nextChoices: currentChoices.map(c => c.value) };
}
```

Line ~1241: `const nextChoices = this.getChoices(...)` -- needs to extract `.value` for the formatted output and check length against enabled choices:
```typescript
const nextAnnotated = this.getChoices(selection, player, nextContext.args);
const nextEnabled = nextAnnotated.filter(c => c.disabled === false);

if (nextEnabled.length === 0) {
  // No more enabled choices -- terminate
  pendingState.collectedArgs[selection.name] = pendingState.repeating.accumulated;
  pendingState.repeating = undefined;
  pendingState.currentSelectionIndex++;
  return { done: true };
}

const nextChoicesRaw = nextAnnotated.map(c => c.value);
const formattedChoices = isElementSelection
  ? this.formatElementChoices(nextChoicesRaw as GameElement[], selection, nextContext)
  : nextChoicesRaw;

return { done: false, nextChoices: formattedChoices };
```

**Step 12: Update game.getSelectionChoices() return type**

In `src/engine/element/game.ts`, the `getSelectionChoices` method (~line 1023) currently returns `unknown[]`. Update it to return `AnnotatedChoice<unknown>[]`:

```typescript
import type { AnnotatedChoice } from '../action/types.js';

getSelectionChoices(
  actionName: string,
  selectionName: string,
  player: P,
  args: Record<string, unknown> = {}
): AnnotatedChoice<unknown>[] {
  ...
}
```

This is a deliberate breaking change per the design document.

**Step 13: Update AI bot to handle AnnotatedChoice**

In `src/ai/mcts-bot.ts`, the `getChoicesForSelection` method (~line 1050) calls `game.getSelectionChoices()` which now returns `AnnotatedChoice<unknown>[]`. Update it to filter out disabled choices and extract `.value`:

```typescript
private getChoicesForSelection(
  game: Game,
  actionName: string,
  selection: Selection,
  player: Player,
  currentArgs: Record<string, unknown>
): unknown[] {
  const annotated = game.getSelectionChoices(actionName, selection.name, player as any, currentArgs);
  // Filter out disabled choices (AI should never select disabled items) and extract raw values
  return annotated
    .filter(c => c.disabled === false)
    .map(c => c.value);
}
```

This preserves the AI bot's existing contract (returns `unknown[]` of raw values) while correctly handling the new annotated return type. The AI bot never needs to see disabled items.
  </action>
  <verify>
Run TypeScript compilation:
```
npx tsc --noEmit
```

Run ALL tests (not just action tests -- the getChoices change is pervasive):
```
npx vitest run
```

If tests fail, it is most likely because existing test assertions compare getChoices output to raw values like `['red', 'blue', 'green']`. These must be updated in Task 2.
  </verify>
  <done>
getChoices() returns AnnotatedChoice[] for all selection types. All internal callers updated to use .value. validateSelection() rejects disabled items. hasValidSelectionPath() only counts enabled items. AI bot filters disabled. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update existing tests and add disabled behavior tests</name>
  <files>src/engine/action/action.test.ts</files>
  <action>
**Part A: Update existing test assertions for AnnotatedChoice return type**

Every test that asserts on `getChoices()` output must be updated. The return type changed from `T[]` to `AnnotatedChoice<T>[]`.

1. In `describe('getChoices')`:
   - "should return static choices" test: Change `expect(choices).toEqual(['red', 'blue', 'green'])` to:
     ```typescript
     expect(choices).toEqual([
       { value: 'red', disabled: false },
       { value: 'blue', disabled: false },
       { value: 'green', disabled: false },
     ]);
     ```

   - "should return dynamic choices" test: Change `expect(choices).toEqual([4])` to:
     ```typescript
     expect(choices).toEqual([{ value: 4, disabled: false }]);
     ```

   - "should filter elements by class" test: `expect(choices).toHaveLength(5)` stays the same (length check works on annotated array too). But add a verification that each item has the right shape:
     ```typescript
     expect(choices[0]).toHaveProperty('value');
     expect(choices[0]).toHaveProperty('disabled', false);
     ```

   - "should filter elements with custom filter" test: Same pattern -- length check OK, add shape check.

2. In `describe('Dependent Selection Filtering')`:
   - Tests that assert on `getChoices()` output equality need updating. For example:
     ```typescript
     // Old
     expect(destsForPiece1).toEqual([
       { pieceId: 1, dest: 'A' },
       { pieceId: 1, dest: 'B' },
     ]);
     // New
     expect(destsForPiece1).toEqual([
       { value: { pieceId: 1, dest: 'A' }, disabled: false },
       { value: { pieceId: 1, dest: 'B' }, disabled: false },
     ]);
     ```
   - Update all similar assertions in this describe block.
   - For `.map((i: any) => i.name)` patterns, update to `.map((i: any) => i.value.name)`.

3. In `describe('Game Action Integration')`:
   - "should get selection choices" test: Change `expect(choices).toEqual(['red', 'blue'])` to:
     ```typescript
     expect(choices).toEqual([
       { value: 'red', disabled: false },
       { value: 'blue', disabled: false },
     ]);
     ```

**Part B: Add new tests for disabled behavior**

Add a new top-level `describe('Disabled Selections')` block. Create the test game/executor in a `beforeEach`. Add these tests:

1. **"disabled callback marks choices as disabled in getChoices"**
   ```typescript
   const action = Action.create('test')
     .chooseFrom('color', {
       choices: ['red', 'blue', 'green'],
       disabled: (choice) => choice === 'red' ? 'Red is unavailable' : false,
     })
     .execute(() => {});

   const choices = executor.getChoices(action.selections[0], player, {});
   expect(choices).toEqual([
     { value: 'red', disabled: 'Red is unavailable' },
     { value: 'blue', disabled: false },
     { value: 'green', disabled: false },
   ]);
   ```

2. **"disabled elements appear in getChoices but marked disabled"**
   Create some Card elements, then:
   ```typescript
   const action = Action.create('test')
     .chooseElement('card', {
       elementClass: Card,
       disabled: (el) => (el as Card).value < 3 ? 'Too weak' : false,
     })
     .execute(() => {});

   const choices = executor.getChoices(action.selections[0], player, {});
   // All 5 cards present, low-value ones marked disabled
   expect(choices).toHaveLength(5);
   const disabledCount = choices.filter(c => c.disabled !== false).length;
   expect(disabledCount).toBe(2); // values 1 and 2
   const enabledCount = choices.filter(c => c.disabled === false).length;
   expect(enabledCount).toBe(3); // values 3, 4, 5
   ```

3. **"disabled fromElements appear in getChoices but marked disabled"**
   ```typescript
   const cards = [...game.all(Card)];
   const action = Action.create('test')
     .fromElements('card', {
       elements: () => cards,
       disabled: (el) => (el as Card).suit === 'H' ? 'Hearts blocked' : false,
     })
     .execute(() => {});

   const choices = executor.getChoices(action.selections[0], player, {});
   expect(choices).toHaveLength(cards.length);
   // Verify disabled items have reason strings
   const disabled = choices.filter(c => c.disabled !== false);
   for (const d of disabled) {
     expect(d.disabled).toBe('Hearts blocked');
   }
   ```

4. **"validateSelection rejects disabled choice with reason"**
   ```typescript
   const action = Action.create('test')
     .chooseFrom('color', {
       choices: ['red', 'blue'],
       disabled: (c) => c === 'red' ? 'Red is banned' : false,
     })
     .execute(() => {});

   const result = executor.validateSelection(action.selections[0], 'red', player, {});
   expect(result.valid).toBe(false);
   expect(result.errors[0]).toBe('Selection disabled: Red is banned');
   ```

5. **"validateSelection accepts enabled choice"**
   ```typescript
   const action = Action.create('test')
     .chooseFrom('color', {
       choices: ['red', 'blue'],
       disabled: (c) => c === 'red' ? 'Red is banned' : false,
     })
     .execute(() => {});

   const result = executor.validateSelection(action.selections[0], 'blue', player, {});
   expect(result.valid).toBe(true);
   ```

6. **"hasValidSelectionPath returns false when all choices disabled (required)"**
   ```typescript
   const action = Action.create('test')
     .chooseFrom('color', {
       choices: ['red', 'blue'],
       disabled: () => 'All disabled',
     })
     .execute(() => {});

   expect(executor.isActionAvailable(action, player)).toBe(false);
   ```

7. **"hasValidSelectionPath returns true when at least one choice enabled"**
   ```typescript
   const action = Action.create('test')
     .chooseFrom('color', {
       choices: ['red', 'blue'],
       disabled: (c) => c === 'red' ? 'Disabled' : false,
     })
     .execute(() => {});

   expect(executor.isActionAvailable(action, player)).toBe(true);
   ```

8. **"optional selection still available when all items disabled"**
   ```typescript
   const action = Action.create('test')
     .chooseFrom('color', {
       choices: ['red', 'blue'],
       disabled: () => 'All disabled',
       optional: true,
     })
     .execute(() => {});

   expect(executor.isActionAvailable(action, player)).toBe(true);
   ```

9. **"disabled uses context for dynamic evaluation"**
   ```typescript
   const action = Action.create('test')
     .chooseFrom('color', {
       choices: ['red', 'blue'],
       disabled: (choice, ctx) => ctx.player.seat === 1 && choice === 'red'
         ? 'Player 1 cannot pick red'
         : false,
     })
     .execute(() => {});

   const player1Choices = executor.getChoices(action.selections[0], game.getPlayer(1)!, {});
   expect(player1Choices[0].disabled).toBe('Player 1 cannot pick red');

   const player2Choices = executor.getChoices(action.selections[0], game.getPlayer(2)!, {});
   expect(player2Choices[0].disabled).toBe(false);
   ```

10. **"no disabled callback means all items enabled"**
    ```typescript
    const action = Action.create('test')
      .chooseFrom('color', { choices: ['red', 'blue'] })
      .execute(() => {});

    const choices = executor.getChoices(action.selections[0], player, {});
    expect(choices.every(c => c.disabled === false)).toBe(true);
    ```

Set up the disabled tests describe block with appropriate game creation (TestGame with playerCount 2 or 3, some Card elements in a Deck for element selection tests).
  </action>
  <verify>
Run the full test suite:
```
npx vitest run
```

All tests must pass -- both updated existing tests and new disabled behavior tests.

Run TypeScript compilation:
```
npx tsc --noEmit
```
  </verify>
  <done>
All existing tests updated for AnnotatedChoice return type. 10+ new tests covering: disabled in getChoices for all selection types, validateSelection rejection with reason, hasValidSelectionPath with disabled, optional selections with all disabled, dynamic disabled evaluation, no-disabled baseline. All tests pass. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx vitest run` -- all tests pass (existing updated + new disabled tests)
3. `getChoices()` returns `AnnotatedChoice<unknown>[]` for choice, element, elements types
4. Disabled items present in results with reason string, enabled items have `disabled: false`
5. `validateSelection()` returns `"Selection disabled: <reason>"` for disabled items
6. `hasValidSelectionPath()` returns `false` when all items disabled on required selection
7. `hasValidSelectionPath()` returns `true` when all items disabled on optional selection
8. AI bot in mcts-bot.ts filters disabled choices and extracts `.value`
9. `game.getSelectionChoices()` return type is `AnnotatedChoice<unknown>[]`
</verification>

<success_criteria>
- getChoices() returns AnnotatedChoice[] for all selection types (ENG-04)
- hasValidSelectionPath() only counts enabled items, optional selections remain available when all disabled (ENG-05)
- validateSelection() rejects disabled items with "Selection disabled: <reason>" (ENG-06)
- All internal callers updated (.value comparison throughout)
- AI bot handles annotated choices correctly
- Comprehensive test coverage for all disabled behaviors
- Full test suite passes, TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/75-engine-core/75-02-SUMMARY.md`
</output>
