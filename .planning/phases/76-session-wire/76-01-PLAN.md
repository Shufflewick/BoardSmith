---
phase: 76-session-wire
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/session/types.ts
  - src/types/protocol.ts
  - src/session/pick-handler.ts
  - src/session/pick-handler.test.ts
autonomous: true

must_haves:
  truths:
    - "ValidElement includes disabled?: string field, present only when the element is disabled"
    - "ChoiceWithRefs includes disabled?: string field, present only when the choice is disabled"
    - "PickHandler.getPickChoices() correctly maps engine disabled callback result onto wire types for both element and choice selections"
    - "Enabled items do NOT have a disabled field in the wire output (sparse representation)"
  artifacts:
    - path: "src/session/types.ts"
      provides: "ValidElement and ChoiceWithRefs with disabled?: string"
      contains: "disabled\\?: string"
    - path: "src/types/protocol.ts"
      provides: "ValidElement and ChoiceWithRefs with disabled?: string"
      contains: "disabled\\?: string"
    - path: "src/session/pick-handler.ts"
      provides: "disabled callback evaluation in getPickChoices"
      contains: "disabled"
    - path: "src/session/pick-handler.test.ts"
      provides: "Tests for disabled threading through PickHandler"
      contains: "disabled"
  key_links:
    - from: "src/session/pick-handler.ts"
      to: "selection.disabled callback"
      via: "direct callback invocation in getPickChoices"
      pattern: "disabled\\("
    - from: "src/session/pick-handler.ts"
      to: "src/session/types.ts ValidElement/ChoiceWithRefs"
      via: "wire type output with disabled field"
      pattern: "\\.disabled ="
---

<objective>
Wire the `disabled` status from engine selection callbacks through the session layer's wire types so the UI layer receives disabled reason strings without re-evaluating engine logic.

Purpose: This is the session-layer bridge between the engine's disabled callbacks (Phase 75) and the UI's disabled rendering (Phase 77). Without this, disabled information is lost at the engine-to-UI boundary.

Output: Updated wire types (`ValidElement`, `ChoiceWithRefs`) with `disabled?: string`, PickHandler logic that evaluates the disabled callback and threads results into wire output, and tests proving correct behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/76-session-wire/76-RESEARCH.md
@.planning/phases/75-engine-core/75-02-SUMMARY.md
@src/session/pick-handler.ts
@src/session/types.ts
@src/types/protocol.ts
@src/engine/action/types.ts
@src/session/animation-events.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add disabled field to wire types and thread in PickHandler</name>
  <files>
    src/session/types.ts
    src/types/protocol.ts
    src/session/pick-handler.ts
  </files>
  <action>
**Wire type changes (SES-01 + SES-02):**

In `src/session/types.ts`:
- Add `/** Disabled reason string, present only when element is disabled */ disabled?: string;` to `ValidElement` interface (after the `ref` field, around line 297)
- Add `/** Disabled reason string, present only when choice is disabled */ disabled?: string;` to `ChoiceWithRefs` interface (after the `targetRef` field, around line 286)

In `src/types/protocol.ts`:
- Add the same `disabled?: string` field to `ValidElement` (after `ref`, around line 274)
- Add the same `disabled?: string` field to `ChoiceWithRefs` (after `targetRef`, around line 263)

Both files must have identical interface shapes.

**PickHandler disabled threading (SES-03):**

In `src/session/pick-handler.ts`, three modification points:

1. **Choice selections** (in the `case 'choice'` block, inside the `formattedChoices.map` callback, after the boardRefs logic around line 159, before the `return choice;` on line 161):

```typescript
// Thread disabled status from engine callback
if (choiceSel.disabled) {
  const disabledReason = choiceSel.disabled(rawValue, ctx);
  if (disabledReason) {
    choice.disabled = disabledReason;
  }
}
```

IMPORTANT: Use `rawValue` (the original value from choices array), NOT the unwrapped `value`. This matches the engine's behavior where the disabled callback receives the same value that `choices` returns. The rawValue may be a plain value OR a pre-formatted `{ value, display }` object (from playerChoices). The disabled callback receives whichever shape `choices` provided.

2. **Element selections** (in `#buildValidElementsList`, after the boardRef logic around line 349, before the `return validElem;` on line 351):

```typescript
// Thread disabled status from engine callback
if (elemSel.disabled) {
  const disabledReason = elemSel.disabled(element, ctx);
  if (disabledReason) {
    validElem.disabled = disabledReason;
  }
}
```

This handles BOTH `case 'element'` and `case 'elements'` since both delegate to `#buildValidElementsList`.

**Key constraints:**
- Use sparse representation: only SET `disabled` when the callback returns a truthy string. Do NOT set `disabled: false` or `disabled: undefined` on the wire object.
- Do NOT call `executor.getChoices()` from PickHandler -- evaluate `selection.disabled` callback directly.
- The existing `ctx` object (line 99: `{ game, player, args: resolvedArgs }`) already has the right shape for the disabled callback. No new context construction needed.
- `elemSel` is typed as `any`, so `elemSel.disabled` access works without type assertions. Check for existence before calling (`if (elemSel.disabled)`).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify type changes compile cleanly. Both `ValidElement` and `ChoiceWithRefs` interfaces should be structurally identical between `src/session/types.ts` and `src/types/protocol.ts`.
  </verify>
  <done>
- `ValidElement` in both files has `disabled?: string`
- `ChoiceWithRefs` in both files has `disabled?: string`
- PickHandler evaluates `selection.disabled` callback for choice, element, and elements selection types
- Disabled result is only included on the wire object when the callback returns a truthy string (sparse)
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PickHandler disabled threading tests</name>
  <files>
    src/session/pick-handler.test.ts
  </files>
  <action>
Create `src/session/pick-handler.test.ts` following the pattern from `src/session/animation-events.test.ts` (create a minimal test game class, use `GameSession.create()`, test through the session API).

The test game needs:
- A `chooseFrom` selection with a `disabled` callback that disables some choices
- A `chooseElement` (or `fromElements`) selection with a `disabled` callback that disables some elements
- Register both as actions with a flow that makes them available

Use `session.getPickChoices(actionName, selectionName, playerSeat, args)` to get the PickChoicesResponse and assert on the output.

**Test cases to write:**

1. **Choice selection: disabled choices carry reason string**
   - Set up `chooseFrom` with choices `['apple', 'banana', 'cherry']` and `disabled: (choice) => choice === 'banana' ? 'Out of stock' : false`
   - Call `getPickChoices` for the choice selection
   - Assert: result has 3 choices total
   - Assert: apple choice has NO `disabled` field (not even undefined -- use `'disabled' in choice` check)
   - Assert: banana choice has `disabled: 'Out of stock'`
   - Assert: cherry choice has NO `disabled` field

2. **Element selection: disabled elements carry reason string**
   - Set up a game with elements (use game.create/game class that creates elements)
   - Add `chooseElement`/`fromElements` with `disabled: (element) => element.name === 'locked' ? 'Item is locked' : false` (or similar logic based on element properties)
   - Call `getPickChoices` for the element selection
   - Assert: enabled elements have NO `disabled` field
   - Assert: disabled element has `disabled: 'Item is locked'`

3. **Sparse representation: enabled items have no disabled field at all**
   - Reuse one of the above setups
   - Assert that for each enabled item, `Object.keys(item)` does NOT include `'disabled'`
   - This ensures clean JSON serialization (no `"disabled": undefined` noise)

4. **No disabled callback: all items have no disabled field**
   - Set up a selection WITHOUT a `disabled` callback
   - Call `getPickChoices`
   - Assert: no items have a `disabled` field

5. **Elements (multi-select) selection: disabled elements carry reason string**
   - If feasible with the test game setup, add a `chooseElements` (plural) selection with disabled callback
   - Call `getPickChoices` for the elements selection
   - Assert disabled threading works for elements multi-select type too

To find `getPickChoices` on `GameSession`, check if it delegates to `PickHandler`. The session likely exposes this method. If not directly available, construct a `PickHandler` directly:

```typescript
import { PickHandler } from './pick-handler.js';
// ...
const handler = new PickHandler(session.runner, 2);
const result = handler.getPickChoices('actionName', 'selectionName', 1);
```

Look at how `GameSession` exposes pick choice fetching -- it likely has a method like `session.getPickChoices()` or delegates through another method. Use whatever the existing pattern is.
  </action>
  <verify>
Run `npx vitest run src/session/pick-handler.test.ts` -- all tests pass.
Run `npx vitest run` -- full test suite passes (no regressions).
  </verify>
  <done>
- At least 4 test cases covering: choice disabled threading, element disabled threading, sparse representation, and no-callback baseline
- All tests pass
- Full test suite has no regressions
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- TypeScript compiles cleanly
2. `npx vitest run src/session/pick-handler.test.ts` -- all new tests pass
3. `npx vitest run` -- full suite passes, no regressions
4. Manually verify that `ValidElement` and `ChoiceWithRefs` interfaces are identical between `src/session/types.ts` and `src/types/protocol.ts`
</verification>

<success_criteria>
- SES-01: `ValidElement` includes `disabled?: string` in both `src/session/types.ts` and `src/types/protocol.ts`
- SES-02: `ChoiceWithRefs` includes `disabled?: string` in both `src/session/types.ts` and `src/types/protocol.ts`
- SES-03: `PickHandler.getPickChoices()` evaluates the disabled callback and includes the reason string on disabled items for choice, element, and elements selection types
- Sparse representation: enabled items have no `disabled` field on the wire
- Tests verify all three requirements
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/76-session-wire/76-01-SUMMARY.md`
</output>
