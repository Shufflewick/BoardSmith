---
phase: 77-ui-integration
plan: 03
type: execute
wave: 2
depends_on: ["77-01"]
files_modified:
  - src/ui/composables/useActionController.ts
  - src/ui/composables/useActionController.test.ts
autonomous: true

must_haves:
  truths:
    - "fill() rejects disabled values with error message containing the reason string"
    - "Auto-fill triggers only when exactly 1 enabled item remains (disabled items skipped)"
    - "Custom UIs can read disabled from getChoices() and getCurrentChoices() return values"
    - "validElements computed carries disabled field for custom UI consumption"
    - "If all items are disabled and selection is required, auto-fill does not fire"
  artifacts:
    - path: "src/ui/composables/useActionController.ts"
      provides: "Disabled-aware validateSelection, tryAutoFillSelection, fill auto-fill, execute auto-fill"
      contains: "Selection disabled:"
    - path: "src/ui/composables/useActionController.test.ts"
      provides: "Tests for disabled validation, auto-fill filtering"
      contains: "disabled"
  key_links:
    - from: "src/ui/composables/useActionController.ts validateSelection"
      to: "src/ui/composables/useActionController.ts fill"
      via: "fill calls validateSelection which checks disabled before containment"
      pattern: "Selection disabled:"
    - from: "src/ui/composables/useActionController.ts tryAutoFillSelection"
      to: "src/ui/composables/useActionControllerTypes.ts"
      via: "Filters choices by disabled field from type"
      pattern: "disabled"
---

<objective>
Add disabled-aware logic to useActionController: validation rejects disabled values, auto-fill skips disabled items, and choices/validElements carry disabled for custom UI consumption.

Purpose: Defense-in-depth for programmatic access (custom UIs calling fill()). Auto-fill correctly skips disabled items so players don't get force-selected into disabled choices. Custom UIs can read disabled field from getChoices()/getCurrentChoices()/validElements.

Output: Updated useActionController with disabled validation and auto-fill filtering, plus tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-ui-integration/77-RESEARCH.md
@src/ui/composables/useActionController.ts
@src/ui/composables/useActionController.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add disabled validation and auto-fill filtering to useActionController</name>
  <files>src/ui/composables/useActionController.ts</files>
  <action>
Four locations in useActionController.ts need disabled-aware logic. The `getChoices()`, `getCurrentChoices()`, and `validElements` computed already pass through the disabled field from PickSnapshot transparently (the snapshot stores whatever JSON came from the server, and the type update in Plan 01 makes TypeScript aware of it). No code changes needed for UI-06/UI-07 -- they work by type declaration alone.

The code changes are:

**1. validateSelection() -- Check disabled BEFORE containment (UI-08)**

In `validateSelection()` (~line 372-416), the current flow is: get choices, check if value matches any choice. We need to add a disabled check BEFORE the containment check so disabled items get a specific error message instead of "Invalid selection".

After `const choices = getChoices(selection);` and the `if (choices.length > 0)` block, restructure the validation:

For single values (the `else` branch of the `Array.isArray(value)` check, ~line 400-413):
- Find the matching choice first (instead of just checking `some`):
```typescript
const matchedChoice = choices.find(c => {
  if (c.value === v) return true;
  if (typeof c.value === 'object' && c.value !== null) {
    return (hasValue(c.value) && c.value.value === v) ||
           (hasId(c.value) && c.value.id === v);
  }
  return false;
});
```
- If matched AND disabled, return specific error:
```typescript
if (matchedChoice && (matchedChoice as any).disabled) {
  return { valid: false, error: `Selection disabled: ${(matchedChoice as any).disabled}` };
}
```
- If not matched, fall through to existing "Invalid selection" error

For array values (multiSelect, ~line 395-399):
- Check each value. If any value matches a disabled choice, reject with specific error:
```typescript
for (const v of value) {
  const matched = choices.find(c => {
    if (c.value === v) return true;
    if (typeof c.value === 'object' && c.value !== null) {
      return (hasValue(c.value) && c.value.value === v) ||
             (hasId(c.value) && c.value.id === v);
    }
    return false;
  });
  if (matched && (matched as any).disabled) {
    return { valid: false, error: `Selection disabled: ${(matched as any).disabled}` };
  }
  if (!matched) {
    return { valid: false, error: `Invalid selection for "${selection.name}"` };
  }
}
```

IMPORTANT: The disabled check MUST come before the "not found" check. Design doc specifies this order so the error message says "disabled: reason" not just "invalid selection".

Use `(matchedChoice as any).disabled` because `getChoices()` returns `Array<{ value: unknown; display: string }>` -- the disabled field is present at runtime but the return type doesn't include it. This is intentional: the return type is the public API for custom UIs. Changing it to include disabled would be a separate type change. Instead, cast to access the field that exists at runtime.

Actually -- since Plan 01 adds `disabled?: string` to `ChoiceWithRefs` and `PickSnapshot.choices`, and `getChoices()` returns from snapshot.choices, the data IS there. But the function return type is `Array<{ value: unknown; display: string }>`. We should update the return type to include `disabled?: string`:

Change the return type of `getChoices()` from:
```typescript
function getChoices(selection: PickMetadata): Array<{ value: unknown; display: string }>
```
to:
```typescript
function getChoices(selection: PickMetadata): Array<{ value: unknown; display: string; disabled?: string }>
```

And similarly for `getCurrentChoices()`:
```typescript
function getCurrentChoices(): Array<{ value: unknown; display: string; disabled?: string }>
```

And update the `UseActionControllerReturn` interface in `useActionControllerTypes.ts` for both methods:
```typescript
getChoices: (pick: PickMetadata) => Array<{ value: unknown; display: string; disabled?: string }>;
getCurrentChoices: () => Array<{ value: unknown; display: string; disabled?: string }>;
```

This eliminates the need for `as any` casts and fulfills UI-07 (custom UIs can read disabled from getChoices/getCurrentChoices).

**2. tryAutoFillSelection() -- Filter disabled before counting (UI-09)**

In `tryAutoFillSelection()` (~line 461-478):
```typescript
function tryAutoFillSelection(selection: PickMetadata): boolean {
  if (!getAutoFill() || isExecuting.value) return false;

  const choices = getChoices(selection);
  const enabledChoices = choices.filter(c => !c.disabled);
  if (enabledChoices.length !== 1 || selection.optional) return false;

  const choice = enabledChoices[0];
  currentArgs.value[selection.name] = choice.value;

  if (actionSnapshot.value) {
    actionSnapshot.value.collectedPicks.set(selection.name, {
      value: choice.value,
      display: choice.display,
      skipped: false,
    });
  }

  return true;
}
```

**3. fill() inline auto-fill -- Filter disabled (UI-09)**

In `fill()` (~line 1114-1129), there's an inline auto-fill after fetching next selection's choices. Change:
```typescript
if (choices.length === 1 && !nextSel.optional) {
```
to:
```typescript
const enabledChoices = choices.filter(c => !c.disabled);
if (enabledChoices.length === 1 && !nextSel.optional) {
  const autoValue = enabledChoices[0].value;
  // ... rest uses enabledChoices[0] instead of choices[0]
```

**4. execute() auto-fill -- Filter disabled (UI-09)**

In `execute()` (~line 852-857), the auto-fill in the build-final-args loop:
```typescript
const choices = getChoices(selection);
if (choices.length === 1 && !selection.optional) {
```
Change to:
```typescript
const choices = getChoices(selection);
const enabledChoices = choices.filter(c => !c.disabled);
if (enabledChoices.length === 1 && !selection.optional) {
  finalArgs[selection.name] = enabledChoices[0].value;
```

All four locations use the same pattern: filter to enabled choices, then check count === 1.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors.
Run `npx vitest run` to confirm no test regressions.
  </verify>
  <done>
- validateSelection rejects disabled values with "Selection disabled: {reason}" error
- Disabled check runs BEFORE containment check for specific error messages
- tryAutoFillSelection filters to enabled choices before counting
- fill() inline auto-fill filters to enabled choices
- execute() auto-fill filters to enabled choices
- getChoices() and getCurrentChoices() return type includes disabled?: string
  </done>
</task>

<task type="auto">
  <name>Task 2: Add disabled-specific tests</name>
  <files>src/ui/composables/useActionController.test.ts</files>
  <action>
Add a test group for disabled selection behavior. Read the existing test file to understand the test patterns used (how actions are set up, how fill/getChoices are called, etc.) and add tests in a new `describe('disabled selections', ...)` block.

Tests to add:

1. **validateSelection rejects disabled choice value:**
Set up an action with choices where one has `disabled: 'Already played'`. Call `fill()` with the disabled choice's value. Expect `{ valid: false, error: 'Selection disabled: Already played' }`.

2. **validateSelection rejects disabled value in multiSelect array:**
Set up a multiSelect choice where one option is disabled. Call `fill()` with an array containing the disabled value. Expect rejection with "Selection disabled: {reason}".

3. **auto-fill skips disabled, selects single enabled:**
Set up an action with 3 choices: 2 disabled, 1 enabled. Verify auto-fill selects the enabled one. The currentArgs should have the enabled choice's value after start().

4. **auto-fill does NOT fire when all choices disabled:**
Set up an action with 2 choices, both disabled. Verify auto-fill does NOT trigger (currentPick still shows this selection awaiting input, currentArgs does not have a value for it).

5. **getChoices returns disabled field:**
Set up choices with disabled field. Call `getChoices()` on the pick. Verify the returned array includes `disabled` on the appropriate items.

Use the existing test patterns in the file. Each test should set up metadata with disabled choices via the `actionMetadata` ref, start the action, and verify behavior. If the existing tests use mock `fetchPickChoices`, mirror that pattern for disabled tests since choices come from the server.

IMPORTANT: Read the existing test file first to understand the exact test helper setup (createTestController or similar). Match the established patterns exactly.
  </action>
  <verify>
Run `npx vitest run src/ui/composables/useActionController.test.ts` -- all tests pass including new disabled tests.
Run `npx vitest run` -- full suite passes.
  </verify>
  <done>
- At least 5 disabled-specific tests covering: validation rejection, multiSelect rejection, auto-fill skip, all-disabled no-auto-fill, getChoices includes disabled
- All tests pass
- Requirements UI-06, UI-07, UI-08, UI-09 verified through tests
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npx vitest run` passes (all tests including new disabled tests)
- validateSelection returns "Selection disabled: {reason}" for disabled values
- tryAutoFillSelection and all auto-fill locations filter by disabled
- getChoices/getCurrentChoices return type includes disabled?: string
</verification>

<success_criteria>
fill() rejects disabled values with reason string. Auto-fill correctly skips disabled items across all 3 code paths (tryAutoFillSelection, fill inline, execute auto-fill). Custom UIs get disabled from getChoices()/getCurrentChoices()/validElements. Requirements UI-06, UI-07, UI-08, UI-09 fully addressed.
</success_criteria>

<output>
After completion, create `.planning/phases/77-ui-integration/77-03-SUMMARY.md`
</output>
