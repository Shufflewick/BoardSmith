---
phase: 79-fix-element-type-disabled-in-getchoices
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/composables/useActionController.ts
  - src/ui/composables/useActionController.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "getChoices() for element-type picks includes disabled field from ValidElement"
    - "getCurrentChoices() for element-type picks includes disabled field (delegates to getChoices)"
    - "fill() rejects disabled element values with reason string"
    - "Auto-fill skips disabled elements and selects the single enabled one"
    - "elementsByDependentValue path carries disabled through to choices"
  artifacts:
    - path: "src/ui/composables/useActionController.ts"
      provides: "Fixed element-to-choice mapping with disabled spread"
      contains: "el.disabled && { disabled: el.disabled }"
    - path: "src/ui/composables/useActionController.test.ts"
      provides: "Element-type disabled test coverage"
      contains: "disabled element"
  key_links:
    - from: "getChoices() element map (line ~286)"
      to: "ValidElement.disabled"
      via: "spread in snapshot validElements map"
      pattern: "el\\.disabled && \\{ disabled: el\\.disabled \\}"
    - from: "getChoices() element map (line ~310)"
      to: "ValidElement.disabled"
      via: "spread in elementsByDependentValue map"
      pattern: "el\\.disabled && \\{ disabled: el\\.disabled \\}"
    - from: "getChoices() element map (line ~320)"
      to: "ValidElement.disabled"
      via: "spread in static validElements fallback map"
      pattern: "el\\.disabled && \\{ disabled: el\\.disabled \\}"
---

<objective>
Fix the 3 element-to-choice mapping calls in getChoices() that drop the disabled field, and add tests covering all code paths.

Purpose: Close the integration gap found by v2.8 milestone audit where element-type picks in getChoices()/getCurrentChoices() silently discard the disabled field, breaking fill() rejection, auto-fill filtering, and custom UI disabled rendering for element selections.

Output: Fixed useActionController.ts with disabled propagation and useActionController.test.ts with 4+ element-type disabled tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/79-fix-element-type-disabled-in-getchoices/79-RESEARCH.md
@src/ui/composables/useActionController.ts
@src/ui/composables/useActionController.test.ts
@src/ui/composables/useActionController.helpers.ts
@src/ui/composables/useActionControllerTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add disabled spread to 3 element-to-choice map calls</name>
  <files>src/ui/composables/useActionController.ts</files>
  <action>
Add `...(el.disabled && { disabled: el.disabled })` to each of the 3 `validElements.map()` / `elements.map()` calls in `getChoices()` that convert elements to choice-like objects. These are the ONLY production code changes needed.

**Location 1 (~line 286): Snapshot validElements**
Change:
```
choices = snapshot.validElements.map(el => ({
  value: el.id,
  display: el.display || `Element ${el.id}`,
}));
```
To:
```
choices = snapshot.validElements.map(el => ({
  value: el.id,
  display: el.display || `Element ${el.id}`,
  ...(el.disabled && { disabled: el.disabled }),
}));
```

**Location 2 (~line 310): elementsByDependentValue**
Change:
```
choices = elements.map(el => ({
  value: el.id,
  display: el.display || `Element ${el.id}`,
}));
```
To:
```
choices = elements.map(el => ({
  value: el.id,
  display: el.display || `Element ${el.id}`,
  ...(el.disabled && { disabled: el.disabled }),
}));
```

**Location 3 (~line 320): Static validElements fallback**
Change:
```
choices = selection.validElements.map(el => ({
  value: el.id,
  display: el.display || `Element ${el.id}`,
}));
```
To:
```
choices = selection.validElements.map(el => ({
  value: el.id,
  display: el.display || `Element ${el.id}`,
  ...(el.disabled && { disabled: el.disabled }),
}));
```

Use the sparse spread pattern `...(el.disabled && { disabled: el.disabled })` -- NOT `disabled: el.disabled`. The sparse pattern keeps the field absent (not `undefined`) on enabled items, matching the project's wire convention. Do NOT use any other pattern.

No type changes needed -- ValidElement already has `disabled?: string` and the getChoices return type already includes `disabled?: string`.
  </action>
  <verify>
Run `npx vitest run src/ui/composables/useActionController.test.ts` -- all existing disabled tests (7 tests in "disabled selections" describe block) must still pass. Also run `npx vitest run src/ui/composables/useActionController.picks.test.ts` to confirm no regressions.

Verify each change with a text search: `grep -n "el.disabled && { disabled" src/ui/composables/useActionController.ts` should return exactly 3 matches.
  </verify>
  <done>All 3 element-to-choice map calls in getChoices() include the disabled spread. Existing tests pass. grep confirms exactly 3 instances of the pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Add element-type disabled tests covering all code paths</name>
  <files>src/ui/composables/useActionController.test.ts</files>
  <action>
Add a new `describe('disabled element-type selections')` block inside the existing `describe('disabled selections')` block (after the last existing test at ~line 1451, before the closing `});` of the disabled selections describe). This groups the new element-type tests logically with the existing choice-type disabled tests.

Follow the exact patterns from the RESEARCH.md code examples. Each test creates inline metadata (do NOT modify the shared createTestMetadata fixtures). Use the same setup pattern as existing disabled tests: create metadata object, merge with createTestMetadata(), push action name to availableActions, create controller.

**Test 1: getChoices() includes disabled for static validElements (Location 3)**
- Action `moveWithDisabled` with type `'element'`, validElements containing `{ id: 100, display: 'Pawn A' }` (enabled) and `{ id: 101, display: 'Pawn B', disabled: 'Pinned' }` (disabled)
- Create controller with `autoFill: false, autoExecute: false`
- Call `controller.start('moveWithDisabled')` then `controller.getChoices(selection)` on the element selection
- Assert: `choices.length === 2`, `choices[0].disabled` is `undefined`, `choices[1].disabled === 'Pinned'`
- Also verify `getCurrentChoices()` returns the same disabled values (start the action, then call getCurrentChoices())

**Test 2: fill() rejects disabled element value (Location 3)**
- Same metadata as Test 1
- Create controller with `autoExecute: false`
- `await controller.start('moveWithDisabled')`
- `const result = await controller.fill('piece', 101)`
- Assert: `result.valid === false`, `result.error === 'Selection disabled: Pinned'`
- Also verify enabled element is accepted: `const ok = await controller.fill('piece', 100)`, `ok.valid === true`

**Test 3: Auto-fill skips disabled elements (Location 3)**
- Action `forcedElement` with type `'element'`, validElements: `{ id: 100, display: 'Pawn A', disabled: 'Blocked' }` and `{ id: 101, display: 'Pawn B' }` (1 enabled)
- Create controller with `autoFill: true, autoExecute: false`
- `await controller.start('forcedElement')` then `await nextTick()`
- Assert: `controller.currentArgs.value.piece === 101`, `controller.isReady.value === true`

**Test 4: getChoices() includes disabled for elementsByDependentValue (Location 2)**
- Action `depElementAction` with 2 selections:
  - First: `{ name: 'zone', type: 'choice', prompt: 'Select zone', choices: [{ value: 'north', display: 'North' }] }`
  - Second: `{ name: 'unit', type: 'element', prompt: 'Select unit', dependsOn: 'zone', elementsByDependentValue: { north: [{ id: 1, display: 'Soldier' }, { id: 2, display: 'Medic', disabled: 'Exhausted' }] } }`
- Create controller with `autoFill: true, autoExecute: false` (so zone auto-fills to 'north')
- `await controller.start('depElementAction')` then `await nextTick()` (zone auto-fills)
- Get the unit selection from metadata and call `controller.getChoices(unitSelection)`
- Assert: `choices[0].disabled` is `undefined`, `choices[1].disabled === 'Exhausted'`

Important: Do NOT use `toBeUndefined()` for checking enabled items' disabled field. Use `expect(choices[0]).not.toHaveProperty('disabled')` to verify the field is truly absent (sparse), matching the wire convention. Wait -- actually the existing tests at line 1374 use `expect(choices[0].disabled).toBeUndefined()`. Follow that same pattern for consistency with the existing test suite, even though it doesn't distinguish absent from undefined. The sparse spread ensures absence, and the test documents the expected behavior.
  </action>
  <verify>
Run `npx vitest run src/ui/composables/useActionController.test.ts` -- all tests pass including both the existing 7 disabled choice-type tests AND the new 4 element-type tests.

Verify test count: the "disabled selections" describe block should now have 11 tests total (7 existing + 4 new).
  </verify>
  <done>4 element-type disabled tests pass covering: (1) getChoices/getCurrentChoices carry disabled for static validElements, (2) fill rejects disabled elements, (3) auto-fill skips disabled elements, (4) getChoices carries disabled for elementsByDependentValue. All 11 disabled tests pass.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Run full test suite for the file: `npx vitest run src/ui/composables/useActionController.test.ts` -- ALL tests pass (0 failures)
2. Run adjacent test file: `npx vitest run src/ui/composables/useActionController.picks.test.ts` -- ALL tests pass (no regressions)
3. Run full UI composables tests: `npx vitest run src/ui/composables/` -- ALL tests pass
4. Verify production code change is minimal: `git diff --stat src/ui/composables/useActionController.ts` shows only 3 lines added (the spread lines)
5. Verify sparse pattern used (not `disabled: el.disabled`): grep confirms `el.disabled && { disabled: el.disabled }` pattern in all 3 locations
</verification>

<success_criteria>
1. getChoices() and getCurrentChoices() for element-type picks (type: 'element' and type: 'elements') include disabled?: string on each choice item -- verified by Test 1
2. Client-side fill() for element-type picks rejects disabled elements with reason surfaced -- verified by Test 2
3. Auto-fill for element-type picks skips disabled elements (exactly 1 enabled = auto-fill) -- verified by Test 3
4. elementsByDependentValue code path also carries disabled -- verified by Test 4
5. All tests pass with 0 failures across both test files
</success_criteria>

<output>
After completion, create `.planning/phases/79-fix-element-type-disabled-in-getchoices/79-01-SUMMARY.md`
</output>
