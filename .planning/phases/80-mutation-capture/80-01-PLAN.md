---
phase: 80-mutation-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/element/mutation-capture.ts
  - src/engine/element/game.ts
  - src/engine/element/index.ts
  - src/engine/index.ts
autonomous: true

must_haves:
  truths:
    - "game.animate(type, data, callback) executes the callback synchronously and returns an AnimationEvent with a mutations array"
    - "Custom game property changes inside animate callbacks are detected via snapshot/diff and recorded as SET_PROPERTY mutations"
    - "Animation event IDs are monotonically increasing across multiple animate() calls"
    - "Nested animate() calls throw a clear error"
    - "Capture context is always cleaned up, even if callback throws"
    - "emitAnimationEvent() still works and existing tests pass unchanged"
  artifacts:
    - path: "src/engine/element/mutation-capture.ts"
      provides: "CapturedMutation union type, MutationCaptureContext interface"
      exports: ["CapturedMutation", "CreateMutation", "MoveMutation", "SetAttributeMutation", "SetPropertyMutation", "MutationCaptureContext"]
    - path: "src/engine/element/game.ts"
      provides: "animate() method on Game class, _captureContext property, _snapshotCustomProperties, _diffCustomProperties"
      contains: "animate("
  key_links:
    - from: "src/engine/element/game.ts"
      to: "src/engine/element/mutation-capture.ts"
      via: "import CapturedMutation and MutationCaptureContext types"
      pattern: "import.*mutation-capture"
    - from: "src/engine/element/index.ts"
      to: "src/engine/element/mutation-capture.ts"
      via: "re-export types"
      pattern: "export.*mutation-capture"
---

<objective>
Create the `game.animate()` scoped callback API and the mutation capture type system. After this plan, games can call `game.animate(type, data, callback)` and get back an AnimationEvent that records custom game property changes as captured mutations. Element-level interception (putInto, create, attributes) is deferred to Plan 02.

Purpose: This is the foundation of the Theatre View system. The animate() method with capture context is the core primitive that all downstream phases (81-84) depend on.

Output: New mutation-capture.ts types file, animate() method on Game, property snapshot/diff, barrel exports updated.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/80-mutation-capture/80-RESEARCH.md
@src/engine/element/game.ts
@src/engine/element/game-element.ts
@src/engine/element/index.ts
@src/engine/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mutation capture types and Game.animate() method</name>
  <files>
    src/engine/element/mutation-capture.ts
    src/engine/element/game.ts
  </files>
  <action>
**New file: `src/engine/element/mutation-capture.ts`**

Create the mutation type system:

```typescript
export type CapturedMutation =
  | CreateMutation
  | MoveMutation
  | SetAttributeMutation
  | SetPropertyMutation;

export interface CreateMutation {
  type: 'CREATE';
  className: string;
  name: string;
  parentId: number;
  elementId: number;
  attributes?: Record<string, unknown>;
}

export interface MoveMutation {
  type: 'MOVE';
  elementId: number;
  fromParentId: number;
  toParentId: number;
  position?: 'first' | 'last';
}

export interface SetAttributeMutation {
  type: 'SET_ATTRIBUTE';
  elementId: number;
  attribute: string;
  oldValue: unknown;
  newValue: unknown;
}

export interface SetPropertyMutation {
  type: 'SET_PROPERTY';
  property: string;
  oldValue: unknown;
  newValue: unknown;
}

export interface MutationCaptureContext {
  mutations: CapturedMutation[];
}
```

Export all types individually (not just the union) so downstream consumers can narrow.

**Modify: `src/engine/element/game.ts`**

1. Import `CapturedMutation`, `MutationCaptureContext`, and `SetPropertyMutation` from `./mutation-capture.js`.

2. Add a public property to the Game class:
   ```typescript
   /** Active mutation capture context. Non-null only inside animate() callbacks.
    *  Public (underscore-prefixed) so element classes can record mutations. */
   _captureContext: MutationCaptureContext | null = null;
   ```

3. Add `'_captureContext'` to `_safeProperties` Set (line ~345-353) so it doesn't trigger HMR warnings.

4. Add `'_captureContext'` to `unserializableAttributes` array (line ~355-366) so it's excluded from serialization.

5. Add the `animate()` method in the Animation Events section (near `emitAnimationEvent`, around line 2372):

   ```typescript
   /**
    * Execute a callback while capturing all mutations, associating them with
    * an animation event. Mutations apply immediately to game state -- capture
    * is purely observational for the theatre view system.
    *
    * @param type - Event type identifier (e.g., 'combat', 'score', 'death')
    * @param data - Event-specific data payload (must be JSON-serializable)
    * @param callback - Synchronous callback containing mutations to capture
    * @returns The animation event with captured mutations
    *
    * @example
    * ```typescript
    * game.animate('death', { pieceId: piece.id }, () => {
    *   piece.remove();
    *   game.score += 10;
    * });
    * ```
    */
   animate(
     type: string,
     data: Record<string, unknown>,
     callback: () => void
   ): AnimationEvent {
     if (this._captureContext) {
       throw new Error(
         `Cannot call game.animate() inside another animate() callback. ` +
         `Nested animation scopes are not supported. ` +
         `Move the inner animate() call outside the outer callback.`
       );
     }

     // Snapshot custom game properties before callback
     const propertySnapshot = this._snapshotCustomProperties();

     // Activate capture context
     this._captureContext = { mutations: [] };

     let mutations: CapturedMutation[];
     try {
       callback();
       mutations = this._captureContext.mutations;
     } finally {
       // Always clear context, even on exception
       if (!mutations!) {
         mutations = this._captureContext.mutations;
       }
       this._captureContext = null;
     }

     // Diff custom properties and append any changes
     const propertyMutations = this._diffCustomProperties(propertySnapshot);
     mutations.push(...propertyMutations);

     const event: AnimationEvent = {
       id: ++this._animationEventSeq,
       type,
       data: { ...data },
       timestamp: Date.now(),
       mutations,
     };
     this._animationEvents.push(event);
     return event;
   }
   ```

   IMPORTANT: Structure the try/finally carefully. Capture `mutations` from context inside the try block on success. In the finally block, only grab mutations from context if the try didn't (exception case), then clear context. After the finally, diff properties and build the event. On exception, the method throws (mutations are lost, context is clean). On success, mutations are captured and event is returned.

   Actually, simpler pattern that avoids the `mutations!` assertion:
   ```typescript
   const ctx: MutationCaptureContext = { mutations: [] };
   this._captureContext = ctx;
   try {
     callback();
   } finally {
     this._captureContext = null;
   }
   // Diff properties after clearing context (so diff helpers don't interfere)
   const propertyMutations = this._diffCustomProperties(propertySnapshot);
   ctx.mutations.push(...propertyMutations);

   const event: AnimationEvent = { ... mutations: ctx.mutations ... };
   ```
   Use this simpler pattern. The `ctx` local variable survives past the finally block. If callback throws, the finally clears `_captureContext` and the exception propagates -- the rest of the method doesn't execute, so no event is produced. This is correct behavior.

6. Add `_snapshotCustomProperties()` private method:
   ```typescript
   private _snapshotCustomProperties(): Record<string, unknown> {
     const snapshot: Record<string, unknown> = {};
     const unserializable = new Set(
       (this.constructor as typeof Game).unserializableAttributes
     );
     const safeProps = (this.constructor as typeof Game)._safeProperties;

     for (const key of Object.keys(this)) {
       if (unserializable.has(key) || safeProps.has(key) || key.startsWith('_')) continue;
       const value = (this as Record<string, unknown>)[key];
       // Skip element references (they have _t) -- tracked via element mutations
       if (value && typeof value === 'object' && '_t' in value) continue;
       // Skip PersistentMap instances -- tracked via settings
       if (value instanceof PersistentMap) continue;
       try {
         snapshot[key] = structuredClone(value);
       } catch {
         // Skip values that can't be cloned (functions, symbols, etc.)
       }
     }
     return snapshot;
   }
   ```

7. Add `_diffCustomProperties()` private method:
   ```typescript
   private _diffCustomProperties(
     before: Record<string, unknown>
   ): SetPropertyMutation[] {
     const mutations: SetPropertyMutation[] = [];
     const after = this._snapshotCustomProperties();
     const allKeys = new Set([...Object.keys(before), ...Object.keys(after)]);

     for (const key of allKeys) {
       const oldVal = before[key];
       const newVal = after[key];
       // Use JSON.stringify for deep comparison (game properties are JSON-serializable by design)
       if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
         mutations.push({
           type: 'SET_PROPERTY',
           property: key,
           oldValue: oldVal,
           newValue: newVal,
         });
       }
     }
     return mutations;
   }
   ```

8. Update the `AnimationEvent` interface to include the optional `mutations` field:
   ```typescript
   export interface AnimationEvent {
     id: number;
     type: string;
     data: Record<string, unknown>;
     timestamp: number;
     group?: string;
     /** Mutations captured during an animate() callback. Empty array for emitAnimationEvent(). */
     mutations?: CapturedMutation[];
   }
   ```
   Make `mutations` optional (not required) so that `emitAnimationEvent()` does not need modification. Events from `emitAnimationEvent()` will have `mutations: undefined`, events from `animate()` will always have a `CapturedMutation[]`. This maintains backward compatibility.

   NOTE: Do NOT make mutations required on the interface. That would break emitAnimationEvent and all existing code that constructs AnimationEvent objects.
  </action>
  <verify>
    Run `npx tsc --noEmit` from the project root. Zero type errors.
    Run `npx vitest run src/engine/element/animation-events.test.ts` -- all 18 existing tests pass unchanged.
  </verify>
  <done>
    - mutation-capture.ts exports all 5 mutation types and MutationCaptureContext
    - Game class has animate() method, _captureContext, _snapshotCustomProperties, _diffCustomProperties
    - AnimationEvent interface has optional mutations field
    - All existing animation event tests pass without modification
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update barrel exports and add animate() unit tests</name>
  <files>
    src/engine/element/index.ts
    src/engine/index.ts
    src/engine/element/mutation-capture.test.ts
  </files>
  <action>
**Modify: `src/engine/element/index.ts`**

Add type exports for the mutation capture types. After the existing AnimationEvent/EmitAnimationEventOptions type export line (line ~25):

```typescript
export type { CapturedMutation, CreateMutation, MoveMutation, SetAttributeMutation, SetPropertyMutation, MutationCaptureContext } from './mutation-capture.js';
```

**Modify: `src/engine/index.ts`**

Add type re-exports in the element section. After the existing AnimationEvent/EmitAnimationEventOptions line (line ~42):

```typescript
export type { CapturedMutation, CreateMutation, MoveMutation, SetAttributeMutation, SetPropertyMutation, MutationCaptureContext } from './element/index.js';
```

**New file: `src/engine/element/mutation-capture.test.ts`**

Write tests for the animate() method and property capture. Use the same TestGame pattern from animation-events.test.ts.

Test cases to write:

1. **animate() basics:**
   - `animate()` returns an AnimationEvent with type, data, and mutations array
   - Event IDs are monotonically increasing (including interleaved with emitAnimationEvent)
   - The returned event is in pendingAnimationEvents
   - Data is shallow-copied (external mutation doesn't affect event)

2. **Property mutation capture:**
   - Create a `TestGame` subclass with a custom property (e.g., `score: number = 0`)
   - Call `animate('score', {}, () => { game.score = 10 })` -- mutations should contain one SET_PROPERTY with property 'score', oldValue 0, newValue 10
   - Multiple property changes in one callback produce multiple SET_PROPERTY mutations
   - Properties that don't change produce no mutations
   - Object/array properties that change are captured with deep values (before and after snapshots)

3. **Callback execution:**
   - Callback is executed synchronously (set a flag inside, check it after)
   - Mutations apply immediately to game state (game.score is 10 after animate returns)
   - If callback throws, _captureContext is null (cleaned up) and the error propagates
   - If callback throws, no event is added to pendingAnimationEvents

4. **Nested animate() prevention:**
   - Calling animate() inside an animate() callback throws with message containing "Cannot call game.animate()"
   - After nested error, outer context is still properly cleaned up

5. **emitAnimationEvent compatibility:**
   - emitAnimationEvent still works, returns event without mutations field
   - animate() and emitAnimationEvent share the same ID counter (IDs are monotonically increasing across both)
   - Acknowledgment works for events from both APIs

6. **Empty callback:**
   - animate() with empty callback `() => {}` produces event with empty mutations array

Create the TestGame subclass with custom properties for testing:
```typescript
class ScoreGame extends Game<ScoreGame, Player> {
  score = 0;
  round = 1;
  status = 'playing';
  history: number[] = [];
}
```

Use `new ScoreGame({ playerCount: 2, seed: 'test' })` for each test.

IMPORTANT: The `history` array will be auto-synced to settings by the Game constructor's volatile state checker. For the tests, use simple value properties (score, round, status) as the primary test targets, not arrays.
  </action>
  <verify>
    Run `npx vitest run src/engine/element/mutation-capture.test.ts` -- all new tests pass.
    Run `npx vitest run src/engine/element/animation-events.test.ts` -- all existing tests still pass.
    Run `npx tsc --noEmit` -- zero type errors.
  </verify>
  <done>
    - mutation-capture types are exported from both barrel files (element/index.ts, engine/index.ts)
    - mutation-capture.test.ts has at least 12 test cases covering animate(), property capture, error handling, and emitAnimationEvent compatibility
    - All tests pass
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero errors (types are sound)
2. `npx vitest run src/engine/element/` -- all tests pass (new + existing)
3. `npx vitest run` -- full test suite passes (no regressions)
</verification>

<success_criteria>
- game.animate(type, data, callback) exists and returns AnimationEvent with mutations
- Custom game property changes inside callbacks are captured as SET_PROPERTY mutations
- Event IDs are monotonically increasing (ENG-08)
- Nested animate() throws clear error
- Capture context cleaned up on exception (try/finally)
- emitAnimationEvent() unchanged and all existing tests pass
- CapturedMutation types exported from engine barrel
</success_criteria>

<output>
After completion, create `.planning/phases/80-mutation-capture/80-01-SUMMARY.md`
</output>
