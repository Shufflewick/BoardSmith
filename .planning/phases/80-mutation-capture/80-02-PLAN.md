---
phase: 80-mutation-capture
plan: 02
type: execute
wave: 2
depends_on: ["80-01"]
files_modified:
  - src/engine/element/piece.ts
  - src/engine/element/game-element.ts
  - src/engine/element/game.ts
  - src/engine/element/mutation-capture.test.ts
autonomous: true

must_haves:
  truths:
    - "Element tree changes (create, move, remove) inside animate callbacks are tracked as mutations on the event"
    - "Element attribute changes inside animate callbacks are tracked as SET_ATTRIBUTE mutations"
    - "remove() produces exactly one MOVE mutation (no duplicates from delegation to putInto)"
    - "putInto() outside animate() works exactly as before (no capture, no recording)"
    - "create() outside animate() works exactly as before"
    - "All existing tests continue to pass"
  artifacts:
    - path: "src/engine/element/piece.ts"
      provides: "putInto() mutation capture when inside animate()"
      contains: "_captureContext"
    - path: "src/engine/element/game-element.ts"
      provides: "create() mutation capture when inside animate(), element attribute snapshot helpers"
      contains: "_captureContext"
    - path: "src/engine/element/game.ts"
      provides: "Element attribute snapshot/diff in animate() method"
      contains: "_snapshotElementAttributes"
    - path: "src/engine/element/mutation-capture.test.ts"
      provides: "Integration tests for element mutation capture"
  key_links:
    - from: "src/engine/element/piece.ts"
      to: "src/engine/element/game.ts"
      via: "this.game._captureContext check in putInto()"
      pattern: "this\\.game\\._captureContext"
    - from: "src/engine/element/game-element.ts"
      to: "src/engine/element/game.ts"
      via: "this.game._captureContext check in create()"
      pattern: "this\\.game\\._captureContext"
    - from: "src/engine/element/game.ts"
      to: "src/engine/element/game-element.ts"
      via: "element attribute snapshot uses toJSON-style enumeration"
      pattern: "_snapshotElementAttributes"
---

<objective>
Add element-level mutation interception so that `putInto()`, `remove()`, `create()`, and element attribute changes inside `animate()` callbacks are captured as mutations on the animation event. After this plan, ALL four mutation types (CREATE, MOVE, SET_ATTRIBUTE, SET_PROPERTY) are captured, completing Phase 80.

Purpose: Without element interception, animate() only captures game property changes. This plan completes the mutation capture system by adding element tree and attribute tracking, making the full data available for the Theatre State Engine (Phase 81).

Output: Updated piece.ts, game-element.ts, game.ts with interception hooks, comprehensive integration tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/80-mutation-capture/80-RESEARCH.md
@.planning/phases/80-mutation-capture/80-01-SUMMARY.md
@src/engine/element/game.ts
@src/engine/element/game-element.ts
@src/engine/element/piece.ts
@src/engine/element/mutation-capture.ts
@src/engine/element/mutation-capture.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mutation interception to putInto(), create(), and element attribute snapshot</name>
  <files>
    src/engine/element/piece.ts
    src/engine/element/game-element.ts
    src/engine/element/game.ts
  </files>
  <action>
**Modify: `src/engine/element/piece.ts`**

Update `putInto()` (line ~73-75) to record a MOVE mutation when capture context is active:

```typescript
putInto(destination: GameElement, options?: { position?: 'first' | 'last' }): void {
  // Record MOVE mutation if inside animate() callback
  if (this.game._captureContext) {
    this.game._captureContext.mutations.push({
      type: 'MOVE',
      elementId: this._t.id,
      fromParentId: this._t.parent?._t.id ?? -1,
      toParentId: destination._t.id,
      position: options?.position,
    });
  }
  this.moveToInternal(destination, options?.position);
}
```

Import `MoveMutation` type if needed for type safety, or rely on the object literal matching the union. The literal approach is fine here since TypeScript will check the shape against `CapturedMutation`.

Do NOT modify `remove()` -- it delegates to `putInto()`, so the MOVE mutation is recorded exactly once (from putInto). This avoids the duplicate mutation pitfall identified in research.

Do NOT modify `moveToInternal()` -- that's the low-level tree manipulation. Capture happens at the public API level (`putInto`) where we know the before/after parents.

**Modify: `src/engine/element/game-element.ts`**

Update `create()` (line ~242-248) to record a CREATE mutation when capture context is active:

```typescript
create<T extends GameElement>(
  elementClass: ElementClass<T>,
  name: string,
  attributes?: ElementAttributes<T>
): T {
  const element = this.createInternal(elementClass, name, attributes);

  // Record CREATE mutation if inside animate() callback
  if (this.game._captureContext) {
    // Snapshot the serializable attributes of the new element
    const attrSnapshot: Record<string, unknown> = {};
    if (attributes) {
      const unserializable = new Set(
        (elementClass as typeof GameElement).unserializableAttributes
      );
      for (const [key, value] of Object.entries(attributes)) {
        if (!unserializable.has(key) && !key.startsWith('_')) {
          attrSnapshot[key] = value;
        }
      }
    }

    this.game._captureContext.mutations.push({
      type: 'CREATE',
      className: elementClass.name,
      name,
      parentId: this._t.id,
      elementId: element._t.id,
      ...(Object.keys(attrSnapshot).length > 0 && { attributes: attrSnapshot }),
    });
  }

  return element;
}
```

No new imports needed -- `GameElement` already has access to `this.game` which holds `_captureContext`.

**Modify: `src/engine/element/game.ts`**

Add element attribute snapshot/diff to the `animate()` method. The strategy: snapshot all elements' serializable attributes before the callback, diff after the callback, and record SET_ATTRIBUTE mutations for any changes.

1. Add a private `_snapshotElementAttributes()` method:

```typescript
/**
 * Snapshot serializable attributes of all elements in the tree.
 * Used to detect attribute changes during animate() callbacks.
 * Returns Map<elementId, Record<attrName, value>>
 */
private _snapshotElementAttributes(): Map<number, Record<string, unknown>> {
  const snapshot = new Map<number, Record<string, unknown>>();

  const walkTree = (element: GameElement): void => {
    const attrs: Record<string, unknown> = {};
    const unserializable = new Set(
      (element.constructor as typeof GameElement).unserializableAttributes
    );

    for (const key of Object.keys(element)) {
      if (unserializable.has(key) || key.startsWith('_')) continue;
      const value = (element as Record<string, unknown>)[key];
      if (value !== undefined) {
        // Skip element references
        if (value && typeof value === 'object' && '_t' in value) continue;
        try {
          attrs[key] = structuredClone(value);
        } catch {
          // Skip non-cloneable values
        }
      }
    }
    snapshot.set(element._t.id, attrs);

    for (const child of element._t.children) {
      walkTree(child);
    }
  };

  // Walk entire tree from this (the Game, which is the root)
  walkTree(this);

  return snapshot;
}
```

Import `GameElement` at the top of game.ts if not already imported (check -- it's likely already imported since Game extends Space which extends GameElement).

2. Add a private `_diffElementAttributes()` method:

```typescript
/**
 * Compare element attribute snapshots and produce SET_ATTRIBUTE mutations.
 */
private _diffElementAttributes(
  before: Map<number, Record<string, unknown>>
): SetAttributeMutation[] {
  const mutations: SetAttributeMutation[] = [];
  const after = this._snapshotElementAttributes();

  // Check elements that existed before
  for (const [elementId, beforeAttrs] of before) {
    const afterAttrs = after.get(elementId);
    if (!afterAttrs) continue; // Element was removed -- tracked as MOVE, not attribute change

    const allKeys = new Set([...Object.keys(beforeAttrs), ...Object.keys(afterAttrs)]);
    for (const key of allKeys) {
      const oldVal = beforeAttrs[key];
      const newVal = afterAttrs[key];
      if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
        mutations.push({
          type: 'SET_ATTRIBUTE',
          elementId,
          attribute: key,
          oldValue: oldVal,
          newValue: newVal,
        });
      }
    }
  }

  // Elements created during callback are tracked via CREATE mutations, not attribute diffs

  return mutations;
}
```

Import `SetAttributeMutation` from `./mutation-capture.js` (add it to the existing import).

3. Update the `animate()` method to also snapshot/diff element attributes:

In the `animate()` method (written in Plan 01), add element attribute snapshotting. The method should:

```typescript
animate(
  type: string,
  data: Record<string, unknown>,
  callback: () => void
): AnimationEvent {
  if (this._captureContext) {
    throw new Error(
      `Cannot call game.animate() inside another animate() callback. ` +
      `Nested animation scopes are not supported. ` +
      `Move the inner animate() call outside the outer callback.`
    );
  }

  // Snapshot before callback
  const propertySnapshot = this._snapshotCustomProperties();
  const elementAttrSnapshot = this._snapshotElementAttributes();

  // Activate capture context
  const ctx: MutationCaptureContext = { mutations: [] };
  this._captureContext = ctx;

  try {
    callback();
  } finally {
    this._captureContext = null;
  }

  // Diff properties and element attributes after callback
  const propertyMutations = this._diffCustomProperties(propertySnapshot);
  const attrMutations = this._diffElementAttributes(elementAttrSnapshot);
  ctx.mutations.push(...propertyMutations, ...attrMutations);

  const event: AnimationEvent = {
    id: ++this._animationEventSeq,
    type,
    data: { ...data },
    timestamp: Date.now(),
    mutations: ctx.mutations,
  };
  this._animationEvents.push(event);
  return event;
}
```

This replaces the animate() method from Plan 01. The key additions are: `elementAttrSnapshot` before callback, `_diffElementAttributes` after callback, and pushing attr mutations into the event.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- zero type errors.
    Run `npx vitest run src/engine/element/mutation-capture.test.ts` -- all Plan 01 tests still pass.
    Run `npx vitest run src/engine/element/animation-events.test.ts` -- all existing tests still pass.
  </verify>
  <done>
    - putInto() records MOVE mutation when inside animate()
    - create() records CREATE mutation when inside animate()
    - Element attribute changes detected via snapshot/diff
    - remove() produces exactly one MOVE (no duplicate)
    - Outside animate(), all element operations work unchanged
    - TypeScript compiles, existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for element mutation capture</name>
  <files>
    src/engine/element/mutation-capture.test.ts
  </files>
  <action>
Add new test describe blocks to the existing mutation-capture.test.ts file (created in Plan 01). These tests exercise the element interception added in Task 1.

Create a richer TestGame for element tests:

```typescript
class ElementTestGame extends Game<ElementTestGame, Player> {
  score = 0;
}
```

Use `beforeEach` to set up a game with Spaces and Pieces:
```typescript
let game: ElementTestGame;
let board: Space;
let hand: Space;
let piece: Piece;

beforeEach(() => {
  game = new ElementTestGame({ playerCount: 2, seed: 'test' });
  board = game.create(Space, 'board');
  hand = game.create(Space, 'hand');
  piece = board.create(Piece, 'token');
});
```

Import `Space`, `Piece`, `Card` (if needed) from the element barrel.

**Test cases for MOVE mutations:**

1. `putInto() inside animate() records a MOVE mutation` -- Move piece from board to hand. Check mutations has one MOVE with correct elementId, fromParentId (board), toParentId (hand).

2. `remove() inside animate() records exactly one MOVE mutation` -- Remove a piece. Check mutations has exactly one MOVE with toParentId being game.pile's id. Verify it is NOT two mutations (no double-recording from remove->putInto delegation).

3. `multiple moves inside one animate() records multiple MOVE mutations` -- Create two pieces, move both. Check two MOVE mutations.

4. `putInto() outside animate() records no mutations` -- Move a piece normally. Check game.pendingAnimationEvents is empty.

**Test cases for CREATE mutations:**

5. `create() inside animate() records a CREATE mutation` -- Create a new Piece inside animate callback. Check mutations has one CREATE with className, name, parentId, elementId.

6. `create() with attributes records them in the mutation` -- Create a Piece with custom attributes (e.g., name and player). Check CREATE mutation has attributes.

7. `create() outside animate() records no mutations` -- Verify no events produced.

**Test cases for SET_ATTRIBUTE mutations:**

8. `attribute change inside animate() records SET_ATTRIBUTE mutation` -- Set up a piece with a custom attribute, change it inside animate(). Verify SET_ATTRIBUTE with correct elementId, attribute name, old/new values.

   For this test, create a typed Piece subclass:
   ```typescript
   class TokenPiece extends Piece<ElementTestGame, Player> {
     health = 10;
     color = 'red';
   }
   ```
   Create a TokenPiece, then inside animate(), change `token.health = 5`. Check for SET_ATTRIBUTE mutation.

9. `multiple attribute changes on different elements` -- Change attributes on two different elements in one animate(). Verify two separate SET_ATTRIBUTE mutations.

10. `attribute unchanged produces no SET_ATTRIBUTE mutation` -- Read an attribute inside animate() but don't change it. No SET_ATTRIBUTE in mutations.

**Test cases for mixed mutations:**

11. `animate() captures all mutation types in one callback` -- Inside one animate(): create a piece, move another, change an attribute, change a game property. Verify all four mutation types appear in the event's mutations array.

12. `mutations apply immediately to game state` -- Inside animate(), move piece to hand, verify piece is in hand. After animate(), verify piece is still in hand. Game state is not deferred.

**Test cases for edge cases:**

13. `animate() with no mutations produces event with empty mutations array` -- Call animate with callback that reads state but mutates nothing.

14. `callback exception does not leak capture context` -- Wrap animate in try/catch with a throwing callback. After catching, verify `game._captureContext` is null. Verify a subsequent putInto() outside animate produces no mutation recording.

15. `mixed animate() and emitAnimationEvent() maintain monotonic IDs` -- Interleave animate() and emitAnimationEvent() calls. Verify all event IDs are strictly increasing.

**Run the full test suite after writing tests.**
  </action>
  <verify>
    Run `npx vitest run src/engine/element/mutation-capture.test.ts` -- all tests pass (Plan 01 tests + new integration tests).
    Run `npx vitest run src/engine/element/` -- all element tests pass.
    Run `npx vitest run` -- full test suite passes (no regressions anywhere).
  </verify>
  <done>
    - At least 15 integration test cases for element mutation capture
    - MOVE, CREATE, SET_ATTRIBUTE, SET_PROPERTY mutations all tested
    - Edge cases tested (empty callback, exceptions, mixed APIs, no-op mutations)
    - remove() duplicate prevention verified
    - Full test suite passes (zero regressions)
    - Phase 80 success criteria met:
      1. game.animate('death', data, () => { piece.remove() }) produces event with piece removal mutation
      2. Element tree changes tracked per event
      3. Game property changes tracked per event
      4. Monotonic IDs across animate() calls
      5. All existing tests pass
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero errors
2. `npx vitest run src/engine/element/mutation-capture.test.ts` -- all tests pass
3. `npx vitest run src/engine/element/animation-events.test.ts` -- existing tests unchanged and passing
4. `npx vitest run` -- full suite passes (no regressions)
5. Manual verification: The five phase success criteria from the roadmap are all covered by tests
</verification>

<success_criteria>
- ENG-01: game.animate(type, data, callback) captures mutations and produces animation event -- DONE (Plan 01 + 02)
- ENG-02: Element tree changes (create, move, remove, attribute changes) tracked -- DONE (this plan)
- ENG-03: Custom game property changes tracked -- DONE (Plan 01)
- ENG-08: Monotonically increasing event IDs -- DONE (Plan 01, verified in Plan 02)
- All existing tests pass without modification -- verified by full suite run
</success_criteria>

<output>
After completion, create `.planning/phases/80-mutation-capture/80-02-SUMMARY.md`
</output>
