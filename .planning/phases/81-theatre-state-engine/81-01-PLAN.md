---
phase: 81-theatre-state-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/element/theatre-state.ts
  - src/engine/element/theatre-state.test.ts
autonomous: true

must_haves:
  truths:
    - "applyMutation() correctly applies MOVE mutations to an ElementJSON snapshot (element moves between parents)"
    - "applyMutation() correctly applies CREATE mutations (new element added to parent's children)"
    - "applyMutation() correctly applies SET_ATTRIBUTE mutations (element attribute updated in snapshot)"
    - "applyMutation() correctly applies SET_PROPERTY mutations (game property updated in snapshot.attributes)"
    - "MOVE to a parent not in the snapshot removes the element entirely (pile removal pattern)"
    - "findElementById() finds elements at any depth in an ElementJSON tree"
    - "removeElementFromParent() removes and returns element from its parent's children array"
  artifacts:
    - path: "src/engine/element/theatre-state.ts"
      provides: "Theatre state mutation application functions"
      exports: ["applyMutation", "applyMutations", "findElementById", "removeElementFromParent"]
    - path: "src/engine/element/theatre-state.test.ts"
      provides: "Unit tests for all mutation applicators"
      min_lines: 100
  key_links:
    - from: "src/engine/element/theatre-state.ts"
      to: "src/engine/element/mutation-capture.ts"
      via: "imports CapturedMutation types"
      pattern: "import.*CapturedMutation.*mutation-capture"
    - from: "src/engine/element/theatre-state.ts"
      to: "src/engine/element/types.ts"
      via: "imports ElementJSON type"
      pattern: "import.*ElementJSON.*types"
---

<objective>
Create the theatre state mutation application module -- pure functions that apply CapturedMutation records to ElementJSON snapshots, advancing the snapshot one mutation at a time.

Purpose: These functions are the mechanical core of the theatre state engine. They operate on plain JSON (no class instances, no side effects), making them easy to test in isolation before wiring into the Game class in Plan 02.

Output: `theatre-state.ts` with mutation applicators and JSON tree helpers, plus comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/81-theatre-state-engine/81-RESEARCH.md

@src/engine/element/mutation-capture.ts
@src/engine/element/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create theatre-state.ts with mutation application functions</name>
  <files>src/engine/element/theatre-state.ts</files>
  <action>
Create `src/engine/element/theatre-state.ts` with these exported functions:

**Tree helpers:**

1. `findElementById(node: ElementJSON, id: number): ElementJSON | undefined`
   - Recursive depth-first search through node and node.children
   - Returns the matching node or undefined

2. `removeElementFromParent(root: ElementJSON, elementId: number): ElementJSON | undefined`
   - Search all nodes for a child with the given ID
   - If found, splice it from parent.children and return it
   - If not found, return undefined

**Mutation applicators (all mutate the snapshot in place):**

3. `applyMoveMutation(snapshot: ElementJSON, mutation: MoveMutation): void`
   - Remove element from current parent via removeElementFromParent
   - Find destination parent via findElementById
   - If destination NOT found in snapshot, the element is being removed from play (moved to pile) -- just leave it removed, don't add anywhere
   - If destination found, add to destination.children (initialize children array if needed)
   - Respect mutation.position: 'first' -> unshift, else push

4. `applyCreateMutation(snapshot: ElementJSON, mutation: CreateMutation): void`
   - Find parent via findElementById
   - If parent not found, return (edge case)
   - Initialize parent.children if needed
   - Push a new ElementJSON object: `{ className: mutation.className, id: mutation.elementId, name: mutation.name, attributes: mutation.attributes ? { ...mutation.attributes } : {} }`

5. `applySetAttributeMutation(snapshot: ElementJSON, mutation: SetAttributeMutation): void`
   - Find element via findElementById
   - If not found, return
   - Set `element.attributes[mutation.attribute] = mutation.newValue`

6. `applySetPropertyMutation(snapshot: ElementJSON, mutation: SetPropertyMutation): void`
   - Game custom properties live in `snapshot.attributes` (from GameElement.toJSON())
   - Set `snapshot.attributes[mutation.property] = mutation.newValue`
   - Note: This always applies to the ROOT snapshot, not a child element. The first argument should be the root.

**Dispatcher:**

7. `applyMutation(snapshot: ElementJSON, mutation: CapturedMutation): void`
   - Switch on mutation.type, delegate to the appropriate applicator
   - Pass snapshot as first arg to all (SET_PROPERTY needs root)

8. `applyMutations(snapshot: ElementJSON, mutations: CapturedMutation[]): void`
   - Iterate mutations in order, call applyMutation for each

**Imports:** Import CapturedMutation (and individual mutation types) from `./mutation-capture.js`, ElementJSON from `./types.js`.

**JSDoc:** Add module-level doc explaining this module operates on plain JSON (no Game instances) and is the core of the theatre state advancement system.
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
  </verify>
  <done>
    All 8 functions exported from theatre-state.ts. TypeScript compiles cleanly. Functions are pure (no side effects beyond mutating the passed snapshot).
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for mutation applicators</name>
  <files>src/engine/element/theatre-state.test.ts</files>
  <action>
Create `src/engine/element/theatre-state.test.ts` with tests covering every mutation applicator and tree helper.

**Test setup pattern:** Create ElementJSON fixtures inline -- these are plain objects, no Game instances needed:

```typescript
function makeSnapshot(): ElementJSON {
  return {
    className: 'Game', id: 0, name: 'game',
    attributes: { score: 0, round: 1 },
    children: [
      {
        className: 'Space', id: 1, name: 'board',
        attributes: {},
        children: [
          { className: 'Piece', id: 10, name: 'warrior', attributes: { hp: 5 } },
          { className: 'Piece', id: 11, name: 'mage', attributes: { hp: 3 } },
        ]
      },
      {
        className: 'Space', id: 2, name: 'discard',
        attributes: {},
        children: []
      },
    ]
  };
}
```

**Test groups:**

1. **findElementById** (3-4 tests)
   - Finds root by id
   - Finds nested child
   - Finds deeply nested child
   - Returns undefined for non-existent id

2. **removeElementFromParent** (3 tests)
   - Removes element from parent, returns it
   - Returns undefined when element not found
   - Element no longer in original parent's children after removal

3. **applyMoveMutation** (4 tests)
   - Moves element between parents (piece from board to discard)
   - Moves element to first position when position='first'
   - Removes element when destination parent not in snapshot (pile pattern -- use a toParentId like 999 that doesn't exist in the snapshot)
   - Source element no longer in original parent after move

4. **applyCreateMutation** (3 tests)
   - Creates element in parent's children
   - Creates element with attributes
   - Initializes children array if parent had none

5. **applySetAttributeMutation** (2 tests)
   - Updates existing attribute
   - Sets new attribute that didn't exist before

6. **applySetPropertyMutation** (2 tests)
   - Updates game property in snapshot.attributes (e.g., score)
   - Sets new game property

7. **applyMutations** (2 tests)
   - Applies multiple mutations in order
   - Handles mixed mutation types (move + attribute + property)

8. **Edge cases** (2-3 tests)
   - applyMoveMutation when source element not found (no-op, no throw)
   - applySetAttributeMutation when element not found (no-op, no throw)
   - applyCreateMutation when parent not found (no-op, no throw)

Use `describe`/`test` blocks. Import from `./theatre-state.js`. Use `expect` assertions.
  </action>
  <verify>
    `npx vitest run src/engine/element/theatre-state.test.ts` passes all tests.
    Also run `npx vitest run` to confirm zero regressions across all test files.
  </verify>
  <done>
    All mutation applicators and tree helpers have test coverage. All tests pass. Zero regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. `npx vitest run src/engine/element/theatre-state.test.ts` -- all tests pass
3. `npx vitest run` -- zero regressions across full test suite
</verification>

<success_criteria>
- theatre-state.ts exports applyMutation, applyMutations, findElementById, removeElementFromParent
- All 4 mutation types (MOVE, CREATE, SET_ATTRIBUTE, SET_PROPERTY) handled correctly
- MOVE to non-existent destination = removal (pile pattern)
- SET_PROPERTY targets snapshot.attributes (where game properties live in JSON)
- 20+ unit tests covering all functions and edge cases
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/81-theatre-state-engine/81-01-SUMMARY.md`
</output>
