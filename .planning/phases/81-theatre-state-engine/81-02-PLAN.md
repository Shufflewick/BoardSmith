---
phase: 81-theatre-state-engine
plan: 02
type: execute
wave: 2
depends_on: ["81-01"]
files_modified:
  - src/engine/element/game.ts
  - src/engine/element/index.ts
  - src/engine/index.ts
  - src/engine/element/theatre-state.test.ts
autonomous: true

must_haves:
  truths:
    - "After game.animate() is called, the theatre state does NOT reflect the callback's mutations (it shows pre-animation state)"
    - "Acknowledging an event by ID applies exactly that event's captured mutations to the theatre state, advancing it one step"
    - "Theatre state serializes with game state and restores correctly (checkpoint round-trip preserves pending events and theatre position)"
    - "Multiple animate calls produce a theatre state that can be stepped through event-by-event in order"
    - "When all events are acknowledged, theatre snapshot is cleared (null) and theatreState getter returns current toJSON()"
    - "Games that never call animate() have zero overhead (no snapshot taken)"
  artifacts:
    - path: "src/engine/element/game.ts"
      provides: "_theatreSnapshot field, lazy init in animate(), mutation application in acknowledgeAnimationEvents(), serialization, theatreState getter"
      contains: "_theatreSnapshot"
    - path: "src/engine/element/theatre-state.test.ts"
      provides: "Integration tests for theatre state engine wired into Game class"
      min_lines: 200
  key_links:
    - from: "src/engine/element/game.ts"
      to: "src/engine/element/theatre-state.ts"
      via: "imports applyMutations for acknowledgment"
      pattern: "import.*applyMutations.*theatre-state"
    - from: "game.ts animate()"
      to: "game._theatreSnapshot"
      via: "lazy initialization before first animate() callback"
      pattern: "this._theatreSnapshot.*=.*this.toJSON"
    - from: "game.ts acknowledgeAnimationEvents()"
      to: "applyMutations()"
      via: "applies mutations from acknowledged events to theatre snapshot"
      pattern: "applyMutations.*_theatreSnapshot"
    - from: "game.ts toJSON()"
      to: "_theatreSnapshot"
      via: "serializes theatre snapshot when present"
      pattern: "theatreSnapshot.*_theatreSnapshot"
    - from: "game.ts restoreGame()"
      to: "_theatreSnapshot"
      via: "restores theatre snapshot from JSON"
      pattern: "theatreSnapshot"
---

<objective>
Wire the theatre state engine into the Game class -- lazy snapshot initialization in animate(), mutation advancement in acknowledgeAnimationEvents(), serialization round-trip, and a public getter for downstream consumers.

Purpose: This completes Phase 81's three requirements (ENG-04, ENG-05, ENG-06). After this plan, the Game class maintains a theatre state that reflects only acknowledged events' mutations, can be stepped through event-by-event, and survives checkpoint/restore.

Output: Modified Game class with theatre state lifecycle, integration tests proving all four success criteria from the roadmap.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/81-theatre-state-engine/81-RESEARCH.md
@.planning/phases/81-theatre-state-engine/81-01-SUMMARY.md

@src/engine/element/game.ts
@src/engine/element/theatre-state.ts
@src/engine/element/mutation-capture.ts
@src/engine/element/types.ts
@src/engine/element/index.ts
@src/engine/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add theatre state lifecycle to Game class</name>
  <files>src/engine/element/game.ts, src/engine/element/index.ts, src/engine/index.ts</files>
  <action>
Modify `src/engine/element/game.ts` to add the theatre state engine:

**1. Add import:**
```typescript
import { applyMutations } from './theatre-state.js';
```

**2. Add private field (near other animation fields ~line 339):**
```typescript
/** Theatre state snapshot. Null when no pending animate() events.
 *  Initialized lazily before first animate() callback, advanced by acknowledgeAnimationEvents(). */
private _theatreSnapshot: ReturnType<Game['toJSON']> | null = null;
```

**3. Add to _safeProperties set:**
Add `'_theatreSnapshot'` to the `_safeProperties` Set (alongside `_animationEvents`, `_animationEventSeq`, etc.).

**4. Add to unserializableAttributes array:**
Add `'_theatreSnapshot'` to the `unserializableAttributes` array. This prevents the snapshot from being treated as a game attribute during toJSON serialization. (The snapshot is serialized explicitly in toJSON, not via the generic attribute walk.)

**5. Lazy init in animate() method:**
Insert BEFORE the property/element snapshots and capture context setup (before `const propertySnapshot = this._snapshotCustomProperties();`):

```typescript
// Lazy-init theatre snapshot before first animate() mutations
if (!this._theatreSnapshot) {
  this._theatreSnapshot = this.toJSON();
}
```

This captures the pre-mutation baseline. Subsequent animate() calls within the same animation sequence do NOT re-snapshot.

**6. Extend acknowledgeAnimationEvents():**
Replace the existing single-line method body with:

```typescript
acknowledgeAnimationEvents(upToId: number): void {
  // Apply mutations to theatre snapshot for acknowledged events
  if (this._theatreSnapshot) {
    const eventsToAck = this._animationEvents
      .filter(e => e.id <= upToId)
      .sort((a, b) => a.id - b.id);

    for (const event of eventsToAck) {
      if (event.mutations) {
        applyMutations(this._theatreSnapshot, event.mutations);
      }
    }
  }

  // Remove acknowledged events from buffer (existing behavior)
  this._animationEvents = this._animationEvents.filter(e => e.id > upToId);

  // Clear theatre snapshot when all events acknowledged (truth and theatre in sync)
  if (this._animationEvents.length === 0) {
    this._theatreSnapshot = null;
  }
}
```

**7. Add theatreState getter (near pendingAnimationEvents getter):**
```typescript
/**
 * Get the theatre state -- the "narrative" view reflecting only acknowledged events.
 * Returns the theatre snapshot if animations are pending, or current toJSON() if in sync.
 *
 * Phase 82 will use this for buildPlayerState() default view.
 */
get theatreState(): ReturnType<Game['toJSON']> {
  return this._theatreSnapshot ?? this.toJSON();
}
```

**8. Extend toJSON() return type and body:**
Add `theatreSnapshot?` to the return type annotation:
```typescript
override toJSON(): ElementJSON & {
  phase: GamePhase;
  isFinished: boolean;
  messages: Array<{ text: string; data?: Record<string, unknown> }>;
  settings: Record<string, unknown>;
  animationEvents?: AnimationEvent[];
  animationEventSeq?: number;
  theatreSnapshot?: ReturnType<Game['toJSON']>;  // ADD THIS
}
```

Add theatre snapshot to the return object (after animationEvents spread):
```typescript
...(this._theatreSnapshot && {
  theatreSnapshot: this._theatreSnapshot,
}),
```

**9. Extend restoreGame():**
After the animation events restoration block (after `game._animationEventSeq = ...`), add:

```typescript
// Restore theatre snapshot if present
if ((json as { theatreSnapshot?: ReturnType<Game['toJSON']> }).theatreSnapshot) {
  game._theatreSnapshot = (json as { theatreSnapshot: ReturnType<Game['toJSON']> }).theatreSnapshot;
}
```

**10. Update barrel exports:**

In `src/engine/element/index.ts`, add to the mutation-capture type exports or add a new export line:
```typescript
export { applyMutation, applyMutations, findElementById, removeElementFromParent } from './theatre-state.js';
```

In `src/engine/index.ts`, add a corresponding re-export:
```typescript
export { applyMutation, applyMutations, findElementById, removeElementFromParent } from './element/index.js';
```

These are value exports (functions), not type-only exports.
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors.
    All existing tests pass: `npx vitest run`.
  </verify>
  <done>
    Game class has _theatreSnapshot field, lazy init in animate(), mutation advancement in acknowledgeAnimationEvents(), theatreState getter, serialization in toJSON(), restoration in restoreGame(). Barrel exports updated. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for theatre state in Game class</name>
  <files>src/engine/element/theatre-state.test.ts</files>
  <action>
Add integration test section to `src/engine/element/theatre-state.test.ts` (after the existing unit tests from Plan 01). These tests create real Game instances with animate() calls and verify theatre state behavior end-to-end.

**Test setup:** Use the same test game pattern from `mutation-capture.test.ts`:

```typescript
import { Game, Space, Piece } from './index.js';

class TestPiece extends Piece { hp = 5; }
class Board extends Space {}
class TestGame extends Game {
  score = 0;
  round = 1;
}

function createTestGame() {
  const game = new TestGame({ playerCount: 2 });
  game._ctx.classRegistry.set('TestPiece', TestPiece);
  game._ctx.classRegistry.set('Board', Board);
  game._ctx.classRegistry.set('TestGame', TestGame);
  const board = game.create(Board, 'board');
  const p1 = board.create(TestPiece, 'warrior');
  const p2 = board.create(TestPiece, 'mage');
  const discard = game.create(Space, 'discard');
  game.phase = 'started';
  return { game, board, p1, p2, discard };
}
```

**Test groups (add as new describe blocks):**

1. **Theatre state lifecycle** (3-4 tests)
   - `_theatreSnapshot is null before any animate() call` -- verify `game._theatreSnapshot` is null initially
   - `animate() creates theatre snapshot before callback runs` -- call animate, verify `game._theatreSnapshot` is not null, and the snapshot does NOT reflect the mutation
   - `theatre snapshot captures pre-mutation state` -- animate with piece.remove(), check that the theatre snapshot still has the piece in its children
   - `theatreState getter returns toJSON() when no animations pending` -- compare game.theatreState with game.toJSON(), they should be deeply equal

2. **Per-event acknowledgment (ENG-05)** (4-5 tests)
   - `acknowledging event advances theatre state` -- animate to remove piece, acknowledge, verify piece is gone from theatreState
   - `acknowledging one of two events advances theatre state by exactly one step` -- two animate calls (remove piece1, then remove piece2), acknowledge first event only, verify piece1 gone but piece2 still present in theatreState
   - `acknowledging all events clears theatre snapshot` -- animate, acknowledge all, verify `game._theatreSnapshot` is null
   - `acknowledging event with property mutation updates theatre state` -- animate with game.score change, acknowledge, verify theatreState.attributes.score updated
   - `acknowledging event without mutations (emitAnimationEvent) is a no-op on theatre state` -- call emitAnimationEvent, then animate. Acknowledge emitAnimationEvent's ID. Theatre state should be unchanged (only animate-produced mutations affect it). Then acknowledge the animate event to verify the full flow works.

3. **Multiple animate calls (roadmap success criteria #4)** (2-3 tests)
   - `multiple animate calls reuse the same snapshot` -- call animate twice, verify `_theatreSnapshot` was taken before the first callback
   - `stepping through events one by one reaches truth` -- three animate calls with different mutations, acknowledge each in order, verify theatreState matches truth after all acknowledged
   - `theatre snapshot not re-initialized between animate calls` -- animate, check snapshot, animate again, verify snapshot hasn't changed (still pre-first-animate baseline)

4. **Serialization round-trip (ENG-06)** (2-3 tests)
   - `toJSON includes theatreSnapshot when pending events exist` -- animate, check toJSON() output has theatreSnapshot key
   - `toJSON omits theatreSnapshot when no pending events` -- verify toJSON() does NOT have theatreSnapshot key
   - `restoreGame preserves theatre snapshot and pending events` -- animate (creating pending events + theatre snapshot), serialize via toJSON(), restore via Game.restoreGame(), verify restored game has same theatreState, same pendingAnimationEvents, and acknowledging events on the restored game advances the theatre state correctly

5. **Edge cases** (2 tests)
   - `theatreState getter returns toJSON when all events acknowledged` -- animate, acknowledge all, verify theatreState equals toJSON() (fresh snapshot, not stale)
   - `animate after full acknowledgment creates new snapshot` -- animate, acknowledge all, animate again, verify new snapshot is taken from current truth (not the old baseline)

Use real Game.animate() calls with actual mutations (piece.putInto, game.score changes, piece.remove). Verify theatre state by checking specific properties: check children arrays for element presence/absence, check attributes for property values.

Access `_theatreSnapshot` directly on the game instance for assertions about internal state. Use `game.theatreState` for the public API assertions.

For deep equality checks on snapshots, compare specific fields rather than full JSON.stringify (the timestamp on animation events makes exact match brittle). Use patterns like:
- `expect(theatreState.children![0].children!.length).toBe(expectedCount)`
- `expect(theatreState.attributes.score).toBe(expectedValue)`
- `expect(findElementById(theatreState, pieceId)).toBeDefined()` / `toBeUndefined()`
  </action>
  <verify>
    `npx vitest run src/engine/element/theatre-state.test.ts` passes all tests (both Plan 01 unit tests and Plan 02 integration tests).
    `npx vitest run` passes all tests across the full suite with zero regressions.
  </verify>
  <done>
    Theatre state engine has comprehensive integration tests covering all 4 roadmap success criteria: (1) theatre state doesn't reflect unacknowledged mutations, (2) per-event acknowledgment advances theatre state, (3) serialization round-trip preserves theatre state, (4) multiple animate calls produce steppable event sequence. Zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. `npx vitest run src/engine/element/theatre-state.test.ts` -- all tests pass (unit + integration)
3. `npx vitest run` -- zero regressions across full test suite
4. Manual check: `game.theatreState` returns pre-mutation snapshot after animate(), returns truth after all events acknowledged
</verification>

<success_criteria>
- ENG-04: After game.animate(), theatreState does NOT reflect the callback's mutations
- ENG-05: acknowledgeAnimationEvents(id) applies exactly that event's mutations to theatre state
- ENG-06: toJSON() includes theatreSnapshot, restoreGame() restores it, round-trip preserves theatre state and pending events
- Roadmap criteria #4: Multiple animate calls produce a theatre state steppable event-by-event
- Theatre snapshot is null when no pending events (zero overhead for games without animate)
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/81-theatre-state-engine/81-02-SUMMARY.md`
</output>
