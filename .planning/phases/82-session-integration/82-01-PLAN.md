---
phase: 82-session-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/element/game.ts
  - src/engine/element/theatre-state.test.ts
autonomous: true

must_haves:
  truths:
    - "theatreStateForPlayer(playerSeat) returns visibility-filtered theatre snapshot when animations are pending"
    - "theatreStateForPlayer(playerSeat) falls through to toJSONForPlayer() when no theatre snapshot exists"
    - "Hidden elements in theatre snapshot get __hidden placeholder, not their real attributes"
    - "Count-only zones in theatre snapshot show childCount and system attrs, not child details"
    - "Owner-only zones in theatre snapshot hide children from non-owners"
    - "Static playerView transformation is applied to filtered theatre JSON"
  artifacts:
    - path: "src/engine/element/game.ts"
      provides: "theatreStateForPlayer() method"
      contains: "theatreStateForPlayer"
    - path: "src/engine/element/theatre-state.test.ts"
      provides: "Unit tests for theatre state visibility filtering"
      contains: "theatreStateForPlayer"
  key_links:
    - from: "src/engine/element/game.ts (theatreStateForPlayer)"
      to: "game.atId()"
      via: "ID-based lookup for live element visibility rules"
      pattern: "this\\.atId\\(json\\.id\\)|this\\.getElementById\\(json\\.id\\)"
    - from: "src/engine/element/game.ts (theatreStateForPlayer)"
      to: "game.theatreState"
      via: "uses theatreState getter for snapshot source"
      pattern: "this\\.theatreState|this\\._theatreSnapshot"
---

<objective>
Add `theatreStateForPlayer(player)` method to the Game class that returns the theatre snapshot filtered for a specific player's visibility.

Purpose: This is the core engine method that Phase 82's session integration depends on. The existing `toJSONForPlayer()` uses parallel tree traversal (walking `json.children[i]` alongside `element._t.children[i]`), which breaks for theatre snapshots because elements may be in different positions than truth. The new method uses element ID-based lookup (`game.atId(json.id)`) to find live elements and apply their visibility rules to the theatre JSON tree.

Output: `Game.theatreStateForPlayer()` method with unit tests covering all visibility modes (hidden, count-only, owner-only, visible) and the fallthrough-to-toJSONForPlayer behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/82-session-integration/82-RESEARCH.md
@src/engine/element/game.ts
@src/engine/element/game-element.ts
@src/engine/element/space.ts
@src/engine/element/types.ts
@src/engine/element/theatre-state.ts
@src/engine/element/theatre-state.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add theatreStateForPlayer() method to Game class</name>
  <files>src/engine/element/game.ts</files>
  <action>
Add a public method `theatreStateForPlayer(player: P | number | null): ElementJSON` to the Game class, placed right after the existing `theatreState` getter (around line 2619).

**Fallthrough behavior:** When `this._theatreSnapshot` is null (no pending animate() events), delegate directly to `this.toJSONForPlayer(player)`. This ensures zero overhead for non-animated games and identical output when theatre/truth are in sync.

**ID-based visibility filtering:** When `_theatreSnapshot` exists, apply visibility filtering to the theatre snapshot using element ID lookups rather than parallel tree traversal. The approach:

1. Resolve `playerSeat` from the `player` parameter (same logic as `toJSONForPlayer` line 2703).
2. Compute `visibilityPosition = playerSeat ?? -1` (spectators use -1).
3. Deep clone the theatre snapshot via `structuredClone(this._theatreSnapshot)` to avoid mutating the shared snapshot.
4. Define a recursive `filterNode(json: ElementJSON): ElementJSON` function that:
   a. Looks up the live element via `this.getElementById(json.id)` (checks main tree AND pile -- important for elements removed in truth but still in theatre).
   b. If no live element found (element created during animate but then destroyed), return json as-is (we can't determine visibility without a live object; this is a rare edge case).
   c. Check `liveElement.getEffectiveVisibility()`:
      - If mode is `'count-only'` AND `!liveElement.isVisibleTo(visibilityPosition)`: Return count-only placeholder with `className`, `id`, `name`, system attrs (keys starting with `$`), and `childCount: json.children?.length ?? 0`. Match the pattern in `toJSONForPlayer` lines 2710-2726, BUT use `json.children?.length` for childCount (not `element._t.children.length`, since theatre children count may differ from truth).
      - If `!liveElement.isVisibleTo(visibilityPosition)`: Return hidden placeholder `{ className, id, attributes: { __hidden: true } }`. Matches `toJSONForPlayer` lines 2728-2736.
   d. Check zone visibility via `(liveElement as any).getZoneVisibility?.()`:
      - If mode is `'hidden'` or `'count-only'`: Create anonymized child placeholders. For each child in `json.children`, create `{ className, id: -(liveElement._t.id * 1000 + i), attributes: { __hidden: true, ...systemAttrs } }`. Use negative IDs based on the LIVE element's ID (via `this.getElementById(json.id)?._t.id ?? json.id`) to prevent correlation. Include `childCount: json.children?.length ?? 0`. Match `toJSONForPlayer` lines 2742-2771.
      - If mode is `'owner'` AND `liveElement.player?.seat !== visibilityPosition`: Create hidden child placeholders preserving className, id, and system attrs. Match `toJSONForPlayer` lines 2772-2795.
   e. Otherwise, recursively filter children: `json.children?.map(c => filterNode(c))`. Remove undefined results (filterNode always returns ElementJSON, so no filtering needed, but be safe).
   f. Return `{ ...json, children: filteredChildren.length > 0 ? filteredChildren : undefined }`.
5. Run `filterNode` on the cloned theatre snapshot root.
6. Apply static `playerView` transformation if defined: `const GameClass = this.constructor as typeof Game; if (GameClass.playerView) { filtered = GameClass.playerView(filtered, playerSeat, this); }`. Same as `toJSONForPlayer` lines 2820-2824.
7. Return the filtered result.

**Important details:**
- Use `this.getElementById(json.id)` (not `this.atId(json.id)`) because `getElementById` checks both the main tree and the pile. This handles elements that were removed in truth (moved to pile) but still exist in the theatre snapshot.
- For zone visibility negative IDs, use the live element's `_t.id` to generate the negative ID pattern (same as `toJSONForPlayer`). Access via `this.getElementById(json.id)?._t?.id ?? json.id` since we need the live element's internal ID.
- The `childCount` for count-only should use `json.children?.length ?? 0` (theatre children count), not `element._t.children.length` (truth children count), because the theatre snapshot may have different element positions.
  </action>
  <verify>
Run `npx vitest run src/engine/element/theatre-state.test.ts` -- existing tests still pass (no regression in theatre state engine).
Run `npx tsc --noEmit` -- no type errors.
  </verify>
  <done>
`Game.theatreStateForPlayer()` exists, falls through to `toJSONForPlayer()` when no theatre snapshot, and applies ID-based visibility filtering to theatre snapshot when one exists. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for theatreStateForPlayer()</name>
  <files>src/engine/element/theatre-state.test.ts</files>
  <action>
Add a new `describe('theatreStateForPlayer()')` block to the existing theatre-state.test.ts file. Use the existing test game classes in that file (or create minimal ones if needed) that exercise visibility.

Create a test game class (e.g., `VisibilityTestGame`) that:
- Has 2 players
- Has a Space "board" (visible to all)
- Has a Space "hand1" with `contentsHiddenFrom('all')` or `setZoneVisibility('hidden')` -- elements here hidden from non-owners
- Has a Space "hand2" similar
- Has a Space "countOnly" with `setZoneVisibility('count-only')`
- Creates some Piece elements in each space
- Has an `animate()` call that moves a piece from board to hand1

Tests to write:

1. **"falls through to toJSONForPlayer when no theatre snapshot"** -- Create game, don't call animate(). Call `theatreStateForPlayer(1)`. Verify result matches `toJSONForPlayer(1)` exactly (deep equal).

2. **"returns theatre snapshot with visibility filtering when animations pending"** -- Call animate() to move a piece. The piece should be in its OLD position in the theatre view. Call `theatreStateForPlayer(1)`. Verify the piece appears at its pre-animate position, NOT post-animate position.

3. **"hides elements from non-owners in theatre view"** -- Set up a Space with owner-only visibility (player 1 owns it). Place a piece there. Call animate() to trigger snapshot. Call `theatreStateForPlayer(2)` -- piece should be hidden (__hidden: true). Call `theatreStateForPlayer(1)` -- piece should be visible.

4. **"count-only zones show childCount in theatre view"** -- Set up a count-only Space. Place pieces there. Call animate(). Call `theatreStateForPlayer(1)`. Verify children have __hidden: true and parent has childCount matching theatre's children count.

5. **"applies static playerView transformation"** -- Create a game subclass with a static `playerView` function that adds a marker attribute. Call animate(). Call `theatreStateForPlayer(1)`. Verify the marker exists in the result.

6. **"does not mutate shared theatre snapshot"** -- Call animate(). Call `theatreStateForPlayer(1)` twice. Verify the underlying `_theatreSnapshot` was not modified (the method should clone before filtering).

7. **"handles elements in pile (removed in truth, present in theatre)"** -- Place a piece on board. Call animate() that removes the piece. In truth, piece is in pile. In theatre, piece is still on board. Call `theatreStateForPlayer(1)`. Verify piece appears in theatre view at its old position (since board is visible).

For the visibility test game, you'll need to use Space's `setZoneVisibility()` method and possibly `setVisibility()` on elements. Check how existing tests in the codebase set up visibility (look at `src/engine/element/game-element.test.ts` or similar for patterns).

Use `game.animate('test', {}, () => { ... })` to trigger mutations and create the theatre snapshot. Use `game.theatreStateForPlayer(playerSeat)` to test.
  </action>
  <verify>
Run `npx vitest run src/engine/element/theatre-state.test.ts` -- all new tests pass alongside existing ones.
  </verify>
  <done>
7+ tests covering all visibility modes (hidden, count-only, owner-only), fallthrough behavior, playerView transformation, no-mutation-of-shared-snapshot, and pile edge case. All pass.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/engine/element/theatre-state.test.ts` -- all tests pass (existing + new)
- `npx tsc --noEmit` -- clean compile
- `game.theatreStateForPlayer(seat)` returns filtered theatre snapshot when `_theatreSnapshot` exists
- `game.theatreStateForPlayer(seat)` returns `toJSONForPlayer(seat)` when no theatre snapshot
</verification>

<success_criteria>
- theatreStateForPlayer() method exists on Game class
- Falls through to toJSONForPlayer() when no animations pending (zero overhead)
- ID-based visibility filtering works for all modes: hidden, count-only, owner-only
- Static playerView transformation applied to theatre filtered output
- Theatre snapshot not mutated by filtering calls
- Elements removed in truth but present in theatre are handled correctly
- 7+ unit tests covering all visibility modes and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/82-session-integration/82-01-SUMMARY.md`
</output>
