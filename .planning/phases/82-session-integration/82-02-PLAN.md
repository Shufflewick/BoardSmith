---
phase: 82-session-integration
plan: 02
type: execute
wave: 2
depends_on: ["82-01"]
files_modified:
  - src/session/types.ts
  - src/session/utils.ts
  - src/server/core.ts
  - src/session/animation-events.test.ts
autonomous: true

must_haves:
  truths:
    - "buildPlayerState().view is the theatre state (not truth) when animations are pending"
    - "buildPlayerState().currentView is present (truth) only when theatre state diverges from truth"
    - "buildPlayerState().currentView is undefined when no animations are pending (bandwidth optimization)"
    - "acknowledgeAnimations() advances theatre state and rebroadcast sends updated theatre view"
    - "WebSocket clients can send acknowledgeAnimations messages to advance theatre state"
    - "All connected clients receive the same theatre view per player seat (no spoilers)"
  artifacts:
    - path: "src/session/types.ts"
      provides: "PlayerGameState with currentView field"
      contains: "currentView"
    - path: "src/session/utils.ts"
      provides: "buildPlayerState() using theatreStateForPlayer for view"
      contains: "theatreStateForPlayer"
    - path: "src/server/core.ts"
      provides: "WebSocket handler for acknowledgeAnimations message"
      contains: "acknowledgeAnimations"
    - path: "src/session/animation-events.test.ts"
      provides: "Integration tests for theatre view in session layer"
      contains: "theatreStateForPlayer\\|theatre view\\|currentView"
  key_links:
    - from: "src/session/utils.ts (buildPlayerState)"
      to: "game.theatreStateForPlayer()"
      via: "calls for primary view field"
      pattern: "theatreStateForPlayer"
    - from: "src/session/utils.ts (buildPlayerState)"
      to: "runner.getPlayerView()"
      via: "calls for currentView when theatre diverges"
      pattern: "getPlayerView.*currentView|currentView.*getPlayerView"
    - from: "src/server/core.ts (handleWebSocketMessage)"
      to: "gameSession.acknowledgeAnimations()"
      via: "new case in switch statement"
      pattern: "case 'acknowledgeAnimations'"
---

<objective>
Wire theatre state into the session layer so that `buildPlayerState()` sends theatre view as the primary `view` field, with current (truth) view as an opt-in `currentView` field, and add WebSocket support for animation acknowledgment.

Purpose: This completes the session integration by connecting the engine's `theatreStateForPlayer()` (Plan 01) to the session's broadcast mechanism. After this plan, all clients receive the theatre view by default -- no client sees "the future" while animations are playing. The WebSocket message type enables multiplayer clients to acknowledge animations and advance the shared theatre state.

Output: Modified `buildPlayerState()`, `PlayerGameState.currentView` type, WebSocket handler, and integration tests proving the full session flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/82-session-integration/82-RESEARCH.md
@.planning/phases/82-session-integration/82-01-SUMMARY.md
@src/session/types.ts
@src/session/utils.ts
@src/session/game-session.ts
@src/server/core.ts
@src/session/animation-events.test.ts
@src/runtime/runner.ts
@src/engine/utils/snapshot.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add currentView to PlayerGameState and wire buildPlayerState()</name>
  <files>src/session/types.ts, src/session/utils.ts</files>
  <action>
**In `src/session/types.ts`:**

Add `currentView` field to the `PlayerGameState` interface, after the existing `view` field (around line 414):

```typescript
view: unknown;
/** Current (truth) game state. Only present when theatre state diverges from truth
 *  (i.e., animations are pending). Components that need truth (AI decisions, post-game
 *  summary) should read this field. When undefined, view IS the truth. */
currentView?: unknown;
```

Also add `'acknowledgeAnimations'` to the `WebSocketMessage.type` union (line 530). Add it to the existing union string literal type. Then add `upToId?: number;` as a new field on `WebSocketMessage` (for the acknowledgeAnimations payload).

**In `src/session/utils.ts`:**

Modify the `buildPlayerState()` function (starting around line 346):

1. Replace the current view computation:
   ```typescript
   // OLD (line 353):
   const view = runner.getPlayerView(playerPosition);
   ```
   With:
   ```typescript
   // Theatre view as primary (narrative state reflecting only acknowledged events)
   const theatreView = runner.game.theatreStateForPlayer(playerPosition);
   ```

2. Compute currentView only when theatre state diverges from truth. Use `runner.game.pendingAnimationEvents.length > 0` as the divergence check (when events are pending, theatre snapshot exists):
   ```typescript
   // Current view (truth) only when animations are pending (bandwidth optimization)
   const hasPendingAnimations = runner.game.pendingAnimationEvents.length > 0;
   const currentView = hasPendingAnimations
     ? runner.getPlayerView(playerPosition).state
     : undefined;
   ```

3. Update the state object construction (around line 408-418):
   ```typescript
   const state: PlayerGameState = {
     phase: runner.game.phase,
     players: fullPlayerData,
     currentPlayer: flowState?.currentPlayer,
     availableActions,
     isMyTurn,
     view: theatreView,           // Theatre state (default for rendering)
     ...(currentView !== undefined && { currentView }),  // Truth (opt-in, only when divergent)
     canUndo,
     actionsThisTurn: isMyTurn ? actionsThisTurn : 0,
     turnStartActionIndex: isMyTurn ? turnStartActionIndex : undefined,
   };
   ```

Note: The `view` field was previously `view.state` (result of `runner.getPlayerView().state` which returns `ElementJSON`). The new `theatreView` is directly `ElementJSON` from `game.theatreStateForPlayer()`, so NO `.state` access is needed.

**Do NOT change** the animation events block at the end (lines 443-448) -- `pendingAnimationEvents` continues to be attached as before.
  </action>
  <verify>
Run `npx tsc --noEmit` -- clean compile, no type errors.
Run `npx vitest run src/session/animation-events.test.ts` -- existing tests still pass.
  </verify>
  <done>
`PlayerGameState.currentView` exists as optional field. `buildPlayerState()` uses `theatreStateForPlayer()` for `view` field and includes `currentView` only when animations are pending. TypeScript compiles cleanly. Existing animation event tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket acknowledgeAnimations handler</name>
  <files>src/server/core.ts</files>
  <action>
Add a new `case 'acknowledgeAnimations'` to the `handleWebSocketMessage()` switch statement in `src/server/core.ts` (before the closing `}` of the switch, around line 769).

The handler should:

1. Check if session is spectator -- spectators should not be able to acknowledge animations (they're observers):
   ```typescript
   case 'acknowledgeAnimations':
     if (session.isSpectator) {
       session.ws.send({ type: 'error', error: 'Spectators cannot acknowledge animations' });
       return;
     }

     if (!gameSession) {
       session.ws.send({ type: 'error', error: 'Game not found' });
       return;
     }

     if (message.upToId === undefined) {
       session.ws.send({ type: 'error', error: 'upToId is required for acknowledgeAnimations' });
       return;
     }

     gameSession.acknowledgeAnimations(session.playerSeat, message.upToId);
     // Success: broadcast happens automatically in GameSession.acknowledgeAnimations()
     break;
   ```

This follows the exact same pattern as other message handlers in the switch. The `acknowledgeAnimations()` method on GameSession already calls `this.broadcast()` (line 831), so all clients receive the updated state automatically.
  </action>
  <verify>
Run `npx tsc --noEmit` -- clean compile.
Verify the new case exists: grep for `case 'acknowledgeAnimations'` in `src/server/core.ts`.
  </verify>
  <done>
WebSocket clients can send `{ type: 'acknowledgeAnimations', upToId: number }` messages. Server validates spectator check and required fields, then delegates to `gameSession.acknowledgeAnimations()` which advances theatre state and rebroadcasts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write session integration tests for theatre view</name>
  <files>src/session/animation-events.test.ts</files>
  <action>
Extend the existing `src/session/animation-events.test.ts` with a new `describe('Theatre view in PlayerGameState')` block. The existing test file already has a `TestGame` class and session setup.

However, the existing `TestGame` uses `emitAnimationEvent()` (old API) rather than `game.animate()` (new API). For theatre view tests, we need `game.animate()` because that's what triggers theatre snapshot creation.

Create a new test game class `TheatreTestGame` in the test file that uses `game.animate()`:

```typescript
class TheatreTestGame extends Game {
  constructor(options: GameOptions) {
    super(options);

    // Create a simple element tree
    const board = this.create(Space, 'board');
    board.create(Piece, 'token');

    this.registerAction(
      Action.create('animateMove')
        .execute(({ game }) => {
          const token = game.first(Piece, 'token')!;
          game.animate('move', { piece: 'token' }, () => {
            token.putInto(game);  // Move to root (changes position in tree)
          });
          return { success: true };
        })
    );

    this.registerAction(
      Action.create('pass')
        .execute(() => ({ success: true }))
    );

    this.setFlow(defineFlow({
      root: actionStep({ actions: ['animateMove', 'pass'], maxMoves: 10 }),
    }));
  }
}
```

You'll need to import `Space` and `Piece` (or whatever element classes are available). Check imports at the top of the file -- add `Space, Piece` (or `GameElement`) to the engine import. If `Piece` doesn't exist as a named export, create a simple class `class TestPiece extends GameElement {}` in the test file and register it.

**Tests to write:**

1. **"view field contains theatre state (pre-animation) when animations pending"**
   - Create session with TheatreTestGame
   - Perform 'animateMove' action
   - Call `session.buildPlayerState(1)`
   - Verify `state.view` shows the token in its OLD position (inside 'board'), not its new position (game root)
   - The token should be findable as a child of the 'board' space in the `view` JSON tree

2. **"currentView is present when animations are pending"**
   - Perform 'animateMove' action
   - Call `session.buildPlayerState(1)`
   - Verify `state.currentView` is defined (truthy)
   - Verify `state.currentView` shows the token in its NEW position (truth)

3. **"currentView is undefined when no animations pending"**
   - Call `session.buildPlayerState(1)` before any animate actions
   - Verify `state.currentView` is undefined

4. **"view updates after acknowledgeAnimations"**
   - Perform 'animateMove' action
   - Get `state.lastAnimationEventId`
   - Call `session.acknowledgeAnimations(1, lastAnimationEventId)`
   - Call `session.buildPlayerState(1)` again
   - Verify `state.view` now shows the token in its NEW position (theatre caught up to truth)
   - Verify `state.currentView` is undefined (no longer divergent)

5. **"all players see the same theatre view for shared elements"**
   - Perform 'animateMove' action
   - Call `session.buildPlayerState(1)` and `session.buildPlayerState(2)`
   - Verify both players' `state.view` show the token in the OLD position (same theatre state)
   - Neither player sees "spoilers" (the new position)

6. **"restored session preserves theatre view"**
   - Perform 'animateMove' action
   - Store and restore session
   - Call `restoredSession.buildPlayerState(1)`
   - Verify `state.view` still shows pre-animation state
   - Verify `state.currentView` is present (truth)

For navigating the ElementJSON tree in assertions, use a helper like:
```typescript
function findInView(view: any, name: string): any {
  if (view.name === name) return view;
  for (const child of view.children ?? []) {
    const found = findInView(child, name);
    if (found) return found;
  }
  return null;
}
```

To check element position, find the parent that contains the element by name. E.g., in the 'board' space's children, the token should be present (theatre) or absent (truth).
  </action>
  <verify>
Run `npx vitest run src/session/animation-events.test.ts` -- all tests pass (existing + new theatre view tests).
  </verify>
  <done>
6+ integration tests proving: view is theatre state when pending, currentView is truth when divergent, currentView undefined when in sync, acknowledgeAnimations advances view, all players see same theatre view, and session restore preserves theatre state.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/session/animation-events.test.ts` -- all tests pass
- `npx tsc --noEmit` -- clean compile
- `npx vitest run` -- full test suite passes (no regressions)
- `buildPlayerState().view` is theatre state when animations pending
- `buildPlayerState().currentView` is truth only when divergent
- WebSocket `acknowledgeAnimations` message type accepted and handled
</verification>

<success_criteria>
- PlayerGameState.currentView field exists as optional type
- buildPlayerState() uses theatreStateForPlayer() for the view field
- currentView included only when theatre diverges from truth (bandwidth optimization)
- WebSocket message type union includes 'acknowledgeAnimations'
- Server handles acknowledgeAnimations messages with validation
- 6+ integration tests covering theatre view in session, acknowledgment advancement, multiplayer fairness, session restore
- Full test suite passes (no regressions in existing tests)
</success_criteria>

<output>
After completion, create `.planning/phases/82-session-integration/82-02-SUMMARY.md`
</output>
