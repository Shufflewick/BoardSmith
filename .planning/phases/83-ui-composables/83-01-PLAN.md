---
phase: 83-ui-composables
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/client/types.ts
  - src/client/game-connection.ts
  - src/client/vue.ts
  - src/ui/composables/useAnimationEvents.ts
  - src/ui/composables/useCurrentView.ts
  - src/ui/index.ts
autonomous: true

must_haves:
  truths:
    - "Client can send acknowledgeAnimations message over WebSocket"
    - "useGame() composable exposes acknowledgeAnimations method"
    - "useCurrentView() composable returns truth state from injection"
    - "Animation events acknowledge per-event (not batch) to advance theatre state incrementally"
  artifacts:
    - path: "src/client/types.ts"
      provides: "WebSocketOutgoingMessage with acknowledgeAnimations type and upToId field"
      contains: "acknowledgeAnimations"
    - path: "src/client/game-connection.ts"
      provides: "acknowledgeAnimations(upToId) method on GameConnection class"
      contains: "acknowledgeAnimations"
    - path: "src/client/vue.ts"
      provides: "acknowledgeAnimations in UseGameReturn interface and useGame function"
      contains: "acknowledgeAnimations"
    - path: "src/ui/composables/useCurrentView.ts"
      provides: "useCurrentView() composable with provide/inject for truth opt-in"
      exports: ["useCurrentView", "CURRENT_VIEW_KEY"]
    - path: "src/ui/composables/useAnimationEvents.ts"
      provides: "Per-event acknowledge in processQueue"
      contains: "acknowledge(event.id)"
    - path: "src/ui/index.ts"
      provides: "Public export of useCurrentView"
      contains: "useCurrentView"
  key_links:
    - from: "src/client/game-connection.ts"
      to: "src/client/types.ts"
      via: "WebSocketOutgoingMessage type used in acknowledgeAnimations method"
      pattern: "type: 'acknowledgeAnimations'"
    - from: "src/client/vue.ts"
      to: "src/client/game-connection.ts"
      via: "useGame delegates to connection.acknowledgeAnimations"
      pattern: "connection\\?.acknowledgeAnimations"
---

<objective>
Add client-side WebSocket transport for acknowledgeAnimations, create the useCurrentView composable for truth opt-in, and change animation event processing to per-event acknowledgment.

Purpose: These are the foundational pieces that Plan 02 (GameShell wiring) depends on. The client SDK needs the transport method before GameShell can wire createAnimationEvents. The useCurrentView composable must exist before GameShell can provide it. The per-event acknowledge change ensures theatre state advances incrementally as each animation plays (matching the prior "per-event advancement" decision).

Output: Client SDK with acknowledgeAnimations transport, useCurrentView composable, per-event acknowledge in processQueue.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/83-ui-composables/83-RESEARCH.md
@src/client/types.ts
@src/client/game-connection.ts
@src/client/vue.ts
@src/ui/composables/useAnimationEvents.ts
@src/ui/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add acknowledgeAnimations to client SDK</name>
  <files>
    src/client/types.ts
    src/client/game-connection.ts
    src/client/vue.ts
  </files>
  <action>
Three changes, bottom-up:

**1. src/client/types.ts** -- Update `WebSocketOutgoingMessage` interface (around line 210):
- Add `'acknowledgeAnimations'` to the `type` union: `type: 'action' | 'ping' | 'getState' | 'acknowledgeAnimations';`
- Add optional `upToId` field: `/** For acknowledgeAnimations: acknowledge events up to this ID */ upToId?: number;`

**2. src/client/game-connection.ts** -- Add `acknowledgeAnimations` method to `GameConnection` class. Place it after `requestState()` (around line 161), in the "State & Actions" section:
```typescript
acknowledgeAnimations(upToId: number): void {
  if (this.ws && this.ws.readyState === WebSocket.OPEN) {
    const message: WebSocketOutgoingMessage = {
      type: 'acknowledgeAnimations',
      upToId,
    };
    this.ws.send(JSON.stringify(message));
  }
}
```
This follows the same pattern as `requestState()` -- fire-and-forget WebSocket send with connection state guard.

**3. src/client/vue.ts** -- Expose `acknowledgeAnimations` through `useGame()`:
- Add to `UseGameReturn` interface (around line 34): `/** Acknowledge animation events up to the given ID */ acknowledgeAnimations: (upToId: number) => void;`
- Add implementation inside `useGame()` function (before the return statement, around line 210):
```typescript
const acknowledgeAnimations = (upToId: number): void => {
  connection?.acknowledgeAnimations(upToId);
};
```
- Add `acknowledgeAnimations` to the return object (around line 222).
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- no type errors. Verify the new method exists by grepping: `grep -n 'acknowledgeAnimations' src/client/types.ts src/client/game-connection.ts src/client/vue.ts` should show hits in all three files.
  </verify>
  <done>
WebSocketOutgoingMessage includes acknowledgeAnimations type with upToId field. GameConnection has acknowledgeAnimations method that sends JSON over WebSocket. useGame() returns acknowledgeAnimations function that delegates to connection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useCurrentView composable and update per-event acknowledge</name>
  <files>
    src/ui/composables/useCurrentView.ts
    src/ui/composables/useAnimationEvents.ts
    src/ui/index.ts
  </files>
  <action>
Two independent changes:

**1. Create src/ui/composables/useCurrentView.ts** -- New composable for truth opt-in:
```typescript
import { inject, type ComputedRef } from 'vue';

/**
 * Injection key for current (truth) game view.
 * Only use when you need the latest truth -- most components should use
 * inject('gameView') which provides the theatre state.
 */
export const CURRENT_VIEW_KEY = 'currentGameView';

/**
 * Get the current (truth) game view.
 *
 * Use this ONLY when you need the latest truth, such as:
 * - AI controller decisions
 * - Post-game summary
 * - Score calculations that must reflect latest state
 *
 * For rendering game elements, use inject('gameView') instead (theatre state).
 *
 * @throws Error if called outside GameShell context
 */
export function useCurrentView(): ComputedRef<Record<string, unknown> | null> {
  const view = inject<ComputedRef<Record<string, unknown> | null>>(CURRENT_VIEW_KEY);
  if (!view) {
    throw new Error(
      'useCurrentView() must be called inside a GameShell context. ' +
      'For rendering game elements, use inject(\'gameView\') instead -- ' +
      'it provides the theatre state which is correct for most UI components.'
    );
  }
  return view;
}
```
Use `Record<string, unknown>` for the view type (same loosely-typed approach as `gameView` which casts to `any`). The injection key is a string (not Symbol) so it matches the provide call in GameShell.

**2. Update src/ui/composables/useAnimationEvents.ts processQueue** -- Change from batch acknowledge to per-event acknowledge. In the `processQueue` function (around line 136), change the while loop to acknowledge after EACH event instead of once at the end:

Replace the current while loop body + post-loop acknowledge (lines 153-192) with:
```typescript
while (queue.length > 0 && !skipRequested) {
  // If paused, wait for resume
  if (paused.value) {
    await waitForUnpause();
    // Check skip again after resuming
    if (skipRequested) {
      break;
    }
  }

  const event = queue.shift()!;
  pendingCount.value = queue.length;

  const handler = handlers.get(event.type);

  if (handler) {
    try {
      await handler(event);
    } catch (error) {
      // Log error but continue processing - don't let one handler break the chain
      console.error(`Animation handler error for event type '${event.type}':`, error);
    }
  } else if (defaultDuration > 0) {
    // No handler, but default duration configured - wait
    await new Promise<void>((resolve) => setTimeout(resolve, defaultDuration));
  }
  // No handler and no default duration - skip immediately

  // Acknowledge THIS event immediately (per-event advancement)
  // This tells the server to advance the theatre snapshot by one step
  acknowledge(event.id);
  lastProcessedId = event.id;
}
```
Remove the post-loop acknowledge block entirely (the old lines 185-192). The per-event acknowledge inside the loop replaces it.

**3. Export from src/ui/index.ts** -- Add export for the new composable. Find the composable exports section and add:
```typescript
export { useCurrentView, CURRENT_VIEW_KEY } from './composables/useCurrentView.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run src/ui/composables/useAnimationEvents.test.ts` -- existing tests still pass with per-event acknowledge change. Verify useCurrentView export: `grep -n 'useCurrentView' src/ui/index.ts` shows the export.
  </verify>
  <done>
useCurrentView composable exists at src/ui/composables/useCurrentView.ts with actionable error message when used outside GameShell. processQueue acknowledges after each event (not batch). useCurrentView and CURRENT_VIEW_KEY exported from src/ui/index.ts.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run src/ui/composables/useAnimationEvents.test.ts` passes (existing tests validate the acknowledge callback is called correctly)
3. All three client files have `acknowledgeAnimations` (types, connection, vue composable)
4. `useCurrentView.ts` exists and is exported from `src/ui/index.ts`
5. `processQueue` in useAnimationEvents.ts calls `acknowledge(event.id)` inside the while loop (per-event, not batch)
</verification>

<success_criteria>
- Client SDK can send `acknowledgeAnimations` messages with `upToId` over WebSocket
- `useGame()` exposes `acknowledgeAnimations` for GameShell to use (Plan 02)
- `useCurrentView()` composable ready for GameShell to provide and components to consume
- Animation event processing acknowledges per-event for incremental theatre advancement
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/83-ui-composables/83-01-SUMMARY.md`
</output>
