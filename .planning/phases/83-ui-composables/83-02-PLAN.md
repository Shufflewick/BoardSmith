---
phase: 83-ui-composables
plan: 02
type: execute
wave: 2
depends_on: ["83-01"]
files_modified:
  - src/ui/components/GameShell.vue
  - src/ui/composables/useCurrentView.test.ts
  - src/ui/composables/useAnimationEvents.test.ts
autonomous: true

must_haves:
  truths:
    - "GameShell creates animation events and provides them to descendant components"
    - "ActionPanel gates on animation playback (shows 'Playing animations...' during animations, shows actions when complete)"
    - "Components injecting gameView see theatre state by default"
    - "Components calling useCurrentView() get truth state"
    - "Skip button acknowledges all pending events via WebSocket and shows current view immediately"
  artifacts:
    - path: "src/ui/components/GameShell.vue"
      provides: "createAnimationEvents wiring, currentGameView provide, animationEvents passed to useActionController"
      contains: "createAnimationEvents"
    - path: "src/ui/composables/useCurrentView.test.ts"
      provides: "Unit tests for useCurrentView composable"
      contains: "useCurrentView"
    - path: "src/ui/composables/useAnimationEvents.test.ts"
      provides: "Updated tests verifying per-event acknowledge behavior"
      contains: "acknowledge"
  key_links:
    - from: "src/ui/components/GameShell.vue"
      to: "src/ui/composables/useAnimationEvents.ts"
      via: "createAnimationEvents() called with acknowledge callback"
      pattern: "createAnimationEvents"
    - from: "src/ui/components/GameShell.vue"
      to: "src/client/vue.ts"
      via: "useGame() returns acknowledgeAnimations, used in createAnimationEvents callback"
      pattern: "acknowledgeAnimations"
    - from: "src/ui/components/GameShell.vue"
      to: "src/ui/composables/useCurrentView.ts"
      via: "provide(CURRENT_VIEW_KEY, currentGameView)"
      pattern: "CURRENT_VIEW_KEY"
    - from: "src/ui/components/GameShell.vue"
      to: "src/ui/composables/useActionController.ts"
      via: "animationEvents option passed to useActionController"
      pattern: "animationEvents"
---

<objective>
Wire createAnimationEvents into GameShell, provide currentGameView for truth opt-in, pass animationEvents to useActionController for gating, and write tests covering the new composable and per-event acknowledge behavior.

Purpose: This is the integration plan that connects all the foundational pieces from Plan 01 into the actual component tree. After this plan, the full pipeline works: server sends theatre view -> GameShell provides it -> animation events play -> acknowledge goes back to server per-event -> theatre advances -> ActionPanel gates correctly -> skip works end-to-end.

Output: GameShell wired for theatre view with animation event processing, tests proving correctness.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/83-ui-composables/83-RESEARCH.md
@.planning/phases/83-ui-composables/83-01-SUMMARY.md
@src/ui/components/GameShell.vue
@src/ui/composables/useAnimationEvents.ts
@src/ui/composables/useAnimationEvents.test.ts
@src/ui/composables/useActionControllerTypes.ts
@src/ui/composables/useCurrentView.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire GameShell for animation events and current view</name>
  <files>src/ui/components/GameShell.vue</files>
  <action>
Four changes to GameShell.vue's `<script setup>` block:

**1. Add imports** (near the top, around line 20-24, alongside existing composable imports):
```typescript
import { createAnimationEvents, provideAnimationEvents } from '../composables/useAnimationEvents';
import { CURRENT_VIEW_KEY } from '../composables/useCurrentView';
```

**2. Destructure acknowledgeAnimations from useGame()** -- Update the existing `useGame()` call (around line 159) to also destructure `acknowledgeAnimations`:
```typescript
const { state, connectionStatus, isConnected, isMyTurn, error, action, acknowledgeAnimations } = useGame(
  client,
  gameId,
  { playerSeat }
);
```

**3. Create and provide animation events** -- Add immediately after the `useGame()` call (before the `watch(state, ...)` on line 166):
```typescript
// Animation events - wire createAnimationEvents to WebSocket acknowledge
const animationEvents = createAnimationEvents({
  events: () => state.value?.state.animationEvents,
  acknowledge: (upToId) => acknowledgeAnimations(upToId),
});
provideAnimationEvents(animationEvents);
```
Note: `state.value?.state.animationEvents` accesses the animation events from PlayerGameState. The `animationEvents` field was added to the state shape in Phase 82 (it's part of `PlayerState` which has `animationEvents?: AnimationEvent[]`).

**4. Create and provide currentGameView** -- Add after the `gameView` computed (around line 202), before the `actionArgs` reactive:
```typescript
// Current (truth) game view for opt-in access (AI controller, post-game)
// When time traveling, both theatre and truth should show historical state
const currentGameView = computed(() => {
  if (timeTravelState.value) {
    return timeTravelState.value.view as any;
  }
  return (state.value?.state.currentView ?? state.value?.state.view) as any;
});
provide(CURRENT_VIEW_KEY, currentGameView);
```
This respects time travel (shows historical state when time traveling) and falls back to `view` when `currentView` is absent (meaning theatre equals truth, no animations pending).

**5. Pass animationEvents to useActionController** -- Update the `useActionController()` call (around line 209-270) to include `animationEvents`:
```typescript
const actionController = useActionController({
  sendAction: async (actionName, args) => {
    const result = await action(actionName, args);
    return result as ControllerActionResult;
  },
  availableActions,
  actionMetadata,
  isMyTurn,
  gameView,
  playerSeat,
  autoFill: autoEndTurn,
  autoExecute: true,
  externalArgs: actionArgs,
  animationEvents,  // <-- ADD THIS LINE
  fetchPickChoices: async (actionName, selectionName, player, currentArgs) => {
    // ... existing implementation unchanged ...
  },
  pickStep: async (player, selectionName, value, actionName, initialArgs) => {
    // ... existing implementation unchanged ...
  },
});
```
This single addition enables `animationsPending` and `showActionPanel` in the action controller, which ActionPanel already reads. No changes to ActionPanel needed.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Search for all the new additions: `grep -n 'createAnimationEvents\|provideAnimationEvents\|CURRENT_VIEW_KEY\|acknowledgeAnimations\|animationEvents,' src/ui/components/GameShell.vue` should show all five wiring points.
  </verify>
  <done>
GameShell creates animation events with WebSocket acknowledge callback, provides them to descendant components, provides currentGameView for truth opt-in, and passes animationEvents to useActionController for gating. ActionPanel automatically starts gating on animation playback. Skip button works because ActionPanel already calls animationEvents.skipAll() which triggers acknowledge.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for useCurrentView and update animation event tests</name>
  <files>
    src/ui/composables/useCurrentView.test.ts
    src/ui/composables/useAnimationEvents.test.ts
  </files>
  <action>
Two test files:

**1. Create src/ui/composables/useCurrentView.test.ts** -- Unit tests for the useCurrentView composable:

```typescript
import { describe, it, expect } from 'vitest';
import { computed, provide, inject } from 'vue';
import { mount } from '@vue/test-utils';
import { useCurrentView, CURRENT_VIEW_KEY } from './useCurrentView';
import { defineComponent, h } from 'vue';

describe('useCurrentView', () => {
  it('throws when called outside GameShell context', () => {
    // Create a component that calls useCurrentView without a provider
    const TestComponent = defineComponent({
      setup() {
        expect(() => useCurrentView()).toThrow('useCurrentView() must be called inside a GameShell context');
        return () => h('div');
      },
    });
    mount(TestComponent);
  });

  it('returns the provided current view', () => {
    const truthView = { id: 1, type: 'game', children: [] };
    let result: ReturnType<typeof useCurrentView> | undefined;

    const Provider = defineComponent({
      setup() {
        provide(CURRENT_VIEW_KEY, computed(() => truthView));
        return () => h(Child);
      },
    });

    const Child = defineComponent({
      setup() {
        result = useCurrentView();
        return () => h('div');
      },
    });

    mount(Provider);
    expect(result).toBeDefined();
    expect(result!.value).toEqual(truthView);
  });

  it('returns null when provided value is null', () => {
    let result: ReturnType<typeof useCurrentView> | undefined;

    const Provider = defineComponent({
      setup() {
        provide(CURRENT_VIEW_KEY, computed(() => null));
        return () => h(Child);
      },
    });

    const Child = defineComponent({
      setup() {
        result = useCurrentView();
        return () => h('div');
      },
    });

    mount(Provider);
    expect(result).toBeDefined();
    expect(result!.value).toBeNull();
  });

  it('error message suggests gameView as alternative', () => {
    const TestComponent = defineComponent({
      setup() {
        try {
          useCurrentView();
        } catch (e: any) {
          expect(e.message).toContain('gameView');
          expect(e.message).toContain('theatre state');
        }
        return () => h('div');
      },
    });
    mount(TestComponent);
  });
});
```

Check if `@vue/test-utils` is available (look at package.json devDependencies). If not available, use a simpler approach: create a test wrapper using Vue's `createApp` with a test component, or check how existing Vue composable tests work in the codebase (look at `useAnimationEvents.test.ts` for the testing pattern used).

**2. Update src/ui/composables/useAnimationEvents.test.ts** -- Add/update tests to verify per-event acknowledge behavior. Find the existing test for acknowledge (likely tests that batch acknowledge was called once at the end) and update expectations:

- Find any test that checks `acknowledge` is called once after all events. Update it to verify `acknowledge` is called once PER event (N events = N acknowledge calls).
- Add a new test: "calls acknowledge after each event (per-event advancement)" that creates 3 events, processes them, and verifies acknowledge was called 3 times with event IDs 1, 2, 3 respectively (not once with 3).
- Verify the existing skip test still works (skip acknowledges the last event ID in the queue, bypassing the per-event pattern).

Read the existing test file first to understand the testing patterns used, then make targeted additions/updates. Do NOT rewrite existing passing tests -- only add new ones and update assertions that changed due to per-event acknowledge.
  </action>
  <verify>
Run `npx vitest run src/ui/composables/useCurrentView.test.ts` -- all tests pass.
Run `npx vitest run src/ui/composables/useAnimationEvents.test.ts` -- all tests pass (including existing + new per-event tests).
Run `npx vitest run` -- full test suite passes, no regressions.
  </verify>
  <done>
useCurrentView has unit tests covering: throws outside context, returns provided truth view, returns null, error message is actionable. Animation event tests verify per-event acknowledge (N events = N calls with individual IDs). Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run src/ui/composables/useCurrentView.test.ts` passes
3. `npx vitest run src/ui/composables/useAnimationEvents.test.ts` passes
4. `npx vitest run` full suite passes -- no regressions
5. GameShell.vue has: createAnimationEvents, provideAnimationEvents, CURRENT_VIEW_KEY provide, acknowledgeAnimations destructured from useGame, animationEvents passed to useActionController
6. Trace the full pipeline: server sends state with animationEvents -> GameShell receives via useGame -> createAnimationEvents watches state.animationEvents -> handlers play each event -> acknowledge(event.id) sends WebSocket message per event -> server advances theatre -> new state broadcast -> gameView updates -> ActionPanel ungates when isAnimating becomes false
</verification>

<success_criteria>
- GameShell wires createAnimationEvents with WebSocket acknowledge callback (UI-01, UI-02)
- currentGameView provided for truth opt-in via useCurrentView (UI-03)
- animationEvents passed to useActionController enables ActionPanel gating (UI-04)
- Skip works end-to-end: skipAll() acknowledges all events, theatre advances to current (UI-05)
- All requirements UI-01 through UI-05 are satisfied
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/83-ui-composables/83-02-SUMMARY.md`
</output>
