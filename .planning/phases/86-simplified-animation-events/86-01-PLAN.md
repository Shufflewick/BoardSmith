---
phase: 86-simplified-animation-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/command/types.ts
  - src/engine/command/executor.ts
  - src/engine/command/inverse.ts
  - src/engine/element/game.ts
  - src/engine/element/animation-events.test.ts
autonomous: true

must_haves:
  truths:
    - "game.animate('combat', { attacker, defender, damage }) emits a pure data event with no mutation capture"
    - "game.animate('combat', data, () => { piece.remove() }) runs the callback as normal game code -- callback mutations are NOT captured as event metadata"
    - "Animation events appear as ANIMATE commands in game.commandHistory"
    - "ANIMATE commands survive JSON serialization round-trips via toJSON/restoreGame/replayCommands"
    - "The animation event buffer is cleared at the start of each performAction call -- previous batch is replaced, not accumulated"
    - "All existing 509+ tests continue to pass (no regressions)"
  artifacts:
    - path: "src/engine/command/types.ts"
      provides: "AnimateCommand interface added to GameCommand union"
      contains: "AnimateCommand"
    - path: "src/engine/command/executor.ts"
      provides: "executeAnimate handler in switch statement"
      contains: "executeAnimate"
    - path: "src/engine/command/inverse.ts"
      provides: "ANIMATE case returning null (not invertible)"
      contains: "'ANIMATE'"
    - path: "src/engine/element/game.ts"
      provides: "animate() public method, pushAnimationEvent() internal method, buffer clearing in performAction()"
      contains: "animate("
    - path: "src/engine/element/animation-events.test.ts"
      provides: "Tests for animate API, command stack, serialization, buffer lifecycle"
      min_lines: 100
  key_links:
    - from: "src/engine/element/game.ts"
      to: "src/engine/command/executor.ts"
      via: "game.execute({ type: 'ANIMATE', ... }) triggers executeAnimate"
      pattern: "type: 'ANIMATE'"
    - from: "src/engine/command/executor.ts"
      to: "src/engine/element/game.ts"
      via: "executeAnimate calls game.pushAnimationEvent()"
      pattern: "pushAnimationEvent"
    - from: "src/engine/element/game.ts"
      to: "src/engine/element/game.ts"
      via: "performAction clears _animationEvents before executing action"
      pattern: "_animationEvents = \\[\\]"
---

<objective>
Build the new `game.animate(type, data)` API with command stack integration.

Purpose: Game developers need a way to emit pure data animation events that land on the command stack, survive serialization, and have a clean buffer lifecycle -- replacing the old theatre/mutation-capture system removed in Phase 85.

Output: Working `animate()` method on Game, `AnimateCommand` in the command system, buffer clearing at action boundaries, and comprehensive tests proving all four ENG requirements are met.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/86-simplified-animation-events/86-RESEARCH.md

@src/engine/command/types.ts
@src/engine/command/executor.ts
@src/engine/command/inverse.ts
@src/engine/element/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AnimateCommand to the command system</name>
  <files>
    src/engine/command/types.ts
    src/engine/command/executor.ts
    src/engine/command/inverse.ts
  </files>
  <action>
    **types.ts:** Add `AnimateCommand` interface extending `BaseCommand`:
    ```typescript
    export interface AnimateCommand extends BaseCommand {
      type: 'ANIMATE';
      /** Animation event type (e.g., 'combat', 'score-item') */
      eventType: string;
      /** Event-specific data payload (must be JSON-serializable) */
      data: Record<string, unknown>;
    }
    ```
    Add `AnimateCommand` to the `GameCommand` union type (after `TrackRemoveLastCommand`).

    **executor.ts:**
    - Import `AnimateCommand` from `./types.js`
    - Add case `'ANIMATE': return executeAnimate(game, command);` in the `executeCommand` switch (before the default case)
    - Add `executeAnimate` function:
      ```typescript
      function executeAnimate(game: Game, command: AnimateCommand): CommandResult {
        game.pushAnimationEvent(command.eventType, command.data);
        return { success: true };
      }
      ```
    The handler is deliberately minimal -- it pushes to the animation event buffer via a public method on Game. No element lookups, no validation beyond what `pushAnimationEvent` does.

    **inverse.ts:**
    - Add case `'ANIMATE':` returning `null` in the `createInverseCommand` switch, with comment: `// Animation events are UI hints, not invertible`
    - Place it alongside the existing `MESSAGE` case (both are non-invertible data commands)
    - No need to import `AnimateCommand` since the case just returns null

    **Why ANIMATE is not invertible:** Animation events are UI hints that don't affect game state. Like MESSAGE commands, they cannot be meaningfully undone. MCTS handles non-invertible commands by falling back to full state restore, which is already the pattern for SHUFFLE, CREATE, CREATE_MANY, and MESSAGE.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no TypeScript errors. The exhaustive switch default cases in executor.ts and inverse.ts should not trigger warnings since ANIMATE is now handled.
  </verify>
  <done>
    AnimateCommand exists in the GameCommand union. executor.ts handles ANIMATE by calling game.pushAnimationEvent(). inverse.ts returns null for ANIMATE. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement game.animate(), pushAnimationEvent(), and buffer lifecycle</name>
  <files>
    src/engine/element/game.ts
  </files>
  <action>
    **Add `pushAnimationEvent()` method** (internal, called by executor):
    ```typescript
    /**
     * Push an animation event to the buffer.
     * @internal Called by command executor -- do not call directly from game code.
     */
    pushAnimationEvent(eventType: string, data: Record<string, unknown>): void {
      this._animationEventSeq++;
      this._animationEvents.push({
        id: this._animationEventSeq,
        type: eventType,
        data,
        timestamp: Date.now(),
      });
    }
    ```
    Place this near the existing `pendingAnimationEvents` getter and `acknowledgeAnimationEvents()` method (around line 2345-2371), in the same "Animation Events" section.

    **Add `animate()` public method:**
    ```typescript
    /**
     * Emit an animation event for UI playback.
     *
     * Animation events are pure data signals -- they do NOT capture mutations
     * or affect game state. The UI layer registers handlers to play them back.
     *
     * @param type - Event type identifier (e.g., 'combat', 'score-item')
     * @param data - Event-specific data payload (must be JSON-serializable)
     * @param callback - Optional callback to advance truth (convenience).
     *   Runs immediately as normal game code. Its mutations are NOT captured
     *   as event metadata -- they generate their own commands on the stack.
     *
     * @example
     * ```typescript
     * // Pure data event
     * game.animate('score', { player: player.name, points: 15 });
     *
     * // With truth-advancing callback
     * game.animate('combat', { attacker: a.id, defender: d.id, damage: 5 }, () => {
     *   defender.hp -= 5;
     *   if (defender.hp <= 0) defender.remove();
     * });
     * ```
     */
    animate(type: string, data: Record<string, unknown>, callback?: () => void): void {
      this.execute({ type: 'ANIMATE', eventType: type, data });
      if (callback) {
        callback();
      }
    }
    ```
    Place this in the same Animation Events section, before `pendingAnimationEvents`.

    **Modify `performAction()` to clear the buffer:**
    At the very top of `performAction()`, before the action lookup, add:
    ```typescript
    // Clear previous animation events -- new action starts a new batch
    this._animationEvents = [];
    ```
    This implements ENG-04: the buffer persists across flow steps (between actions), and is replaced when the next action starts.

    **Do NOT modify:**
    - `toJSON()` -- already serializes `_animationEvents` and `_animationEventSeq`
    - `restoreGame()` -- already restores animation events from JSON
    - `pendingAnimationEvents` getter -- already returns a copy of the buffer
    - `acknowledgeAnimationEvents()` -- still needed by session layer until Phase 87
    - `replayCommands()` -- ANIMATE commands will replay and push to buffer; `performAction()` clearing handles the lifecycle naturally
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no TypeScript errors. Run `npx vitest run` -- all existing tests pass (509+). The new methods exist and TypeScript recognizes them.
  </verify>
  <done>
    `game.animate(type, data, callback?)` creates an ANIMATE command, pushes it to the command stack, populates the animation event buffer, and optionally runs a callback. `performAction()` clears the buffer at the start of each action. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Comprehensive tests for animate API</name>
  <files>
    src/engine/element/animation-events.test.ts
  </files>
  <action>
    Create a new test file `src/engine/element/animation-events.test.ts` with thorough coverage of all four ENG requirements.

    **Test setup:** Use the existing test game patterns from the codebase. Look at `src/engine/element/game-element.test.ts` for how test games are set up (Game subclass, setup method, flow definition, actions). Create a minimal test game class with at least one action that calls `game.animate()`.

    **Test groups:**

    **1. ENG-01: Pure data events (`describe('animate - pure data events')`)**
    - `game.animate('combat', { attacker: 1, defender: 2, damage: 5 })` creates an event in `pendingAnimationEvents` with correct type, data, and auto-incrementing id
    - Multiple `animate()` calls produce multiple events with incrementing IDs
    - Event has `timestamp` property (number)
    - Event data is exactly what was passed (no extra mutation metadata, no `mutations` property)

    **2. ENG-02: Optional callback (`describe('animate - callback')`)**
    - `game.animate('combat', { damage: 5 }, () => { /* runs */ })` -- callback executes immediately
    - Callback mutations generate their own commands on the command stack (e.g., callback calls a method that emits a SET_ATTRIBUTE command -- verify that command appears in `commandHistory` AFTER the ANIMATE command)
    - Callback mutations are NOT present in the animation event's `data` field
    - If no callback provided, animate still works (callback is optional)
    - If callback throws, the error propagates (not swallowed) -- the ANIMATE command is still on the stack

    **3. ENG-03: Command stack integration (`describe('animate - command stack')`)**
    - After `game.animate()`, `commandHistory` contains an ANIMATE command with matching `eventType` and `data`
    - ANIMATE command is not invertible: `game.undoLastCommand()` returns false when the last command is ANIMATE
    - Multiple animate calls produce multiple ANIMATE commands in order
    - **Serialization round-trip:** Call `game.animate()`, then `game.toJSON()`, then create a new game and `replayCommands(original.commandHistory)` -- the restored game's `pendingAnimationEvents` contains the same events (type, data match; id and timestamp may differ due to replay)

    **4. ENG-04: Buffer lifecycle (`describe('animate - buffer lifecycle')`)**
    - After calling `game.animate()` inside an action, `pendingAnimationEvents` returns the events
    - When a SECOND action executes (via `performAction()`), the buffer is cleared BEFORE the new action runs -- previous events are gone
    - If the second action also calls `animate()`, only the second action's events are in the buffer
    - Events emitted outside of `performAction()` (e.g., direct `game.animate()` call in test) persist until the next `performAction()` clears them
    - Empty buffer stays empty after `performAction()` if no `animate()` calls happen

    **Important test patterns:**
    - Use `game.commandHistory.filter(c => c.type === 'ANIMATE')` to inspect ANIMATE commands
    - Use `game.pendingAnimationEvents` to inspect the buffer
    - For the action-based tests, define an action in the test game that calls `this.game.animate()` inside its execute callback, then trigger it via `game.performAction()`
    - For serialization, use `game.toJSON()` and verify the JSON includes the ANIMATE commands in `commandHistory` (they are there because `commandHistory` is serialized by existing toJSON logic -- verify this works)

    **Do NOT test:**
    - Session layer broadcasting (Phase 87)
    - UI consumption (Phase 88-89)
    - MCTS performance (just verify ANIMATE is non-invertible, which covers the MCTS concern)
  </action>
  <verify>
    Run `npx vitest run src/engine/element/animation-events.test.ts` -- all tests pass.
    Run `npx vitest run` -- all tests pass including the new file (509+ existing + new tests).
  </verify>
  <done>
    All four ENG requirements have test coverage. Tests verify: pure data events with no mutation metadata (ENG-01), callback runs as normal code without capture (ENG-02), ANIMATE commands on the command stack survive serialization (ENG-03), and buffer clears at action boundaries (ENG-04). Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. `npx vitest run` -- all tests pass (509+ existing + new animation-events tests)
3. `npx vitest run src/engine/element/animation-events.test.ts` -- new tests pass in isolation
4. Grep verification: `grep -r "type: 'ANIMATE'" src/engine/` returns hits in types.ts, executor.ts, inverse.ts, and game.ts
5. Grep verification: `grep "animate(" src/engine/element/game.ts` returns the new public method
6. Grep verification: `grep "_animationEvents = \[\]" src/engine/element/game.ts` returns the buffer clearing in performAction
</verification>

<success_criteria>
- game.animate('combat', { attacker, defender, damage }) emits a pure data event (no mutation capture context)
- game.animate('combat', data, () => { piece.remove() }) runs callback as normal game code (mutations NOT captured as event metadata)
- ANIMATE commands appear in game.commandHistory and survive serialization round-trips
- Animation event buffer is cleared at the start of each performAction() -- previous batch replaced, not accumulated
- All 509+ existing tests pass with zero regressions
- New animation-events.test.ts has tests covering all four ENG requirements
</success_criteria>

<output>
After completion, create `.planning/phases/86-simplified-animation-events/86-01-SUMMARY.md`
</output>
