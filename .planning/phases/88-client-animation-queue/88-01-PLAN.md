---
phase: 88-client-animation-queue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/composables/useAnimationEvents.ts
  - src/ui/composables/useAnimationEvents.test.ts
autonomous: true

must_haves:
  truths:
    - "Events arriving from the server are queued FIFO and processed in order (one at a time)"
    - "When the queue encounters an event type with no registered handler, processing pauses for up to handlerWaitTimeout ms"
    - "If timeout expires with no handler, a console warning names the event type and ID, the event is skipped, and processing continues"
    - "registerHandler() called while the queue is waiting for that type resumes processing immediately"
    - "skipAll() clears the queue instantly, cancels any pending handler wait, and resets reactive state"
    - "isAnimating and pendingCount remain reactive and correct throughout all wait-for-handler scenarios"
  artifacts:
    - path: "src/ui/composables/useAnimationEvents.ts"
      provides: "Wait-for-handler mechanism in processQueue, handlerWaitTimeout option, skipAll timer cleanup"
      contains: "handlerWaitTimeout"
    - path: "src/ui/composables/useAnimationEvents.test.ts"
      provides: "Test coverage for all wait-for-handler scenarios"
      contains: "wait-for-handler"
  key_links:
    - from: "processQueue no-handler branch"
      to: "waitForHandler helper"
      via: "await waitForHandler(event.type, handlerWaitTimeout)"
      pattern: "waitForHandler"
    - from: "registerHandler"
      to: "waitResolve callback"
      via: "Synchronous resolution of pending wait when matching type registers"
      pattern: "waitResolve"
    - from: "skipAll"
      to: "wait timeout + waitResolve"
      via: "clearTimeout and null-resolve to cancel pending wait"
      pattern: "clearTimeout"
---

<objective>
Add wait-for-handler semantics to the existing animation event composable. When the queue encounters an event with no registered handler, it pauses (up to a configurable timeout, default 3s) to allow lazy-mounted components to register. If a handler registers during the wait, processing resumes immediately. If timeout expires, a console warning is logged with event type and ID, the event is skipped, and the queue continues.

Purpose: Components that mount lazily (conditional rendering, route transitions) can still catch animation events they're designed to handle, instead of those events being silently dropped.

Output: Modified `useAnimationEvents.ts` with wait-for-handler mechanism and extended test suite covering all 9 CLI requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/88-client-animation-queue/88-RESEARCH.md
@src/ui/composables/useAnimationEvents.ts
@src/ui/composables/useAnimationEvents.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add wait-for-handler mechanism to useAnimationEvents composable</name>
  <files>src/ui/composables/useAnimationEvents.ts</files>
  <action>
Modify the existing `createAnimationEvents()` composable in `src/ui/composables/useAnimationEvents.ts` with these specific changes:

**1. Add `handlerWaitTimeout` to options interface:**
Add `handlerWaitTimeout?: number` to `UseAnimationEventsOptions` (default 3000ms). Keep `defaultDuration` for backward compatibility but it becomes irrelevant when `handlerWaitTimeout` is active.

**2. Destructure new option:**
In `createAnimationEvents()`, destructure `handlerWaitTimeout = 3000` from options alongside the existing destructured fields.

**3. Add wait-for-handler state variables:**
After the existing `unpauseResolve` variable, add:
- `waitingForType: string | null = null` -- the event type we're waiting for
- `waitResolve: ((handler: AnimationHandler | null) => void) | null = null` -- resolves the wait promise
- `waitTimer: ReturnType<typeof setTimeout> | null = null` -- the timeout handle (for cleanup in skipAll)

**4. Add `waitForHandler` helper function:**
```typescript
function waitForHandler(type: string, timeout: number): Promise<AnimationHandler | null> {
  return new Promise((resolve) => {
    waitingForType = type;
    waitResolve = resolve;
    waitTimer = setTimeout(() => {
      if (waitingForType === type) {
        waitResolve = null;
        waitingForType = null;
        waitTimer = null;
        resolve(null); // timeout -- no handler arrived
      }
    }, timeout);
  });
}
```

**5. Replace the "no handler" branch in processQueue:**
Replace the current handler execution block (lines 164-176, from `const handler = handlers.get(event.type)` through the `else if (defaultDuration > 0)` branch) with:

```typescript
let handler = handlers.get(event.type);

if (!handler && handlerWaitTimeout > 0) {
  // Wait for handler registration or timeout
  handler = await waitForHandler(event.type, handlerWaitTimeout);

  if (!handler) {
    // Timeout expired -- warn and skip
    console.warn(
      `Animation event "${event.type}" (id: ${event.id}) skipped: no handler registered after ${handlerWaitTimeout}ms`
    );
    acknowledge(event.id);
    lastProcessedId = event.id;
    continue;
  }
}

if (handler) {
  try {
    await handler(event);
  } catch (error) {
    console.error(`Animation handler error for event type '${event.type}':`, error);
  }
}
// No handler and handlerWaitTimeout is 0 -- skip immediately (backward compat)
```

Note: When `handlerWaitTimeout > 0` (the default), the `defaultDuration` fallback is no longer used for the "no handler" case. When `handlerWaitTimeout` is 0, events with no handler skip immediately (matching old behavior when `defaultDuration` was 0). The `defaultDuration` option is kept in the interface but is effectively superseded.

**6. Update `registerHandler` to resolve pending waits:**
After `handlers.set(eventType, handler)`, add:
```typescript
if (waitingForType === eventType && waitResolve) {
  const resolve = waitResolve;
  waitResolve = null;
  waitingForType = null;
  if (waitTimer !== null) {
    clearTimeout(waitTimer);
    waitTimer = null;
  }
  resolve(handler);
}
```
The cleanup function returned by `registerHandler` (the unregister) stays as-is -- it only removes from the map.

**7. Update `skipAll` to cancel pending handler wait:**
After the existing "If paused, resolve the unpause promise" block, add:
```typescript
// If waiting for a handler, cancel the wait
if (waitResolve) {
  const resolve = waitResolve;
  waitResolve = null;
  waitingForType = null;
  if (waitTimer !== null) {
    clearTimeout(waitTimer);
    waitTimer = null;
  }
  resolve(null); // unblock processQueue
}
```

**8. Update JSDoc:**
Update the module-level JSDoc to mention wait-for-handler semantics. Update the `handlerWaitTimeout` option doc: "Time to wait for a handler to register before skipping an unhandled event (ms, default: 3000). Set to 0 to skip immediately."

**What NOT to change:**
- Do NOT remove the `acknowledge` callback or change its signature (that's Phase 89, CLI-10)
- Do NOT remove `defaultDuration` from the interface (backward compat)
- Do NOT change the return type `UseAnimationEventsReturn`
- Do NOT change the provide/inject pattern
- Do NOT change the event deduplication logic
- Do NOT change the pause/resume mechanism (it operates at a different point in the loop)
  </action>
  <verify>
Run the existing test suite: `npx vitest run src/ui/composables/useAnimationEvents.test.ts`
All 25+ existing tests must pass. TypeScript must compile: `npx tsc --noEmit --project src/ui/tsconfig.json` (or the project's TS config).
  </verify>
  <done>
- `UseAnimationEventsOptions` has `handlerWaitTimeout?: number` (default 3000)
- `processQueue()` waits for handler registration when no handler found (instead of skipping)
- `registerHandler()` resolves pending wait immediately when matching type registers
- `skipAll()` cancels pending handler wait timer and resolves with null
- All existing tests pass with no regressions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for wait-for-handler behavior</name>
  <files>src/ui/composables/useAnimationEvents.test.ts</files>
  <action>
Add a new `describe('wait-for-handler')` block to the existing test file. Use `vi.useFakeTimers()` for tests involving the 3s timeout (so tests don't actually wait 3 seconds). Use `vi.useRealTimers()` in afterEach/cleanup.

The existing `waitForIdle` helper and `createEvent` helper should be reused.

**Test 1: Event with no handler pauses queue, handler registration resumes processing**
- Create instance with NO handlers registered
- Push an event of type 'combat'
- After nextTick, verify `isAnimating` is true (queue is processing, waiting for handler)
- Register a handler for 'combat' that records the event
- Wait for idle
- Verify the handler was called with the event

**Test 2: Timeout expires and event is skipped with console warning**
- Use `vi.useFakeTimers()`
- Create instance, push event of type 'unknownType' with id 42
- After nextTick, advance timers by 3000ms (`vi.advanceTimersByTime(3000)`)
- Verify `console.warn` was called with a message containing "unknownType" and "42"
- Verify `isAnimating` becomes false (event was skipped, queue empty)
- Verify `acknowledge` was called with the event id

**Test 3: After timeout, processing continues to next event**
- Use `vi.useFakeTimers()`
- Create instance with a handler for 'handled' type only
- Push events: [unhandled type (id 1), handled type (id 2)]
- After nextTick, advance timers by 3000ms (timeout the unhandled event)
- Switch to real timers, wait for idle
- Verify the 'handled' event (id 2) was processed
- Verify console.warn was called for the unhandled event

**Test 4: Handler registered during wait resumes immediately (no timeout)**
- Use `vi.useFakeTimers()`
- Create instance, push event of type 'lazy' (id 1)
- After nextTick, verify isAnimating is true
- Do NOT advance timers to 3000ms
- Call `registerHandler('lazy', handler)`
- Allow microtasks to flush (use `await vi.advanceTimersByTimeAsync(0)` or similar)
- Verify the handler was called
- Verify console.warn was NOT called (no timeout)

**Test 5: skipAll during handler wait cancels the wait and clears queue**
- Use `vi.useFakeTimers()`
- Create instance, push events: [unhandled (id 1), unhandled (id 2)]
- After nextTick, verify isAnimating is true
- Call `skipAll()`
- Verify `isAnimating` is false
- Verify `pendingCount` is 0
- Advance timers by 5000ms -- verify console.warn was NOT called (timer was cleaned up)

**Test 6: Custom timeout value works**
- Use `vi.useFakeTimers()`
- Create instance with `handlerWaitTimeout: 500`
- Push unhandled event
- Advance timers by 499ms -- verify still waiting (isAnimating true, no warn)
- Advance timers by 1ms more -- verify timeout fires (console.warn called)

**Test 7: handlerWaitTimeout: 0 skips immediately (backward compat)**
- Create instance with `handlerWaitTimeout: 0`
- Push unhandled event
- Wait for idle
- Verify event was skipped without waiting, no console.warn (immediate skip like old behavior)
- Verify acknowledge was still called

**Test 8: Multiple unhandled events each get their own wait**
- Use `vi.useFakeTimers()`
- Create instance with handler for 'known' only
- Push events: [unknown-a (id 1), known (id 2), unknown-b (id 3)]
- Advance timers by 3000ms for first timeout
- Allow processing, advance timers by 3000ms for second timeout
- Verify console.warn called twice (once for unknown-a, once for unknown-b)
- Verify 'known' handler was called for id 2

**Test 9: Handler already registered before event -- no wait needed (existing behavior preserved)**
- Create instance, register handler for 'preregistered'
- Push event of type 'preregistered'
- Wait for idle
- Verify handler called immediately, no console.warn, no timeout involved

Ensure all tests clean up fake timers with `vi.useRealTimers()` in afterEach if using a shared describe block with `vi.useFakeTimers()` in beforeEach. Or use per-test fake timer setup.

**Important:** Some existing tests (like "events without handlers are skipped") may need adjustment because the default `handlerWaitTimeout` is now 3000ms instead of skipping immediately. Either:
- Pass `handlerWaitTimeout: 0` in tests that expect immediate skip behavior, OR
- Use fake timers and advance past the timeout

Check that the existing test "events without handlers are skipped (with optional delay)" still passes. It uses `defaultDuration: 10` -- with the new logic, since `handlerWaitTimeout` defaults to 3000, unhandled events will wait for a handler instead. This test needs `handlerWaitTimeout: 0` to preserve its original intent (testing defaultDuration delay behavior). Similarly, the "returns unregister function that removes handler" test expects the second event to be skipped after unregistering -- it will now wait 3s instead. Add `handlerWaitTimeout: 0` to that test's options too.

Audit ALL existing tests: any test that expects an unhandled event to be processed quickly (without a registered handler) must either:
1. Set `handlerWaitTimeout: 0` in options, or
2. Use fake timers and advance past the timeout

This is critical to avoid test timeouts.
  </action>
  <verify>
Run the full test suite: `npx vitest run src/ui/composables/useAnimationEvents.test.ts`
All tests pass (both existing and new). No test takes more than 5 seconds.
Run the full project test suite to check for regressions: `npx vitest run`
  </verify>
  <done>
- 9 new test cases in a 'wait-for-handler' describe block covering CLI-02 through CLI-05, CLI-07, CLI-08 extensions, and edge cases
- All existing tests still pass (adjusted where needed for new default handlerWaitTimeout)
- Full project test suite passes with zero regressions
- Requirements CLI-01 through CLI-09 are all verified by tests
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run src/ui/composables/useAnimationEvents.test.ts` -- all tests pass
2. `npx vitest run` -- full project test suite passes, zero regressions
3. `npx tsc --noEmit` -- TypeScript compiles without errors
4. Verify CLI-01 (FIFO): Existing "processes events in order" test passes
5. Verify CLI-02 (wait-for-handler): New test shows queue pauses when no handler registered
6. Verify CLI-03 (configurable timeout): New test with custom timeout (500ms) works
7. Verify CLI-04 (timeout warning): console.warn includes event type and ID
8. Verify CLI-05 (skip on timeout): After timeout, next event is processed
9. Verify CLI-06 (registerHandler API): Existing handler registration tests pass
10. Verify CLI-07 (resume on register): New test shows immediate resume
11. Verify CLI-08 (skipAll): New test shows skipAll cancels wait timer
12. Verify CLI-09 (reactive state): isAnimating and pendingCount correct in all new tests
</verification>

<success_criteria>
- The `useAnimationEvents` composable supports wait-for-handler with configurable timeout
- All 9 CLI requirements (CLI-01 through CLI-09) are satisfied and tested
- No regressions in existing functionality (25+ existing tests pass)
- No timer leaks on skipAll (verified by test advancing timers after skipAll)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/88-client-animation-queue/88-01-SUMMARY.md`
</output>
