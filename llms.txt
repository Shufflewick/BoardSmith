This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/**/*.md, packages/engine/src/**/*.ts, packages/engine/ARCHITECTURE.md, packages/runtime/src/**/*.ts, packages/ai/src/**/*.ts, packages/ui/src/index.ts, packages/ui/src/composables/**/*.ts, packages/ui/src/types.ts, packages/cli/src/**/*.ts, packages/session/src/**/*.ts, packages/testing/src/**/*.ts, packages/games/hex/rules/src/**/*.ts, packages/games/go-fish/rules/src/**/*.ts, packages/games/checkers/rules/src/**/*.ts, packages/games/cribbage/rules/src/**/*.ts, package.json, packages/*/package.json
- Files matching these patterns are excluded: node_modules/**, dist/**, **/dist/**, **/*.d.ts, **/*.test.ts, **/*.spec.ts, pnpm-lock.yaml, .git/**, coverage/**, *.log
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)

# User Provided Header
# BoardSmith - Turn-Based Game Framework

This file contains the BoardSmith codebase optimized for LLM consumption.

BoardSmith is a TypeScript framework for building multiplayer turn-based board and card games.

## Quick Reference

- Start with `docs/llm-overview.md` for a comprehensive summary
- See `docs/getting-started.md` for CLI and project setup
- See `docs/core-concepts.md` for element tree, actions, commands
- See `packages/games/hex/` for the simplest complete example
- See `packages/games/cribbage/` for a complex multi-phase example

# Directory Structure
```
docs/
  actions-and-flow.md
  ai-system.md
  core-concepts.md
  game-examples.md
  getting-started.md
  llm-overview.md
  ui-components.md
packages/
  ai/
    src/
      index.ts
      mcts-bot.ts
      types.ts
      utils.ts
    package.json
  cli/
    src/
      commands/
        build.ts
        dev.ts
        init.ts
        publish.ts
        test.ts
        validate.ts
      cli.ts
      local-server.ts
    package.json
  client/
    package.json
  engine/
    src/
      action/
        action.ts
        index.ts
        types.ts
      command/
        executor.ts
        index.ts
        types.ts
        visibility.ts
      element/
        card.ts
        deck.ts
        element-collection.ts
        game-element.ts
        game.ts
        grid.ts
        hand.ts
        hex-grid.ts
        index.ts
        piece.ts
        space.ts
        types.ts
      flow/
        builders.ts
        engine.ts
        index.ts
        turn-order.ts
        types.ts
      player/
        index.ts
        player.ts
      sandbox/
        index.ts
      utils/
        index.ts
        replay.ts
        serializer.ts
        snapshot.ts
      index.ts
    ARCHITECTURE.md
    package.json
  eslint-plugin/
    package.json
  games/
    checkers/
      rules/
        src/
          actions.ts
          ai.ts
          elements.ts
          flow.ts
          game.ts
          index.ts
    cribbage/
      rules/
        src/
          actions.ts
          ai.ts
          elements.ts
          flow.ts
          game.ts
          index.ts
          scoring.ts
    go-fish/
      rules/
        src/
          actions.ts
          ai.ts
          elements.ts
          flow.ts
          game.ts
          index.ts
    hex/
      rules/
        src/
          actions.ts
          ai.ts
          elements.ts
          flow.ts
          game.ts
          index.ts
  runtime/
    src/
      index.ts
      runner.ts
    package.json
  server/
    package.json
  session/
    src/
      ai-controller.ts
      game-session.ts
      index.ts
      types.ts
      utils.ts
    package.json
  testing/
    src/
      index.ts
      random-simulation.ts
      simulate-action.ts
      test-game.ts
    package.json
  ui/
    src/
      composables/
        useBoardInteraction.ts
        useCardDisplay.ts
        useCardFlip.ts
        useElementAnimation.ts
        useElementChangeTracker.ts
        useFLIPAnimation.ts
        useFlyingCards.ts
        useFlyOnAppear.ts
        useGameGrid.ts
        useGameViewHelpers.ts
        useHexGrid.ts
        usePlayerStatAnimation.ts
      index.ts
      types.ts
    package.json
  worker/
    package.json
package.json
```

# Files

## File: docs/actions-and-flow.md
````markdown
  1: # Actions & Flow System
  2: 
  3: This document covers the Action builder API and the declarative Flow system for controlling game structure.
  4: 
  5: ## Actions
  6: 
  7: Actions define what players can do during the game. They use a fluent builder pattern.
  8: 
  9: ### Basic Action Structure
 10: 
 11: ```typescript
 12: import { Action, type ActionDefinition } from '@boardsmith/engine';
 13: 
 14: export function createMyAction(game: MyGame): ActionDefinition {
 15:   return Action.create('actionName')
 16:     .prompt('Description shown to player')
 17:     .condition((ctx) => /* when this action is available */)
 18:     .chooseFrom('selection', { /* selection options */ })
 19:     .execute((args, ctx) => {
 20:       // Game logic here
 21:       return { success: true };
 22:     });
 23: }
 24: ```
 25: 
 26: ### Selection Methods
 27: 
 28: #### `chooseFrom<T>` - Choose from a list
 29: 
 30: ```typescript
 31: Action.create('selectRank')
 32:   .chooseFrom<string>('rank', {
 33:     prompt: 'Choose a rank to ask for',
 34:     choices: (ctx) => ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],
 35:   })
 36: ```
 37: 
 38: #### `chooseElement<T>` - Choose a game element
 39: 
 40: ```typescript
 41: Action.create('placeStone')
 42:   .chooseElement<Cell>('cell', {
 43:     prompt: 'Select an empty cell',
 44:     elementClass: Cell,
 45:     filter: (cell, ctx) => cell.isEmpty(),
 46:     display: (cell) => cell.notation,        // Display text
 47:     boardRef: (cell) => ({ id: cell.id }),   // For UI highlighting
 48:   })
 49: ```
 50: 
 51: #### `choosePlayer` - Choose another player
 52: 
 53: ```typescript
 54: Action.create('askPlayer')
 55:   .choosePlayer('target', {
 56:     prompt: 'Who do you want to ask?',
 57:     filter: (player, ctx) => player !== ctx.player,  // Not self
 58:   })
 59: ```
 60: 
 61: #### `chooseNumber` - Enter a number
 62: 
 63: ```typescript
 64: Action.create('bid')
 65:   .chooseNumber('amount', {
 66:     prompt: 'Enter your bid',
 67:     min: 1,
 68:     max: (ctx) => ctx.player.coins,
 69:   })
 70: ```
 71: 
 72: #### `chooseText` - Enter text
 73: 
 74: ```typescript
 75: Action.create('name')
 76:   .chooseText('name', {
 77:     prompt: 'Enter a name',
 78:     maxLength: 20,
 79:   })
 80: ```
 81: 
 82: ### Chaining Selections
 83: 
 84: Actions can have multiple selections that depend on each other:
 85: 
 86: ```typescript
 87: Action.create('move')
 88:   .chooseElement<Piece>('piece', {
 89:     prompt: 'Select a piece to move',
 90:     elementClass: Piece,
 91:     filter: (p, ctx) => p.player === ctx.player,
 92:   })
 93:   .chooseElement<Cell>('destination', {
 94:     prompt: 'Select destination',
 95:     elementClass: Cell,
 96:     // Filter depends on previously selected piece
 97:     filter: (cell, ctx) => {
 98:       const piece = ctx.args.piece as Piece;
 99:       return piece.canMoveTo(cell);
100:     },
101:   })
102: ```
103: 
104: ### Conditions
105: 
106: Control when actions are available:
107: 
108: ```typescript
109: Action.create('draw')
110:   .condition((ctx) => {
111:     // Only available when deck has cards
112:     return game.deck.count(Card) > 0;
113:   })
114:   .execute(...)
115: ```
116: 
117: ### Validation
118: 
119: Validate the complete action before execution:
120: 
121: ```typescript
122: Action.create('play')
123:   .chooseFrom('cards', { choices: getPlayableCards, multi: true })
124:   .validate((args, ctx) => {
125:     const cards = args.cards as Card[];
126:     if (cards.length < 2) {
127:       return { valid: false, message: 'Must play at least 2 cards' };
128:     }
129:     return { valid: true };
130:   })
131:   .execute(...)
132: ```
133: 
134: ### Execute Function
135: 
136: The execute function performs the actual game logic:
137: 
138: ```typescript
139: .execute((args, ctx) => {
140:   const player = ctx.player as MyPlayer;
141:   const card = args.card as Card;
142: 
143:   // Perform game actions (generates commands automatically)
144:   card.putInto(game.discardPile);
145:   player.score += card.value;
146: 
147:   // Add game message
148:   game.message(`${player.name} played ${card.name}`);
149: 
150:   // Return result
151:   return {
152:     success: true,
153:     message: 'Card played successfully',
154:     data: { cardId: card.id },
155:   };
156: });
157: ```
158: 
159: ### Action Options
160: 
161: ```typescript
162: Action.create('move')
163:   .prompt('Move your piece')
164:   .notUndoable()                    // Cannot undo this action
165:   .skipIf((ctx) => /* condition */) // Skip if condition is true
166: ```
167: 
168: ### Example: Go Fish Ask Action
169: 
170: From `packages/games/go-fish/rules/src/actions.ts`:
171: 
172: ```typescript
173: export function createAskAction(game: GoFishGame): ActionDefinition {
174:   return Action.create('ask')
175:     .prompt('Ask another player for a card')
176:     .choosePlayer('target', {
177:       prompt: 'Who do you want to ask?',
178:       filter: (p, ctx) => p !== ctx.player && p.hand.count(Card) > 0,
179:     })
180:     .chooseFrom<string>('rank', {
181:       prompt: 'What rank do you want?',
182:       choices: (ctx) => {
183:         const player = ctx.player as GoFishPlayer;
184:         const ranks = new Set<string>();
185:         for (const card of player.hand.all(Card)) {
186:           ranks.add(card.rank);
187:         }
188:         return [...ranks];
189:       },
190:     })
191:     .execute((args, ctx) => {
192:       const player = ctx.player as GoFishPlayer;
193:       const target = args.target as GoFishPlayer;
194:       const rank = args.rank as string;
195: 
196:       const matchingCards = target.hand.all(Card).filter(c => c.rank === rank);
197: 
198:       if (matchingCards.length > 0) {
199:         for (const card of matchingCards) {
200:           card.putInto(player.hand);
201:         }
202:         game.message(`${player.name} got ${matchingCards.length} ${rank}(s) from ${target.name}!`);
203:         game.setPlayerGoesAgain(true);
204:       } else {
205:         game.message(`${target.name} says "Go Fish!"`);
206:         game.setPlayerGoesAgain(false);
207:       }
208: 
209:       return { success: true };
210:     });
211: }
212: ```
213: 
214: ## Flow System
215: 
216: The Flow system defines game structure using composable nodes.
217: 
218: ### Flow Definition
219: 
220: ```typescript
221: import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from '@boardsmith/engine';
222: 
223: export function createGameFlow(game: MyGame): FlowDefinition {
224:   return {
225:     root: /* flow node */,
226:     isComplete: (ctx) => game.isFinished(),
227:     getWinners: (ctx) => game.getWinners(),
228:   };
229: }
230: ```
231: 
232: ### Flow Nodes
233: 
234: #### `sequence` - Run steps in order
235: 
236: ```typescript
237: sequence(
238:   actionStep({ actions: ['draw'] }),
239:   actionStep({ actions: ['play'] }),
240: )
241: ```
242: 
243: #### `loop` - Repeat while condition is true
244: 
245: ```typescript
246: loop({
247:   name: 'game-loop',
248:   while: (ctx) => !game.isFinished(),
249:   maxIterations: 1000,  // Safety limit
250:   do: /* flow node */,
251: })
252: ```
253: 
254: #### `repeat` - Fixed number of iterations
255: 
256: ```typescript
257: repeat({
258:   name: 'deal-cards',
259:   times: 5,
260:   do: actionStep({ actions: ['deal'] }),
261: })
262: ```
263: 
264: #### `eachPlayer` - Iterate over players
265: 
266: ```typescript
267: eachPlayer({
268:   name: 'player-turns',
269:   order: TurnOrder.clockwise(),
270:   filter: (player, ctx) => !player.hasPassed,
271:   do: /* flow node */,
272: })
273: ```
274: 
275: #### `forEach` - Iterate over array
276: 
277: ```typescript
278: forEach({
279:   name: 'score-hands',
280:   collection: (ctx) => game.players,
281:   do: (player) => execute({
282:     do: () => game.scoreHand(player),
283:   }),
284: })
285: ```
286: 
287: #### `actionStep` - Wait for player action
288: 
289: ```typescript
290: actionStep({
291:   name: 'move-step',
292:   actions: ['move', 'jump'],      // Available actions
293:   prompt: 'Move or jump a piece',
294:   skipIf: (ctx) => game.isFinished(),
295: })
296: ```
297: 
298: #### `simultaneousActionStep` - All players act at once
299: 
300: ```typescript
301: simultaneousActionStep({
302:   name: 'discard-step',
303:   actions: ['discard'],
304:   prompt: 'Choose cards to discard',
305: })
306: ```
307: 
308: #### `phase` - Named game phase
309: 
310: ```typescript
311: phase('setup', {
312:   do: sequence(
313:     execute({ do: () => game.deal() }),
314:     simultaneousActionStep({ actions: ['discard'] }),
315:   ),
316: })
317: ```
318: 
319: #### `switchOn` - Conditional branching
320: 
321: ```typescript
322: switchOn({
323:   value: (ctx) => game.currentPhase,
324:   cases: {
325:     'deal': /* flow node */,
326:     'play': /* flow node */,
327:     'score': /* flow node */,
328:   },
329:   default: /* flow node */,
330: })
331: ```
332: 
333: #### `ifThen` - If-else logic
334: 
335: ```typescript
336: ifThen({
337:   if: (ctx) => game.deck.count(Card) > 0,
338:   then: actionStep({ actions: ['draw'] }),
339:   else: execute({ do: () => game.endRound() }),
340: })
341: ```
342: 
343: #### `execute` - Run code
344: 
345: ```typescript
346: execute({
347:   name: 'shuffle-deck',
348:   do: (ctx) => {
349:     game.deck.shuffle();
350:     game.message('Deck shuffled!');
351:   },
352: })
353: ```
354: 
355: #### `setVar` - Set flow variable
356: 
357: ```typescript
358: setVar({
359:   name: 'roundNumber',
360:   value: (ctx) => (ctx.vars.roundNumber ?? 0) + 1,
361: })
362: ```
363: 
364: ### Turn Order
365: 
366: Control player order with `TurnOrder`:
367: 
368: ```typescript
369: eachPlayer({
370:   order: TurnOrder.roundRobin(),       // Default: 0, 1, 2, ...
371:   order: TurnOrder.clockwise(),        // Same as roundRobin
372:   order: TurnOrder.counterClockwise(), // Reverse
373:   order: TurnOrder.custom((players, ctx) => {
374:     // Return players in custom order
375:     return players.sort((a, b) => a.score - b.score);
376:   }),
377: })
378: ```
379: 
380: ### Flow Variables
381: 
382: Access and set variables during flow:
383: 
384: ```typescript
385: // Set variable
386: setVar({ name: 'dealer', value: (ctx) => ctx.players[0] })
387: 
388: // Access in conditions
389: loop({
390:   while: (ctx) => ctx.vars.roundNumber < 10,
391:   do: ...
392: })
393: ```
394: 
395: ### Example: Cribbage Flow
396: 
397: Complex multi-phase flow from `packages/games/cribbage/`:
398: 
399: ```typescript
400: export function createCribbageFlow(game: CribbageGame): FlowDefinition {
401:   return {
402:     root: loop({
403:       name: 'game-loop',
404:       while: () => !game.isFinished(),
405:       do: sequence(
406:         // Deal phase
407:         phase('deal', {
408:           do: execute({ do: () => game.dealHands() }),
409:         }),
410: 
411:         // Discard phase - all players discard simultaneously
412:         phase('discard', {
413:           do: simultaneousActionStep({
414:             actions: ['discard'],
415:             prompt: 'Discard 2 cards to the crib',
416:           }),
417:         }),
418: 
419:         // Play phase - alternating card play
420:         phase('play', {
421:           do: loop({
422:             while: () => !game.playPhaseComplete(),
423:             do: eachPlayer({
424:               do: actionStep({
425:                 actions: ['playCard', 'sayGo'],
426:                 skipIf: (ctx) => !game.canPlay(ctx.player),
427:               }),
428:             }),
429:           }),
430:         }),
431: 
432:         // Show phase - score hands
433:         phase('show', {
434:           do: forEach({
435:             collection: () => game.getShowOrder(),
436:             do: (player) => execute({
437:               do: () => game.scoreHand(player),
438:             }),
439:           }),
440:         }),
441: 
442:         // Rotate dealer
443:         execute({ do: () => game.rotateDealer() }),
444:       ),
445:     }),
446:     isComplete: () => game.isFinished(),
447:     getWinners: () => game.getWinners(),
448:   };
449: }
450: ```
451: 
452: ### Example: Simple Turn-Based Flow (Hex)
453: 
454: Minimal flow from `packages/games/hex/`:
455: 
456: ```typescript
457: export function createHexFlow(game: HexGame): FlowDefinition {
458:   return {
459:     root: loop({
460:       name: 'game-loop',
461:       while: () => !game.isFinished(),
462:       maxIterations: 100,
463:       do: eachPlayer({
464:         name: 'player-turns',
465:         filter: (player) => !game.isFinished(),
466:         do: actionStep({
467:           name: 'place-stone',
468:           actions: ['placeStone'],
469:           skipIf: () => game.isFinished(),
470:         }),
471:       }),
472:     }),
473:     isComplete: () => game.isFinished(),
474:     getWinners: () => game.winner ? [game.winner] : [],
475:   };
476: }
477: ```
478: 
479: ## Registering Actions
480: 
481: Actions must be registered in your Game constructor:
482: 
483: ```typescript
484: constructor(options) {
485:   super(options);
486:   // ... element setup ...
487: 
488:   this.registerAction(createMoveAction(this));
489:   this.registerAction(createDrawAction(this));
490:   this.registerAction(createPlayAction(this));
491: 
492:   this.setFlow(createGameFlow(this));
493: }
494: ```
495: 
496: ## Related Documentation
497: 
498: - [Core Concepts](./core-concepts.md) - Elements and state management
499: - [UI Components](./ui-components.md) - Displaying actions in the UI
500: - [Game Examples](./game-examples.md) - Real implementations
````

## File: docs/ai-system.md
````markdown
  1: # AI System
  2: 
  3: BoardSmith includes a game-agnostic AI system using Monte-Carlo Tree Search (MCTS). The AI works with any game without game-specific tuning.
  4: 
  5: ## Overview
  6: 
  7: The `@boardsmith/ai` package provides:
  8: - **MCTSBot**: MCTS-based AI player
  9: - **Difficulty presets**: easy, medium, hard
 10: - **Custom objectives**: Guide AI behavior for specific games
 11: 
 12: ## How MCTS Works
 13: 
 14: Monte-Carlo Tree Search builds a game tree by repeatedly:
 15: 
 16: 1. **SELECT**: Walk down the tree using UCT (Upper Confidence Bound for Trees) to balance exploration vs exploitation
 17: 2. **EXPAND**: Try one unexplored action from a leaf node
 18: 3. **PLAYOUT**: Random moves until game ends (or depth limit)
 19: 4. **BACKPROPAGATE**: Update win counts back up the tree
 20: 
 21: After many iterations, the bot chooses the most-visited child of the root (robust choice).
 22: 
 23: ## Basic Usage
 24: 
 25: ### Using the CLI
 26: 
 27: The easiest way to add AI players is via the CLI:
 28: 
 29: ```bash
 30: # Player 1 is AI (medium difficulty)
 31: boardsmith dev --ai 1
 32: 
 33: # Players 0 and 2 are AI
 34: boardsmith dev --ai 0 2
 35: 
 36: # Set difficulty level
 37: boardsmith dev --ai 1 --ai-level hard
 38: 
 39: # Custom iteration count
 40: boardsmith dev --ai 1 --ai-level 50
 41: ```
 42: 
 43: ### Difficulty Levels
 44: 
 45: | Level | Iterations | Playout Depth | Timeout |
 46: |-------|-----------|---------------|---------|
 47: | easy | 3 | 3 | 1000ms |
 48: | medium | 5 | 4 | 1500ms |
 49: | hard | 8 | 5 | 2000ms |
 50: 
 51: Note: Iterations are kept low because game operations can be slow (~18ms per move). The timeout ensures responsive behavior.
 52: 
 53: ### Programmatic Usage
 54: 
 55: ```typescript
 56: import { createBot, parseAILevel } from '@boardsmith/ai';
 57: import { MyGame } from './game.js';
 58: 
 59: // Create a bot for player 1
 60: const bot = createBot(
 61:   game,                    // Game instance
 62:   MyGame,                  // Game class constructor
 63:   'my-game',               // Game type identifier
 64:   1,                       // Player index (0-based)
 65:   actionHistory,           // History of actions taken so far
 66:   'hard'                   // Difficulty level or iteration count
 67: );
 68: 
 69: // Get the bot's move
 70: const move = await bot.play();
 71: console.log(`Bot plays: ${move.action}`, move.args);
 72: 
 73: // Execute the move
 74: game.continueFlow(move.action, move.args, 1);
 75: ```
 76: 
 77: ## Custom Objectives
 78: 
 79: For games where win/loss isn't sufficient guidance, you can define objectives that give the AI partial credit during playouts.
 80: 
 81: ### Defining Objectives
 82: 
 83: ```typescript
 84: import type { AIConfig, Game } from '@boardsmith/ai';
 85: 
 86: const aiConfig: AIConfig = {
 87:   objectives: (game: Game, playerIndex: number) => ({
 88:     // Positive weight = good for the player
 89:     controlCenter: {
 90:       checker: (g, p) => {
 91:         const center = g.board.cells.filter(c => c.isCentral);
 92:         const playerPieces = center.filter(c => c.piece?.player?.position === p);
 93:         return playerPieces.length >= 2;
 94:       },
 95:       weight: 0.3,
 96:     },
 97: 
 98:     // Negative weight = bad for the player
 99:     exposedKing: {
100:       checker: (g, p) => {
101:         const king = g.players[p].king;
102:         return king.isExposed();
103:       },
104:       weight: -0.5,
105:     },
106: 
107:     // Material advantage
108:     materialAdvantage: {
109:       checker: (g, p) => {
110:         const myPieces = g.pieces.filter(pc => pc.player?.position === p);
111:         const oppPieces = g.pieces.filter(pc => pc.player?.position !== p);
112:         return myPieces.length > oppPieces.length;
113:       },
114:       weight: 0.4,
115:     },
116:   }),
117: };
118: 
119: // Use with createBot
120: const bot = createBot(game, MyGame, 'my-game', 1, [], 'medium', aiConfig);
121: ```
122: 
123: ### Objective Evaluation
124: 
125: During playouts that don't reach a terminal state:
126: - If total objective score > 0: returns 0.6 (slightly favorable)
127: - If total objective score < 0: returns 0.4 (slightly unfavorable)
128: - If total objective score = 0: returns 0.5 (neutral)
129: 
130: Terminal states always use actual win/loss (1.0/0.0).
131: 
132: ## Example: Checkers AI
133: 
134: From `packages/games/checkers/rules/src/ai.ts`:
135: 
136: ```typescript
137: import type { AIConfig, Game } from '@boardsmith/ai';
138: 
139: export const checkersAIConfig: AIConfig = {
140:   objectives: (game: Game, playerIndex: number) => ({
141:     // Having more pieces is good
142:     morePieces: {
143:       checker: (g, p) => {
144:         const myPieces = countPieces(g, p);
145:         const oppPieces = countPieces(g, 1 - p);
146:         return myPieces > oppPieces;
147:       },
148:       weight: 0.5,
149:     },
150: 
151:     // Having kings is good
152:     hasKings: {
153:       checker: (g, p) => {
154:         const myKings = countKings(g, p);
155:         return myKings > 0;
156:       },
157:       weight: 0.3,
158:     },
159: 
160:     // Controlling the center is good
161:     centerControl: {
162:       checker: (g, p) => {
163:         const centerCells = getCenterCells(g);
164:         const myPiecesInCenter = centerCells.filter(
165:           c => c.piece?.player?.position === p
166:         );
167:         return myPiecesInCenter.length >= 2;
168:       },
169:       weight: 0.2,
170:     },
171:   }),
172: };
173: ```
174: 
175: ## Integration with GameSession
176: 
177: The `@boardsmith/session` package integrates AI automatically:
178: 
179: ```typescript
180: import { GameSession } from '@boardsmith/session';
181: import { MyGame } from './game.js';
182: import { myGameAIConfig } from './ai.js';
183: 
184: const session = new GameSession({
185:   gameClass: MyGame,
186:   gameType: 'my-game',
187:   playerCount: 2,
188:   aiPlayers: [1],           // Player 1 is AI
189:   aiLevel: 'hard',
190:   aiConfig: myGameAIConfig,  // Optional custom objectives
191: });
192: 
193: // AI will automatically play when it's player 1's turn
194: session.start();
195: ```
196: 
197: ## BotConfig Options
198: 
199: ```typescript
200: interface BotConfig {
201:   /** Number of MCTS iterations (higher = stronger but slower). Default: 100 */
202:   iterations: number;
203: 
204:   /** Maximum playout depth before evaluating position. Default: 5 */
205:   playoutDepth: number;
206: 
207:   /** Random seed for reproducible behavior */
208:   seed?: string;
209: 
210:   /** Run async to yield to event loop (prevents UI freezing). Default: true */
211:   async?: boolean;
212: 
213:   /** Maximum time in milliseconds before returning best move found. Default: 2000 */
214:   timeout?: number;
215: }
216: ```
217: 
218: ## Performance Considerations
219: 
220: 1. **Iteration count**: More iterations = better play, but slower. The default presets are tuned for responsiveness.
221: 
222: 2. **Playout depth**: Deeper playouts give more accurate evaluations but take longer. 3-5 is usually sufficient.
223: 
224: 3. **Timeout**: The timeout ensures the bot always returns within a reasonable time, even if iterations haven't completed.
225: 
226: 4. **Branching factor**: Games with many possible moves per turn will have fewer iterations explored per move. The bot samples up to 20 choices per selection to limit combinatorial explosion.
227: 
228: 5. **Game complexity**: Simple games (Hex, Checkers) work well. Complex games (Cribbage with many scoring possibilities) may need custom objectives.
229: 
230: ## Limitations
231: 
232: - **No learning**: The AI doesn't learn from past games. Each game starts fresh.
233: - **Text/number inputs**: The AI can't handle actions that require text or number input (it can only choose from discrete options).
234: - **Determinism**: With a seed, the bot is deterministic. Without a seed, it uses `Math.random()`.
235: 
236: ## API Reference
237: 
238: ### createBot()
239: 
240: ```typescript
241: function createBot<G extends Game>(
242:   game: G,
243:   GameClass: new (options: GameOptions) => G,
244:   gameType: string,
245:   playerIndex: number,
246:   actionHistory?: SerializedAction[],
247:   difficulty?: DifficultyLevel | number,
248:   aiConfig?: AIConfig
249: ): MCTSBot<G>
250: ```
251: 
252: ### MCTSBot.play()
253: 
254: ```typescript
255: async play(): Promise<BotMove>
256: ```
257: 
258: Returns the best move found after running MCTS iterations.
259: 
260: ### parseAILevel()
261: 
262: ```typescript
263: function parseAILevel(level: string): DifficultyLevel | number
264: ```
265: 
266: Parse an AI level string (e.g., from CLI arguments).
267: 
268: ## Related Documentation
269: 
270: - [Core Concepts](./core-concepts.md) - Understanding game state
271: - [Actions & Flow](./actions-and-flow.md) - How actions work
272: - [Game Examples](./game-examples.md) - Games with AI implementations
````

## File: docs/core-concepts.md
````markdown
  1: # Core Concepts
  2: 
  3: This document explains the fundamental concepts and architecture of BoardSmith.
  4: 
  5: ## Overview
  6: 
  7: BoardSmith uses a hierarchical element tree to represent game state, with a clear separation between:
  8: - **Actions** (what players do) - high-level, game-specific
  9: - **Commands** (how state changes) - low-level, generic, event-sourced
 10: 
 11: ## Element Tree
 12: 
 13: Games are represented as a tree of `GameElement` objects:
 14: 
 15: ```
 16: Game (root)
 17: ├── Board/Grid/Deck (Spaces - containers)
 18: │   ├── Piece/Card (game pieces)
 19: │   └── More spaces...
 20: ├── Player Hands (Spaces)
 21: └── Pile (removed elements)
 22: ```
 23: 
 24: ### Element Types
 25: 
 26: | Class | Purpose | Example |
 27: |-------|---------|---------|
 28: | `GameElement` | Base class (never instantiate directly) | - |
 29: | `Space` | Container for other elements | Board, pile, zone |
 30: | `Deck` | Stack of cards (shuffleable) | Draw pile, discard |
 31: | `Hand` | Player's private cards | Player's hand |
 32: | `Grid` | Square grid | Chess/checkers board |
 33: | `HexGrid` | Hexagonal grid | Hex game board |
 34: | `Piece` | Physical game piece | Checker, stone |
 35: | `Card` | Playing card | Standard deck card |
 36: 
 37: ### Creating Elements
 38: 
 39: Elements are created as children of other elements:
 40: 
 41: ```typescript
 42: // In your Game constructor
 43: class MyGame extends Game<MyGame, MyPlayer> {
 44:   constructor(options) {
 45:     super(options);
 46: 
 47:     // Register element classes (required for serialization)
 48:     this.registerElements([Card, Hand, Deck, Board]);
 49: 
 50:     // Create elements as children of the game
 51:     this.deck = this.create(Deck, 'deck');
 52:     this.board = this.create(Board, 'board');
 53: 
 54:     // Create cards inside the deck
 55:     for (const suit of suits) {
 56:       for (const rank of ranks) {
 57:         this.deck.create(Card, `${rank}${suit}`, { suit, rank });
 58:       }
 59:     }
 60:   }
 61: }
 62: ```
 63: 
 64: ### Element Operations
 65: 
 66: ```typescript
 67: // Query elements
 68: const card = deck.first(Card);              // First card
 69: const cards = deck.all(Card);               // All cards
 70: const count = deck.count(Card);             // Count cards
 71: const aceOfSpades = deck.first(Card, c => c.rank === 'A' && c.suit === 'S');
 72: 
 73: // Move elements
 74: card.putInto(hand);                         // Move card to hand
 75: card.putInto(hand, { position: 'first' }); // Put at beginning
 76: 
 77: // Remove elements
 78: card.remove();                              // Remove from game
 79: 
 80: // Create elements
 81: const stone = cell.create(Stone, 'stone-1', { player });
 82: 
 83: // Shuffle (Deck only)
 84: deck.shuffle();
 85: 
 86: // Element ordering
 87: deck.setOrder('stacking');                  // Last in, first out
 88: ```
 89: 
 90: ### Custom Element Classes
 91: 
 92: Extend base classes to add game-specific properties:
 93: 
 94: ```typescript
 95: // elements.ts
 96: import { Card as BaseCard, Piece as BasePiece } from '@boardsmith/engine';
 97: 
 98: export class Card extends BaseCard {
 99:   suit!: 'H' | 'D' | 'C' | 'S';
100:   rank!: string;
101: 
102:   get value(): number {
103:     const values: Record<string, number> = { 'A': 1, 'J': 11, 'Q': 12, 'K': 13 };
104:     return values[this.rank] ?? parseInt(this.rank);
105:   }
106: }
107: 
108: export class CheckerPiece extends BasePiece {
109:   player!: CheckersPlayer;
110:   isKing: boolean = false;
111: 
112:   promote(): void {
113:     this.isKing = true;
114:   }
115: }
116: ```
117: 
118: ## Visibility System
119: 
120: Control what each player can see.
121: 
122: ### Element Visibility
123: 
124: ```typescript
125: // Make contents visible to everyone
126: deck.contentsVisible();
127: 
128: // Hide contents from everyone
129: deck.contentsHidden();
130: 
131: // Only owner can see contents
132: hand.contentsVisibleToOwner();
133: ```
134: 
135: ### Attribute Visibility
136: 
137: Use static `visibleAttributes` to control which attributes are visible:
138: 
139: ```typescript
140: class Card extends BaseCard {
141:   suit!: Suit;
142:   rank!: Rank;
143:   secretValue!: number;  // Hidden from players
144: 
145:   // Only suit and rank are visible in hidden contexts
146:   static visibleAttributes = ['suit', 'rank'];
147: }
148: ```
149: 
150: ## Actions vs Commands
151: 
152: BoardSmith separates player intent from state mutations.
153: 
154: ### Actions (High-Level)
155: 
156: Actions are what players do - game-specific operations with prompts, selections, and validation:
157: 
158: ```typescript
159: const moveAction = Action.create('move')
160:   .prompt('Move a piece')
161:   .chooseElement('piece', { filter: p => p.player === ctx.player })
162:   .chooseElement('destination', { filter: c => c.isEmpty() })
163:   .execute((args, ctx) => {
164:     args.piece.putInto(args.destination);  // Generates MoveCommand
165:   });
166: ```
167: 
168: ### Commands (Low-Level)
169: 
170: Commands are generic state mutations that happen automatically when you call element methods:
171: 
172: | Element Method | Generated Command |
173: |---------------|-------------------|
174: | `parent.create(Class, name, attrs)` | `CreateElementCommand` |
175: | `element.putInto(target)` | `MoveCommand` |
176: | `element.remove()` | `RemoveCommand` |
177: | `deck.shuffle()` | `ShuffleCommand` |
178: | `element.setAttribute(key, value)` | `SetAttributeCommand` |
179: | `element.contentsVisible()` | `SetVisibilityCommand` |
180: 
181: ### Why This Matters
182: 
183: 1. **Event Sourcing**: Commands form a replayable event log
184: 2. **Undo/Redo**: Actions can be undone by reversing commands
185: 3. **Networking**: Only commands are sent over the network
186: 4. **Security**: Players can't directly manipulate state
187: 5. **Debugging**: Full history of what happened
188: 
189: ### Best Practices
190: 
191: ```typescript
192: // DO: Use element methods in action execute functions
193: .execute((args, ctx) => {
194:   card.putInto(hand);
195:   player.score += 10;
196: });
197: 
198: // DON'T: Try to create commands manually
199: // DON'T: Bypass actions for player operations
200: ```
201: 
202: ## Player System
203: 
204: ### Custom Player Classes
205: 
206: ```typescript
207: export class MyPlayer extends Player<MyGame, MyPlayer> {
208:   hand!: Hand;
209:   score: number = 0;
210: 
211:   constructor(position: number, name: string, game: MyGame) {
212:     super(position, name);
213:     this.game = game;
214: 
215:     // Create player's hand
216:     this.hand = game.create(Hand, `hand-${position}`);
217:     this.hand.player = this;
218:     this.hand.contentsVisibleToOwner();
219:   }
220: }
221: ```
222: 
223: ### Player Properties
224: 
225: - `position`: 0-indexed player position
226: - `name`: Display name
227: - `game`: Reference to the game instance
228: 
229: ### Accessing Players
230: 
231: ```typescript
232: // In game class
233: this.players                    // All players array
234: this.players[0]                 // First player
235: this.currentPlayer              // Player whose turn it is
236: 
237: // In action context
238: ctx.player                      // Current action's player
239: ```
240: 
241: ## Game State Serialization
242: 
243: BoardSmith automatically handles serialization for:
244: - Network transmission
245: - State persistence
246: - Replays
247: 
248: ### Registering Elements
249: 
250: All custom element classes must be registered:
251: 
252: ```typescript
253: this.registerElements([Card, Hand, Deck, Board, Piece]);
254: ```
255: 
256: ### State Snapshots
257: 
258: ```typescript
259: // Get complete state snapshot
260: const snapshot = game.getSnapshot();
261: 
262: // Get player-specific view (with visibility applied)
263: const playerView = game.getPlayerView(playerPosition);
264: ```
265: 
266: ### Player Views
267: 
268: Each player receives a filtered view of the game state:
269: - Hidden elements show only `visibleAttributes`
270: - Private zones of other players are hidden
271: - Server-side information is stripped
272: 
273: ## Game Lifecycle
274: 
275: ```
276: 1. Constructor
277:    - Register elements
278:    - Create initial state
279:    - Register actions
280:    - Set flow
281: 
282: 2. setup() - Called after constructor
283:    - Additional initialization
284: 
285: 3. start() - Game begins
286:    - Flow starts executing
287:    - Players take actions
288: 
289: 4. isFinished() returns true
290:    - Game ends
291:    - getWinners() called
292: ```
293: 
294: ## Example: Hex Game
295: 
296: A minimal but complete example from `packages/games/hex/`:
297: 
298: ```typescript
299: // game.ts
300: export class HexGame extends Game<HexGame, HexPlayer> {
301:   board!: Board;
302:   winner?: HexPlayer;
303: 
304:   constructor(options: HexOptions) {
305:     super(options);
306: 
307:     this.registerElements([Board, Cell, Stone]);
308: 
309:     // Create hex board
310:     this.board = this.create(Board, 'board', { boardSize: 7 });
311:     for (let r = 0; r < 7; r++) {
312:       for (let q = 0; q < 7; q++) {
313:         this.board.create(Cell, `cell-${q}-${r}`, { q, r });
314:       }
315:     }
316: 
317:     this.registerAction(createPlaceStoneAction(this));
318:     this.setFlow(createHexFlow(this));
319:   }
320: 
321:   override isFinished(): boolean {
322:     return !!this.winner;
323:   }
324: 
325:   override getWinners(): HexPlayer[] {
326:     return this.winner ? [this.winner] : [];
327:   }
328: }
329: ```
330: 
331: ## Related Documentation
332: 
333: - [Actions & Flow](./actions-and-flow.md) - Deep dive on actions and game flow
334: - [UI Components](./ui-components.md) - Building game UIs
335: - [Game Examples](./game-examples.md) - Real game implementations
````

## File: docs/game-examples.md
````markdown
  1: # Game Examples & Patterns
  2: 
  3: This document analyzes the example games in `packages/games/` to demonstrate common patterns and best practices.
  4: 
  5: ## Example Games Overview
  6: 
  7: | Game | Location | Complexity | Key Patterns |
  8: |------|----------|-----------|--------------|
  9: | Hex | `packages/games/hex/` | Simple | Hex grid, path-finding, simple flow |
 10: | Go Fish | `packages/games/go-fish/` | Medium | Cards, hidden info, conditional turns |
 11: | Checkers | `packages/games/checkers/` | Medium | Square grid, multi-step actions, piece promotion |
 12: | Cribbage | `packages/games/cribbage/` | Complex | Multi-phase, simultaneous actions, complex scoring |
 13: 
 14: ---
 15: 
 16: ## Hex - Simplest Example
 17: 
 18: **Location**: `packages/games/hex/`
 19: 
 20: Hex is the simplest example, demonstrating core patterns with minimal complexity.
 21: 
 22: ### Key Features
 23: - Hex grid board
 24: - Simple alternating turns
 25: - Path-finding win condition
 26: - Single action type
 27: 
 28: ### Game Structure
 29: 
 30: ```typescript
 31: // game.ts
 32: export class HexGame extends Game<HexGame, HexPlayer> {
 33:   board!: Board;
 34:   winner?: HexPlayer;
 35: 
 36:   constructor(options: HexOptions) {
 37:     super(options);
 38: 
 39:     // Register elements
 40:     this.registerElements([Board, Cell, Stone]);
 41: 
 42:     // Create hex board
 43:     this.board = this.create(Board, 'board', { boardSize: 7 });
 44:     for (let r = 0; r < 7; r++) {
 45:       for (let q = 0; q < 7; q++) {
 46:         this.board.create(Cell, `cell-${q}-${r}`, { q, r });
 47:       }
 48:     }
 49: 
 50:     // Single action
 51:     this.registerAction(createPlaceStoneAction(this));
 52:     this.setFlow(createHexFlow(this));
 53:   }
 54: }
 55: ```
 56: 
 57: ### Simple Flow
 58: 
 59: ```typescript
 60: // flow.ts
 61: export function createHexFlow(game: HexGame): FlowDefinition {
 62:   return {
 63:     root: loop({
 64:       name: 'game-loop',
 65:       while: () => !game.isFinished(),
 66:       do: eachPlayer({
 67:         do: actionStep({
 68:           actions: ['placeStone'],
 69:           skipIf: () => game.isFinished(),
 70:         }),
 71:       }),
 72:     }),
 73:     isComplete: () => game.isFinished(),
 74:     getWinners: () => game.winner ? [game.winner] : [],
 75:   };
 76: }
 77: ```
 78: 
 79: ### Element with Board Reference
 80: 
 81: ```typescript
 82: // actions.ts
 83: Action.create('placeStone')
 84:   .chooseElement<Cell>('cell', {
 85:     filter: (cell) => cell.isEmpty(),
 86:     boardRef: (cell) => ({
 87:       id: cell.id,
 88:       notation: cell.notation,
 89:     }),
 90:   })
 91:   .execute((args, ctx) => {
 92:     const cell = args.cell as Cell;
 93:     cell.create(Stone, `stone-${player.position}`, { player });
 94: 
 95:     // Check win condition
 96:     if (game.board.checkWin(player)) {
 97:       game.setWinner(player);
 98:     }
 99:   });
100: ```
101: 
102: ### Pattern: Custom Element Classes
103: 
104: ```typescript
105: // elements.ts
106: export class Cell extends HexCell {
107:   q!: number;
108:   r!: number;
109: 
110:   get notation(): string {
111:     return `${String.fromCharCode(97 + this.q)}${this.r + 1}`;
112:   }
113: 
114:   isEmpty(): boolean {
115:     return this.count(Stone) === 0;
116:   }
117: }
118: ```
119: 
120: ---
121: 
122: ## Go Fish - Card Game Patterns
123: 
124: **Location**: `packages/games/go-fish/`
125: 
126: Go Fish demonstrates card game patterns including hidden information and conditional turns.
127: 
128: ### Key Features
129: - Standard deck creation
130: - Private hands with visibility
131: - Player interaction (asking)
132: - Conditional turns (go again if match)
133: - Book collection
134: 
135: ### Hidden Information
136: 
137: ```typescript
138: // game.ts
139: constructor(options) {
140:   // Create player hands - hidden from other players
141:   for (const player of this.players) {
142:     const hand = this.create(Hand, `hand-${player.position}`);
143:     hand.player = player;
144:     hand.contentsVisibleToOwner();  // Only owner sees their cards
145:   }
146: 
147:   // The pond (draw pile) - hidden
148:   this.pond = this.create(Pond, 'pond');
149:   this.pond.contentsHidden();
150: }
151: ```
152: 
153: ### Conditional Turns (Extra Turn Logic)
154: 
155: ```typescript
156: // flow.ts - Turn loop with extra turns
157: const playerTurn = sequence(
158:   setVar('extraTurn', false),
159:   setVar('turnEnded', false),
160: 
161:   loop({
162:     name: 'turn-loop',
163:     while: (ctx) => {
164:       if (ctx.get('turnEnded')) return false;
165:       // ... other conditions
166:       return true;
167:     },
168:     do: sequence(
169:       actionStep({ actions: ['ask'] }),
170:       execute((ctx) => {
171:         const extraTurn = ctx.lastActionResult?.data?.extraTurn;
172:         if (!extraTurn) {
173:           ctx.set('turnEnded', true);
174:         }
175:       }),
176:     ),
177:   }),
178: );
179: ```
180: 
181: ### Action with Extra Turn Signal
182: 
183: ```typescript
184: // actions.ts
185: .execute((args, ctx) => {
186:   const matchingCards = target.hand.all(Card).filter(c => c.rank === rank);
187: 
188:   if (matchingCards.length > 0) {
189:     for (const card of matchingCards) {
190:       card.putInto(player.hand);
191:     }
192:     // Signal extra turn
193:     return { success: true, data: { extraTurn: true } };
194:   } else {
195:     game.drawFromPond(player);
196:     return { success: true, data: { extraTurn: false } };
197:   }
198: });
199: ```
200: 
201: ### Pattern: Book/Set Collection
202: 
203: ```typescript
204: // game.ts
205: checkForBooks(player: GoFishPlayer): void {
206:   const hand = this.getPlayerHand(player);
207:   const cards = hand.all(Card);
208: 
209:   // Count cards by rank
210:   const rankCounts = new Map<string, Card[]>();
211:   for (const card of cards) {
212:     const existing = rankCounts.get(card.rank) || [];
213:     existing.push(card);
214:     rankCounts.set(card.rank, existing);
215:   }
216: 
217:   // Create books for complete sets
218:   for (const [rank, rankCards] of rankCounts) {
219:     if (rankCards.length === 4) {
220:       const book = this.books.create(Book, `book-${rank}`, { rank, player });
221:       for (const card of rankCards) {
222:         card.putInto(book);
223:       }
224:       player.score++;
225:     }
226:   }
227: }
228: ```
229: 
230: ---
231: 
232: ## Checkers - Grid & Multi-Step Actions
233: 
234: **Location**: `packages/games/checkers/`
235: 
236: Checkers demonstrates square grids, forced moves, and multi-step actions.
237: 
238: ### Key Features
239: - 8x8 square grid
240: - Jump chains (multi-step moves)
241: - Forced jump rule
242: - Piece promotion (kings)
243: 
244: ### Grid Setup
245: 
246: ```typescript
247: // game.ts
248: constructor(options) {
249:   this.board = this.create(Board, 'board');
250:   this.board.contentsVisible();
251: 
252:   // Create 8x8 grid
253:   for (let row = 0; row < 8; row++) {
254:     for (let col = 0; col < 8; col++) {
255:       const cell = this.board.create(Cell, `cell-${col}-${row}`, {
256:         col, row,
257:         isPlayable: (row + col) % 2 === 1,  // Dark squares only
258:       });
259:     }
260:   }
261: 
262:   // Place initial pieces
263:   this.setupInitialPieces();
264: }
265: ```
266: 
267: ### Multi-Step Action (Jump Chain)
268: 
269: ```typescript
270: // actions.ts - Handling jump chains
271: Action.create('move')
272:   .chooseElement<Piece>('piece', {
273:     filter: (piece, ctx) => {
274:       const game = ctx.game as CheckersGame;
275:       // If there's a pending jump, only that piece can continue
276:       if (game.pendingJumpPiece) {
277:         return piece === game.pendingJumpPiece;
278:       }
279:       return piece.player === ctx.player && game.hasValidMoves(piece);
280:     },
281:   })
282:   .chooseElement<Cell>('destination', {
283:     filter: (cell, ctx) => {
284:       const piece = ctx.args.piece as Piece;
285:       return game.isValidMove(piece, cell);
286:     },
287:   })
288:   .execute((args, ctx) => {
289:     const piece = args.piece as Piece;
290:     const dest = args.destination as Cell;
291: 
292:     const isJump = game.isJumpMove(piece, dest);
293:     piece.putInto(dest);
294: 
295:     if (isJump) {
296:       game.captureJumpedPiece(piece, dest);
297: 
298:       // Check for additional jumps
299:       if (game.canContinueJumping(piece)) {
300:         game.pendingJumpPiece = piece;
301:         game.setPlayerGoesAgain(true);
302:       } else {
303:         game.pendingJumpPiece = null;
304:       }
305:     }
306: 
307:     // Check for promotion
308:     if (game.shouldPromote(piece)) {
309:       piece.isKing = true;
310:     }
311:   });
312: ```
313: 
314: ### Forced Move Logic
315: 
316: ```typescript
317: // game.ts
318: getValidMoves(player: CheckersPlayer): Move[] {
319:   const pieces = this.board.all(Piece).filter(p => p.player === player);
320: 
321:   // Check for forced jumps
322:   const jumpMoves = [];
323:   for (const piece of pieces) {
324:     jumpMoves.push(...this.getJumpMoves(piece));
325:   }
326: 
327:   // If jumps available, must take one
328:   if (jumpMoves.length > 0) {
329:     return jumpMoves;
330:   }
331: 
332:   // Otherwise, regular moves
333:   return pieces.flatMap(p => this.getRegularMoves(p));
334: }
335: ```
336: 
337: ---
338: 
339: ## Cribbage - Complex Multi-Phase Game
340: 
341: **Location**: `packages/games/cribbage/`
342: 
343: Cribbage is the most complex example, demonstrating multi-phase flow, simultaneous actions, and complex scoring.
344: 
345: ### Key Features
346: - Multi-phase rounds (deal, discard, play, show)
347: - Simultaneous actions (both players discard at once)
348: - Complex scoring logic
349: - Running count during play
350: - "Go" mechanics
351: 
352: ### Multi-Phase Flow
353: 
354: ```typescript
355: // flow.ts
356: const playRound = sequence(
357:   // Initialize round
358:   execute((ctx) => game.startNewRound()),
359: 
360:   // Discard phase - simultaneous
361:   phase('discarding', {
362:     do: simultaneousActionStep({
363:       actions: ['discard'],
364:       prompt: 'Discard 2 cards to the crib',
365:       playerDone: (ctx, player) => {
366:         const hand = game.getPlayerHand(player);
367:         return hand.count(Card) <= 4;  // Done when 4 cards left
368:       },
369:       allDone: (ctx) => game.allPlayersDiscarded(),
370:     }),
371:   }),
372: 
373:   // Store hands before play
374:   execute(() => game.storeOriginalHands()),
375: 
376:   // Cut starter
377:   execute(() => game.cutStarterCard()),
378: 
379:   // Play phase - alternating turns
380:   phase('play', { do: playPhaseSequence }),
381: 
382:   // Scoring phase
383:   phase('scoring', {
384:     do: sequence(
385:       execute(() => game.scoreRoundAndBuildSummary()),
386:       simultaneousActionStep({
387:         actions: ['acknowledgeScore'],
388:         allDone: () => !game.roundSummary.active,
389:       }),
390:     ),
391:   }),
392: 
393:   // Rotate dealer
394:   execute(() => game.rotateDealer()),
395: );
396: ```
397: 
398: ### Simultaneous Actions
399: 
400: ```typescript
401: // Both players discard at the same time
402: simultaneousActionStep({
403:   name: 'simultaneous-discard',
404:   actions: ['discard'],
405:   prompt: 'Discard 2 cards to the crib',
406:   playerDone: (ctx, player) => {
407:     const hand = game.getPlayerHand(player as CribbagePlayer);
408:     return hand.count(Card) <= 4;
409:   },
410:   allDone: (ctx) => {
411:     return game.allPlayersDiscarded() || game.isFinished();
412:   },
413: });
414: ```
415: 
416: ### Phase Lifecycle Hooks
417: 
418: ```typescript
419: // flow.ts
420: return {
421:   root: /* ... */,
422:   isComplete: /* ... */,
423:   getWinners: /* ... */,
424: 
425:   // Phase lifecycle hooks
426:   onEnterPhase: (phaseName, ctx) => {
427:     const game = ctx.game as CribbageGame;
428:     game.cribbagePhase = phaseName;
429: 
430:     const phaseNames = {
431:       discarding: 'DISCARD PHASE',
432:       play: 'PLAY PHASE',
433:       scoring: 'SCORING PHASE',
434:     };
435:     game.message(`=== ${phaseNames[phaseName]} ===`);
436:   },
437: };
438: ```
439: 
440: ### Complex Play Phase with Go
441: 
442: ```typescript
443: // Play phase loop with "Go" mechanics
444: loop({
445:   name: 'play-loop',
446:   while: () => !game.allCardsPlayed() && !game.isFinished(),
447:   do: sequence(
448:     // Check if count needs reset
449:     execute(() => {
450:       const currentStuck = currentSaidGo || !currentCanPlay;
451:       const otherStuck = otherSaidGo || !otherCanPlay;
452: 
453:       if (currentStuck && otherStuck && (hasCards)) {
454:         // Award "Go" point
455:         if (game.runningTotal < 31) {
456:           game.addPoints(lastPlayer, 1, 'Go');
457:         }
458:         game.resetCount();
459:       }
460:     }),
461: 
462:     // Player plays or says Go
463:     actionStep({
464:       player: () => game.getCurrentPlayPlayer(),
465:       actions: ['playCard', 'sayGo'],
466:       skipIf: () => playerAlreadySaidGo || !hasCards,
467:     }),
468: 
469:     // Switch turns
470:     execute(() => {
471:       if (!otherSaidGo && otherHasCards) {
472:         game.switchPlayTurn();
473:       }
474:     }),
475:   ),
476: });
477: ```
478: 
479: ### Scoring System
480: 
481: ```typescript
482: // scoring.ts - Complex scoring calculation
483: export function scoreHand(cards: Card[], starter: Card, isCrib: boolean): ScoreBreakdown {
484:   const allFive = [...cards, starter];
485:   const breakdown: ScoreBreakdown = { fifteens: 0, pairs: 0, runs: 0, flush: 0, nobs: 0 };
486: 
487:   // Score 15s (combinations summing to 15)
488:   breakdown.fifteens = scoreFifteens(allFive);
489: 
490:   // Score pairs
491:   breakdown.pairs = scorePairs(allFive);
492: 
493:   // Score runs (sequences)
494:   breakdown.runs = scoreRuns(allFive);
495: 
496:   // Score flush (requires 4 in hand, or 5 total for crib)
497:   breakdown.flush = scoreFlush(cards, starter, isCrib);
498: 
499:   // Score nobs (Jack of starter suit)
500:   breakdown.nobs = scoreNobs(cards, starter);
501: 
502:   return breakdown;
503: }
504: ```
505: 
506: ---
507: 
508: ## Common Patterns Summary
509: 
510: ### 1. Game Initialization
511: 
512: ```typescript
513: constructor(options) {
514:   super(options);
515:   this.registerElements([...]);  // Always register elements
516:   // Create board/deck
517:   // Register actions
518:   this.setFlow(createGameFlow(this));
519: }
520: ```
521: 
522: ### 2. Custom Player Classes
523: 
524: ```typescript
525: export class MyPlayer extends Player<MyGame, MyPlayer> {
526:   hand!: Hand;
527:   score: number = 0;
528: 
529:   constructor(position: number, name: string, game: MyGame) {
530:     super(position, name);
531:     this.game = game;
532:     this.hand = game.create(Hand, `hand-${position}`);
533:     this.hand.player = this;
534:   }
535: }
536: ```
537: 
538: ### 3. Win Condition Checking
539: 
540: ```typescript
541: override isFinished(): boolean {
542:   return this.winner !== undefined || /* other condition */;
543: }
544: 
545: override getWinners(): MyPlayer[] {
546:   if (!this.isFinished()) return [];
547:   return this.winner ? [this.winner] : [];
548: }
549: ```
550: 
551: ### 4. Action Result Data
552: 
553: ```typescript
554: .execute((args, ctx) => {
555:   // ... game logic ...
556:   return {
557:     success: true,
558:     message: 'Action completed',
559:     data: {
560:       extraTurn: shouldGoAgain,  // Can be read by flow
561:       customData: 'anything',
562:     },
563:   };
564: });
565: ```
566: 
567: ### 5. Flow Variables
568: 
569: ```typescript
570: sequence(
571:   setVar('roundNumber', 1),
572:   loop({
573:     while: (ctx) => ctx.get('roundNumber') <= 10,
574:     do: sequence(
575:       /* round logic */,
576:       execute((ctx) => ctx.set('roundNumber', ctx.get('roundNumber') + 1)),
577:     ),
578:   }),
579: )
580: ```
581: 
582: ### 6. Visibility Control
583: 
584: ```typescript
585: // Hidden from everyone
586: deck.contentsHidden();
587: 
588: // Visible to everyone
589: board.contentsVisible();
590: 
591: // Only owner sees
592: hand.contentsVisibleToOwner();
593: ```
594: 
595: ## Related Documentation
596: 
597: - [Getting Started](./getting-started.md) - Create your first game
598: - [Core Concepts](./core-concepts.md) - Element tree, visibility, state
599: - [Actions & Flow](./actions-and-flow.md) - Action and flow API details
````

## File: docs/getting-started.md
````markdown
  1: # Getting Started with BoardSmith
  2: 
  3: BoardSmith is a TypeScript framework for building turn-based board and card games with built-in multiplayer support, AI opponents, and automatic UI generation.
  4: 
  5: ## Prerequisites
  6: 
  7: - Node.js 20+
  8: - npm, pnpm, or yarn
  9: 
 10: ## Quick Start
 11: 
 12: ### 1. Create a New Game Project
 13: 
 14: ```bash
 15: npx boardsmith init my-game
 16: cd my-game
 17: npm install
 18: ```
 19: 
 20: This creates a new game project with the following structure:
 21: 
 22: ```
 23: my-game/
 24: ├── boardsmith.json          # Game configuration
 25: ├── package.json             # Dependencies
 26: ├── tsconfig.json            # TypeScript config
 27: ├── vite.config.ts           # Vite bundler config
 28: ├── index.html               # Entry HTML
 29: ├── public/                  # Static assets
 30: ├── src/
 31: │   ├── main.ts              # App entry point
 32: │   ├── rules/               # Game logic
 33: │   │   ├── game.ts          # Main Game class
 34: │   │   ├── elements.ts      # Custom element classes
 35: │   │   ├── actions.ts       # Player action definitions
 36: │   │   ├── flow.ts          # Game flow definition
 37: │   │   └── index.ts         # Exports
 38: │   └── ui/                  # Vue UI components
 39: │       ├── App.vue          # Main app component
 40: │       ├── components/      # Custom components
 41: │       │   └── GameBoard.vue
 42: │       └── index.ts         # UI exports
 43: └── tests/
 44:     └── game.test.ts         # Game tests
 45: ```
 46: 
 47: ### 2. Start Development Server
 48: 
 49: ```bash
 50: boardsmith dev
 51: ```
 52: 
 53: This starts:
 54: - A Vite dev server on port 5173 (UI)
 55: - A game server on port 8787 (API/WebSocket)
 56: - Automatically opens browser tabs for each player
 57: 
 58: #### Dev Server Options
 59: 
 60: ```bash
 61: # Specify number of players
 62: boardsmith dev --players 3
 63: 
 64: # Add AI opponents
 65: boardsmith dev --ai 1              # Player 1 is AI
 66: boardsmith dev --ai 0 2            # Players 0 and 2 are AI
 67: 
 68: # Set AI difficulty
 69: boardsmith dev --ai 1 --ai-level hard    # easy, medium, hard, expert
 70: 
 71: # Custom ports
 72: boardsmith dev --port 3000 --worker-port 9000
 73: ```
 74: 
 75: ### 3. Run Tests
 76: 
 77: ```bash
 78: boardsmith test           # Run once
 79: boardsmith test --watch   # Watch mode
 80: ```
 81: 
 82: ### 4. Validate Before Publishing
 83: 
 84: ```bash
 85: boardsmith validate
 86: ```
 87: 
 88: This runs:
 89: - TypeScript compilation checks
 90: - Configuration validation
 91: - Random game simulation to detect infinite loops or game-ending bugs
 92: 
 93: ### 5. Build for Production
 94: 
 95: ```bash
 96: boardsmith build
 97: ```
 98: 
 99: ### 6. Publish to boardsmith.io
100: 
101: ```bash
102: boardsmith publish
103: ```
104: 
105: ## Understanding the Generated Code
106: 
107: ### Game Configuration (boardsmith.json)
108: 
109: ```json
110: {
111:   "$schema": "https://boardsmith.io/schemas/game.json",
112:   "name": "my-game",
113:   "displayName": "My Game",
114:   "description": "A fun game for 2-4 players",
115:   "playerCount": { "min": 2, "max": 4 },
116:   "estimatedDuration": "15-30 minutes",
117:   "complexity": 2,
118:   "categories": ["card-game"],
119:   "thumbnail": "./public/thumbnail.png",
120:   "scoreboard": { "stats": ["score"] }
121: }
122: ```
123: 
124: ### Game Class (src/rules/game.ts)
125: 
126: The Game class is the heart of your game. It:
127: - Extends `Game<YourGame, YourPlayer>`
128: - Registers element classes
129: - Creates the initial game state (deck, board, etc.)
130: - Registers actions players can take
131: - Defines the game flow
132: 
133: ```typescript
134: export class MyGame extends Game<MyGame, MyPlayer> {
135:   deck!: Deck;
136: 
137:   constructor(options: MyGameOptions) {
138:     super(options);
139: 
140:     // Register element classes (required for serialization)
141:     this.registerElements([Card, Hand, Deck]);
142: 
143:     // Create game elements
144:     this.deck = this.create(Deck, 'deck');
145: 
146:     // Set up initial state
147:     this.deck.shuffle();
148:     for (const player of this.players) {
149:       // Deal cards...
150:     }
151: 
152:     // Register player actions
153:     this.registerAction(createDrawAction(this));
154:     this.registerAction(createPlayAction(this));
155: 
156:     // Set up game flow
157:     this.setFlow(createGameFlow(this));
158:   }
159: 
160:   override isFinished(): boolean {
161:     return this.deck.count(Card) === 0;
162:   }
163: 
164:   override getWinners(): MyPlayer[] {
165:     // Return winning player(s)
166:   }
167: }
168: ```
169: 
170: ### Element Classes (src/rules/elements.ts)
171: 
172: Elements are the building blocks of your game state. BoardSmith provides base classes:
173: 
174: - **Space** - Containers that hold other elements
175:   - **Deck** - Stackable card pile (can shuffle)
176:   - **Hand** - Player's private cards
177:   - **Grid** - Square grid (e.g., chess board)
178:   - **HexGrid** - Hexagonal grid
179: - **Piece** - Physical game pieces
180: - **Card** - Playing cards
181: 
182: ```typescript
183: import { Card as BaseCard, Hand as BaseHand, Deck as BaseDeck } from '@boardsmith/engine';
184: 
185: export type Suit = 'H' | 'D' | 'C' | 'S';
186: export type Rank = 'A' | '2' | '3' | ... | 'K';
187: 
188: export class Card extends BaseCard {
189:   suit!: Suit;
190:   rank!: Rank;
191: }
192: 
193: export class Hand extends BaseHand {}
194: export class Deck extends BaseDeck {}
195: ```
196: 
197: ### Actions (src/rules/actions.ts)
198: 
199: Actions define what players can do. Use the fluent builder API:
200: 
201: ```typescript
202: import { Action, type ActionDefinition } from '@boardsmith/engine';
203: 
204: export function createPlayAction(game: MyGame): ActionDefinition {
205:   return Action.create('play')
206:     .prompt('Play a card from your hand')
207:     .chooseFrom<Card>('card', {
208:       prompt: 'Select a card to play',
209:       choices: (ctx) => [...ctx.player.hand.all(Card)],
210:     })
211:     .execute((args, ctx) => {
212:       const card = args.card as Card;
213:       card.remove();
214:       ctx.player.score += 1;
215:       return { success: true };
216:     });
217: }
218: ```
219: 
220: ### Flow (src/rules/flow.ts)
221: 
222: The flow defines turn structure and game phases:
223: 
224: ```typescript
225: import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from '@boardsmith/engine';
226: 
227: export function createGameFlow(game: MyGame): FlowDefinition {
228:   return {
229:     root: loop({
230:       name: 'game-loop',
231:       while: () => !game.isFinished(),
232:       do: eachPlayer({
233:         name: 'player-turns',
234:         do: sequence(
235:           actionStep({ actions: ['draw'] }),
236:           actionStep({ actions: ['play'] }),
237:         ),
238:       }),
239:     }),
240:     isComplete: () => game.isFinished(),
241:     getWinners: () => game.getWinners(),
242:   };
243: }
244: ```
245: 
246: ### UI (src/ui/App.vue)
247: 
248: The UI uses Vue 3 and the `@boardsmith/ui` package:
249: 
250: ```vue
251: <template>
252:   <GameShell
253:     game-type="my-game"
254:     display-name="My Game"
255:     :player-count="2"
256:   >
257:     <template #game-board="{ gameView, playerPosition, isMyTurn, availableActions, action }">
258:       <GameBoard
259:         :game-view="gameView"
260:         :player-position="playerPosition"
261:         :is-my-turn="isMyTurn"
262:         :available-actions="availableActions"
263:         :action="action"
264:       />
265:     </template>
266:   </GameShell>
267: </template>
268: ```
269: 
270: ## Next Steps
271: 
272: - Read [Core Concepts](./core-concepts.md) to understand elements, actions, and commands
273: - Learn about [Actions & Flow](./actions-and-flow.md) for complex game logic
274: - Explore [UI Components](./ui-components.md) for building custom UIs
275: - See [Game Examples](./game-examples.md) for real implementations
276: 
277: ## Example Games
278: 
279: BoardSmith includes several example games in `packages/games/`:
280: 
281: | Game | Complexity | Key Features |
282: |------|-----------|--------------|
283: | **Hex** | Simple | Hex grid, path-finding win condition |
284: | **Go Fish** | Medium | Cards, hidden information, player interaction |
285: | **Checkers** | Medium | Square grid, multi-step moves, piece promotion |
286: | **Cribbage** | Complex | Multi-phase flow, simultaneous actions, scoring |
287: 
288: Study these to learn common patterns and best practices.
````

## File: docs/llm-overview.md
````markdown
  1: # BoardSmith LLM Overview
  2: 
  3: This document provides a comprehensive overview of the BoardSmith framework optimized for LLM consumption. Use this to quickly understand the project architecture and key patterns.
  4: 
  5: ## What is BoardSmith?
  6: 
  7: BoardSmith is a TypeScript framework for building turn-based multiplayer board and card games. It provides:
  8: 
  9: - **Element-based state management** - Games are trees of typed elements (Board, Deck, Hand, Piece, Card)
 10: - **Declarative flow system** - Define game structure with composable flow nodes
 11: - **Action builder API** - Fluent API for defining player actions with selections and validation
 12: - **Event-sourced commands** - All state mutations are tracked and replayable
 13: - **Automatic UI generation** - AutoUI can render any game without custom components
 14: - **MCTS AI** - Game-agnostic AI opponents using Monte-Carlo Tree Search
 15: - **Multiplayer networking** - WebSocket-based real-time game sessions
 16: 
 17: ## Project Structure
 18: 
 19: ```
 20: BoardSmith/
 21: ├── packages/
 22: │   ├── engine/       # Core framework (~15k lines)
 23: │   ├── runtime/      # Game execution
 24: │   ├── session/      # Session management
 25: │   ├── ai/           # MCTS bot (~700 lines)
 26: │   ├── ui/           # Vue 3 components (~15k lines)
 27: │   ├── client/       # Browser networking
 28: │   ├── server/       # Platform-agnostic server
 29: │   ├── worker/       # Cloudflare Workers runtime
 30: │   ├── cli/          # Dev tools
 31: │   ├── testing/      # Test utilities
 32: │   └── games/        # Example games
 33: │       ├── hex/      # Simplest example
 34: │       ├── go-fish/  # Card game patterns
 35: │       ├── checkers/ # Grid + multi-step
 36: │       └── cribbage/ # Complex multi-phase
 37: └── docs/             # Documentation
 38: ```
 39: 
 40: ## Key Concepts
 41: 
 42: ### 1. Element Tree
 43: 
 44: Games are represented as a tree of `GameElement` objects:
 45: 
 46: ```
 47: Game (root)
 48: ├── Board (Space)
 49: │   └── Cell (Space) → Piece
 50: ├── Deck (Space) → Card, Card, ...
 51: ├── Hand (Space) → Card (owner sees)
 52: └── Pile (removed elements)
 53: ```
 54: 
 55: **Element types**: `Space` (container), `Deck`, `Hand`, `Grid`, `HexGrid`, `Piece`, `Card`
 56: 
 57: ### 2. Actions vs Commands
 58: 
 59: **Actions** = What players do (high-level, game-specific)
 60: ```typescript
 61: Action.create('move')
 62:   .chooseElement('piece', { filter: p => p.player === ctx.player })
 63:   .chooseElement('dest', { filter: c => c.isEmpty() })
 64:   .execute((args) => args.piece.putInto(args.dest));
 65: ```
 66: 
 67: **Commands** = How state changes (low-level, generic, event-sourced)
 68: ```typescript
 69: // Generated automatically by element methods
 70: { type: 'move', elementId: 42, targetId: 17 }
 71: ```
 72: 
 73: ### 3. Flow System
 74: 
 75: Declarative game flow with composable nodes:
 76: 
 77: ```typescript
 78: const flow: FlowDefinition = {
 79:   root: loop({
 80:     while: () => !game.isFinished(),
 81:     do: eachPlayer({
 82:       do: actionStep({ actions: ['move'] }),
 83:     }),
 84:   }),
 85:   isComplete: () => game.isFinished(),
 86:   getWinners: () => game.getWinners(),
 87: };
 88: ```
 89: 
 90: **Flow nodes**: `sequence`, `loop`, `repeat`, `eachPlayer`, `forEach`, `actionStep`, `simultaneousActionStep`, `phase`, `switchOn`, `ifThen`, `execute`, `setVar`
 91: 
 92: ### 4. Visibility System
 93: 
 94: Control what players can see:
 95: 
 96: ```typescript
 97: deck.contentsHidden();           // Hidden from all
 98: hand.contentsVisibleToOwner();   // Only owner sees
 99: board.contentsVisible();         // Everyone sees
100: ```
101: 
102: ## Creating a Game
103: 
104: ### 1. Initialize Project
105: 
106: ```bash
107: npx boardsmith init my-game
108: cd my-game
109: npm install
110: boardsmith dev
111: ```
112: 
113: ### 2. Define Elements
114: 
115: ```typescript
116: // elements.ts
117: export class Card extends BaseCard {
118:   suit!: 'H' | 'D' | 'C' | 'S';
119:   rank!: string;
120: }
121: export class Hand extends BaseHand {}
122: export class Deck extends BaseDeck {}
123: ```
124: 
125: ### 3. Define Actions
126: 
127: ```typescript
128: // actions.ts
129: export function createPlayAction(game: MyGame): ActionDefinition {
130:   return Action.create('play')
131:     .chooseFrom<Card>('card', {
132:       choices: (ctx) => [...ctx.player.hand.all(Card)],
133:     })
134:     .execute((args) => {
135:       const card = args.card as Card;
136:       card.remove();
137:       ctx.player.score += 1;
138:     });
139: }
140: ```
141: 
142: ### 4. Define Flow
143: 
144: ```typescript
145: // flow.ts
146: export function createGameFlow(game: MyGame): FlowDefinition {
147:   return {
148:     root: loop({
149:       while: () => !game.isFinished(),
150:       do: eachPlayer({
151:         do: actionStep({ actions: ['play'] }),
152:       }),
153:     }),
154:     isComplete: () => game.isFinished(),
155:     getWinners: () => game.getWinners(),
156:   };
157: }
158: ```
159: 
160: ### 5. Game Class
161: 
162: ```typescript
163: // game.ts
164: export class MyGame extends Game<MyGame, MyPlayer> {
165:   deck!: Deck;
166: 
167:   constructor(options: MyGameOptions) {
168:     super(options);
169:     this.registerElements([Card, Hand, Deck]);
170:     this.deck = this.create(Deck, 'deck');
171:     // ... setup ...
172:     this.registerAction(createPlayAction(this));
173:     this.setFlow(createGameFlow(this));
174:   }
175: 
176:   override isFinished(): boolean {
177:     return this.deck.count(Card) === 0;
178:   }
179: }
180: ```
181: 
182: ## Common Patterns
183: 
184: ### Conditional Turns (Go Again)
185: 
186: ```typescript
187: .execute((args, ctx) => {
188:   if (gotMatch) {
189:     return { success: true, data: { extraTurn: true } };
190:   }
191:   return { success: true, data: { extraTurn: false } };
192: });
193: 
194: // In flow
195: execute((ctx) => {
196:   if (!ctx.lastActionResult?.data?.extraTurn) {
197:     ctx.set('turnEnded', true);
198:   }
199: })
200: ```
201: 
202: ### Multi-Step Actions (Jump Chains)
203: 
204: ```typescript
205: .execute((args, ctx) => {
206:   if (canContinueJumping) {
207:     game.pendingJumpPiece = piece;
208:     game.setPlayerGoesAgain(true);
209:   }
210: });
211: ```
212: 
213: ### Simultaneous Actions
214: 
215: ```typescript
216: simultaneousActionStep({
217:   actions: ['discard'],
218:   playerDone: (ctx, player) => player.hand.count(Card) <= 4,
219:   allDone: (ctx) => game.allPlayersDiscarded(),
220: })
221: ```
222: 
223: ### Phase-Based Games
224: 
225: ```typescript
226: sequence(
227:   phase('deal', { do: execute(() => game.deal()) }),
228:   phase('discard', { do: simultaneousActionStep({ actions: ['discard'] }) }),
229:   phase('play', { do: playLoop }),
230:   phase('score', { do: execute(() => game.score()) }),
231: )
232: ```
233: 
234: ## UI Components
235: 
236: **Core**: `GameShell`, `DebugPanel`, `PlayersPanel`, `GameHistory`
237: 
238: **Helpers**: `Draggable`, `DiceRoller`, `CardFan`, `DeckPile`, `FlyingCardsOverlay`
239: 
240: **Auto-UI**: `AutoUI`, `AutoGameBoard`, `AutoElement`, `ActionPanel`
241: 
242: **Composables**:
243: - `useBoardInteraction` - Board ↔ ActionPanel communication
244: - `useElementAnimation` - FLIP animations
245: - `useCardFlip`, `useFlyingCards` - Card animations
246: - `useGameViewHelpers` - Query game state
247: - `useGameGrid`, `useHexGrid` - Grid utilities
248: - `useCardDisplay` - Card formatting
249: 
250: ## AI System
251: 
252: ```typescript
253: import { createBot } from '@boardsmith/ai';
254: 
255: const bot = createBot(game, MyGame, 'my-game', 1, [], 'hard');
256: const move = await bot.play();
257: ```
258: 
259: **Difficulty levels**: `easy` (3 iter), `medium` (5 iter), `hard` (8 iter)
260: 
261: **Custom objectives** for better play:
262: ```typescript
263: const aiConfig = {
264:   objectives: (game, playerIndex) => ({
265:     materialAdvantage: {
266:       checker: (g, p) => myPieces > oppPieces,
267:       weight: 0.5,
268:     },
269:   }),
270: };
271: ```
272: 
273: ## CLI Commands
274: 
275: ```bash
276: boardsmith init <name>    # Create new game
277: boardsmith dev            # Start dev server
278: boardsmith dev --ai 1     # Player 1 is AI
279: boardsmith test           # Run tests
280: boardsmith validate       # Validate before publish
281: boardsmith build          # Production build
282: boardsmith publish        # Publish to boardsmith.io
283: ```
284: 
285: ## Example Games Reference
286: 
287: | Game | File | Key Patterns |
288: |------|------|--------------|
289: | Hex | `packages/games/hex/rules/src/` | Simple flow, hex grid, single action |
290: | Go Fish | `packages/games/go-fish/rules/src/` | Cards, hidden info, conditional turns |
291: | Checkers | `packages/games/checkers/rules/src/` | Grid, multi-step jumps, promotion |
292: | Cribbage | `packages/games/cribbage/rules/src/` | Multi-phase, simultaneous, scoring |
293: 
294: ## Key Files to Understand
295: 
296: 1. **Engine core**: `packages/engine/src/`
297:    - `game.ts` - Game base class
298:    - `element/` - Element system
299:    - `action/` - Action builder
300:    - `flow/` - Flow system
301:    - `command/` - Command types
302: 
303: 2. **Example game**: `packages/games/hex/rules/src/`
304:    - `game.ts` - Minimal game class
305:    - `elements.ts` - Custom elements
306:    - `actions.ts` - Action definitions
307:    - `flow.ts` - Simple flow
308: 
309: 3. **UI**: `packages/ui/src/`
310:    - `components/GameShell.vue` - Main wrapper
311:    - `composables/` - Reusable logic
312: 
313: ## Architecture Summary
314: 
315: ```
316: User Action → Action System → Commands → State Change
317:                 ↑                           ↓
318:             Flow System ←──────── Game State ←── Serialization
319:                                      ↓
320:                               Player Views → UI Render
321: ```
322: 
323: - **Actions** validate and execute player intent
324: - **Commands** are event-sourced state mutations
325: - **Flow** controls game structure and turn order
326: - **State** is an element tree, serializable to JSON
327: - **Player Views** filter state by visibility rules
328: - **UI** renders views and submits actions
````

## File: docs/ui-components.md
````markdown
  1: # UI Components & Composables
  2: 
  3: BoardSmith provides Vue 3 components and composables for building game UIs. The `@boardsmith/ui` package includes everything from high-level shells to low-level animation utilities.
  4: 
  5: ## Core Components
  6: 
  7: ### GameShell
  8: 
  9: The main wrapper component that provides the complete game UI structure: header, player panels, game board area, action panel, and game history.
 10: 
 11: ```vue
 12: <template>
 13:   <GameShell
 14:     game-type="my-game"
 15:     display-name="My Game"
 16:     :player-count="2"
 17:   >
 18:     <!-- Custom game board -->
 19:     <template #game-board="{
 20:       state,
 21:       gameView,
 22:       playerPosition,
 23:       isMyTurn,
 24:       availableActions,
 25:       action,
 26:       actionArgs,
 27:       executeAction,
 28:       setBoardPrompt
 29:     }">
 30:       <GameBoard
 31:         :game-view="gameView"
 32:         :player-position="playerPosition"
 33:         :is-my-turn="isMyTurn"
 34:         :available-actions="availableActions"
 35:         :action="action"
 36:         :action-args="actionArgs"
 37:         :execute-action="executeAction"
 38:         :set-board-prompt="setBoardPrompt"
 39:       />
 40:     </template>
 41: 
 42:     <!-- Custom player stats display -->
 43:     <template #player-stats="{ player, gameView }">
 44:       <div class="player-stat">
 45:         <span class="label">Score:</span>
 46:         <span class="value">{{ player.score }}</span>
 47:       </div>
 48:     </template>
 49:   </GameShell>
 50: </template>
 51: 
 52: <script setup lang="ts">
 53: import { GameShell } from '@boardsmith/ui';
 54: import GameBoard from './components/GameBoard.vue';
 55: </script>
 56: ```
 57: 
 58: #### Slot Props
 59: 
 60: The `#game-board` slot receives:
 61: 
 62: | Prop | Type | Description |
 63: |------|------|-------------|
 64: | `state` | `GameState` | Full game state |
 65: | `gameView` | `object` | Player-filtered view of game state |
 66: | `playerPosition` | `number` | Current player's position |
 67: | `isMyTurn` | `boolean` | Whether it's this player's turn |
 68: | `availableActions` | `string[]` | Actions available to the player |
 69: | `action` | `function` | Execute an action: `(name, args) => Promise` |
 70: | `actionArgs` | `object` | Current action arguments |
 71: | `executeAction` | `function` | Execute current action: `(name) => Promise` |
 72: | `setBoardPrompt` | `function` | Set a prompt message: `(text) => void` |
 73: 
 74: ### AutoUI
 75: 
 76: Automatic UI generation from game state. Useful for prototyping or as a reference implementation.
 77: 
 78: ```vue
 79: <template>
 80:   <AutoUI
 81:     :game-view="gameView"
 82:     :player-position="playerPosition"
 83:     :flow-state="flowState"
 84:   />
 85: </template>
 86: 
 87: <script setup lang="ts">
 88: import { AutoUI } from '@boardsmith/ui';
 89: </script>
 90: ```
 91: 
 92: The auto-generated UI includes:
 93: - **AutoGameBoard**: Renders the game element tree
 94: - **AutoElement**: Renders individual elements based on type
 95: - **ActionPanel**: Displays available actions with selection UI
 96: 
 97: ### DebugPanel
 98: 
 99: Development tool for inspecting game state, history, and debugging.
100: 
101: ```vue
102: <template>
103:   <DebugPanel
104:     :state="state"
105:     :game-view="gameView"
106:     :action-history="actionHistory"
107:   />
108: </template>
109: ```
110: 
111: ## Helper Components
112: 
113: ### DeckPile
114: 
115: Visual representation of a deck/pile of cards.
116: 
117: ```vue
118: <template>
119:   <DeckPile
120:     :count="deckCount"
121:     :clickable="canDraw"
122:     @click="onDrawCard"
123:   />
124: </template>
125: ```
126: 
127: ### CardFan
128: 
129: Display cards in a fanned layout (like a hand of cards).
130: 
131: ```vue
132: <template>
133:   <CardFan
134:     :cards="playerHand"
135:     :selectable="isMyTurn"
136:     @select="onCardSelect"
137:   />
138: </template>
139: ```
140: 
141: ### DiceRoller
142: 
143: Animated dice rolling component.
144: 
145: ```vue
146: <template>
147:   <DiceRoller
148:     :value="diceResult"
149:     :rolling="isRolling"
150:     @roll-complete="onRollComplete"
151:   />
152: </template>
153: ```
154: 
155: ### Draggable
156: 
157: Wrapper for drag-and-drop interactions.
158: 
159: ```vue
160: <template>
161:   <Draggable
162:     :disabled="!canDrag"
163:     @drag-start="onDragStart"
164:     @drag-end="onDragEnd"
165:   >
166:     <Card :card="card" />
167:   </Draggable>
168: </template>
169: ```
170: 
171: ### FlyingCardsOverlay
172: 
173: Overlay for card flight animations between positions.
174: 
175: ```vue
176: <template>
177:   <FlyingCardsOverlay
178:     :flying-cards="flyingCards"
179:   />
180: </template>
181: ```
182: 
183: ## Composables
184: 
185: ### useBoardInteraction
186: 
187: Bidirectional interaction between action panel and game board.
188: 
189: ```typescript
190: import { useBoardInteraction, createBoardInteraction, provideBoardInteraction } from '@boardsmith/ui';
191: 
192: // In GameShell (provide)
193: const boardInteraction = createBoardInteraction();
194: provideBoardInteraction(boardInteraction);
195: 
196: // In GameBoard or ActionPanel (inject)
197: const boardInteraction = useBoardInteraction();
198: 
199: // Check element states
200: boardInteraction.isHighlighted(element)  // Hovered in action panel
201: boardInteraction.isSelected(element)     // Currently selected
202: boardInteraction.isValidTarget(element)  // Valid drop/selection target
203: boardInteraction.isSelectableElement(element)  // Can be clicked to select
204: 
205: // Trigger selections
206: boardInteraction.triggerElementSelect(element)
207: 
208: // Drag and drop
209: boardInteraction.startDrag(element)
210: boardInteraction.endDrag()
211: boardInteraction.isDropTarget(element)
212: boardInteraction.isDraggedElement(element)
213: ```
214: 
215: ### useElementAnimation
216: 
217: FLIP animations for smooth element movement.
218: 
219: ```typescript
220: import { useElementAnimation } from '@boardsmith/ui';
221: 
222: const { capturePositions, animateToCurrentPositions, cancelAll } = useElementAnimation();
223: 
224: // Before state changes
225: capturePositions(containerRef.value);
226: 
227: // After state changes (in nextTick or watch)
228: animateToCurrentPositions(containerRef.value, {
229:   duration: 300,
230:   selector: '[data-animatable="true"]',
231: });
232: ```
233: 
234: Elements must have `data-animatable="true"` and `data-element-id="..."` attributes.
235: 
236: ### useCardFlip / useCardReveal
237: 
238: Card flip and reveal animations.
239: 
240: ```typescript
241: import { useCardFlip, useCardReveal } from '@boardsmith/ui';
242: 
243: const { isFlipped, flip, flipBack } = useCardFlip({
244:   duration: 300,
245: });
246: 
247: const { isRevealed, reveal } = useCardReveal({
248:   delay: 100,
249: });
250: ```
251: 
252: ### useFlyingCards
253: 
254: Manage cards flying between positions.
255: 
256: ```typescript
257: import { useFlyingCards, type FlyingCard } from '@boardsmith/ui';
258: 
259: const { flyingCards, flyCard, clearFlying } = useFlyingCards();
260: 
261: // Fly a card from one position to another
262: flyCard({
263:   id: card.id,
264:   from: { x: 100, y: 200 },
265:   to: { x: 500, y: 300 },
266:   duration: 500,
267:   onComplete: () => console.log('Card arrived'),
268: });
269: ```
270: 
271: ### useFlyOnAppear
272: 
273: Animate elements flying in when they appear.
274: 
275: ```typescript
276: import { useFlyOnAppear } from '@boardsmith/ui';
277: 
278: const { trackElement, getInitialPosition } = useFlyOnAppear({
279:   from: 'deck',  // Element ID to fly from
280:   duration: 400,
281: });
282: ```
283: 
284: ### usePlayerStatAnimation
285: 
286: Animate stat changes and fly elements to player stat displays.
287: 
288: ```typescript
289: import { usePlayerStatAnimation, flyToPlayerStat } from '@boardsmith/ui';
290: 
291: // Fly a card to a player's score display
292: flyToPlayerStat({
293:   cardElement: cardEl,
294:   playerPosition: 0,
295:   statName: 'score',
296:   onComplete: () => updateScore(),
297: });
298: ```
299: 
300: ### useGameViewHelpers
301: 
302: Utilities for querying game state.
303: 
304: ```typescript
305: import {
306:   useGameViewHelpers,
307:   findElement,
308:   findElements,
309:   findPlayerHand,
310:   getCards,
311:   getElementOwner,
312:   isMyElement,
313: } from '@boardsmith/ui';
314: 
315: // Find specific element
316: const deck = findElement(gameView, { type: 'deck' });
317: 
318: // Find player's hand
319: const myHand = findPlayerHand(gameView, playerPosition);
320: 
321: // Get all cards in an element
322: const cardsInHand = getCards(myHand);
323: 
324: // Check ownership
325: const owner = getElementOwner(card);
326: const isMine = isMyElement(card, playerPosition);
327: ```
328: 
329: ### useGameGrid
330: 
331: Utilities for square grids (chess notation, etc.).
332: 
333: ```typescript
334: import { useGameGrid, toAlgebraicNotation, fromAlgebraicNotation } from '@boardsmith/ui';
335: 
336: const { getCellAt, getAlgebraic, pixelToCell } = useGameGrid({
337:   rows: 8,
338:   cols: 8,
339:   cellSize: 60,
340: });
341: 
342: // Convert coordinates
343: const notation = toAlgebraicNotation(0, 0);  // "a1"
344: const { col, row } = fromAlgebraicNotation('e4');  // { col: 4, row: 3 }
345: ```
346: 
347: ### useHexGrid
348: 
349: Utilities for hexagonal grids.
350: 
351: ```typescript
352: import {
353:   useHexGrid,
354:   hexToPixel,
355:   getHexPolygonPoints,
356:   calculateHexDistance
357: } from '@boardsmith/ui';
358: 
359: const {
360:   hexToPixel,
361:   pixelToHex,
362:   getHexCorners,
363:   getNeighbors
364: } = useHexGrid({
365:   size: 30,
366:   orientation: 'flat',  // or 'pointy'
367: });
368: 
369: // Convert hex coords to pixel position
370: const { x, y } = hexToPixel(3, 2, 30, 'flat');
371: 
372: // Get SVG polygon points for a hex cell
373: const points = getHexPolygonPoints(cx, cy, size, 'flat');
374: 
375: // Calculate distance between hexes
376: const dist = calculateHexDistance(q1, r1, q2, r2);
377: ```
378: 
379: ### useCardDisplay
380: 
381: Card display formatting utilities.
382: 
383: ```typescript
384: import {
385:   useCardDisplay,
386:   getSuitSymbol,
387:   getSuitColor,
388:   getRankName,
389:   isRedSuit
390: } from '@boardsmith/ui';
391: 
392: getSuitSymbol('H');  // "♥"
393: getSuitSymbol('D');  // "♦"
394: getSuitSymbol('C');  // "♣"
395: getSuitSymbol('S');  // "♠"
396: 
397: getSuitColor('H');   // "#e74c3c" (red)
398: getSuitColor('S');   // "#2c3e50" (black)
399: 
400: getRankName('K');    // "King"
401: isRedSuit('D');      // true
402: ```
403: 
404: ### useElementChangeTracker
405: 
406: Track element position and count changes for animations.
407: 
408: ```typescript
409: import { useElementChangeTracker, useCountTracker } from '@boardsmith/ui';
410: 
411: const { trackElements, getChanges } = useElementChangeTracker();
412: 
413: // Track element movements
414: trackElements(gameView);
415: // ... state changes ...
416: const changes = getChanges(gameView);  // { added, removed, moved }
417: 
418: // Track count changes
419: const { track, getChange } = useCountTracker();
420: track('deckCount', deck.children.length);
421: const delta = getChange('deckCount');  // e.g., -3 (deck lost 3 cards)
422: ```
423: 
424: ### useFLIPAnimation
425: 
426: Low-level FLIP (First, Last, Invert, Play) animation utility.
427: 
428: ```typescript
429: import { useFLIPAnimation, createFLIPSnapshot } from '@boardsmith/ui';
430: 
431: const { recordFirst, recordLast, play } = useFLIPAnimation({
432:   duration: 300,
433:   easing: 'ease-out',
434: });
435: 
436: // Before change
437: recordFirst(elements);
438: 
439: // After change
440: recordLast(elements);
441: 
442: // Animate
443: play();
444: ```
445: 
446: ## Theming
447: 
448: Customize the UI appearance with themes.
449: 
450: ```typescript
451: import { applyTheme, type ThemeConfig } from '@boardsmith/ui';
452: 
453: const customTheme: ThemeConfig = {
454:   primary: '#00d9ff',
455:   secondary: '#00ff88',
456:   background: '#1a1a2e',
457:   surface: '#16213e',
458:   text: '#ffffff',
459:   textMuted: '#888888',
460:   error: '#e74c3c',
461:   success: '#00ff88',
462: };
463: 
464: applyTheme(customTheme);
465: ```
466: 
467: ## Building Custom UIs
468: 
469: ### Example: Custom Game Board
470: 
471: ```vue
472: <script setup lang="ts">
473: import { computed, ref } from 'vue';
474: import { useBoardInteraction, useElementAnimation, findPlayerHand, getCards } from '@boardsmith/ui';
475: 
476: const props = defineProps<{
477:   gameView: any;
478:   playerPosition: number;
479:   isMyTurn: boolean;
480:   availableActions: string[];
481:   action: (name: string, args: Record<string, unknown>) => Promise<any>;
482: }>();
483: 
484: const boardInteraction = useBoardInteraction();
485: const { capturePositions, animateToCurrentPositions } = useElementAnimation();
486: const containerRef = ref<HTMLElement>();
487: 
488: // Extract data from game view
489: const myHand = computed(() => {
490:   const hand = findPlayerHand(props.gameView, props.playerPosition);
491:   return hand ? getCards(hand) : [];
492: });
493: 
494: // Handle card click
495: async function onCardClick(card: any) {
496:   if (!props.isMyTurn) return;
497:   if (!props.availableActions.includes('play')) return;
498: 
499:   // Check if card is selectable via board interaction
500:   if (boardInteraction?.isSelectableElement(card)) {
501:     boardInteraction.triggerElementSelect(card);
502:   } else {
503:     // Direct action
504:     await props.action('play', { card: card.id });
505:   }
506: }
507: 
508: // Animate state changes
509: watch(() => props.gameView, (newView, oldView) => {
510:   if (containerRef.value && oldView) {
511:     capturePositions(containerRef.value);
512:     nextTick(() => {
513:       animateToCurrentPositions(containerRef.value!);
514:     });
515:   }
516: });
517: </script>
518: 
519: <template>
520:   <div ref="containerRef" class="game-board">
521:     <div class="hand">
522:       <div
523:         v-for="card in myHand"
524:         :key="card.id"
525:         class="card"
526:         :class="{
527:           'highlighted': boardInteraction?.isHighlighted(card),
528:           'selected': boardInteraction?.isSelected(card),
529:           'selectable': boardInteraction?.isSelectableElement(card),
530:         }"
531:         data-animatable="true"
532:         :data-element-id="card.id"
533:         @click="onCardClick(card)"
534:       >
535:         {{ card.attributes?.rank }}{{ card.attributes?.suit }}
536:       </div>
537:     </div>
538:   </div>
539: </template>
540: ```
541: 
542: ## Related Documentation
543: 
544: - [Core Concepts](./core-concepts.md) - Understanding game state
545: - [Actions & Flow](./actions-and-flow.md) - How actions work
546: - [Game Examples](./game-examples.md) - Real UI implementations
````

## File: packages/ai/src/index.ts
````typescript
 1: import type { Game, GameOptions, SerializedAction } from '@boardsmith/engine';
 2: import { MCTSBot } from './mcts-bot.js';
 3: import type { BotConfig, AIConfig, DifficultyLevel } from './types.js';
 4: import { DIFFICULTY_PRESETS } from './types.js';
 5: 
 6: // Re-export types
 7: export { MCTSBot } from './mcts-bot.js';
 8: export type {
 9:   BotConfig,
10:   BotMove,
11:   AIConfig,
12:   Objective,
13:   DifficultyLevel,
14: } from './types.js';
15: export { DIFFICULTY_PRESETS, DEFAULT_CONFIG } from './types.js';
16: 
17: /** Game class constructor type */
18: type GameClass<G extends Game = Game> = new (options: GameOptions) => G;
19: 
20: /**
21:  * Create an MCTS bot for a game
22:  *
23:  * @param game - The game instance
24:  * @param GameClass - The game class constructor (needed for cloning during simulation)
25:  * @param gameType - The game type identifier
26:  * @param playerIndex - Which player this bot controls
27:  * @param actionHistory - History of actions taken so far
28:  * @param difficulty - Difficulty level or iteration count
29:  * @param aiConfig - Optional AI configuration with objectives
30:  *
31:  * @example
32:  * ```typescript
33:  * const bot = createBot(
34:  *   game,
35:  *   CheckersGame,
36:  *   'checkers',
37:  *   1,
38:  *   actionHistory,
39:  *   'hard'
40:  * );
41:  * const move = await bot.play();
42:  * ```
43:  */
44: export function createBot<G extends Game>(
45:   game: G,
46:   GameClass: GameClass<G>,
47:   gameType: string,
48:   playerIndex: number,
49:   actionHistory: SerializedAction[] = [],
50:   difficulty: DifficultyLevel | number = 'medium',
51:   aiConfig?: AIConfig
52: ): MCTSBot<G> {
53:   const config: Partial<BotConfig> = typeof difficulty === 'number'
54:     ? { iterations: difficulty }
55:     : DIFFICULTY_PRESETS[difficulty];
56: 
57:   return new MCTSBot(
58:     game,
59:     GameClass,
60:     gameType,
61:     playerIndex,
62:     actionHistory,
63:     config,
64:     aiConfig
65:   );
66: }
67: 
68: /**
69:  * Parse AI level from string (CLI argument)
70:  */
71: export function parseAILevel(level: string): DifficultyLevel | number {
72:   // Check if it's a preset name
73:   if (level in DIFFICULTY_PRESETS) {
74:     return level as DifficultyLevel;
75:   }
76: 
77:   // Try to parse as number
78:   const num = parseInt(level, 10);
79:   if (!isNaN(num) && num > 0) {
80:     return num;
81:   }
82: 
83:   // Default to medium
84:   return 'medium';
85: }
````

## File: packages/ai/src/mcts-bot.ts
````typescript
  1: import type {
  2:   Game,
  3:   GameOptions,
  4:   Player,
  5:   FlowState,
  6:   SerializedAction,
  7:   ActionDefinition,
  8:   Selection,
  9:   GameStateSnapshot,
 10: } from '@boardsmith/engine';
 11: import { createSnapshot, deserializeAction } from '@boardsmith/engine';
 12: import type { BotConfig, BotMove, MCTSNode, AIConfig, Objective } from './types.js';
 13: import { DEFAULT_CONFIG } from './types.js';
 14: import { createSeededRandom, randomChoice } from './utils.js';
 15: 
 16: /** Game class constructor type */
 17: type GameClass<G extends Game = Game> = new (options: GameOptions) => G;
 18: 
 19: /**
 20:  * MCTS (Monte-Carlo Tree Search) Bot
 21:  *
 22:  * Implements the UCT algorithm for game-agnostic AI:
 23:  * 1. SELECT: Walk tree using UCT formula to find promising leaf
 24:  * 2. EXPAND: Try one unexplored action from that leaf
 25:  * 3. PLAYOUT: Random moves until game ends (up to playoutDepth)
 26:  * 4. BACKPROPAGATE: Update win counts up the tree
 27:  */
 28: export class MCTSBot<G extends Game = Game> {
 29:   private game: G;
 30:   private GameClass: GameClass<G>;
 31:   private gameType: string;
 32:   private playerIndex: number;
 33:   private config: BotConfig;
 34:   private objectives?: (game: Game, playerIndex: number) => Record<string, Objective>;
 35:   private rng: () => number;
 36:   private actionHistory: SerializedAction[];
 37:   private seed?: string;
 38: 
 39:   constructor(
 40:     game: G,
 41:     GameClass: GameClass<G>,
 42:     gameType: string,
 43:     playerIndex: number,
 44:     actionHistory: SerializedAction[] = [],
 45:     config: Partial<BotConfig> = {},
 46:     aiConfig?: AIConfig
 47:   ) {
 48:     this.game = game;
 49:     this.GameClass = GameClass;
 50:     this.gameType = gameType;
 51:     this.playerIndex = playerIndex;
 52:     this.actionHistory = actionHistory;
 53:     this.config = { ...DEFAULT_CONFIG, ...config };
 54:     this.objectives = aiConfig?.objectives;
 55:     this.seed = this.config.seed;
 56:     this.rng = createSeededRandom(this.config.seed);
 57:   }
 58: 
 59:   /**
 60:    * Run MCTS and return the best move
 61:    */
 62:   async play(): Promise<BotMove> {
 63:     const flowState = this.game.getFlowState();
 64:     if (!flowState?.awaitingInput) {
 65:       throw new Error('Game is not awaiting input');
 66:     }
 67: 
 68:     // Check if this is our turn (either currentPlayer matches or we're in awaitingPlayers)
 69:     if (!this.canBotAct(flowState)) {
 70:       throw new Error(`Not bot's turn (player ${this.playerIndex})`);
 71:     }
 72: 
 73:     // Get available moves at current state
 74:     const moves = this.enumerateMoves(this.game, flowState);
 75:     if (moves.length === 0) {
 76:       throw new Error('No available moves');
 77:     }
 78: 
 79:     // If only one move, return it immediately
 80:     if (moves.length === 1) {
 81:       return moves[0];
 82:     }
 83: 
 84:     // Create root node
 85:     const root = this.createNode(
 86:       this.captureSnapshot(),
 87:       flowState,
 88:       null,
 89:       null,
 90:       moves
 91:     );
 92: 
 93:     // Run MCTS iterations with timeout failsafe
 94:     const startTime = Date.now();
 95:     const timeout = this.config.timeout ?? 2000;
 96:     const chunkSize = 1; // Check timeout after each iteration
 97: 
 98:     for (let i = 0; i < this.config.iterations; i++) {
 99:       // Check timeout before each iteration
100:       if (Date.now() - startTime > timeout) {
101:         console.log(`MCTS timeout after ${i} iterations`);
102:         break;
103:       }
104: 
105:       const leaf = this.select(root);
106:       const { child, game } = this.expand(leaf);
107:       const result = this.playout(child, game);
108:       this.backpropagate(child, result);
109: 
110:       // Yield to event loop in async mode (every iteration for responsiveness)
111:       if (this.config.async) {
112:         await new Promise(resolve => setImmediate(resolve));
113:       }
114:     }
115: 
116:     // Select best child (most visits for robustness)
117:     if (root.children.length === 0) {
118:       // No children explored, pick random from initial moves
119:       return randomChoice(moves, this.rng);
120:     }
121: 
122:     const best = root.children.reduce((a, b) =>
123:       a.visits > b.visits ? a : b
124:     );
125: 
126:     return best.parentMove!;
127:   }
128: 
129:   /**
130:    * SELECTION: Walk down tree using UCT until we find a node with untried moves
131:    */
132:   private select(node: MCTSNode): MCTSNode {
133:     while (node.untriedMoves.length === 0 && node.children.length > 0) {
134:       node = this.selectChild(node);
135:     }
136:     return node;
137:   }
138: 
139:   /**
140:    * Select child using UCT (Upper Confidence Bound for Trees)
141:    */
142:   private selectChild(node: MCTSNode): MCTSNode {
143:     const C = Math.sqrt(2); // Exploration constant
144:     let best = node.children[0];
145:     let bestUCT = -Infinity;
146: 
147:     for (const child of node.children) {
148:       const visits = child.visits + 1e-6; // Avoid division by zero
149:       const exploitation = child.value / visits;
150:       const exploration = C * Math.sqrt(Math.log(node.visits + 1) / visits);
151:       const uct = exploitation + exploration;
152: 
153:       if (uct > bestUCT) {
154:         bestUCT = uct;
155:         best = child;
156:       }
157:     }
158:     return best;
159:   }
160: 
161:   /**
162:    * EXPANSION: Add one child node for an untried move
163:    * Returns both the child node and the game instance for reuse in playout
164:    */
165:   private expand(node: MCTSNode): { child: MCTSNode; game: Game | null } {
166:     if (node.untriedMoves.length === 0 || node.flowState.complete) {
167:       return { child: node, game: null };
168:     }
169: 
170:     // Pick random untried move
171:     const idx = Math.floor(this.rng() * node.untriedMoves.length);
172:     const move = node.untriedMoves.splice(idx, 1)[0];
173: 
174:     // Restore game once and reuse it
175:     const game = this.restoreGame(node.snapshot);
176:     if (!game) {
177:       // Restoration failed - return current node without expanding
178:       return { child: node, game: null };
179:     }
180: 
181:     // Use the current player from flow state (handles simultaneous actions)
182:     const currentPlayer = this.getCurrentPlayerFromFlowState(node.flowState);
183: 
184:     // Try to apply the move - if it fails, return the current node without expanding
185:     let flowState: FlowState;
186:     try {
187:       flowState = game.continueFlow(move.action, move.args, currentPlayer);
188:     } catch (error) {
189:       // Move failed during simulation - this can happen with complex game state transitions
190:       // Return the current node and let playout evaluate it
191:       return { child: node, game: null };
192:     }
193: 
194:     // Get available moves for the NEXT player (whoever's turn it is now)
195:     const newMoves = flowState.complete ? [] : this.enumerateMovesForSimulation(game as G, flowState);
196: 
197:     // Create snapshot for storing in tree (needed for future expansions)
198:     const newActionHistory = [
199:       ...node.snapshot.actionHistory,
200:       {
201:         name: move.action,
202:         player: currentPlayer,
203:         args: move.args,
204:         timestamp: Date.now(),
205:       },
206:     ];
207:     const snapshot = createSnapshot(game, this.gameType, newActionHistory, node.snapshot.seed);
208: 
209:     const child = this.createNode(snapshot, flowState, node, move, newMoves);
210:     node.children.push(child);
211: 
212:     return { child, game };
213:   }
214: 
215:   /**
216:    * PLAYOUT: Random simulation until game ends or depth limit
217:    * Can optionally receive a pre-created game instance from expand()
218:    */
219:   private playout(node: MCTSNode, existingGame: Game | null): number {
220:     // Reuse existing game if provided, otherwise restore
221:     const game = existingGame ?? this.restoreGame(node.snapshot);
222:     if (!game) {
223:       // Restoration failed - return neutral result
224:       return 0.5;
225:     }
226: 
227:     let flowState = node.flowState;
228:     let depth = 0;
229: 
230:     while (!flowState.complete && depth < this.config.playoutDepth) {
231:       // Get available moves for the current player (whoever's turn it is)
232:       const moves = this.enumerateMovesForSimulation(game as G, flowState);
233:       if (moves.length === 0) {
234:         break;
235:       }
236: 
237:       // Random move
238:       const move = randomChoice(moves, this.rng);
239: 
240:       // Apply move for the current player (handles simultaneous actions)
241:       const currentPlayer = this.getCurrentPlayerFromFlowState(flowState);
242: 
243:       // Try to apply the move - if it fails, stop the playout
244:       try {
245:         flowState = game.continueFlow(move.action, move.args, currentPlayer);
246:       } catch (error) {
247:         // Move failed during simulation - stop playout and evaluate current state
248:         break;
249:       }
250:       depth++;
251:     }
252: 
253:     // Evaluate using the final game state
254:     return this.evaluateTerminalFromGame(game, flowState);
255:   }
256: 
257:   /**
258:    * BACKPROPAGATION: Update statistics up the tree
259:    */
260:   private backpropagate(node: MCTSNode | null, result: number): void {
261:     while (node !== null) {
262:       node.visits++;
263:       // Value is from perspective of player who just moved to reach this node
264:       // If it's our player's turn at parent, result is good for us
265:       // If it's opponent's turn at parent, result is bad for them (good for us)
266:       const isOurPerspective = node.parent === null ||
267:         node.parent.currentPlayer === this.playerIndex;
268:       node.value += isOurPerspective ? result : (1 - result);
269:       node = node.parent;
270:     }
271:   }
272: 
273:   /**
274:    * Check if the bot can act in the current flow state
275:    */
276:   private canBotAct(flowState: FlowState): boolean {
277:     // Simultaneous action step - check awaitingPlayers first (takes priority)
278:     if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
279:       const playerState = flowState.awaitingPlayers.find(
280:         p => p.playerIndex === this.playerIndex && !p.completed
281:       );
282:       return playerState !== undefined && playerState.availableActions.length > 0;
283:     }
284: 
285:     // Regular action step - check currentPlayer
286:     if (flowState.currentPlayer !== undefined) {
287:       return flowState.currentPlayer === this.playerIndex;
288:     }
289: 
290:     return false;
291:   }
292: 
293:   /**
294:    * Get available actions for the bot player from flow state
295:    */
296:   private getAvailableActionsForBot(flowState: FlowState): string[] {
297:     // Simultaneous action step - check awaitingPlayers first (takes priority)
298:     if (flowState.awaitingPlayers) {
299:       const playerState = flowState.awaitingPlayers.find(
300:         p => p.playerIndex === this.playerIndex && !p.completed
301:       );
302:       if (playerState && playerState.availableActions.length > 0) {
303:         return playerState.availableActions;
304:       }
305:     }
306: 
307:     // Regular action step - use availableActions if currentPlayer matches
308:     if (flowState.availableActions && flowState.availableActions.length > 0 &&
309:         flowState.currentPlayer === this.playerIndex) {
310:       return flowState.availableActions;
311:     }
312: 
313:     // Fallback to availableActions if currentPlayer matches or is undefined
314:     if (flowState.availableActions && flowState.availableActions.length > 0) {
315:       return flowState.availableActions;
316:     }
317: 
318:     return [];
319:   }
320: 
321:   /**
322:    * Enumerate all valid moves for the bot player at current game state
323:    * Used for the initial move selection
324:    */
325:   private enumerateMoves(game: G, flowState: FlowState): BotMove[] {
326:     const moves: BotMove[] = [];
327:     const actions = this.getAvailableActionsForBot(flowState);
328:     const player = game.players[this.playerIndex];
329: 
330:     for (const actionName of actions) {
331:       const actionDef = game.getAction(actionName);
332:       if (!actionDef) continue;
333: 
334:       // Generate all valid argument combinations
335:       const argCombos = this.enumerateSelections(game, actionDef, player);
336:       for (const args of argCombos) {
337:         moves.push({ action: actionName, args });
338:       }
339:     }
340: 
341:     return moves;
342:   }
343: 
344:   /**
345:    * Enumerate all valid moves for the current player (whoever's turn it is)
346:    * Used during MCTS simulation (expand/playout)
347:    */
348:   private enumerateMovesForSimulation(game: G, flowState: FlowState): BotMove[] {
349:     const moves: BotMove[] = [];
350: 
351:     // Get the current player from flow state
352:     let currentPlayerIndex = flowState.currentPlayer;
353:     let actions: string[] = flowState.availableActions ?? [];
354: 
355:     // For simultaneous actions, pick the first awaiting player
356:     if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
357:       const firstAwaiting = flowState.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
358:       if (firstAwaiting) {
359:         currentPlayerIndex = firstAwaiting.playerIndex;
360:         actions = firstAwaiting.availableActions;
361:       }
362:     }
363: 
364:     if (currentPlayerIndex === undefined) {
365:       return moves;
366:     }
367: 
368:     const player = game.players[currentPlayerIndex];
369:     if (!player) {
370:       return moves;
371:     }
372: 
373:     for (const actionName of actions) {
374:       const actionDef = game.getAction(actionName);
375:       if (!actionDef) continue;
376: 
377:       // Generate all valid argument combinations
378:       const argCombos = this.enumerateSelections(game, actionDef, player);
379:       for (const args of argCombos) {
380:         moves.push({ action: actionName, args });
381:       }
382:     }
383: 
384:     return moves;
385:   }
386: 
387:   /**
388:    * Get the current player index from flow state (for simulation)
389:    */
390:   private getCurrentPlayerFromFlowState(flowState: FlowState): number {
391:     // For simultaneous actions, pick the first awaiting player
392:     if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
393:       const firstAwaiting = flowState.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
394:       if (firstAwaiting) {
395:         return firstAwaiting.playerIndex;
396:       }
397:     }
398:     return flowState.currentPlayer ?? this.playerIndex;
399:   }
400: 
401:   /**
402:    * Enumerate moves from a snapshot (creates temporary game)
403:    */
404:   private enumerateMovesFromSnapshot(snapshot: GameStateSnapshot, flowState: FlowState): BotMove[] {
405:     const game = this.restoreGame(snapshot);
406:     if (!game) return [];
407:     return this.enumerateMoves(game as G, flowState);
408:   }
409: 
410:   /**
411:    * Enumerate all valid argument combinations for an action
412:    */
413:   private enumerateSelections(
414:     game: Game,
415:     actionDef: ActionDefinition,
416:     player: Player
417:   ): Record<string, unknown>[] {
418:     if (actionDef.selections.length === 0) {
419:       return [{}];
420:     }
421: 
422:     return this.enumerateSelectionsRecursive(game, actionDef, player, 0, {});
423:   }
424: 
425:   /**
426:    * Recursively build all valid argument combinations
427:    */
428:   private enumerateSelectionsRecursive(
429:     game: Game,
430:     actionDef: ActionDefinition,
431:     player: Player,
432:     index: number,
433:     currentArgs: Record<string, unknown>
434:   ): Record<string, unknown>[] {
435:     if (index >= actionDef.selections.length) {
436:       return [{ ...currentArgs }];
437:     }
438: 
439:     const selection = actionDef.selections[index];
440:     const choices = this.getChoicesForSelection(game, actionDef.name, selection, player, currentArgs);
441: 
442:     // Handle text and number inputs (skip for AI - can't enumerate)
443:     if (selection.type === 'text' || selection.type === 'number') {
444:       if (selection.optional) {
445:         return this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, currentArgs);
446:       }
447:       // Required text/number input - AI can't handle this
448:       return [];
449:     }
450: 
451:     if (choices.length === 0) {
452:       if (selection.optional) {
453:         return this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, currentArgs);
454:       }
455:       return [];
456:     }
457: 
458:     const results: Record<string, unknown>[] = [];
459: 
460:     // Limit branching factor to avoid combinatorial explosion
461:     const maxChoices = 20;
462:     const sampledChoices = choices.length > maxChoices
463:       ? this.sampleChoices(choices, maxChoices)
464:       : choices;
465: 
466:     for (const choice of sampledChoices) {
467:       // Serialize the choice for args
468:       const serializedChoice = this.serializeChoice(choice, selection);
469:       const newArgs = { ...currentArgs, [selection.name]: serializedChoice };
470:       const subResults = this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, newArgs);
471:       results.push(...subResults);
472:     }
473: 
474:     return results;
475:   }
476: 
477:   /**
478:    * Get valid choices for a selection
479:    */
480:   private getChoicesForSelection(
481:     game: Game,
482:     actionName: string,
483:     selection: Selection,
484:     player: Player,
485:     currentArgs: Record<string, unknown>
486:   ): unknown[] {
487:     return game.getSelectionChoices(actionName, selection.name, player as any, currentArgs);
488:   }
489: 
490:   /**
491:    * Serialize a choice value for action args
492:    */
493:   private serializeChoice(choice: unknown, selection: Selection): unknown {
494:     if (selection.type === 'player') {
495:       return (choice as Player).position;
496:     }
497:     if (selection.type === 'element') {
498:       return (choice as { _t: { id: number } })._t.id;
499:     }
500:     return choice;
501:   }
502: 
503:   /**
504:    * Sample choices to limit branching
505:    */
506:   private sampleChoices<T>(choices: T[], maxCount: number): T[] {
507:     if (choices.length <= maxCount) return choices;
508: 
509:     const sampled: T[] = [];
510:     const indices = new Set<number>();
511: 
512:     while (sampled.length < maxCount) {
513:       const idx = Math.floor(this.rng() * choices.length);
514:       if (!indices.has(idx)) {
515:         indices.add(idx);
516:         sampled.push(choices[idx]);
517:       }
518:     }
519: 
520:     return sampled;
521:   }
522: 
523:   /**
524:    * Capture current game state as snapshot
525:    */
526:   private captureSnapshot(): GameStateSnapshot {
527:     return createSnapshot(this.game, this.gameType, this.actionHistory, this.seed);
528:   }
529: 
530:   /**
531:    * Restore a game from snapshot
532:    * Returns null if restoration fails (e.g., due to complex phase transitions)
533:    */
534:   private restoreGame(snapshot: GameStateSnapshot): Game | null {
535:     try {
536:       const game = new this.GameClass({
537:         playerCount: snapshot.state.players.length,
538:         playerNames: snapshot.state.players.map(p => p.name as string),
539:         seed: snapshot.seed,
540:       });
541: 
542:       // Replay commands to restore element state
543:       game.replayCommands(snapshot.commandHistory);
544: 
545:       // Start flow and replay actions
546:       game.startFlow();
547:       for (const action of snapshot.actionHistory) {
548:         const { actionName, player, args } = deserializeAction(action, game);
549:         // Pass the player position to continueFlow (required for simultaneous actions)
550:         game.continueFlow(actionName, args, player.position);
551:       }
552: 
553:       return game;
554:     } catch (error) {
555:       // Restoration failed - this can happen with complex game state transitions
556:       return null;
557:     }
558:   }
559: 
560:   /**
561:    * Apply a move to a snapshot, returning new snapshot and flow state
562:    * Returns null if the game cannot be restored or move fails
563:    */
564:   private applyMove(
565:     snapshot: GameStateSnapshot,
566:     move: BotMove
567:   ): { snapshot: GameStateSnapshot; flowState: FlowState } | null {
568:     const game = this.restoreGame(snapshot);
569:     if (!game) return null;
570: 
571:     const currentPlayer = game.getFlowState()?.currentPlayer ?? this.playerIndex;
572: 
573:     // Apply the move
574:     let flowState: FlowState;
575:     try {
576:       flowState = game.continueFlow(move.action, move.args, currentPlayer);
577:     } catch (error) {
578:       return null;
579:     }
580: 
581:     // Create new snapshot with updated action history
582:     const newActionHistory = [
583:       ...snapshot.actionHistory,
584:       {
585:         name: move.action,
586:         player: currentPlayer,
587:         args: move.args,
588:         timestamp: Date.now(),
589:       },
590:     ];
591: 
592:     const newSnapshot = createSnapshot(game, this.gameType, newActionHistory, snapshot.seed);
593: 
594:     return { snapshot: newSnapshot, flowState };
595:   }
596: 
597:   /**
598:    * Create an MCTS node
599:    */
600:   private createNode(
601:     snapshot: GameStateSnapshot,
602:     flowState: FlowState,
603:     parent: MCTSNode | null,
604:     parentMove: BotMove | null,
605:     untriedMoves: BotMove[]
606:   ): MCTSNode {
607:     return {
608:       snapshot,
609:       flowState,
610:       parent,
611:       parentMove,
612:       children: [],
613:       untriedMoves: [...untriedMoves],
614:       visits: 0,
615:       value: 0,
616:       currentPlayer: flowState.currentPlayer ?? this.playerIndex,
617:     };
618:   }
619: 
620:   /**
621:    * Evaluate objectives at a position
622:    */
623:   private evaluateObjectives(snapshot: GameStateSnapshot): number {
624:     if (!this.objectives) return 0;
625: 
626:     const game = this.restoreGame(snapshot);
627:     if (!game) return 0;
628: 
629:     const objectives = this.objectives(game, this.playerIndex);
630: 
631:     let totalScore = 0;
632:     for (const obj of Object.values(objectives)) {
633:       if (obj.checker(game, this.playerIndex)) {
634:         totalScore += obj.weight;
635:       }
636:     }
637: 
638:     return totalScore;
639:   }
640: 
641:   /**
642:    * Evaluate terminal position from snapshot
643:    */
644:   private evaluateTerminal(snapshot: GameStateSnapshot, flowState: FlowState): number {
645:     if (!flowState.complete) {
646:       // Game didn't complete - use objectives if available
647:       if (this.objectives) {
648:         const score = this.evaluateObjectives(snapshot);
649:         // Normalize to [0, 1]
650:         return score > 0 ? 0.6 : (score < 0 ? 0.4 : 0.5);
651:       }
652:       return 0.5; // Draw/unknown
653:     }
654: 
655:     // Check for winner
656:     const winners = snapshot.state.settings.winners as number[] | undefined;
657:     if (!winners || winners.length === 0) {
658:       return 0.5; // Draw
659:     }
660: 
661:     if (winners.includes(this.playerIndex)) {
662:       return 1; // Win
663:     }
664: 
665:     return 0; // Loss
666:   }
667: 
668:   /**
669:    * Evaluate terminal position directly from game instance (faster, no snapshot needed)
670:    */
671:   private evaluateTerminalFromGame(game: Game, flowState: FlowState): number {
672:     if (!flowState.complete) {
673:       // Game didn't complete - use objectives if available
674:       if (this.objectives) {
675:         const objectives = this.objectives(game, this.playerIndex);
676:         let totalScore = 0;
677:         for (const obj of Object.values(objectives)) {
678:           if (obj.checker(game, this.playerIndex)) {
679:             totalScore += obj.weight;
680:           }
681:         }
682:         // Normalize to [0, 1]
683:         return totalScore > 0 ? 0.6 : (totalScore < 0 ? 0.4 : 0.5);
684:       }
685:       return 0.5; // Draw/unknown
686:     }
687: 
688:     // Check for winner from game settings
689:     const winners = (game as any).settings?.winners as number[] | undefined;
690:     if (!winners || winners.length === 0) {
691:       return 0.5; // Draw
692:     }
693: 
694:     if (winners.includes(this.playerIndex)) {
695:       return 1; // Win
696:     }
697: 
698:     return 0; // Loss
699:   }
700: }
````

## File: packages/ai/src/types.ts
````typescript
 1: import type { Game, Player, FlowState, GameStateSnapshot } from '@boardsmith/engine';
 2: 
 3: /**
 4:  * Configuration options for the MCTS bot
 5:  */
 6: export interface BotConfig {
 7:   /** Number of MCTS iterations (higher = stronger but slower). Default: 1000 */
 8:   iterations: number;
 9:   /** Maximum playout depth before evaluating position. Default: 50 */
10:   playoutDepth: number;
11:   /** Random seed for reproducible behavior */
12:   seed?: string;
13:   /** Run async to yield to event loop (prevents UI freezing). Default: true */
14:   async?: boolean;
15:   /** Maximum time in milliseconds before returning best move found. Default: 2000 */
16:   timeout?: number;
17: }
18: 
19: /**
20:  * A move the bot can make
21:  */
22: export interface BotMove {
23:   /** The action name to perform */
24:   action: string;
25:   /** The arguments for the action */
26:   args: Record<string, unknown>;
27: }
28: 
29: /**
30:  * Internal node in the MCTS search tree
31:  */
32: export interface MCTSNode {
33:   /** Serialized game state at this node */
34:   snapshot: GameStateSnapshot;
35:   /** Flow state at this node */
36:   flowState: FlowState;
37:   /** Parent node (null for root) */
38:   parent: MCTSNode | null;
39:   /** Move that led to this node */
40:   parentMove: BotMove | null;
41:   /** Child nodes that have been explored */
42:   children: MCTSNode[];
43:   /** Moves that haven't been tried yet */
44:   untriedMoves: BotMove[];
45:   /** Number of times this node has been visited */
46:   visits: number;
47:   /** Cumulative value (wins) from this node */
48:   value: number;
49:   /** Which player is to move at this node */
50:   currentPlayer: number;
51: }
52: 
53: /**
54:  * An objective that guides AI decision-making during playouts
55:  */
56: export interface Objective {
57:   /** Function to check if this objective is achieved */
58:   checker: (game: Game, playerIndex: number) => boolean;
59:   /** Weight for this objective (positive = good for player, negative = bad) */
60:   weight: number;
61: }
62: 
63: /**
64:  * AI configuration that can be attached to a game definition
65:  */
66: export interface AIConfig {
67:   /**
68:    * Optional objectives function to guide AI decisions.
69:    * Returns objectives that give partial credit during playouts.
70:    */
71:   objectives?: (game: Game, playerIndex: number) => Record<string, Objective>;
72: }
73: 
74: /**
75:  * Default bot configuration
76:  */
77: export const DEFAULT_CONFIG: BotConfig = {
78:   iterations: 100,
79:   playoutDepth: 5,
80:   async: true,
81:   timeout: 2000,
82: };
83: 
84: /**
85:  * Preset difficulty levels
86:  * Note: iterations are kept very low because game operations are slow (~18ms per move).
87:  * The timeout ensures the bot always returns within a reasonable time.
88:  */
89: export const DIFFICULTY_PRESETS: Record<string, Partial<BotConfig>> = {
90:   easy: { iterations: 3, playoutDepth: 3, timeout: 1000 },
91:   medium: { iterations: 5, playoutDepth: 4, timeout: 1500 },
92:   hard: { iterations: 8, playoutDepth: 5, timeout: 2000 },
93: };
94: 
95: /**
96:  * Difficulty level type
97:  */
98: export type DifficultyLevel = keyof typeof DIFFICULTY_PRESETS;
````

## File: packages/ai/src/utils.ts
````typescript
 1: /**
 2:  * Create a seeded random number generator using mulberry32 algorithm.
 3:  * Returns numbers in [0, 1) range.
 4:  */
 5: export function createSeededRandom(seed?: string): () => number {
 6:   // Convert string seed to number using simple hash
 7:   let h = 0;
 8:   const seedStr = seed ?? Math.random().toString(36).substring(2);
 9:   for (let i = 0; i < seedStr.length; i++) {
10:     h = Math.imul(31, h) + seedStr.charCodeAt(i) | 0;
11:   }
12: 
13:   // Mulberry32 PRNG
14:   return function () {
15:     h |= 0;
16:     h = h + 0x6D2B79F5 | 0;
17:     let t = Math.imul(h ^ h >>> 15, 1 | h);
18:     t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
19:     return ((t ^ t >>> 14) >>> 0) / 4294967296;
20:   };
21: }
22: 
23: /**
24:  * Pick a random element from an array using the provided RNG
25:  */
26: export function randomChoice<T>(array: T[], rng: () => number): T {
27:   return array[Math.floor(rng() * array.length)];
28: }
29: 
30: /**
31:  * Shuffle an array in place using Fisher-Yates and the provided RNG
32:  */
33: export function shuffle<T>(array: T[], rng: () => number): T[] {
34:   for (let i = array.length - 1; i > 0; i--) {
35:     const j = Math.floor(rng() * (i + 1));
36:     [array[i], array[j]] = [array[j], array[i]];
37:   }
38:   return array;
39: }
````

## File: packages/ai/package.json
````json
 1: {
 2:   "name": "@boardsmith/ai",
 3:   "version": "0.0.1",
 4:   "description": "MCTS AI bot for BoardSmith games - provides generic AI opponents that work with any game",
 5:   "type": "module",
 6:   "main": "./dist/index.js",
 7:   "types": "./dist/index.d.ts",
 8:   "scripts": {
 9:     "build": "tsc",
10:     "test": "vitest run"
11:   },
12:   "dependencies": {
13:     "@boardsmith/engine": "workspace:*"
14:   },
15:   "devDependencies": {
16:     "@boardsmith/checkers-rules": "workspace:*",
17:     "@boardsmith/cribbage-rules": "workspace:*",
18:     "typescript": "^5.6.3",
19:     "vitest": "^2.1.9"
20:   }
21: }
````

## File: packages/cli/src/commands/build.ts
````typescript
 1: import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';
 2: import { join } from 'node:path';
 3: import { build as viteBuild } from 'vite';
 4: import chalk from 'chalk';
 5: import ora from 'ora';
 6: 
 7: interface BuildOptions {
 8:   outDir?: string;
 9: }
10: 
11: export async function buildCommand(options: BuildOptions): Promise<void> {
12:   const cwd = process.cwd();
13:   const outDir = options.outDir || 'dist';
14: 
15:   // Validate project
16:   const configPath = join(cwd, 'boardsmith.json');
17:   if (!existsSync(configPath)) {
18:     console.error(chalk.red('Error: boardsmith.json not found'));
19:     console.error(chalk.dim('Make sure you are in a BoardSmith game project directory'));
20:     process.exit(1);
21:   }
22: 
23:   const config = JSON.parse(readFileSync(configPath, 'utf-8'));
24:   console.log(chalk.cyan(`\nBuilding ${config.displayName || config.name}...\n`));
25: 
26:   const spinner = ora('Building game rules...').start();
27: 
28:   try {
29:     // Build rules (TypeScript -> JS)
30:     await viteBuild({
31:       root: cwd,
32:       build: {
33:         outDir: join(outDir, 'rules'),
34:         lib: {
35:           entry: join(cwd, 'src/rules/index.ts'),
36:           name: config.name,
37:           fileName: 'rules',
38:           formats: ['es'],
39:         },
40:         rollupOptions: {
41:           external: ['@boardsmith/engine'],
42:         },
43:         emptyOutDir: true,
44:       },
45:       logLevel: 'warn',
46:     });
47:     spinner.succeed('Game rules built');
48: 
49:     // Build UI (Vue -> JS bundle)
50:     spinner.start('Building UI...');
51:     await viteBuild({
52:       root: cwd,
53:       build: {
54:         outDir: join(outDir, 'ui'),
55:         emptyOutDir: true,
56:       },
57:       logLevel: 'warn',
58:     });
59:     spinner.succeed('UI built');
60: 
61:     // Copy and update config
62:     spinner.start('Generating manifest...');
63:     const manifest = {
64:       ...config,
65:       buildTime: new Date().toISOString(),
66:       version: config.version || '1.0.0',
67:     };
68: 
69:     mkdirSync(join(cwd, outDir), { recursive: true });
70:     writeFileSync(
71:       join(cwd, outDir, 'manifest.json'),
72:       JSON.stringify(manifest, null, 2)
73:     );
74:     spinner.succeed('Manifest generated');
75: 
76:     // Report build sizes
77:     console.log(chalk.green('\nBuild complete!\n'));
78:     console.log(chalk.dim(`  Output: ${outDir}/`));
79:     console.log(chalk.dim(`    rules/  - Game logic bundle`));
80:     console.log(chalk.dim(`    ui/     - User interface bundle`));
81:     console.log(chalk.dim(`    manifest.json - Game metadata\n`));
82: 
83:     console.log(chalk.cyan('Next steps:'));
84:     console.log(chalk.dim('  boardsmith validate  - Run pre-publish checks'));
85:     console.log(chalk.dim('  boardsmith publish   - Publish to boardsmith.io\n'));
86: 
87:   } catch (error) {
88:     spinner.fail('Build failed');
89:     console.error(chalk.red('\nBuild error:'), error);
90:     process.exit(1);
91:   }
92: }
````

## File: packages/cli/src/commands/publish.ts
````typescript
 1: import { existsSync, readFileSync } from 'node:fs';
 2: import { join } from 'node:path';
 3: import chalk from 'chalk';
 4: import ora from 'ora';
 5: 
 6: interface PublishOptions {
 7:   dryRun?: boolean;
 8: }
 9: 
10: export async function publishCommand(options: PublishOptions): Promise<void> {
11:   const cwd = process.cwd();
12: 
13:   // Validate project
14:   const configPath = join(cwd, 'boardsmith.json');
15:   if (!existsSync(configPath)) {
16:     console.error(chalk.red('Error: boardsmith.json not found'));
17:     console.error(chalk.dim('Make sure you are in a BoardSmith game project directory'));
18:     process.exit(1);
19:   }
20: 
21:   const config = JSON.parse(readFileSync(configPath, 'utf-8'));
22: 
23:   console.log(chalk.cyan(`\nPreparing to publish ${config.displayName || config.name}...\n`));
24: 
25:   // Check for built artifacts
26:   const distDir = join(cwd, 'dist');
27:   if (!existsSync(distDir)) {
28:     console.error(chalk.red('Error: No build found'));
29:     console.error(chalk.dim('Run `boardsmith build` first to create production bundles'));
30:     process.exit(1);
31:   }
32: 
33:   const spinner = ora('Validating build...').start();
34: 
35:   // Check manifest
36:   const manifestPath = join(distDir, 'manifest.json');
37:   if (!existsSync(manifestPath)) {
38:     spinner.fail('Invalid build');
39:     console.error(chalk.dim('manifest.json not found in dist/'));
40:     console.error(chalk.dim('Run `boardsmith build` to regenerate'));
41:     process.exit(1);
42:   }
43: 
44:   spinner.succeed('Build validated');
45: 
46:   if (options.dryRun) {
47:     console.log(chalk.yellow('\nDry run mode - no changes will be made\n'));
48:     console.log(chalk.dim('Would publish:'));
49:     console.log(chalk.dim(`  Game: ${config.displayName || config.name}`));
50:     console.log(chalk.dim(`  Version: ${config.version || '1.0.0'}`));
51:     console.log(chalk.dim(`  Players: ${config.playerCount?.min}-${config.playerCount?.max}`));
52:     console.log('');
53:     return;
54:   }
55: 
56:   // Check authentication (stub - platform not built yet)
57:   spinner.start('Checking authentication...');
58: 
59:   // Simulate auth check
60:   await sleep(500);
61:   spinner.warn('Authentication required');
62: 
63:   console.log(chalk.yellow('\nPublishing is not yet available.\n'));
64:   console.log(chalk.dim('The boardsmith.io platform is coming soon!'));
65:   console.log(chalk.dim('For now, use `boardsmith dev` to test your game locally.\n'));
66: 
67:   console.log(chalk.cyan('What you can do now:'));
68:   console.log(chalk.dim('  boardsmith dev       - Test locally with multiple players'));
69:   console.log(chalk.dim('  boardsmith validate  - Ensure your game meets requirements'));
70:   console.log(chalk.dim('  boardsmith build     - Create production bundles\n'));
71: 
72:   console.log(chalk.dim('Stay tuned for boardsmith.io launch!\n'));
73: }
74: 
75: function sleep(ms: number): Promise<void> {
76:   return new Promise(resolve => setTimeout(resolve, ms));
77: }
````

## File: packages/cli/src/commands/test.ts
````typescript
 1: import { existsSync } from 'node:fs';
 2: import { join } from 'node:path';
 3: import { spawn } from 'node:child_process';
 4: import chalk from 'chalk';
 5: 
 6: interface TestOptions {
 7:   watch?: boolean;
 8:   coverage?: boolean;
 9: }
10: 
11: export async function testCommand(options: TestOptions): Promise<void> {
12:   const cwd = process.cwd();
13: 
14:   // Validate project
15:   const configPath = join(cwd, 'boardsmith.json');
16:   if (!existsSync(configPath)) {
17:     console.error(chalk.red('Error: boardsmith.json not found'));
18:     console.error(chalk.dim('Make sure you are in a BoardSmith game project directory'));
19:     process.exit(1);
20:   }
21: 
22:   // Check for test files
23:   const testsDir = join(cwd, 'tests');
24:   if (!existsSync(testsDir)) {
25:     console.log(chalk.yellow('No tests directory found.'));
26:     console.log(chalk.dim('Create tests in the tests/ directory'));
27:     process.exit(0);
28:   }
29: 
30:   console.log(chalk.cyan('\nRunning game tests...\n'));
31: 
32:   // Build vitest args
33:   const args = ['vitest', 'run'];
34: 
35:   if (options.watch) {
36:     args[1] = 'watch';
37:   }
38: 
39:   if (options.coverage) {
40:     args.push('--coverage');
41:   }
42: 
43:   // Run vitest via npx
44:   const child = spawn('npx', args, {
45:     cwd,
46:     stdio: 'inherit',
47:     shell: true,
48:   });
49: 
50:   child.on('close', (code) => {
51:     if (code === 0) {
52:       console.log(chalk.green('\nAll tests passed!\n'));
53:     } else {
54:       console.log(chalk.red(`\nTests failed with exit code ${code}\n`));
55:       process.exit(code || 1);
56:     }
57:   });
58: 
59:   child.on('error', (error) => {
60:     console.error(chalk.red('Failed to run tests:'), error.message);
61:     console.log(chalk.dim('\nMake sure vitest is installed:'));
62:     console.log(chalk.dim('  npm install -D vitest\n'));
63:     process.exit(1);
64:   });
65: }
````

## File: packages/cli/src/commands/validate.ts
````typescript
  1: import { existsSync, readFileSync, statSync, readdirSync } from 'node:fs';
  2: import { join } from 'node:path';
  3: import { spawn } from 'node:child_process';
  4: import chalk from 'chalk';
  5: import ora from 'ora';
  6: 
  7: interface ValidateOptions {
  8:   fix?: boolean;
  9:   skipSimulation?: boolean;
 10: }
 11: 
 12: interface ValidationResult {
 13:   name: string;
 14:   passed: boolean;
 15:   message: string;
 16:   details?: string[];
 17: }
 18: 
 19: export async function validateCommand(options: ValidateOptions): Promise<void> {
 20:   const cwd = process.cwd();
 21: 
 22:   // Validate project exists
 23:   const configPath = join(cwd, 'boardsmith.json');
 24:   if (!existsSync(configPath)) {
 25:     console.error(chalk.red('Error: boardsmith.json not found'));
 26:     console.error(chalk.dim('Make sure you are in a BoardSmith game project directory'));
 27:     process.exit(1);
 28:   }
 29: 
 30:   console.log(chalk.cyan('\nValidating game...\n'));
 31: 
 32:   const results: ValidationResult[] = [];
 33: 
 34:   // 1. Check metadata completeness
 35:   results.push(await validateMetadata(cwd));
 36: 
 37:   // 2. TypeScript compilation
 38:   results.push(await validateTypeScript(cwd));
 39: 
 40:   // 3. Security checks (forbidden APIs)
 41:   results.push(await validateSecurity(cwd));
 42: 
 43:   // 4. Bundle size check
 44:   results.push(await validateBundleSize(cwd));
 45: 
 46:   // 5. Required files check
 47:   results.push(await validateRequiredFiles(cwd));
 48: 
 49:   // Print results
 50:   console.log(chalk.cyan('\nValidation Results:\n'));
 51: 
 52:   let allPassed = true;
 53:   for (const result of results) {
 54:     const icon = result.passed ? chalk.green('✓') : chalk.red('✗');
 55:     const status = result.passed ? chalk.green('PASS') : chalk.red('FAIL');
 56:     console.log(`  ${icon} ${result.name}: ${status}`);
 57: 
 58:     if (!result.passed) {
 59:       allPassed = false;
 60:       console.log(chalk.dim(`    ${result.message}`));
 61:       if (result.details) {
 62:         for (const detail of result.details) {
 63:           console.log(chalk.dim(`      - ${detail}`));
 64:         }
 65:       }
 66:     }
 67:   }
 68: 
 69:   console.log('');
 70: 
 71:   if (allPassed) {
 72:     console.log(chalk.green('All validation checks passed!\n'));
 73:     console.log(chalk.cyan('Next steps:'));
 74:     console.log(chalk.dim('  boardsmith build    - Build for production'));
 75:     console.log(chalk.dim('  boardsmith publish  - Publish to boardsmith.io\n'));
 76:   } else {
 77:     console.log(chalk.red('Validation failed. Please fix the issues above.\n'));
 78:     process.exit(1);
 79:   }
 80: }
 81: 
 82: async function validateMetadata(cwd: string): Promise<ValidationResult> {
 83:   const configPath = join(cwd, 'boardsmith.json');
 84: 
 85:   try {
 86:     const config = JSON.parse(readFileSync(configPath, 'utf-8'));
 87:     const issues: string[] = [];
 88: 
 89:     // Required fields
 90:     const required = ['name', 'displayName', 'description', 'playerCount'];
 91:     for (const field of required) {
 92:       if (!config[field]) {
 93:         issues.push(`Missing required field: ${field}`);
 94:       }
 95:     }
 96: 
 97:     // Player count validation
 98:     if (config.playerCount) {
 99:       if (!config.playerCount.min || !config.playerCount.max) {
100:         issues.push('playerCount must have min and max');
101:       }
102:       if (config.playerCount.min > config.playerCount.max) {
103:         issues.push('playerCount.min cannot be greater than playerCount.max');
104:       }
105:     }
106: 
107:     return {
108:       name: 'Metadata',
109:       passed: issues.length === 0,
110:       message: issues.length > 0 ? 'Missing or invalid metadata' : '',
111:       details: issues,
112:     };
113:   } catch (error) {
114:     return {
115:       name: 'Metadata',
116:       passed: false,
117:       message: `Failed to parse boardsmith.json: ${(error as Error).message}`,
118:     };
119:   }
120: }
121: 
122: async function validateTypeScript(cwd: string): Promise<ValidationResult> {
123:   return new Promise((resolve) => {
124:     const child = spawn('npx', ['tsc', '--noEmit'], {
125:       cwd,
126:       shell: true,
127:       stdio: 'pipe',
128:     });
129: 
130:     let output = '';
131:     child.stdout?.on('data', (data) => { output += data; });
132:     child.stderr?.on('data', (data) => { output += data; });
133: 
134:     child.on('close', (code) => {
135:       if (code === 0) {
136:         resolve({
137:           name: 'TypeScript',
138:           passed: true,
139:           message: '',
140:         });
141:       } else {
142:         const errors = output.split('\n').filter(line =>
143:           line.includes('error TS')
144:         ).slice(0, 5);
145: 
146:         resolve({
147:           name: 'TypeScript',
148:           passed: false,
149:           message: 'TypeScript compilation failed',
150:           details: errors.length > 0 ? errors : ['Run `npx tsc --noEmit` for details'],
151:         });
152:       }
153:     });
154: 
155:     child.on('error', () => {
156:       resolve({
157:         name: 'TypeScript',
158:         passed: false,
159:         message: 'Failed to run TypeScript compiler',
160:       });
161:     });
162:   });
163: }
164: 
165: async function validateSecurity(cwd: string): Promise<ValidationResult> {
166:   const rulesDir = join(cwd, 'src/rules');
167:   if (!existsSync(rulesDir)) {
168:     return {
169:       name: 'Security',
170:       passed: false,
171:       message: 'src/rules directory not found',
172:     };
173:   }
174: 
175:   const forbiddenPatterns = [
176:     { pattern: /\bfetch\s*\(/, description: 'Network requests (fetch)' },
177:     { pattern: /\bXMLHttpRequest\b/, description: 'Network requests (XMLHttpRequest)' },
178:     { pattern: /\bimport\s*\(\s*['"]fs['"]/, description: 'Filesystem access' },
179:     { pattern: /\brequire\s*\(\s*['"]fs['"]/, description: 'Filesystem access' },
180:     { pattern: /\bsetTimeout\s*\(/, description: 'Timers (setTimeout)' },
181:     { pattern: /\bsetInterval\s*\(/, description: 'Timers (setInterval)' },
182:     { pattern: /\bDate\.now\s*\(/, description: 'Non-deterministic (Date.now)' },
183:     { pattern: /\bMath\.random\s*\(/, description: 'Non-deterministic (Math.random)' },
184:     { pattern: /\beval\s*\(/, description: 'Code evaluation (eval)' },
185:     { pattern: /\bFunction\s*\(/, description: 'Code evaluation (Function constructor)' },
186:   ];
187: 
188:   const issues: string[] = [];
189: 
190:   function scanFile(filePath: string) {
191:     const content = readFileSync(filePath, 'utf-8');
192:     const relativePath = filePath.replace(cwd + '/', '');
193: 
194:     for (const { pattern, description } of forbiddenPatterns) {
195:       if (pattern.test(content)) {
196:         // Check if it's in a comment (simple heuristic)
197:         const lines = content.split('\n');
198:         for (let i = 0; i < lines.length; i++) {
199:           const line = lines[i];
200:           // Skip comments
201:           if (line.trim().startsWith('//') || line.trim().startsWith('*')) {
202:             continue;
203:           }
204:           if (pattern.test(line)) {
205:             issues.push(`${relativePath}:${i + 1} - ${description}`);
206:             break;
207:           }
208:         }
209:       }
210:     }
211:   }
212: 
213:   function scanDir(dir: string) {
214:     const entries = readdirSync(dir, { withFileTypes: true });
215:     for (const entry of entries) {
216:       const fullPath = join(dir, entry.name);
217:       if (entry.isDirectory()) {
218:         scanDir(fullPath);
219:       } else if (entry.name.endsWith('.ts') || entry.name.endsWith('.js')) {
220:         scanFile(fullPath);
221:       }
222:     }
223:   }
224: 
225:   scanDir(rulesDir);
226: 
227:   return {
228:     name: 'Security',
229:     passed: issues.length === 0,
230:     message: issues.length > 0 ? 'Forbidden APIs detected in rules code' : '',
231:     details: issues.slice(0, 10),
232:   };
233: }
234: 
235: async function validateBundleSize(cwd: string): Promise<ValidationResult> {
236:   const maxRulesSize = 500 * 1024; // 500KB
237:   const maxUISize = 2 * 1024 * 1024; // 2MB
238: 
239:   const rulesDir = join(cwd, 'src/rules');
240:   const uiDir = join(cwd, 'src/ui');
241: 
242:   let rulesSize = 0;
243:   let uiSize = 0;
244: 
245:   function getDirSize(dir: string): number {
246:     if (!existsSync(dir)) return 0;
247: 
248:     let size = 0;
249:     const entries = readdirSync(dir, { withFileTypes: true });
250:     for (const entry of entries) {
251:       const fullPath = join(dir, entry.name);
252:       if (entry.isDirectory()) {
253:         size += getDirSize(fullPath);
254:       } else {
255:         size += statSync(fullPath).size;
256:       }
257:     }
258:     return size;
259:   }
260: 
261:   rulesSize = getDirSize(rulesDir);
262:   uiSize = getDirSize(uiDir);
263: 
264:   const issues: string[] = [];
265: 
266:   if (rulesSize > maxRulesSize) {
267:     issues.push(`Rules size (${formatBytes(rulesSize)}) exceeds limit (${formatBytes(maxRulesSize)})`);
268:   }
269: 
270:   if (uiSize > maxUISize) {
271:     issues.push(`UI size (${formatBytes(uiSize)}) exceeds limit (${formatBytes(maxUISize)})`);
272:   }
273: 
274:   return {
275:     name: 'Bundle Size',
276:     passed: issues.length === 0,
277:     message: issues.length > 0 ? 'Bundle size limits exceeded' : '',
278:     details: issues.length > 0 ? issues : [
279:       `Rules: ${formatBytes(rulesSize)} / ${formatBytes(maxRulesSize)}`,
280:       `UI: ${formatBytes(uiSize)} / ${formatBytes(maxUISize)}`,
281:     ],
282:   };
283: }
284: 
285: async function validateRequiredFiles(cwd: string): Promise<ValidationResult> {
286:   const required = [
287:     'boardsmith.json',
288:     'package.json',
289:     'src/rules/index.ts',
290:     'src/rules/game.ts',
291:     'src/ui/App.vue',
292:   ];
293: 
294:   const missing: string[] = [];
295: 
296:   for (const file of required) {
297:     if (!existsSync(join(cwd, file))) {
298:       missing.push(file);
299:     }
300:   }
301: 
302:   return {
303:     name: 'Required Files',
304:     passed: missing.length === 0,
305:     message: missing.length > 0 ? 'Missing required files' : '',
306:     details: missing,
307:   };
308: }
309: 
310: function formatBytes(bytes: number): string {
311:   if (bytes < 1024) return `${bytes} B`;
312:   if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
313:   return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
314: }
````

## File: packages/cli/src/cli.ts
````typescript
 1: #!/usr/bin/env node
 2: import { Command } from 'commander';
 3: import { initCommand } from './commands/init.js';
 4: import { devCommand } from './commands/dev.js';
 5: import { buildCommand } from './commands/build.js';
 6: import { testCommand } from './commands/test.js';
 7: import { validateCommand } from './commands/validate.js';
 8: import { publishCommand } from './commands/publish.js';
 9: 
10: const program = new Command();
11: 
12: program
13:   .name('boardsmith')
14:   .description('BoardSmith CLI - Build and run board games')
15:   .version('0.0.1');
16: 
17: // Project initialization
18: program
19:   .command('init <name>')
20:   .description('Create a new BoardSmith game project')
21:   .option('-t, --template <template>', 'Template to use (default: card-game)', 'card-game')
22:   .action(initCommand);
23: 
24: // Development
25: program
26:   .command('dev')
27:   .description('Start local development server')
28:   .option('-p, --port <port>', 'UI server port', '5173')
29:   .option('--players <count>', 'Number of player tabs to open', '2')
30:   .option('--worker-port <port>', 'Worker/API server port', '8787')
31:   .option('--ai <players...>', 'Player positions to be AI (e.g., --ai 1 or --ai 0 2)')
32:   .option('--ai-level <level>', 'AI difficulty: easy, medium, hard, expert, or iteration count', 'medium')
33:   .action(devCommand);
34: 
35: // Testing
36: program
37:   .command('test')
38:   .description('Run game tests')
39:   .option('-w, --watch', 'Watch mode - re-run tests on changes')
40:   .option('--coverage', 'Generate coverage report')
41:   .action(testCommand);
42: 
43: // Building
44: program
45:   .command('build')
46:   .description('Build game for production')
47:   .option('-o, --out-dir <dir>', 'Output directory', 'dist')
48:   .action(buildCommand);
49: 
50: // Validation
51: program
52:   .command('validate')
53:   .description('Validate game before publishing')
54:   .option('--fix', 'Attempt to auto-fix issues')
55:   .option('--skip-simulation', 'Skip random game simulation')
56:   .action(validateCommand);
57: 
58: // Publishing
59: program
60:   .command('publish')
61:   .description('Publish game to boardsmith.io')
62:   .option('--dry-run', 'Show what would be published without uploading')
63:   .action(publishCommand);
64: 
65: program.parse();
````

## File: packages/client/package.json
````json
 1: {
 2:   "name": "@boardsmith/client",
 3:   "version": "0.1.0",
 4:   "description": "Browser client SDK for BoardSmith - provides BoardSmithClient for matchmaking and GameConnection for real-time game communication via WebSockets",
 5:   "type": "module",
 6:   "main": "./dist/index.js",
 7:   "module": "./dist/index.js",
 8:   "types": "./dist/index.d.ts",
 9:   "exports": {
10:     ".": {
11:       "types": "./dist/index.d.ts",
12:       "import": "./dist/index.js"
13:     },
14:     "./vue": {
15:       "types": "./dist/vue.d.ts",
16:       "import": "./dist/vue.js"
17:     }
18:   },
19:   "files": [
20:     "dist",
21:     "src"
22:   ],
23:   "scripts": {
24:     "build": "tsc",
25:     "dev": "tsc --watch",
26:     "test": "vitest",
27:     "test:run": "vitest run",
28:     "typecheck": "tsc --noEmit"
29:   },
30:   "dependencies": {},
31:   "devDependencies": {
32:     "@types/node": "^20.0.0",
33:     "typescript": "^5.3.0",
34:     "vitest": "^1.0.0",
35:     "vue": "^3.4.0"
36:   },
37:   "peerDependencies": {
38:     "vue": ">=3.0.0"
39:   },
40:   "peerDependenciesMeta": {
41:     "vue": {
42:       "optional": true
43:     }
44:   }
45: }
````

## File: packages/engine/src/command/executor.ts
````typescript
  1: import type {
  2:   GameCommand,
  3:   CommandResult,
  4:   CreateElementCommand,
  5:   CreateManyCommand,
  6:   MoveCommand,
  7:   RemoveCommand,
  8:   ShuffleCommand,
  9:   SetAttributeCommand,
 10:   SetVisibilityCommand,
 11:   AddVisibleToCommand,
 12:   SetCurrentPlayerCommand,
 13:   MessageCommand,
 14:   StartGameCommand,
 15:   EndGameCommand,
 16:   SetOrderCommand,
 17:   VisibilityConfig,
 18: } from './types.js';
 19: import type { Game } from '../element/game.js';
 20: import type { GameElement } from '../element/game-element.js';
 21: import type { Space } from '../element/space.js';
 22: import type { Piece } from '../element/piece.js';
 23: import type { ElementClass } from '../element/types.js';
 24: import { visibilityFromMode, type VisibilityMode, type VisibilityState } from './visibility.js';
 25: 
 26: /**
 27:  * Execute a command against a game state
 28:  */
 29: export function executeCommand(game: Game, command: GameCommand): CommandResult {
 30:   try {
 31:     switch (command.type) {
 32:       case 'CREATE':
 33:         return executeCreate(game, command);
 34:       case 'CREATE_MANY':
 35:         return executeCreateMany(game, command);
 36:       case 'MOVE':
 37:         return executeMove(game, command);
 38:       case 'REMOVE':
 39:         return executeRemove(game, command);
 40:       case 'SHUFFLE':
 41:         return executeShuffle(game, command);
 42:       case 'SET_ATTRIBUTE':
 43:         return executeSetAttribute(game, command);
 44:       case 'SET_VISIBILITY':
 45:         return executeSetVisibility(game, command);
 46:       case 'ADD_VISIBLE_TO':
 47:         return executeAddVisibleTo(game, command);
 48:       case 'SET_CURRENT_PLAYER':
 49:         return executeSetCurrentPlayer(game, command);
 50:       case 'MESSAGE':
 51:         return executeMessage(game, command);
 52:       case 'START_GAME':
 53:         return executeStartGame(game, command);
 54:       case 'END_GAME':
 55:         return executeEndGame(game, command);
 56:       case 'SET_ORDER':
 57:         return executeSetOrder(game, command);
 58:       default:
 59:         return { success: false, error: `Unknown command type: ${(command as any).type}` };
 60:     }
 61:   } catch (err) {
 62:     return {
 63:       success: false,
 64:       error: err instanceof Error ? err.message : String(err),
 65:     };
 66:   }
 67: }
 68: 
 69: function executeCreate(game: Game, command: CreateElementCommand): CommandResult {
 70:   const parent = game.getElementById(command.parentId);
 71:   if (!parent) {
 72:     return { success: false, error: `Parent element not found: ${command.parentId}` };
 73:   }
 74: 
 75:   const ElementClass = game.getElementClass(command.className);
 76:   if (!ElementClass) {
 77:     return { success: false, error: `Unknown element class: ${command.className}` };
 78:   }
 79: 
 80:   const element = parent.createInternal(ElementClass, command.name, command.attributes);
 81:   return { success: true, createdIds: [element.id] };
 82: }
 83: 
 84: function executeCreateMany(game: Game, command: CreateManyCommand): CommandResult {
 85:   const parent = game.getElementById(command.parentId);
 86:   if (!parent) {
 87:     return { success: false, error: `Parent element not found: ${command.parentId}` };
 88:   }
 89: 
 90:   const ElementClass = game.getElementClass(command.className);
 91:   if (!ElementClass) {
 92:     return { success: false, error: `Unknown element class: ${command.className}` };
 93:   }
 94: 
 95:   const createdIds: number[] = [];
 96:   for (let i = 0; i < command.count; i++) {
 97:     const attrs = command.attributesList?.[i] ?? {};
 98:     const element = parent.createInternal(ElementClass, command.name, attrs);
 99:     createdIds.push(element.id);
100:   }
101: 
102:   return { success: true, createdIds };
103: }
104: 
105: function executeMove(game: Game, command: MoveCommand): CommandResult {
106:   const element = game.getElementById(command.elementId);
107:   if (!element) {
108:     return { success: false, error: `Element not found: ${command.elementId}` };
109:   }
110: 
111:   const destination = game.getElementById(command.destinationId);
112:   if (!destination) {
113:     return { success: false, error: `Destination not found: ${command.destinationId}` };
114:   }
115: 
116:   // Use internal move method
117:   (element as Piece).moveToInternal(destination, command.position);
118:   return { success: true };
119: }
120: 
121: function executeRemove(game: Game, command: RemoveCommand): CommandResult {
122:   const element = game.getElementById(command.elementId);
123:   if (!element) {
124:     return { success: false, error: `Element not found: ${command.elementId}` };
125:   }
126: 
127:   (element as Piece).moveToInternal(game.pile);
128:   return { success: true };
129: }
130: 
131: function executeShuffle(game: Game, command: ShuffleCommand): CommandResult {
132:   const space = game.getElementById(command.spaceId) as Space | undefined;
133:   if (!space) {
134:     return { success: false, error: `Space not found: ${command.spaceId}` };
135:   }
136: 
137:   space.shuffleInternal();
138:   return { success: true };
139: }
140: 
141: function executeSetAttribute(game: Game, command: SetAttributeCommand): CommandResult {
142:   const element = game.getElementById(command.elementId);
143:   if (!element) {
144:     return { success: false, error: `Element not found: ${command.elementId}` };
145:   }
146: 
147:   (element as any)[command.attribute] = command.value;
148:   return { success: true };
149: }
150: 
151: function executeSetVisibility(game: Game, command: SetVisibilityCommand): CommandResult {
152:   const element = game.getElementById(command.elementId);
153:   if (!element) {
154:     return { success: false, error: `Element not found: ${command.elementId}` };
155:   }
156: 
157:   let visibility: VisibilityState;
158:   if (typeof command.visibility === 'string') {
159:     visibility = visibilityFromMode(command.visibility);
160:   } else {
161:     visibility = {
162:       mode: command.visibility.mode,
163:       addPlayers: command.visibility.addPlayers,
164:       exceptPlayers: command.visibility.exceptPlayers,
165:       explicit: true,
166:     };
167:   }
168: 
169:   element.setVisibilityInternal(visibility);
170:   return { success: true };
171: }
172: 
173: function executeAddVisibleTo(game: Game, command: AddVisibleToCommand): CommandResult {
174:   const element = game.getElementById(command.elementId);
175:   if (!element) {
176:     return { success: false, error: `Element not found: ${command.elementId}` };
177:   }
178: 
179:   element.addVisibleToInternal(command.players);
180:   return { success: true };
181: }
182: 
183: function executeSetCurrentPlayer(game: Game, command: SetCurrentPlayerCommand): CommandResult {
184:   game.players.setCurrent(command.playerPosition);
185:   return { success: true };
186: }
187: 
188: function executeMessage(game: Game, command: MessageCommand): CommandResult {
189:   game.addMessageInternal(command.text, command.data);
190:   return { success: true };
191: }
192: 
193: function executeStartGame(game: Game, command: StartGameCommand): CommandResult {
194:   if (game.phase !== 'setup') {
195:     return { success: false, error: 'Game has already started' };
196:   }
197:   game.phase = 'started';
198:   return { success: true };
199: }
200: 
201: function executeEndGame(game: Game, command: EndGameCommand): CommandResult {
202:   game.phase = 'finished';
203:   if (command.winners) {
204:     game.settings.winners = command.winners;
205:   }
206:   return { success: true };
207: }
208: 
209: function executeSetOrder(game: Game, command: SetOrderCommand): CommandResult {
210:   const space = game.getElementById(command.spaceId);
211:   if (!space) {
212:     return { success: false, error: `Space not found: ${command.spaceId}` };
213:   }
214: 
215:   space._t.order = command.order;
216:   return { success: true };
217: }
````

## File: packages/engine/src/command/index.ts
````typescript
 1: export type {
 2:   GameCommand,
 3:   CommandResult,
 4:   BaseCommand,
 5:   CreateElementCommand,
 6:   CreateManyCommand,
 7:   MoveCommand,
 8:   RemoveCommand,
 9:   ShuffleCommand,
10:   SetAttributeCommand,
11:   SetVisibilityCommand,
12:   AddVisibleToCommand,
13:   SetCurrentPlayerCommand,
14:   MessageCommand,
15:   StartGameCommand,
16:   EndGameCommand,
17:   SetOrderCommand,
18:   VisibilityConfig,
19: } from './types.js';
20: 
21: export {
22:   type VisibilityMode,
23:   type VisibilityState,
24:   canPlayerSee,
25:   visibilityFromMode,
26:   resolveVisibility,
27:   DEFAULT_VISIBILITY,
28: } from './visibility.js';
29: 
30: export { executeCommand } from './executor.js';
````

## File: packages/engine/src/command/types.ts
````typescript
  1: /**
  2:  * Command System - Low-level state mutations for event sourcing
  3:  *
  4:  * Commands are imperative, low-level operations that directly modify the game state tree.
  5:  * They are generated internally when game code calls element methods (putInto, create, etc.)
  6:  * or during Action execution.
  7:  *
  8:  * Commands vs Actions:
  9:  * - Actions = High-level player operations (game-specific, user-facing)
 10:  * - Commands = Low-level state mutations (generic, event-sourced, internal)
 11:  *
 12:  * @see {@link ../../ARCHITECTURE.md} for the Actions vs Commands architecture explanation
 13:  */
 14: 
 15: import type { ElementClass, ElementAttributes } from '../element/types.js';
 16: import type { GameElement } from '../element/game-element.js';
 17: import type { VisibilityMode } from './visibility.js';
 18: 
 19: /**
 20:  * Base command interface - all commands extend this
 21:  */
 22: export interface BaseCommand {
 23:   type: string;
 24:   /** Timestamp when command was created */
 25:   timestamp?: number;
 26: }
 27: 
 28: /**
 29:  * Create a new element
 30:  */
 31: export interface CreateElementCommand extends BaseCommand {
 32:   type: 'CREATE';
 33:   /** Class name of element to create */
 34:   className: string;
 35:   /** Name for the new element */
 36:   name: string;
 37:   /** ID of parent element */
 38:   parentId: number;
 39:   /** Initial attributes */
 40:   attributes?: Record<string, unknown>;
 41: }
 42: 
 43: /**
 44:  * Create multiple elements at once
 45:  */
 46: export interface CreateManyCommand extends BaseCommand {
 47:   type: 'CREATE_MANY';
 48:   /** Class name of elements to create */
 49:   className: string;
 50:   /** Base name for elements */
 51:   name: string;
 52:   /** ID of parent element */
 53:   parentId: number;
 54:   /** Number of elements to create */
 55:   count: number;
 56:   /** Attributes for each element (by index) */
 57:   attributesList?: Record<string, unknown>[];
 58: }
 59: 
 60: /**
 61:  * Move an element to a new parent
 62:  */
 63: export interface MoveCommand extends BaseCommand {
 64:   type: 'MOVE';
 65:   /** ID of element to move */
 66:   elementId: number;
 67:   /** ID of destination element */
 68:   destinationId: number;
 69:   /** Position in destination */
 70:   position?: 'first' | 'last';
 71: }
 72: 
 73: /**
 74:  * Remove an element (move to pile)
 75:  */
 76: export interface RemoveCommand extends BaseCommand {
 77:   type: 'REMOVE';
 78:   /** ID of element to remove */
 79:   elementId: number;
 80: }
 81: 
 82: /**
 83:  * Shuffle children of a space
 84:  */
 85: export interface ShuffleCommand extends BaseCommand {
 86:   type: 'SHUFFLE';
 87:   /** ID of space to shuffle */
 88:   spaceId: number;
 89: }
 90: 
 91: /**
 92:  * Set an attribute on an element
 93:  */
 94: export interface SetAttributeCommand extends BaseCommand {
 95:   type: 'SET_ATTRIBUTE';
 96:   /** ID of element */
 97:   elementId: number;
 98:   /** Attribute name */
 99:   attribute: string;
100:   /** New value */
101:   value: unknown;
102: }
103: 
104: /**
105:  * Set visibility on an element
106:  */
107: export interface SetVisibilityCommand extends BaseCommand {
108:   type: 'SET_VISIBILITY';
109:   /** ID of element */
110:   elementId: number;
111:   /** Visibility mode or configuration */
112:   visibility: VisibilityMode | VisibilityConfig;
113: }
114: 
115: /**
116:  * Add a player to visibility list
117:  */
118: export interface AddVisibleToCommand extends BaseCommand {
119:   type: 'ADD_VISIBLE_TO';
120:   /** ID of element */
121:   elementId: number;
122:   /** Player position(s) to add */
123:   players: number[];
124: }
125: 
126: /**
127:  * Set the current player
128:  */
129: export interface SetCurrentPlayerCommand extends BaseCommand {
130:   type: 'SET_CURRENT_PLAYER';
131:   /** Player position */
132:   playerPosition: number;
133: }
134: 
135: /**
136:  * Add a message to the game log
137:  */
138: export interface MessageCommand extends BaseCommand {
139:   type: 'MESSAGE';
140:   /** Message text (can include {{placeholders}}) */
141:   text: string;
142:   /** Data for placeholder substitution */
143:   data?: Record<string, unknown>;
144: }
145: 
146: /**
147:  * Start the game
148:  */
149: export interface StartGameCommand extends BaseCommand {
150:   type: 'START_GAME';
151: }
152: 
153: /**
154:  * End the game
155:  */
156: export interface EndGameCommand extends BaseCommand {
157:   type: 'END_GAME';
158:   /** Winner player positions */
159:   winners?: number[];
160: }
161: 
162: /**
163:  * Set the ordering mode for a space
164:  */
165: export interface SetOrderCommand extends BaseCommand {
166:   type: 'SET_ORDER';
167:   /** ID of space */
168:   spaceId: number;
169:   /** Order mode */
170:   order: 'normal' | 'stacking';
171: }
172: 
173: /**
174:  * Visibility configuration for complex cases
175:  */
176: export interface VisibilityConfig {
177:   /** Base mode */
178:   mode: VisibilityMode;
179:   /** Additional players who can see (additive) */
180:   addPlayers?: number[];
181:   /** Players who cannot see (subtractive, only with 'all' mode) */
182:   exceptPlayers?: number[];
183: }
184: 
185: /**
186:  * Union of all command types
187:  */
188: export type GameCommand =
189:   | CreateElementCommand
190:   | CreateManyCommand
191:   | MoveCommand
192:   | RemoveCommand
193:   | ShuffleCommand
194:   | SetAttributeCommand
195:   | SetVisibilityCommand
196:   | AddVisibleToCommand
197:   | SetCurrentPlayerCommand
198:   | MessageCommand
199:   | StartGameCommand
200:   | EndGameCommand
201:   | SetOrderCommand;
202: 
203: /**
204:  * Result of executing a command
205:  */
206: export interface CommandResult {
207:   /** Whether command succeeded */
208:   success: boolean;
209:   /** Error message if failed */
210:   error?: string;
211:   /** IDs of created elements (for CREATE commands) */
212:   createdIds?: number[];
213: }
````

## File: packages/engine/src/command/visibility.ts
````typescript
 1: /**
 2:  * Visibility modes for game elements
 3:  *
 4:  * - 'all': Visible to all players (default)
 5:  * - 'owner': Visible only to the element's owner
 6:  * - 'hidden': Not visible to any player
 7:  * - 'count-only': Players can see count but not contents (e.g., opponent's hand)
 8:  * - 'unordered': Players can see contents but not order (e.g., shuffled deck peek)
 9:  */
10: export type VisibilityMode = 'all' | 'owner' | 'hidden' | 'count-only' | 'unordered';
11: 
12: /**
13:  * Complete visibility state for an element
14:  */
15: export interface VisibilityState {
16:   /** Base visibility mode */
17:   mode: VisibilityMode;
18:   /** Additional players who can see (beyond the mode) */
19:   addPlayers?: number[];
20:   /** Players excluded from seeing (only applies to 'all' mode) */
21:   exceptPlayers?: number[];
22:   /** Whether this is explicitly set or inherited */
23:   explicit: boolean;
24: }
25: 
26: /**
27:  * Resolve effective visibility for an element given its state and player
28:  */
29: export function canPlayerSee(
30:   visibility: VisibilityState,
31:   playerPosition: number,
32:   ownerPosition: number | undefined
33: ): boolean {
34:   // Check exceptPlayers first (exclusion list)
35:   if (visibility.exceptPlayers?.includes(playerPosition)) {
36:     return false;
37:   }
38: 
39:   // Check addPlayers (inclusion list override)
40:   if (visibility.addPlayers?.includes(playerPosition)) {
41:     return true;
42:   }
43: 
44:   // Apply base mode
45:   switch (visibility.mode) {
46:     case 'all':
47:       return true;
48:     case 'owner':
49:       return ownerPosition !== undefined && playerPosition === ownerPosition;
50:     case 'hidden':
51:     case 'count-only':
52:     case 'unordered':
53:       return false;
54:     default:
55:       return true;
56:   }
57: }
58: 
59: /**
60:  * Default visibility (visible to all)
61:  */
62: export const DEFAULT_VISIBILITY: VisibilityState = {
63:   mode: 'all',
64:   explicit: false,
65: };
66: 
67: /**
68:  * Create visibility state from a mode
69:  */
70: export function visibilityFromMode(mode: VisibilityMode): VisibilityState {
71:   return {
72:     mode,
73:     explicit: true,
74:   };
75: }
76: 
77: /**
78:  * Merge parent visibility with child override
79:  */
80: export function resolveVisibility(
81:   childVisibility: VisibilityState | undefined,
82:   parentVisibility: VisibilityState | undefined
83: ): VisibilityState {
84:   // If child has explicit visibility, use it
85:   if (childVisibility?.explicit) {
86:     return childVisibility;
87:   }
88: 
89:   // Otherwise inherit from parent
90:   if (parentVisibility) {
91:     return {
92:       ...parentVisibility,
93:       explicit: false, // Mark as inherited
94:     };
95:   }
96: 
97:   // Default to visible to all
98:   return DEFAULT_VISIBILITY;
99: }
````

## File: packages/engine/src/element/card.ts
````typescript
 1: import { Piece } from './piece.js';
 2: import type { ElementContext } from './types.js';
 3: import type { Player } from '../player/player.js';
 4: import type { Game } from './game.js';
 5: 
 6: /**
 7:  * Card - A two-sided game piece commonly used in card games
 8:  *
 9:  * Cards are pieces that typically have:
10:  * - Two faces (front and back)
11:  * - Attributes like rank, suit, value, etc.
12:  * - Can be face-up or face-down
13:  *
14:  * Examples: playing cards, tarot cards, game cards
15:  *
16:  * Usage:
17:  * ```ts
18:  * class PlayingCard extends Card {
19:  *   rank!: string; // 'A', '2'-'10', 'J', 'Q', 'K'
20:  *   suit!: 'hearts' | 'diamonds' | 'clubs' | 'spades';
21:  * }
22:  * ```
23:  */
24: export class Card<G extends Game = any, P extends Player = any> extends Piece<G, P> {
25:   /**
26:    * System property to identify this element type for AutoUI
27:    * $ prefix indicates this is a system property
28:    */
29:   $type!: 'card';
30: 
31:   /** Whether the card is face-up (true) or face-down (false) */
32:   faceUp: boolean = true;
33: 
34:   constructor(ctx: Partial<ElementContext>) {
35:     super(ctx);
36:     // Explicitly set as instance property for serialization
37:     this.$type = 'card';
38:   }
39: 
40:   /**
41:    * Flip the card to show the other face
42:    */
43:   flip(): void {
44:     this.faceUp = !this.faceUp;
45:   }
46: 
47:   /**
48:    * Set the card face-up
49:    */
50:   showFace(): void {
51:     this.faceUp = true;
52:   }
53: 
54:   /**
55:    * Set the card face-down
56:    */
57:   hideFace(): void {
58:     this.faceUp = false;
59:   }
60: }
````

## File: packages/engine/src/element/element-collection.ts
````typescript
  1: import type { GameElement } from './game-element.js';
  2: import type { ElementClass, ElementFinder, Sorter } from './types.js';
  3: 
  4: /**
  5:  * Options for the internal finder method
  6:  */
  7: type FinderOptions = {
  8:   limit?: number;
  9:   order?: 'asc' | 'desc';
 10:   noRecursive?: boolean;
 11: };
 12: 
 13: /**
 14:  * Array-like collection of GameElements with query methods.
 15:  * Returned by element query operations like `.all()`, `.first()`, etc.
 16:  */
 17: export class ElementCollection<T extends GameElement = GameElement> extends Array<T> {
 18:   /**
 19:    * Override slice to return ElementCollection
 20:    */
 21:   override slice(...args: Parameters<Array<T>['slice']>): ElementCollection<T> {
 22:     return super.slice(...args) as ElementCollection<T>;
 23:   }
 24: 
 25:   /**
 26:    * Override filter to return ElementCollection
 27:    */
 28:   override filter(
 29:     predicate: (value: T, index: number, array: T[]) => boolean
 30:   ): ElementCollection<T> {
 31:     return super.filter(predicate) as ElementCollection<T>;
 32:   }
 33: 
 34:   /**
 35:    * Find all matching elements recursively within this collection
 36:    */
 37:   all<F extends GameElement>(
 38:     className: ElementClass<F>,
 39:     ...finders: ElementFinder<F>[]
 40:   ): ElementCollection<F>;
 41:   all(...finders: ElementFinder<T>[]): ElementCollection<T>;
 42:   all<F extends GameElement>(
 43:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
 44:     ...finders: ElementFinder<F>[]
 45:   ): ElementCollection<F> {
 46:     if (this.isElementClass(classNameOrFinder)) {
 47:       return this._finder(classNameOrFinder, {}, ...finders);
 48:     }
 49:     if (classNameOrFinder !== undefined) {
 50:       finders = [classNameOrFinder as ElementFinder<F>, ...finders];
 51:     }
 52:     return this._finder(undefined, {}, ...finders) as ElementCollection<F>;
 53:   }
 54: 
 55:   /**
 56:    * Find the first matching element
 57:    */
 58:   first<F extends GameElement>(
 59:     className: ElementClass<F>,
 60:     ...finders: ElementFinder<F>[]
 61:   ): F | undefined;
 62:   first(...finders: ElementFinder<T>[]): T | undefined;
 63:   first<F extends GameElement>(
 64:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
 65:     ...finders: ElementFinder<F>[]
 66:   ): F | undefined {
 67:     if (this.isElementClass(classNameOrFinder)) {
 68:       return this._finder(classNameOrFinder, { limit: 1 }, ...finders)[0];
 69:     }
 70:     if (classNameOrFinder !== undefined) {
 71:       finders = [classNameOrFinder as ElementFinder<F>, ...finders];
 72:     }
 73:     return this._finder(undefined, { limit: 1 }, ...finders)[0] as F | undefined;
 74:   }
 75: 
 76:   /**
 77:    * Find the first N matching elements
 78:    */
 79:   firstN<F extends GameElement>(
 80:     n: number,
 81:     className: ElementClass<F>,
 82:     ...finders: ElementFinder<F>[]
 83:   ): ElementCollection<F>;
 84:   firstN(n: number, ...finders: ElementFinder<T>[]): ElementCollection<T>;
 85:   firstN<F extends GameElement>(
 86:     n: number,
 87:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
 88:     ...finders: ElementFinder<F>[]
 89:   ): ElementCollection<F> {
 90:     if (this.isElementClass(classNameOrFinder)) {
 91:       return this._finder(classNameOrFinder, { limit: n }, ...finders);
 92:     }
 93:     if (classNameOrFinder !== undefined) {
 94:       finders = [classNameOrFinder as ElementFinder<F>, ...finders];
 95:     }
 96:     return this._finder(undefined, { limit: n }, ...finders) as ElementCollection<F>;
 97:   }
 98: 
 99:   /**
100:    * Find the last matching element
101:    */
102:   last<F extends GameElement>(
103:     className: ElementClass<F>,
104:     ...finders: ElementFinder<F>[]
105:   ): F | undefined;
106:   last(...finders: ElementFinder<T>[]): T | undefined;
107:   last<F extends GameElement>(
108:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
109:     ...finders: ElementFinder<F>[]
110:   ): F | undefined {
111:     if (this.isElementClass(classNameOrFinder)) {
112:       return this._finder(classNameOrFinder, { limit: 1, order: 'desc' }, ...finders)[0];
113:     }
114:     if (classNameOrFinder !== undefined) {
115:       finders = [classNameOrFinder as ElementFinder<F>, ...finders];
116:     }
117:     return this._finder(undefined, { limit: 1, order: 'desc' }, ...finders)[0] as F | undefined;
118:   }
119: 
120:   /**
121:    * Find the last N matching elements
122:    */
123:   lastN<F extends GameElement>(
124:     n: number,
125:     className: ElementClass<F>,
126:     ...finders: ElementFinder<F>[]
127:   ): ElementCollection<F>;
128:   lastN(n: number, ...finders: ElementFinder<T>[]): ElementCollection<T>;
129:   lastN<F extends GameElement>(
130:     n: number,
131:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
132:     ...finders: ElementFinder<F>[]
133:   ): ElementCollection<F> {
134:     if (this.isElementClass(classNameOrFinder)) {
135:       return this._finder(classNameOrFinder, { limit: n, order: 'desc' }, ...finders);
136:     }
137:     if (classNameOrFinder !== undefined) {
138:       finders = [classNameOrFinder as ElementFinder<F>, ...finders];
139:     }
140:     return this._finder(undefined, { limit: n, order: 'desc' }, ...finders) as ElementCollection<F>;
141:   }
142: 
143:   /**
144:    * Check if any matching elements exist
145:    */
146:   has<F extends GameElement>(
147:     className: ElementClass<F>,
148:     ...finders: ElementFinder<F>[]
149:   ): boolean;
150:   has(...finders: ElementFinder<T>[]): boolean;
151:   has<F extends GameElement>(
152:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
153:     ...finders: ElementFinder<F>[]
154:   ): boolean {
155:     return this.first(classNameOrFinder as ElementClass<F>, ...finders) !== undefined;
156:   }
157: 
158:   /**
159:    * Sort elements by a property or function
160:    */
161:   sortBy<K extends Sorter<T>>(key: K, direction: 'asc' | 'desc' = 'asc'): ElementCollection<T> {
162:     const sorted = new ElementCollection<T>(...this);
163:     sorted.sort((a, b) => {
164:       const aVal = typeof key === 'function' ? key(a) : a[key as keyof T];
165:       const bVal = typeof key === 'function' ? key(b) : b[key as keyof T];
166:       if (aVal < bVal) return direction === 'asc' ? -1 : 1;
167:       if (aVal > bVal) return direction === 'asc' ? 1 : -1;
168:       return 0;
169:     });
170:     return sorted;
171:   }
172: 
173:   /**
174:    * Get the sum of a numeric property
175:    */
176:   sum(key: keyof T | ((element: T) => number)): number {
177:     return this.reduce((acc, el) => {
178:       const val = typeof key === 'function' ? key(el) : el[key as keyof T];
179:       return acc + (typeof val === 'number' ? val : 0);
180:     }, 0);
181:   }
182: 
183:   /**
184:    * Get the minimum value of a property
185:    */
186:   min(key: keyof T | ((element: T) => number)): T | undefined {
187:     if (this.length === 0) return undefined;
188:     return this.reduce((min, el) => {
189:       const minVal = typeof key === 'function' ? key(min) : min[key as keyof T];
190:       const elVal = typeof key === 'function' ? key(el) : el[key as keyof T];
191:       return elVal < minVal ? el : min;
192:     });
193:   }
194: 
195:   /**
196:    * Get the maximum value of a property
197:    */
198:   max(key: keyof T | ((element: T) => number)): T | undefined {
199:     if (this.length === 0) return undefined;
200:     return this.reduce((max, el) => {
201:       const maxVal = typeof key === 'function' ? key(max) : max[key as keyof T];
202:       const elVal = typeof key === 'function' ? key(el) : el[key as keyof T];
203:       return elVal > maxVal ? el : max;
204:     });
205:   }
206: 
207:   /**
208:    * Shuffle the collection in place using the provided random function
209:    */
210:   shuffle(random: () => number = Math.random): ElementCollection<T> {
211:     for (let i = this.length - 1; i > 0; i--) {
212:       const j = Math.floor(random() * (i + 1));
213:       [this[i], this[j]] = [this[j], this[i]];
214:     }
215:     return this;
216:   }
217: 
218:   /**
219:    * Get unique values of a property
220:    */
221:   unique<K extends keyof T>(key: K): T[K][] {
222:     const seen = new Set<T[K]>();
223:     for (const el of this) {
224:       seen.add(el[key]);
225:     }
226:     return Array.from(seen);
227:   }
228: 
229:   /**
230:    * Internal finder implementation
231:    */
232:   _finder<F extends GameElement>(
233:     className: ElementClass<F> | undefined,
234:     options: FinderOptions,
235:     ...finders: ElementFinder<F>[]
236:   ): ElementCollection<F> {
237:     const result = new ElementCollection<F>();
238:     if (options.limit !== undefined && options.limit <= 0) return result;
239: 
240:     // Convert finders to predicate functions
241:     const predicates = finders.map((finder) => this.finderToPredicate<F>(finder));
242: 
243:     const process = (elements: GameElement[], order: 'asc' | 'desc') => {
244:       const items = order === 'desc' ? [...elements].reverse() : elements;
245: 
246:       for (const el of items) {
247:         if (options.limit !== undefined && result.length >= options.limit) break;
248: 
249:         // Check if element matches class and all predicates
250:         const matchesClass = !className || el instanceof className;
251:         const matchesPredicates = predicates.every((pred) => pred(el as F));
252: 
253:         if (matchesClass && matchesPredicates) {
254:           if (order === 'desc') {
255:             result.unshift(el as F);
256:           } else {
257:             result.push(el as F);
258:           }
259:         }
260: 
261:         // Recurse into children unless disabled
262:         if (!options.noRecursive && el._t.children.length > 0) {
263:           const childCollection = new ElementCollection(...el._t.children);
264:           const remaining = options.limit !== undefined
265:             ? options.limit - result.length
266:             : undefined;
267:           const childResults = childCollection._finder(className, {
268:             ...options,
269:             limit: remaining,
270:           }, ...finders);
271:           result.push(...childResults);
272:         }
273:       }
274:     };
275: 
276:     process(this as unknown as GameElement[], options.order ?? 'asc');
277:     return result;
278:   }
279: 
280:   /**
281:    * Convert an ElementFinder to a predicate function
282:    */
283:   private finderToPredicate<F extends GameElement>(finder: ElementFinder<F>): (el: F) => boolean {
284:     if (typeof finder === 'string') {
285:       return (el) => el.name === finder;
286:     }
287:     if (typeof finder === 'function') {
288:       return finder;
289:     }
290:     // Object matcher
291:     return (el) => {
292:       for (const [key, value] of Object.entries(finder)) {
293:         if (key === 'empty') {
294:           if (value !== el.isEmpty()) return false;
295:         } else if (key === 'mine') {
296:           if (value !== el.isMine()) return false;
297:         } else {
298:           if ((el as Record<string, unknown>)[key] !== value) return false;
299:         }
300:       }
301:       return true;
302:     };
303:   }
304: 
305:   /**
306:    * Check if a value is an ElementClass
307:    */
308:   private isElementClass<F extends GameElement>(
309:     value: unknown
310:   ): value is ElementClass<F> {
311:     return (
312:       typeof value === 'function' &&
313:       'isGameElement' in value &&
314:       (value as ElementClass<F>).isGameElement === true
315:     );
316:   }
317: }
````

## File: packages/engine/src/element/game-element.ts
````typescript
  1: import { ElementCollection } from './element-collection.js';
  2: import type {
  3:   ElementClass,
  4:   ElementContext,
  5:   ElementTree,
  6:   ElementJSON,
  7:   ElementFinder,
  8:   ElementAttributes,
  9: } from './types.js';
 10: import type { Player } from '../player/player.js';
 11: import type { Game } from './game.js';
 12: import type { VisibilityState } from '../command/visibility.js';
 13: import { DEFAULT_VISIBILITY, canPlayerSee, resolveVisibility } from '../command/visibility.js';
 14: 
 15: /**
 16:  * Base class for all game elements. Elements form a tree structure representing
 17:  * the game state. Do not instantiate directly - use Space or Piece as base classes.
 18:  */
 19: export class GameElement<G extends Game = any, P extends Player = any> {
 20:   /** Element name for identification and queries */
 21:   name?: string;
 22: 
 23:   /** Player who owns this element (affects "mine" queries and visibility) */
 24:   player?: P;
 25: 
 26:   /** Row position in grid layout */
 27:   row?: number;
 28: 
 29:   /** Column position in grid layout */
 30:   column?: number;
 31: 
 32:   /** Reference to the root game */
 33:   game!: G;
 34: 
 35:   /** Shared context for all elements in the tree */
 36:   _ctx!: ElementContext;
 37: 
 38:   /** Internal tree structure */
 39:   _t: ElementTree<GameElement>;
 40: 
 41:   /** Visibility state for this element */
 42:   _visibility?: VisibilityState;
 43: 
 44:   /** Static flag to identify GameElement classes */
 45:   static isGameElement = true;
 46: 
 47:   /** Attributes that should not be serialized */
 48:   static unserializableAttributes = ['_ctx', '_t', 'game', '_visibility'];
 49: 
 50:   /** Attributes visible to all players (undefined = all visible) */
 51:   static visibleAttributes: string[] | undefined;
 52: 
 53:   constructor(ctx: Partial<ElementContext>) {
 54:     this._ctx = ctx as ElementContext;
 55: 
 56:     // Initialize sequence if this is the root
 57:     if (this._ctx.sequence === undefined) {
 58:       this._ctx.sequence = 0;
 59:     }
 60: 
 61:     // Initialize class registry as Map
 62:     if (!this._ctx.classRegistry) {
 63:       this._ctx.classRegistry = new Map();
 64:     }
 65: 
 66:     // Create tree structure with unique ID
 67:     const id = this._ctx.sequence++;
 68:     this._t = {
 69:       children: [],
 70:       id,
 71:       order: 'normal',
 72:     };
 73:   }
 74: 
 75:   /**
 76:    * String representation of the element
 77:    */
 78:   toString(): string {
 79:     return this.name ?? this.constructor.name.replace(/([a-z0-9])([A-Z])/g, '$1 $2');
 80:   }
 81: 
 82:   // ============================================
 83:   // Tree Structure
 84:   // ============================================
 85: 
 86:   /**
 87:    * Get the parent element
 88:    */
 89:   get parent(): GameElement | undefined {
 90:     return this._t.parent;
 91:   }
 92: 
 93:   /**
 94:    * Get all direct children
 95:    */
 96:   get children(): ElementCollection<GameElement> {
 97:     return new ElementCollection(...this._t.children);
 98:   }
 99: 
100:   /**
101:    * Check if this element has no children
102:    */
103:   isEmpty(): boolean {
104:     return this._t.children.length === 0;
105:   }
106: 
107:   /**
108:    * Check if this element belongs to the current player context
109:    */
110:   isMine(): boolean {
111:     if (!this._ctx.player) return false;
112:     return this.player === this._ctx.player;
113:   }
114: 
115:   /**
116:    * Get the branch path from root to this element (e.g., "0/2/1")
117:    */
118:   branch(): string {
119:     const path: number[] = [];
120:     let current: GameElement | undefined = this as GameElement;
121: 
122:     while (current?._t.parent) {
123:       const parent: GameElement = current._t.parent;
124:       const index = parent._t.children.indexOf(current);
125:       path.unshift(index);
126:       current = parent;
127:     }
128: 
129:     return path.join('/');
130:   }
131: 
132:   /**
133:    * Find an element by its branch path
134:    */
135:   atBranch(branch: string): GameElement | undefined {
136:     if (!branch) return this;
137: 
138:     const indices = branch.split('/').map(Number);
139:     let current: GameElement = this;
140: 
141:     for (const index of indices) {
142:       const child = current._t.children[index];
143:       if (!child) return undefined;
144:       current = child;
145:     }
146: 
147:     return current;
148:   }
149: 
150:   /**
151:    * Find an element by its immutable ID
152:    */
153:   atId(id: number): GameElement | undefined {
154:     if (this._t.id === id) return this;
155: 
156:     for (const child of this._t.children) {
157:       const found = child.atId(id);
158:       if (found) return found;
159:     }
160: 
161:     return undefined;
162:   }
163: 
164: 
165:   // ============================================
166:   // Element Creation
167:   // ============================================
168: 
169:   /**
170:    * Create a single child element
171:    */
172:   create<T extends GameElement>(
173:     elementClass: ElementClass<T>,
174:     name: string,
175:     attributes?: ElementAttributes<T>
176:   ): T {
177:     return this.createInternal(elementClass, name, attributes);
178:   }
179: 
180:   /**
181:    * Internal creation method called by command executor
182:    */
183:   createInternal<T extends GameElement>(
184:     elementClass: ElementClass<T>,
185:     name: string,
186:     attributes?: Record<string, unknown>
187:   ): T {
188:     const element = new elementClass(this._ctx);
189:     element.name = name;
190:     element.game = this.game;
191: 
192:     // Apply attributes
193:     if (attributes) {
194:       Object.assign(element, attributes);
195:     }
196: 
197:     // Add to tree
198:     this.addChild(element);
199: 
200:     // Register class for deserialization (using Map)
201:     const className = elementClass.name;
202:     if (!this._ctx.classRegistry.has(className)) {
203:       this._ctx.classRegistry.set(className, elementClass);
204:     }
205: 
206:     return element;
207:   }
208: 
209:   /**
210:    * Create multiple child elements
211:    */
212:   createMany<T extends GameElement>(
213:     count: number,
214:     elementClass: ElementClass<T>,
215:     name: string,
216:     attributes?: ElementAttributes<T> | ((index: number) => ElementAttributes<T>)
217:   ): ElementCollection<T> {
218:     const elements = new ElementCollection<T>();
219: 
220:     for (let i = 0; i < count; i++) {
221:       const attrs = typeof attributes === 'function' ? attributes(i) : attributes;
222:       elements.push(this.create(elementClass, name, attrs));
223:     }
224: 
225:     return elements;
226:   }
227: 
228:   /**
229:    * Add a child element to this element
230:    */
231:   protected addChild(element: GameElement): void {
232:     element._t.parent = this;
233: 
234:     if (this._t.order === 'stacking') {
235:       this._t.children.unshift(element);
236:     } else {
237:       this._t.children.push(element);
238:     }
239:   }
240: 
241:   /**
242:    * Remove a child element from this element
243:    */
244:   protected removeChild(element: GameElement): void {
245:     const index = this._t.children.indexOf(element);
246:     if (index !== -1) {
247:       this._t.children.splice(index, 1);
248:       element._t.parent = undefined;
249:     }
250:   }
251: 
252:   /**
253:    * Set the ordering mode for children
254:    */
255:   setOrder(order: 'normal' | 'stacking'): void {
256:     this._t.order = order;
257:   }
258: 
259:   // ============================================
260:   // Queries
261:   // ============================================
262: 
263:   /**
264:    * Find all matching descendant elements
265:    */
266:   all<F extends GameElement>(
267:     className: ElementClass<F>,
268:     ...finders: ElementFinder<F>[]
269:   ): ElementCollection<F>;
270:   all(...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
271:   all<F extends GameElement>(
272:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
273:     ...finders: ElementFinder<F>[]
274:   ): ElementCollection<F> {
275:     const collection = new ElementCollection(...this._t.children);
276:     return collection.all(classNameOrFinder as ElementClass<F>, ...finders);
277:   }
278: 
279:   /**
280:    * Find the first matching descendant element
281:    */
282:   first<F extends GameElement>(
283:     className: ElementClass<F>,
284:     ...finders: ElementFinder<F>[]
285:   ): F | undefined;
286:   first(...finders: ElementFinder<GameElement>[]): GameElement | undefined;
287:   first<F extends GameElement>(
288:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
289:     ...finders: ElementFinder<F>[]
290:   ): F | undefined {
291:     const collection = new ElementCollection(...this._t.children);
292:     return collection.first(classNameOrFinder as ElementClass<F>, ...finders);
293:   }
294: 
295:   /**
296:    * Find the first N matching descendant elements
297:    */
298:   firstN<F extends GameElement>(
299:     n: number,
300:     className: ElementClass<F>,
301:     ...finders: ElementFinder<F>[]
302:   ): ElementCollection<F>;
303:   firstN(n: number, ...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
304:   firstN<F extends GameElement>(
305:     n: number,
306:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
307:     ...finders: ElementFinder<F>[]
308:   ): ElementCollection<F> {
309:     const collection = new ElementCollection(...this._t.children);
310:     return collection.firstN(n, classNameOrFinder as ElementClass<F>, ...finders);
311:   }
312: 
313:   /**
314:    * Find the last matching descendant element
315:    */
316:   last<F extends GameElement>(
317:     className: ElementClass<F>,
318:     ...finders: ElementFinder<F>[]
319:   ): F | undefined;
320:   last(...finders: ElementFinder<GameElement>[]): GameElement | undefined;
321:   last<F extends GameElement>(
322:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
323:     ...finders: ElementFinder<F>[]
324:   ): F | undefined {
325:     const collection = new ElementCollection(...this._t.children);
326:     return collection.last(classNameOrFinder as ElementClass<F>, ...finders);
327:   }
328: 
329:   /**
330:    * Find the last N matching descendant elements
331:    */
332:   lastN<F extends GameElement>(
333:     n: number,
334:     className: ElementClass<F>,
335:     ...finders: ElementFinder<F>[]
336:   ): ElementCollection<F>;
337:   lastN(n: number, ...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
338:   lastN<F extends GameElement>(
339:     n: number,
340:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
341:     ...finders: ElementFinder<F>[]
342:   ): ElementCollection<F> {
343:     const collection = new ElementCollection(...this._t.children);
344:     return collection.lastN(n, classNameOrFinder as ElementClass<F>, ...finders);
345:   }
346: 
347:   /**
348:    * Check if any matching descendant elements exist
349:    */
350:   has<F extends GameElement>(
351:     className: ElementClass<F>,
352:     ...finders: ElementFinder<F>[]
353:   ): boolean;
354:   has(...finders: ElementFinder<GameElement>[]): boolean;
355:   has<F extends GameElement>(
356:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
357:     ...finders: ElementFinder<F>[]
358:   ): boolean {
359:     const collection = new ElementCollection(...this._t.children);
360:     return collection.has(classNameOrFinder as ElementClass<F>, ...finders);
361:   }
362: 
363:   /**
364:    * Count matching descendant elements
365:    */
366:   count<F extends GameElement>(
367:     className: ElementClass<F>,
368:     ...finders: ElementFinder<F>[]
369:   ): number;
370:   count(...finders: ElementFinder<GameElement>[]): number;
371:   count<F extends GameElement>(
372:     classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
373:     ...finders: ElementFinder<F>[]
374:   ): number {
375:     return this.all(classNameOrFinder as ElementClass<F>, ...finders).length;
376:   }
377: 
378:   // ============================================
379:   // Visibility
380:   // ============================================
381: 
382:   /**
383:    * Get effective visibility (own or inherited from parent zone)
384:    */
385:   getEffectiveVisibility(): VisibilityState {
386:     // If this element has explicit visibility, use it
387:     if (this._visibility?.explicit) {
388:       return this._visibility;
389:     }
390:     // Otherwise inherit from parent's zone visibility
391:     return resolveVisibility(this._visibility, this.getParentZoneVisibility());
392:   }
393: 
394:   /**
395:    * Get the zone visibility from the nearest parent Space
396:    */
397:   protected getParentZoneVisibility(): VisibilityState | undefined {
398:     // Import Space dynamically to avoid circular dependency
399:     const parent = this._t.parent;
400:     if (!parent) return undefined;
401: 
402:     // Check if parent is a Space with zone visibility
403:     if ('getZoneVisibility' in parent && typeof parent.getZoneVisibility === 'function') {
404:       const zoneVis = (parent as any).getZoneVisibility();
405:       if (zoneVis) return zoneVis;
406:     }
407: 
408:     // Otherwise continue up the tree
409:     return parent.getParentZoneVisibility?.();
410:   }
411: 
412:   /**
413:    * Check if this element is visible to a player
414:    */
415:   isVisibleTo(player: Player | number): boolean {
416:     const position = typeof player === 'number' ? player : player.position;
417:     const visibility = this.getEffectiveVisibility();
418:     // For owner-based visibility, check this element's owner first,
419:     // then walk up the tree to find an owner (for inherited visibility)
420:     const ownerPosition = this.getEffectiveOwner()?.position;
421:     return canPlayerSee(visibility, position, ownerPosition);
422:   }
423: 
424:   /**
425:    * Get the effective owner for visibility purposes
426:    * (this element's player, or inherited from parent)
427:    */
428:   getEffectiveOwner(): Player | undefined {
429:     if (this.player) return this.player;
430:     return this._t.parent?.getEffectiveOwner();
431:   }
432: 
433:   /**
434:    * Check if this element is visible in the current context
435:    */
436:   isVisible(): boolean {
437:     if (!this._ctx.player) return true;
438:     return this.isVisibleTo(this._ctx.player);
439:   }
440: 
441:   /**
442:    * Internal method to set visibility (called by command executor)
443:    */
444:   setVisibilityInternal(visibility: VisibilityState): void {
445:     this._visibility = visibility;
446:   }
447: 
448:   /**
449:    * Internal method to add players to visibility list
450:    */
451:   addVisibleToInternal(players: number[]): void {
452:     if (!this._visibility) {
453:       this._visibility = { ...DEFAULT_VISIBILITY, explicit: true };
454:     }
455:     this._visibility.addPlayers = Array.from(
456:       new Set([...(this._visibility.addPlayers ?? []), ...players])
457:     );
458:   }
459: 
460:   // ============================================
461:   // Serialization
462:   // ============================================
463: 
464:   /**
465:    * Serialize this element and its descendants to JSON
466:    */
467:   toJSON(): ElementJSON {
468:     const className = this.constructor.name;
469:     const unserializable = new Set(
470:       (this.constructor as typeof GameElement).unserializableAttributes
471:     );
472: 
473:     // Collect serializable attributes
474:     const attributes: Record<string, unknown> = {};
475:     for (const key of Object.keys(this)) {
476:       if (!unserializable.has(key) && !key.startsWith('_')) {
477:         const value = (this as Record<string, unknown>)[key];
478:         if (value !== undefined) {
479:           attributes[key] = this.serializeValue(value);
480:         }
481:       }
482:     }
483: 
484:     const json: ElementJSON = {
485:       className,
486:       id: this._t.id,
487:       attributes,
488:     };
489: 
490:     if (this.name) {
491:       json.name = this.name;
492:     }
493: 
494:     // Include visibility if explicitly set
495:     if (this._visibility?.explicit) {
496:       json.visibility = this._visibility;
497:     }
498: 
499:     if (this._t.children.length > 0) {
500:       json.children = this._t.children.map((child) => child.toJSON());
501:     }
502: 
503:     return json;
504:   }
505: 
506:   /**
507:    * Serialize a value for JSON
508:    */
509:   protected serializeValue(value: unknown): unknown {
510:     if (value instanceof GameElement) {
511:       // Serialize element references as branch paths
512:       return { __elementRef: value.branch() };
513:     }
514:     if (Array.isArray(value)) {
515:       return value.map((v) => this.serializeValue(v));
516:     }
517:     if (value && typeof value === 'object') {
518:       const result: Record<string, unknown> = {};
519:       for (const [k, v] of Object.entries(value)) {
520:         result[k] = this.serializeValue(v);
521:       }
522:       return result;
523:     }
524:     return value;
525:   }
526: 
527:   /**
528:    * Create an element tree from JSON
529:    */
530:   static fromJSON<T extends GameElement>(
531:     json: ElementJSON,
532:     ctx: ElementContext,
533:     classRegistry: Map<string, ElementClass>
534:   ): T {
535:     const ElementClass = classRegistry.get(json.className);
536:     if (!ElementClass) {
537:       throw new Error(`Unknown element class: ${json.className}`);
538:     }
539: 
540:     const element = new ElementClass(ctx);
541:     element._t.id = json.id;
542: 
543:     if (json.name) {
544:       element.name = json.name;
545:     }
546: 
547:     // Restore visibility if present
548:     if (json.visibility) {
549:       element._visibility = json.visibility;
550:     }
551: 
552:     // Apply attributes
553:     for (const [key, value] of Object.entries(json.attributes)) {
554:       (element as unknown as Record<string, unknown>)[key] = value;
555:     }
556: 
557:     // Recursively create children
558:     if (json.children) {
559:       for (const childJson of json.children) {
560:         const child = GameElement.fromJSON(childJson, ctx, classRegistry);
561:         child._t.parent = element;
562:         element._t.children.push(child);
563:       }
564:     }
565: 
566:     return element as T;
567:   }
568: 
569:   // ============================================
570:   // ID Access
571:   // ============================================
572: 
573:   /**
574:    * Get the immutable ID
575:    */
576:   get id(): number {
577:     return this._t.id;
578:   }
579: }
````

## File: packages/engine/src/element/grid.ts
````typescript
  1: import { Space } from './space.js';
  2: import type { Game } from './game.js';
  3: import type { Player } from '../player/player.js';
  4: 
  5: /**
  6:  * Layout types that AutoUI can render
  7:  * These are system-defined and guaranteed by the engine
  8:  */
  9: export type ElementLayout =
 10:   | 'grid'           // 2D grid layout (chess, checkers, tic-tac-toe)
 11:   | 'hex-grid'       // Hexagonal grid (Catan, Civilization)
 12:   | 'list'           // Linear sequence (default for most containers)
 13:   | 'stack'          // Stacked elements (deck of cards)
 14:   | 'hand'           // Fanned hand of cards
 15:   | 'free-form';     // No specific layout (custom positioning)
 16: 
 17: /**
 18:  * A grid-based board container
 19:  *
 20:  * Grid is a Space that contains GridCell children arranged in a 2D rectangular grid.
 21:  * Game designers should extend this class when creating grid-based boards.
 22:  *
 23:  * Example:
 24:  * ```typescript
 25:  * class CheckerBoard extends Grid {}
 26:  * class ChessBoard extends Grid {}
 27:  * class GoBoard extends Grid {}
 28:  * ```
 29:  */
 30: export class Grid<G extends Game = any, P extends Player = any> extends Space<G, P> {
 31:   /**
 32:    * System-defined layout type
 33:    * AutoUI uses this to determine how to render this container
 34:    * $ prefix indicates this is a system property
 35:    */
 36:   readonly $layout: ElementLayout = 'grid';
 37: 
 38:   /**
 39:    * Labels for rows (optional - game designer provides these)
 40:    * Example: ['8', '7', '6', '5', '4', '3', '2', '1'] for chess
 41:    * If not provided, AutoUI will use numeric indices
 42:    */
 43:   $rowLabels?: string[];
 44: 
 45:   /**
 46:    * Labels for columns (optional - game designer provides these)
 47:    * Example: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] for chess
 48:    * If not provided, AutoUI will use numeric indices
 49:    */
 50:   $columnLabels?: string[];
 51: 
 52:   /**
 53:    * Name of the attribute on GridCell children that represents the row coordinate
 54:    * Example: 'row', 'rank', 'y'
 55:    * AutoUI uses this to position grid cells correctly
 56:    */
 57:   $rowCoord?: string;
 58: 
 59:   /**
 60:    * Name of the attribute on GridCell children that represents the column coordinate
 61:    * Example: 'col', 'column', 'file', 'x'
 62:    * AutoUI uses this to position grid cells correctly
 63:    */
 64:   $colCoord?: string;
 65: 
 66:   static override unserializableAttributes = [
 67:     ...Space.unserializableAttributes,
 68:   ];
 69: }
 70: 
 71: /**
 72:  * A single cell within a Grid
 73:  *
 74:  * GridCell is a Space that represents one position in a grid.
 75:  * It must have numeric position coordinates (the attribute names are flexible).
 76:  *
 77:  * The game designer defines which attributes represent coordinates.
 78:  *
 79:  * Example:
 80:  * ```typescript
 81:  * class Square extends GridCell {
 82:  *   row!: number;
 83:  *   col!: number;
 84:  * }
 85:  *
 86:  * class ChessSquare extends GridCell {
 87:  *   rank!: number;  // 1-8
 88:  *   file!: number;  // 1-8
 89:  * }
 90:  * ```
 91:  */
 92: export class GridCell<G extends Game = any, P extends Player = any> extends Space<G, P> {
 93:   /**
 94:    * System-defined layout type
 95:    * Indicates this is a positioned cell within a grid
 96:    * $ prefix indicates this is a system property
 97:    */
 98:   readonly $layout: ElementLayout = 'list'; // GridCell itself is just a container
 99: 
100:   static override unserializableAttributes = [
101:     ...Space.unserializableAttributes,
102:   ];
103: }
````

## File: packages/engine/src/element/hex-grid.ts
````typescript
  1: import { Space } from './space.js';
  2: import type { Game } from './game.js';
  3: import type { Player } from '../player/player.js';
  4: import type { ElementLayout } from './grid.js';
  5: 
  6: /**
  7:  * Hex orientation options
  8:  */
  9: export type HexOrientation = 'flat' | 'pointy';
 10: 
 11: /**
 12:  * Hex coordinate systems
 13:  * - offset: Uses col/row with offset for even/odd rows
 14:  * - axial: Uses q/r coordinates (efficient for most operations)
 15:  * - cube: Uses x/y/z coordinates where x + y + z = 0
 16:  */
 17: export type HexCoordSystem = 'offset' | 'axial' | 'cube';
 18: 
 19: /**
 20:  * A hexagonal grid container
 21:  *
 22:  * HexGrid is a Space that contains HexCell children arranged in a hexagonal pattern.
 23:  * Supports both flat-top and pointy-top orientations.
 24:  *
 25:  * Example:
 26:  * ```typescript
 27:  * class CatanBoard extends HexGrid {}
 28:  * class BattletechMap extends HexGrid {}
 29:  * ```
 30:  */
 31: export class HexGrid<G extends Game = any, P extends Player = any> extends Space<G, P> {
 32:   /**
 33:    * System-defined layout type
 34:    * AutoUI uses this to determine how to render this container
 35:    * $ prefix indicates this is a system property
 36:    */
 37:   readonly $layout: ElementLayout = 'hex-grid';
 38: 
 39:   /**
 40:    * Hex orientation: flat-top or pointy-top
 41:    * - flat: Flat edge at top and bottom (like a ⬡ rotated)
 42:    * - pointy: Point at top and bottom (like a ⬡)
 43:    * @default 'pointy'
 44:    */
 45:   $hexOrientation: HexOrientation = 'pointy';
 46: 
 47:   /**
 48:    * Coordinate system used for hex cells
 49:    * @default 'axial'
 50:    */
 51:   $coordSystem: HexCoordSystem = 'axial';
 52: 
 53:   /**
 54:    * Name of the Q coordinate attribute on HexCell children (axial/cube)
 55:    * @default 'q'
 56:    */
 57:   $qCoord?: string;
 58: 
 59:   /**
 60:    * Name of the R coordinate attribute on HexCell children (axial/cube)
 61:    * @default 'r'
 62:    */
 63:   $rCoord?: string;
 64: 
 65:   /**
 66:    * Name of the S coordinate attribute on HexCell children (cube only)
 67:    * For cube coordinates, s = -q - r
 68:    */
 69:   $sCoord?: string;
 70: 
 71:   /**
 72:    * Size of hexes in pixels (width for flat, height for pointy)
 73:    * @default 50
 74:    */
 75:   $hexSize?: number;
 76: 
 77:   static override unserializableAttributes = [
 78:     ...Space.unserializableAttributes,
 79:   ];
 80: }
 81: 
 82: /**
 83:  * A single cell within a HexGrid
 84:  *
 85:  * HexCell is a Space that represents one hexagonal position in a hex grid.
 86:  * It must have coordinate attributes (q, r for axial; q, r, s for cube).
 87:  *
 88:  * Example:
 89:  * ```typescript
 90:  * class Tile extends HexCell {
 91:  *   q!: number;
 92:  *   r!: number;
 93:  *   terrain!: 'forest' | 'mountain' | 'plains' | 'water';
 94:  *   resource?: 'wood' | 'brick' | 'sheep' | 'wheat' | 'ore';
 95:  * }
 96:  * ```
 97:  */
 98: export class HexCell<G extends Game = any, P extends Player = any> extends Space<G, P> {
 99:   /**
100:    * System property to identify this element type for AutoUI
101:    * $ prefix indicates this is a system property
102:    */
103:   $type!: 'hex-cell';
104: 
105:   constructor(ctx: Partial<import('./types.js').ElementContext>) {
106:     super(ctx);
107:     this.$type = 'hex-cell';
108:   }
109: 
110:   static override unserializableAttributes = [
111:     ...Space.unserializableAttributes,
112:   ];
113: }
````

## File: packages/engine/src/element/piece.ts
````typescript
  1: import { GameElement } from './game-element.js';
  2: import { Space } from './space.js';
  3: import type { ElementClass, ElementAttributes, ElementContext } from './types.js';
  4: import type { Player } from '../player/player.js';
  5: import type { Game } from './game.js';
  6: import type { VisibilityMode } from '../command/visibility.js';
  7: import { visibilityFromMode } from '../command/visibility.js';
  8: 
  9: /**
 10:  * Pieces are game elements that can move during play.
 11:  * Unlike Spaces, Pieces can be relocated between containers.
 12:  *
 13:  * Visibility: Pieces inherit visibility from their parent Space by default.
 14:  * They can explicitly override this to be different from their zone.
 15:  *
 16:  * Examples: cards, tokens, meeples, dice
 17:  */
 18: export class Piece<G extends Game = any, P extends Player = any> extends GameElement<G, P> {
 19:   constructor(ctx: Partial<ElementContext>) {
 20:     super(ctx);
 21:   }
 22: 
 23:   // ============================================
 24:   // Movement
 25:   // ============================================
 26: 
 27:   /**
 28:    * Move this piece into another element (Space or Piece)
 29:    */
 30:   putInto(destination: GameElement, options?: { position?: 'first' | 'last' }): void {
 31:     this.moveToInternal(destination, options?.position);
 32:   }
 33: 
 34:   /**
 35:    * Internal move method called by command executor
 36:    */
 37:   moveToInternal(destination: GameElement, position?: 'first' | 'last'): void {
 38:     const oldParent = this._t.parent;
 39: 
 40:     // Remove from current parent
 41:     if (oldParent) {
 42:       const index = oldParent._t.children.indexOf(this);
 43:       if (index !== -1) {
 44:         oldParent._t.children.splice(index, 1);
 45:       }
 46: 
 47:       // Trigger exit event if parent is a Space
 48:       if (oldParent instanceof Space) {
 49:         oldParent.triggerEvent('exit', this);
 50:       }
 51:     }
 52: 
 53:     // Add to new parent
 54:     this._t.parent = destination;
 55: 
 56:     const pos = position ?? (destination._t.order === 'stacking' ? 'first' : 'last');
 57:     if (pos === 'first') {
 58:       destination._t.children.unshift(this);
 59:     } else {
 60:       destination._t.children.push(this);
 61:     }
 62: 
 63:     // Trigger enter event if moving to a Space
 64:     if (destination instanceof Space) {
 65:       destination.triggerEvent('enter', this);
 66:     }
 67:   }
 68: 
 69:   /**
 70:    * Remove this piece from play (moves to game.pile)
 71:    */
 72:   remove(): void {
 73:     if (this.game.pile) {
 74:       this.putInto(this.game.pile);
 75:     }
 76:   }
 77: 
 78:   // ============================================
 79:   // Visibility Control (explicit overrides of zone default)
 80:   // ============================================
 81: 
 82:   /**
 83:    * Explicitly set this piece's visibility (overrides zone default)
 84:    */
 85:   setVisibility(mode: VisibilityMode): void {
 86:     this._visibility = visibilityFromMode(mode);
 87:   }
 88: 
 89:   /**
 90:    * Make this piece visible to all (overrides zone default)
 91:    */
 92:   showToAll(): void {
 93:     this.setVisibility('all');
 94:   }
 95: 
 96:   /**
 97:    * Make this piece visible only to owner (overrides zone default)
 98:    */
 99:   showToOwner(): void {
100:     this.setVisibility('owner');
101:   }
102: 
103:   /**
104:    * Hide this piece from all (overrides zone default)
105:    */
106:   hideFromAll(): void {
107:     this.setVisibility('hidden');
108:   }
109: 
110:   /**
111:    * Add specific players who can see this piece (beyond inherited visibility)
112:    */
113:   addVisibleTo(...players: (Player | number)[]): void {
114:     const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
115:     this.addVisibleToInternal(positions);
116:   }
117: 
118:   /**
119:    * Show this piece only to a specific player (hide from all others)
120:    */
121:   showOnlyTo(player: Player | number): void {
122:     const position = typeof player === 'number' ? player : player.position;
123:     this._visibility = {
124:       mode: 'hidden',
125:       addPlayers: [position],
126:       explicit: true,
127:     };
128:   }
129: 
130:   /**
131:    * Hide this piece from specific players (visible to all others)
132:    */
133:   hideFrom(...players: (Player | number)[]): void {
134:     const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
135:     this._visibility = {
136:       mode: 'all',
137:       exceptPlayers: positions,
138:       explicit: true,
139:     };
140:   }
141: 
142:   /**
143:    * Clear explicit visibility, reverting to inherited zone visibility
144:    */
145:   clearVisibility(): void {
146:     this._visibility = undefined;
147:   }
148: 
149:   // ============================================
150:   // Piece Restrictions
151:   // ============================================
152: 
153:   /**
154:    * Override create to prevent creating Spaces inside Pieces
155:    */
156:   override create<T extends GameElement>(
157:     elementClass: ElementClass<T>,
158:     name: string,
159:     attributes?: ElementAttributes<T>
160:   ): T {
161:     if (elementClass === Space as unknown as ElementClass<T> ||
162:         Object.prototype.isPrototypeOf.call(Space, elementClass)) {
163:       throw new Error(`Cannot create Space "${name}" inside Piece "${this.name}"`);
164:     }
165:     return super.create(elementClass, name, attributes);
166:   }
167: 
168:   // ============================================
169:   // Type guard
170:   // ============================================
171: 
172:   /**
173:    * Check if this element is a Piece
174:    */
175:   isPiece(): boolean {
176:     return true;
177:   }
178: }
````

## File: packages/engine/src/element/types.ts
````typescript
 1: import type { GameElement } from './game-element.js';
 2: import type { Game } from './game.js';
 3: import type { Player } from '../player/player.js';
 4: import type { VisibilityState } from '../command/visibility.js';
 5: 
 6: /**
 7:  * Constructor type for GameElement subclasses
 8:  */
 9: export type ElementClass<T extends GameElement = GameElement> = {
10:   new (ctx: Partial<ElementContext>): T;
11:   isGameElement: boolean;
12: };
13: 
14: /**
15:  * Shared context for all elements in a game tree
16:  */
17: export type ElementContext = {
18:   /** Root game element */
19:   game: Game;
20:   /** ID sequence counter */
21:   sequence: number;
22:   /** Current player context (for "mine" queries) */
23:   player?: Player;
24:   /** Registry of element classes by name for deserialization and commands */
25:   classRegistry: Map<string, ElementClass>;
26:   /** Random number generator (seeded for replay) */
27:   random: () => number;
28: };
29: 
30: /**
31:  * Internal tree structure for elements
32:  */
33: export type ElementTree<T extends GameElement = GameElement> = {
34:   /** Child elements */
35:   children: T[];
36:   /** Parent element */
37:   parent?: GameElement;
38:   /** Unique immutable ID assigned at creation */
39:   id: number;
40:   /** Child ordering: 'normal' = append, 'stacking' = prepend (like card piles) */
41:   order: 'normal' | 'stacking';
42: };
43: 
44: /**
45:  * JSON representation of an element for serialization
46:  */
47: export type ElementJSON = {
48:   className: string;
49:   id: number;
50:   name?: string;
51:   attributes: Record<string, unknown>;
52:   visibility?: VisibilityState;
53:   children?: ElementJSON[];
54:   /** For 'count-only' visibility mode, just show the count */
55:   childCount?: number;
56: };
57: 
58: /**
59:  * Query finder types - can be:
60:  * - string: match by name
61:  * - function: predicate filter
62:  * - object: match by properties
63:  */
64: export type ElementFinder<T extends GameElement = GameElement> =
65:   | string
66:   | ((element: T) => boolean)
67:   | Partial<Record<string, unknown> & { mine?: boolean; empty?: boolean }>;
68: 
69: /**
70:  * Sorter for element collections
71:  */
72: export type Sorter<T> = keyof T | ((element: T) => number | string);
73: 
74: /**
75:  * Extract settable attributes from an element class (excluding methods and internal props)
76:  */
77: export type ElementAttributes<T extends GameElement> = Partial<
78:   Pick<
79:     T,
80:     {
81:       [K in keyof T]: K extends keyof GameElement
82:         ? never
83:         : T[K] extends (...args: unknown[]) => unknown
84:           ? never
85:           : K;
86:     }[keyof T]
87:   > & {
88:     name?: string;
89:     player?: Player;
90:     row?: number;
91:     column?: number;
92:   }
93: >;
````

## File: packages/engine/src/flow/turn-order.ts
````typescript
  1: import type { Player } from '../player/player.js';
  2: import type { FlowContext } from './types.js';
  3: 
  4: /**
  5:  * Configuration options for eachPlayer that can be spread into the eachPlayer() call
  6:  */
  7: export interface TurnOrderConfig {
  8:   direction?: 'forward' | 'backward';
  9:   filter?: (player: Player, context: FlowContext) => boolean;
 10:   startingPlayer?: (context: FlowContext) => Player;
 11: }
 12: 
 13: /**
 14:  * Turn order presets for common patterns.
 15:  * Use by spreading into eachPlayer():
 16:  *
 17:  * @example
 18:  * ```typescript
 19:  * eachPlayer({
 20:  *   ...TurnOrder.DEFAULT,
 21:  *   do: actionStep({ actions: ['play'] })
 22:  * })
 23:  * ```
 24:  *
 25:  * Note: eachPlayer iterates from startingPlayer to the end of the list,
 26:  * it does NOT wrap around. For full round-robin from a specific player,
 27:  * use CONTINUE or manually structure your flow.
 28:  */
 29: export const TurnOrder = {
 30:   /**
 31:    * Standard round-robin from player 0, going forward through all players
 32:    */
 33:   DEFAULT: {
 34:     direction: 'forward' as const,
 35:   } satisfies TurnOrderConfig,
 36: 
 37:   /**
 38:    * Round-robin going backward (from last player to first)
 39:    */
 40:   REVERSE: {
 41:     direction: 'backward' as const,
 42:   } satisfies TurnOrderConfig,
 43: 
 44:   /**
 45:    * Continue from the current player to the end of the player list.
 46:    * Note: This goes from current player to end, it doesn't wrap around.
 47:    * For a full round starting from a specific player, structure your
 48:    * flow to handle wrap-around explicitly.
 49:    */
 50:   CONTINUE: {
 51:     direction: 'forward' as const,
 52:     startingPlayer: (ctx: FlowContext) => ctx.game.players.current,
 53:   } satisfies TurnOrderConfig,
 54: 
 55:   /**
 56:    * Only players who haven't been eliminated (checks player.eliminated if it exists)
 57:    */
 58:   ACTIVE_ONLY: {
 59:     direction: 'forward' as const,
 60:     filter: (player: Player) => !(player as any).eliminated,
 61:   } satisfies TurnOrderConfig,
 62: 
 63:   /**
 64:    * Start from a specific player position and go forward to the end.
 65:    * Note: Does NOT wrap around - goes from startPlayer to last player only.
 66:    *
 67:    * @example
 68:    * ```typescript
 69:    * // Start from player 1, will visit players 1, 2, ... (not 0)
 70:    * eachPlayer({
 71:    *   ...TurnOrder.START_FROM(1),
 72:    *   do: actionStep({ actions: ['bet'] })
 73:    * })
 74:    *
 75:    * // Start from the dealer
 76:    * eachPlayer({
 77:    *   ...TurnOrder.START_FROM(ctx => ctx.game.dealer),
 78:    *   do: actionStep({ actions: ['bet'] })
 79:    * })
 80:    * ```
 81:    */
 82:   START_FROM: (getPlayer: number | ((ctx: FlowContext) => Player)): TurnOrderConfig => ({
 83:     direction: 'forward' as const,
 84:     startingPlayer: (ctx: FlowContext) => {
 85:       if (typeof getPlayer === 'number') {
 86:         return ctx.game.players[getPlayer];
 87:       }
 88:       return getPlayer(ctx);
 89:     },
 90:   }),
 91: 
 92:   /**
 93:    * Only include specific players by position.
 94:    * Players are still visited in their natural order (0, 1, 2...).
 95:    *
 96:    * @example
 97:    * ```typescript
 98:    * // Only players 0 and 2 participate
 99:    * eachPlayer({
100:    *   ...TurnOrder.ONLY([0, 2]),
101:    *   do: actionStep({ actions: ['bid'] })
102:    * })
103:    * ```
104:    */
105:   ONLY: (positions: number[]): TurnOrderConfig => ({
106:     direction: 'forward' as const,
107:     filter: (player: Player) => positions.includes(player.position),
108:   }),
109: };
````

## File: packages/engine/src/player/index.ts
````typescript
1: export { Player, PlayerCollection } from './player.js';
````

## File: packages/engine/src/player/player.ts
````typescript
  1: import type { Game } from '../element/game.js';
  2: import type { GameElement, ElementClass, ElementFinder } from '../element/index.js';
  3: import { ElementCollection } from '../element/element-collection.js';
  4: 
  5: /**
  6:  * Base Player class. Extend this to add custom player properties.
  7:  */
  8: export class Player<G extends Game = Game> {
  9:   /** Immutable seat position (0-indexed) */
 10:   readonly position: number;
 11: 
 12:   /** Player display name */
 13:   name: string;
 14: 
 15:   /** Player color (hex code) */
 16:   color?: string;
 17: 
 18:   /** Player avatar URL */
 19:   avatar?: string;
 20: 
 21:   /** Reference to the game */
 22:   game!: G;
 23: 
 24:   /** Whether this player is currently taking their turn */
 25:   private _isCurrent: boolean = false;
 26: 
 27:   /** Attributes hidden from other players */
 28:   static hiddenAttributes: string[] = [];
 29: 
 30:   constructor(position: number, name: string) {
 31:     this.position = position;
 32:     this.name = name;
 33:   }
 34: 
 35:   /**
 36:    * Check if this player is the current player
 37:    */
 38:   isCurrent(): boolean {
 39:     return this._isCurrent;
 40:   }
 41: 
 42:   /**
 43:    * Set whether this player is current (called by game flow)
 44:    */
 45:   setCurrent(isCurrent: boolean): void {
 46:     this._isCurrent = isCurrent;
 47:   }
 48: 
 49:   /**
 50:    * Find all elements owned by this player
 51:    */
 52:   allMy<T extends GameElement>(
 53:     className: ElementClass<T>,
 54:     ...finders: ElementFinder<T>[]
 55:   ): ElementCollection<T> {
 56:     return this.game.all(className, { player: this } as ElementFinder<T>, ...finders);
 57:   }
 58: 
 59:   /**
 60:    * Find the first element owned by this player
 61:    */
 62:   my<T extends GameElement>(
 63:     className: ElementClass<T>,
 64:     ...finders: ElementFinder<T>[]
 65:   ): T | undefined {
 66:     return this.game.first(className, { player: this } as ElementFinder<T>, ...finders);
 67:   }
 68: 
 69:   /**
 70:    * Check if this player has any matching elements
 71:    */
 72:   has<T extends GameElement>(
 73:     className: ElementClass<T>,
 74:     ...finders: ElementFinder<T>[]
 75:   ): boolean {
 76:     return this.my(className, ...finders) !== undefined;
 77:   }
 78: 
 79:   /**
 80:    * Get string representation
 81:    */
 82:   toString(): string {
 83:     return this.name;
 84:   }
 85: 
 86:   /**
 87:    * Serialize player to JSON
 88:    */
 89:   toJSON(): Record<string, unknown> {
 90:     return {
 91:       position: this.position,
 92:       name: this.name,
 93:       color: this.color,
 94:       avatar: this.avatar,
 95:     };
 96:   }
 97: }
 98: 
 99: /**
100:  * Collection of players with query methods
101:  */
102: export class PlayerCollection<P extends Player = Player> extends Array<P> {
103:   /** Index of the current player */
104:   private _currentIndex: number = 0;
105: 
106:   /**
107:    * Get the current player
108:    */
109:   get current(): P | undefined {
110:     return this[this._currentIndex];
111:   }
112: 
113:   /**
114:    * Set the current player
115:    */
116:   setCurrent(player: P | number): void {
117:     const index = typeof player === 'number' ? player : player.position;
118: 
119:     // Clear previous current
120:     if (this[this._currentIndex]) {
121:       this[this._currentIndex].setCurrent(false);
122:     }
123: 
124:     this._currentIndex = index;
125: 
126:     // Set new current
127:     if (this[this._currentIndex]) {
128:       this[this._currentIndex].setCurrent(true);
129:     }
130:   }
131: 
132:   /**
133:    * Get the next player in turn order
134:    */
135:   next(from?: P): P {
136:     const currentPos = from?.position ?? this._currentIndex;
137:     const nextPos = (currentPos + 1) % this.length;
138:     return this[nextPos];
139:   }
140: 
141:   /**
142:    * Get the previous player in turn order
143:    */
144:   previous(from?: P): P {
145:     const currentPos = from?.position ?? this._currentIndex;
146:     const prevPos = (currentPos - 1 + this.length) % this.length;
147:     return this[prevPos];
148:   }
149: 
150:   /**
151:    * Get all other players (excluding the given player or current player)
152:    */
153:   others(excluding?: P): PlayerCollection<P> {
154:     const excludePos = excluding?.position ?? this._currentIndex;
155:     const result = new PlayerCollection<P>();
156:     for (const player of this) {
157:       if (player.position !== excludePos) {
158:         result.push(player);
159:       }
160:     }
161:     return result;
162:   }
163: 
164:   /**
165:    * Get the other player (for 2-player games)
166:    */
167:   other(from?: P): P | undefined {
168:     if (this.length !== 2) {
169:       throw new Error('other() can only be used in 2-player games');
170:     }
171:     const fromPos = from?.position ?? this._currentIndex;
172:     return this.find(p => p.position !== fromPos);
173:   }
174: 
175:   /**
176:    * Find a player by position
177:    */
178:   byPosition(position: number): P | undefined {
179:     return this.find(p => p.position === position);
180:   }
181: 
182:   /**
183:    * Get players in turn order starting from a given player
184:    */
185:   inOrderFrom(startPlayer: P): PlayerCollection<P> {
186:     const result = new PlayerCollection<P>();
187:     const startIndex = startPlayer.position;
188: 
189:     for (let i = 0; i < this.length; i++) {
190:       const index = (startIndex + i) % this.length;
191:       result.push(this[index]);
192:     }
193: 
194:     return result;
195:   }
196: 
197:   /**
198:    * Serialize to JSON
199:    */
200:   toJSON(): Record<string, unknown>[] {
201:     return this.map(p => {
202:       // Defensive check for when prototype chain is broken (bundler issues)
203:       if (typeof p.toJSON === 'function') {
204:         return p.toJSON();
205:       }
206:       // Fallback serialization
207:       return {
208:         position: p.position,
209:         name: p.name,
210:         color: p.color,
211:         avatar: p.avatar,
212:       };
213:     });
214:   }
215: }
````

## File: packages/engine/src/sandbox/index.ts
````typescript
  1: /**
  2:  * Sandbox utilities for secure game execution
  3:  *
  4:  * Provides runtime limits and safety checks for executing game code
  5:  */
  6: 
  7: /**
  8:  * Execution limits configuration
  9:  */
 10: export interface ExecutionLimits {
 11:   /** Maximum time for a single action in milliseconds (default: 100ms) */
 12:   actionTimeout: number;
 13:   /** Maximum number of operations before timeout (default: 100000) */
 14:   maxOperations: number;
 15:   /** Maximum recursion depth (default: 100) */
 16:   maxRecursionDepth: number;
 17: }
 18: 
 19: /**
 20:  * Default execution limits
 21:  */
 22: export const DEFAULT_LIMITS: ExecutionLimits = {
 23:   actionTimeout: 100,
 24:   maxOperations: 100000,
 25:   maxRecursionDepth: 100,
 26: };
 27: 
 28: /**
 29:  * Error thrown when execution limits are exceeded
 30:  */
 31: export class ExecutionLimitError extends Error {
 32:   constructor(
 33:     public readonly limitType: 'timeout' | 'operations' | 'recursion',
 34:     message: string
 35:   ) {
 36:     super(message);
 37:     this.name = 'ExecutionLimitError';
 38:   }
 39: }
 40: 
 41: /**
 42:  * Execution context for tracking limits
 43:  */
 44: export class ExecutionContext {
 45:   private operationCount = 0;
 46:   private recursionDepth = 0;
 47:   private startTime: number | null = null;
 48:   private limits: ExecutionLimits;
 49: 
 50:   constructor(limits: Partial<ExecutionLimits> = {}) {
 51:     this.limits = { ...DEFAULT_LIMITS, ...limits };
 52:   }
 53: 
 54:   /**
 55:    * Start tracking execution
 56:    */
 57:   start(): void {
 58:     this.operationCount = 0;
 59:     this.recursionDepth = 0;
 60:     this.startTime = Date.now();
 61:   }
 62: 
 63:   /**
 64:    * Stop tracking and reset
 65:    */
 66:   stop(): void {
 67:     this.startTime = null;
 68:     this.operationCount = 0;
 69:     this.recursionDepth = 0;
 70:   }
 71: 
 72:   /**
 73:    * Record an operation and check limits
 74:    * @throws ExecutionLimitError if limits exceeded
 75:    */
 76:   tick(): void {
 77:     this.operationCount++;
 78: 
 79:     // Check operation count
 80:     if (this.operationCount > this.limits.maxOperations) {
 81:       throw new ExecutionLimitError(
 82:         'operations',
 83:         `Maximum operation count (${this.limits.maxOperations}) exceeded. ` +
 84:         'This may indicate an infinite loop in your game logic.'
 85:       );
 86:     }
 87: 
 88:     // Check timeout
 89:     if (this.startTime !== null) {
 90:       const elapsed = Date.now() - this.startTime;
 91:       if (elapsed > this.limits.actionTimeout) {
 92:         throw new ExecutionLimitError(
 93:           'timeout',
 94:           `Action timeout (${this.limits.actionTimeout}ms) exceeded. ` +
 95:           'Game actions must complete quickly.'
 96:         );
 97:       }
 98:     }
 99:   }
100: 
101:   /**
102:    * Enter a function call (tracks recursion depth)
103:    * @throws ExecutionLimitError if max recursion exceeded
104:    */
105:   enterFunction(): void {
106:     this.recursionDepth++;
107:     if (this.recursionDepth > this.limits.maxRecursionDepth) {
108:       throw new ExecutionLimitError(
109:         'recursion',
110:         `Maximum recursion depth (${this.limits.maxRecursionDepth}) exceeded. ` +
111:         'This may indicate infinite recursion in your game logic.'
112:       );
113:     }
114:   }
115: 
116:   /**
117:    * Exit a function call
118:    */
119:   exitFunction(): void {
120:     this.recursionDepth = Math.max(0, this.recursionDepth - 1);
121:   }
122: 
123:   /**
124:    * Get current execution stats
125:    */
126:   getStats(): {
127:     operations: number;
128:     recursionDepth: number;
129:     elapsedMs: number | null;
130:   } {
131:     return {
132:       operations: this.operationCount,
133:       recursionDepth: this.recursionDepth,
134:       elapsedMs: this.startTime ? Date.now() - this.startTime : null,
135:     };
136:   }
137: }
138: 
139: /**
140:  * Execute a function with limits
141:  * @param fn Function to execute
142:  * @param limits Optional execution limits
143:  * @returns Result of the function
144:  * @throws ExecutionLimitError if limits exceeded
145:  */
146: export function withLimits<T>(
147:   fn: (ctx: ExecutionContext) => T,
148:   limits?: Partial<ExecutionLimits>
149: ): T {
150:   const ctx = new ExecutionContext(limits);
151:   ctx.start();
152:   try {
153:     return fn(ctx);
154:   } finally {
155:     ctx.stop();
156:   }
157: }
158: 
159: /**
160:  * Async version of withLimits
161:  */
162: export async function withLimitsAsync<T>(
163:   fn: (ctx: ExecutionContext) => Promise<T>,
164:   limits?: Partial<ExecutionLimits>
165: ): Promise<T> {
166:   const ctx = new ExecutionContext(limits);
167:   ctx.start();
168:   try {
169:     return await fn(ctx);
170:   } finally {
171:     ctx.stop();
172:   }
173: }
174: 
175: /**
176:  * Create a guarded version of a function that respects execution limits
177:  */
178: export function guard<T extends (...args: unknown[]) => unknown>(
179:   fn: T,
180:   ctx: ExecutionContext
181: ): T {
182:   return ((...args: Parameters<T>) => {
183:     ctx.tick();
184:     ctx.enterFunction();
185:     try {
186:       return fn(...args);
187:     } finally {
188:       ctx.exitFunction();
189:     }
190:   }) as T;
191: }
192: 
193: /**
194:  * Validate that code doesn't contain forbidden patterns
195:  * Used as a secondary check at runtime
196:  */
197: export function validateCode(code: string): { valid: boolean; issues: string[] } {
198:   const issues: string[] = [];
199: 
200:   const forbiddenPatterns = [
201:     { pattern: /\bfetch\s*\(/, message: 'Network access (fetch) is forbidden' },
202:     { pattern: /\bXMLHttpRequest\b/, message: 'Network access (XMLHttpRequest) is forbidden' },
203:     { pattern: /\beval\s*\(/, message: 'Code evaluation (eval) is forbidden' },
204:     { pattern: /\bnew\s+Function\s*\(/, message: 'Code evaluation (Function) is forbidden' },
205:     { pattern: /\bsetTimeout\s*\(/, message: 'Timers (setTimeout) are forbidden' },
206:     { pattern: /\bsetInterval\s*\(/, message: 'Timers (setInterval) are forbidden' },
207:     { pattern: /\bMath\.random\s*\(/, message: 'Math.random() is forbidden - use game.random instead' },
208:     { pattern: /\bDate\.now\s*\(/, message: 'Date.now() is forbidden' },
209:     { pattern: /\brequire\s*\(\s*['"]fs/, message: 'Filesystem access is forbidden' },
210:     { pattern: /\bimport\s*\(\s*['"]fs/, message: 'Filesystem access is forbidden' },
211:   ];
212: 
213:   for (const { pattern, message } of forbiddenPatterns) {
214:     if (pattern.test(code)) {
215:       issues.push(message);
216:     }
217:   }
218: 
219:   return {
220:     valid: issues.length === 0,
221:     issues,
222:   };
223: }
````

## File: packages/engine/src/utils/index.ts
````typescript
 1: // Serialization utilities
 2: export {
 3:   serializeValue,
 4:   deserializeValue,
 5:   serializeAction,
 6:   deserializeAction,
 7:   isSerializedReference,
 8: } from './serializer.js';
 9: 
10: export type {
11:   SerializedReference,
12:   SerializeOptions,
13: } from './serializer.js';
14: 
15: // State snapshots
16: export {
17:   createSnapshot,
18:   createPlayerView,
19:   createAllPlayerViews,
20:   computeDiff,
21: } from './snapshot.js';
22: 
23: export type {
24:   GameStateSnapshot,
25:   PlayerStateView,
26:   StateDiff,
27: } from './snapshot.js';
28: 
29: // Replay system
30: export {
31:   createReplayFile,
32:   validateReplayFile,
33:   parseReplayFile,
34: } from './replay.js';
35: 
36: export type {
37:   ReplayFile,
38: } from './replay.js';
````

## File: packages/engine/src/utils/replay.ts
````typescript
  1: import type { SerializedAction } from '../action/types.js';
  2: 
  3: /**
  4:  * Standardized replay format for:
  5:  * - Local debugging (time-travel)
  6:  * - Platform replay viewing
  7:  * - Bug reproduction (download replays)
  8:  */
  9: export interface ReplayFile {
 10:   /** Replay format version */
 11:   version: 1;
 12: 
 13:   /** Game type identifier (e.g., "go-fish", "cribbage") */
 14:   gameType: string;
 15: 
 16:   /** Game code revision/version when played */
 17:   gameRevision: string;
 18: 
 19:   /** Random seed for deterministic replay */
 20:   seed: string;
 21: 
 22:   /** Number of players in this game */
 23:   playerCount: number;
 24: 
 25:   /** Player names/identifiers */
 26:   playerNames: string[];
 27: 
 28:   /** Complete action history */
 29:   actions: SerializedAction[];
 30: 
 31:   /** How the game ended */
 32:   outcome: 'complete' | 'aborted';
 33: 
 34:   /** Winner positions (if game completed) */
 35:   winners?: number[];
 36: 
 37:   /** ISO timestamp when game was played */
 38:   timestamp: string;
 39: 
 40:   /** Optional metadata */
 41:   metadata?: {
 42:     /** Duration in milliseconds */
 43:     duration?: number;
 44:     /** Platform version */
 45:     platform?: string;
 46:     /** Custom game-specific data */
 47:     custom?: Record<string, unknown>;
 48:   };
 49: }
 50: 
 51: /**
 52:  * Create a new replay file from game data
 53:  */
 54: export function createReplayFile(options: {
 55:   gameType: string;
 56:   gameRevision: string;
 57:   seed: string;
 58:   playerCount: number;
 59:   playerNames: string[];
 60:   actions: SerializedAction[];
 61:   outcome: 'complete' | 'aborted';
 62:   winners?: number[];
 63:   metadata?: ReplayFile['metadata'];
 64: }): ReplayFile {
 65:   return {
 66:     version: 1,
 67:     gameType: options.gameType,
 68:     gameRevision: options.gameRevision,
 69:     seed: options.seed,
 70:     playerCount: options.playerCount,
 71:     playerNames: options.playerNames,
 72:     actions: options.actions,
 73:     outcome: options.outcome,
 74:     winners: options.winners,
 75:     timestamp: new Date().toISOString(),
 76:     metadata: options.metadata,
 77:   };
 78: }
 79: 
 80: /**
 81:  * Validate a replay file structure
 82:  */
 83: export function validateReplayFile(data: unknown): data is ReplayFile {
 84:   if (typeof data !== 'object' || data === null) {
 85:     return false;
 86:   }
 87: 
 88:   const replay = data as Record<string, unknown>;
 89: 
 90:   return (
 91:     replay.version === 1 &&
 92:     typeof replay.gameType === 'string' &&
 93:     typeof replay.gameRevision === 'string' &&
 94:     typeof replay.seed === 'string' &&
 95:     typeof replay.playerCount === 'number' &&
 96:     Array.isArray(replay.playerNames) &&
 97:     Array.isArray(replay.actions) &&
 98:     (replay.outcome === 'complete' || replay.outcome === 'aborted') &&
 99:     typeof replay.timestamp === 'string'
100:   );
101: }
102: 
103: /**
104:  * Parse a JSON string into a ReplayFile
105:  * @throws Error if invalid format
106:  */
107: export function parseReplayFile(json: string): ReplayFile {
108:   const data = JSON.parse(json);
109:   if (!validateReplayFile(data)) {
110:     throw new Error('Invalid replay file format');
111:   }
112:   return data;
113: }
````

## File: packages/engine/src/utils/snapshot.ts
````typescript
  1: import type { Game } from '../element/game.js';
  2: import type { GameCommand } from '../command/types.js';
  3: import type { SerializedAction } from '../action/types.js';
  4: import type { FlowState } from '../flow/types.js';
  5: import type { ElementJSON } from '../element/types.js';
  6: 
  7: /**
  8:  * Complete game state snapshot for persistence/transmission
  9:  */
 10: export interface GameStateSnapshot {
 11:   /** Version for compatibility checking */
 12:   version: number;
 13: 
 14:   /** Game class name for reconstruction */
 15:   gameType: string;
 16: 
 17:   /** Timestamp when snapshot was created */
 18:   timestamp: number;
 19: 
 20:   /** Full element tree state */
 21:   state: ElementJSON & {
 22:     players: Record<string, unknown>[];
 23:     phase: string;
 24:     messages: Array<{ text: string; data?: Record<string, unknown> }>;
 25:     settings: Record<string, unknown>;
 26:   };
 27: 
 28:   /** Flow engine state (if flow is active) */
 29:   flowState?: FlowState;
 30: 
 31:   /** Command history for replay */
 32:   commandHistory: GameCommand[];
 33: 
 34:   /** Action history for replay */
 35:   actionHistory: SerializedAction[];
 36: 
 37:   /** Random seed for deterministic replay */
 38:   seed?: string;
 39: }
 40: 
 41: /**
 42:  * Per-player view of the game state
 43:  */
 44: export interface PlayerStateView {
 45:   /** Player position */
 46:   player: number;
 47: 
 48:   /** Filtered state (hidden elements obscured) */
 49:   state: ElementJSON;
 50: 
 51:   /** Flow state relevant to this player */
 52:   flowState?: {
 53:     awaitingInput: boolean;
 54:     isMyTurn: boolean;
 55:     availableActions?: string[];
 56:     prompt?: string;
 57:   };
 58: 
 59:   /** Messages visible to this player */
 60:   messages: Array<{ text: string; data?: Record<string, unknown> }>;
 61: 
 62:   /** Game phase */
 63:   phase: string;
 64: 
 65:   /** Is game complete? */
 66:   complete: boolean;
 67: 
 68:   /** Winners (if game is complete) */
 69:   winners?: number[];
 70: }
 71: 
 72: /**
 73:  * Create a complete game state snapshot
 74:  */
 75: export function createSnapshot(
 76:   game: Game,
 77:   gameType: string,
 78:   actionHistory: SerializedAction[] = [],
 79:   seed?: string
 80: ): GameStateSnapshot {
 81:   const flowState = game.getFlowState();
 82: 
 83:   return {
 84:     version: 1,
 85:     gameType,
 86:     timestamp: Date.now(),
 87:     state: game.toJSON() as GameStateSnapshot['state'],
 88:     flowState: flowState ?? undefined,
 89:     commandHistory: [...game.commandHistory],
 90:     actionHistory: [...actionHistory],
 91:     seed,
 92:   };
 93: }
 94: 
 95: /**
 96:  * Create a player-specific view of the game state
 97:  */
 98: export function createPlayerView(
 99:   game: Game,
100:   playerPosition: number
101: ): PlayerStateView {
102:   const flowState = game.getFlowState();
103:   const currentPlayer = flowState?.currentPlayer;
104: 
105:   return {
106:     player: playerPosition,
107:     state: game.toJSONForPlayer(playerPosition),
108:     flowState: flowState ? {
109:       awaitingInput: flowState.awaitingInput,
110:       isMyTurn: currentPlayer === playerPosition,
111:       availableActions: flowState.awaitingInput && currentPlayer === playerPosition
112:         ? flowState.availableActions
113:         : undefined,
114:       prompt: flowState.awaitingInput && currentPlayer === playerPosition
115:         ? flowState.prompt
116:         : undefined,
117:     } : undefined,
118:     messages: game.getFormattedMessages().map(text => ({ text })),
119:     phase: game.phase,
120:     complete: flowState?.complete ?? false,
121:     winners: flowState?.complete ? game.getWinners().map(p => p.position) : undefined,
122:   };
123: }
124: 
125: /**
126:  * Create views for all players
127:  */
128: export function createAllPlayerViews(game: Game): PlayerStateView[] {
129:   return game.players.map((_, i) => createPlayerView(game, i));
130: }
131: 
132: /**
133:  * Compute the difference between two snapshots (for efficient sync)
134:  */
135: export interface StateDiff {
136:   /** Changed elements (by ID) */
137:   changed: Map<number, Partial<ElementJSON>>;
138:   /** Added element IDs */
139:   added: number[];
140:   /** Removed element IDs */
141:   removed: number[];
142:   /** New commands since last sync */
143:   newCommands: GameCommand[];
144:   /** New actions since last sync */
145:   newActions: SerializedAction[];
146:   /** Updated flow state */
147:   flowState?: FlowState;
148: }
149: 
150: /**
151:  * Compute diff between two snapshots
152:  */
153: export function computeDiff(
154:   oldSnapshot: GameStateSnapshot,
155:   newSnapshot: GameStateSnapshot
156: ): StateDiff {
157:   const diff: StateDiff = {
158:     changed: new Map(),
159:     added: [],
160:     removed: [],
161:     newCommands: newSnapshot.commandHistory.slice(oldSnapshot.commandHistory.length),
162:     newActions: newSnapshot.actionHistory.slice(oldSnapshot.actionHistory.length),
163:     flowState: newSnapshot.flowState,
164:   };
165: 
166:   // Build maps of elements by ID
167:   const oldElements = new Map<number, ElementJSON>();
168:   const newElements = new Map<number, ElementJSON>();
169: 
170:   function collectElements(json: ElementJSON, map: Map<number, ElementJSON>) {
171:     map.set(json.id, json);
172:     if (json.children) {
173:       for (const child of json.children) {
174:         collectElements(child, map);
175:       }
176:     }
177:   }
178: 
179:   collectElements(oldSnapshot.state, oldElements);
180:   collectElements(newSnapshot.state, newElements);
181: 
182:   // Find added and removed
183:   for (const id of newElements.keys()) {
184:     if (!oldElements.has(id)) {
185:       diff.added.push(id);
186:     }
187:   }
188: 
189:   for (const id of oldElements.keys()) {
190:     if (!newElements.has(id)) {
191:       diff.removed.push(id);
192:     }
193:   }
194: 
195:   // Find changed (simple comparison for now)
196:   for (const [id, newEl] of newElements) {
197:     const oldEl = oldElements.get(id);
198:     if (oldEl && JSON.stringify(oldEl) !== JSON.stringify(newEl)) {
199:       diff.changed.set(id, newEl);
200:     }
201:   }
202: 
203:   return diff;
204: }
````

## File: packages/engine/ARCHITECTURE.md
````markdown
  1: # BoardSmith Engine Architecture
  2: 
  3: ## Core Concepts
  4: 
  5: ### Actions vs Commands
  6: 
  7: BoardSmith uses a two-layer architecture for handling player operations:
  8: 
  9: #### **Actions** (High-Level, Game-Specific)
 10: 
 11: **Location:** `src/action/`
 12: 
 13: Actions represent what **players do** in the game from a game design perspective. They are:
 14: 
 15: - **High-level operations**: "move piece", "draw card", "ask for rank"
 16: - **Game-specific**: Defined by game designers for their particular game
 17: - **Declarative**: Describe *what* players want to do, not *how* to do it
 18: - **User-facing**: Have prompts, selections, and validation for the UI
 19: 
 20: **Example:**
 21: ```typescript
 22: const moveAction = Action.create('move')
 23:   .prompt('Move a piece')
 24:   .chooseElement('from', { prompt: 'Select piece to move' })
 25:   .chooseFrom('to', { prompt: 'Select destination', choices: getValidMoves })
 26:   .execute((args, ctx) => {
 27:     // This execute function generates Commands
 28:     const piece = args.from as Piece;
 29:     const destination = args.to as Space;
 30:     piece.putInto(destination); // ← Generates MoveCommand internally
 31:   });
 32: ```
 33: 
 34: #### **Commands** (Low-Level, Event-Sourced)
 35: 
 36: **Location:** `src/command/`
 37: 
 38: Commands represent **low-level state mutations** that modify the game tree. They are:
 39: 
 40: - **Low-level operations**: `CreateElementCommand`, `MoveCommand`, `SetAttributeCommand`
 41: - **Generic**: Same commands work for any game
 42: - **Imperative**: Direct instructions to modify state
 43: - **Event-sourced**: Tracked, serializable, and replayable
 44: - **Internal**: Not exposed to game designers directly
 45: 
 46: **Example:**
 47: ```typescript
 48: // When piece.putInto(destination) is called, it generates:
 49: {
 50:   type: 'move',
 51:   elementId: piece.id,
 52:   targetId: destination.id,
 53:   position: 'last'
 54: }
 55: ```
 56: 
 57: ### Why This Separation?
 58: 
 59: #### 1. **Separation of Concerns**
 60: - **Actions** handle game logic and player intent
 61: - **Commands** handle state management and persistence
 62: 
 63: #### 2. **Event Sourcing**
 64: - Commands form an event log that can be:
 65:   - Replayed for debugging
 66:   - Stored for game history
 67:   - Used for undo/redo
 68:   - Validated and sanitized
 69: 
 70: #### 3. **Flexibility**
 71: - Game designers work with intuitive Actions
 72: - Engine manages state changes via Commands
 73: - UI can be auto-generated from Action metadata
 74: 
 75: #### 4. **Security**
 76: - Commands are validated before execution
 77: - Players can't directly manipulate state
 78: - All mutations go through the command system
 79: 
 80: ### Flow Diagram
 81: 
 82: ```
 83: ┌─────────────────────────────────────────────────────┐
 84: │ Player selects action in UI                        │
 85: └─────────────────┬───────────────────────────────────┘
 86:                   │
 87:                   ▼
 88: ┌─────────────────────────────────────────────────────┐
 89: │ Action System (High-Level)                          │
 90: │ - Validates selections                              │
 91: │ - Executes game logic                               │
 92: │ - Calls element methods (putInto, create, etc.)    │
 93: └─────────────────┬───────────────────────────────────┘
 94:                   │
 95:                   ▼
 96: ┌─────────────────────────────────────────────────────┐
 97: │ Command System (Low-Level)                          │
 98: │ - Generates MoveCommand, CreateElementCommand, etc.│
 99: │ - Validates against current state                   │
100: │ - Executes state mutations                          │
101: │ - Logs for event sourcing                           │
102: └─────────────────┬───────────────────────────────────┘
103:                   │
104:                   ▼
105: ┌─────────────────────────────────────────────────────┐
106: │ Game State Updated                                  │
107: └─────────────────────────────────────────────────────┘
108: ```
109: 
110: ### Comparison to Other Patterns
111: 
112: #### Redux/Vuex (Frontend State Management)
113: - **Actions** = Actions (user intent)
114: - **Commands** = Mutations (state changes)
115: - Similar pattern, different domain
116: 
117: #### Event Sourcing (Backend Architecture)
118: - **Actions** = Commands (user intent)
119: - **Commands** = Events (things that happened)
120: - BoardSmith uses imperative commands, not past-tense events
121: 
122: #### CQRS (Command Query Responsibility Segregation)
123: - **Actions** = Application commands
124: - **Commands** = Domain events
125: - Similar layering concept
126: 
127: ## When to Use Which?
128: 
129: ### Game Designers Use: **Actions**
130: 
131: ```typescript
132: // Define what players can do
133: const askAction = Action.create('ask')
134:   .choosePlayer('target')
135:   .chooseFrom('rank', { choices: ['A', '2', '3', ...] })
136:   .execute((args, ctx) => {
137:     // Game logic here
138:   });
139: ```
140: 
141: ### Engine Developers Use: **Commands**
142: 
143: ```typescript
144: // Internal state mutations
145: executeCommand({
146:   type: 'move',
147:   elementId: 42,
148:   targetId: 17,
149: });
150: ```
151: 
152: ### Element Methods Generate: **Commands**
153: 
154: ```typescript
155: // Game designers call this
156: piece.putInto(destination);
157: 
158: // Which internally generates this command
159: {
160:   type: 'move',
161:   elementId: piece.id,
162:   targetId: destination.id,
163: }
164: ```
165: 
166: ## Best Practices
167: 
168: ### ✅ Do
169: 
170: - Use Actions for game-specific player operations
171: - Use element methods (`putInto`, `create`) which generate Commands
172: - Let the command system handle state mutations
173: - Keep Action execute functions focused on game logic
174: 
175: ### ❌ Don't
176: 
177: - Don't manually create Commands in game code
178: - Don't bypass the Action system for player operations
179: - Don't directly mutate element properties (use `setAttribute` if needed)
180: - Don't mix UI concerns into Action execute functions
181: 
182: ## Related Documentation
183: 
184: - **[Action API](src/action/README.md)** - Creating player actions
185: - **[Command Types](src/command/types.ts)** - Available command types
186: - **[Element System](src/element/README.md)** - Game element tree structure
187: - **[Flow System](src/flow/README.md)** - Game flow control
188: 
189: ---
190: 
191: **Summary:** Actions are what players *do*. Commands are how the engine *does it*.
````

## File: packages/engine/package.json
````json
 1: {
 2:   "name": "@boardsmith/engine",
 3:   "version": "0.0.1",
 4:   "description": "Core game framework for BoardSmith - provides Game, Player, GameElement, Action, and Flow primitives for building turn-based board and card games",
 5:   "type": "module",
 6:   "main": "./dist/index.js",
 7:   "types": "./dist/index.d.ts",
 8:   "exports": {
 9:     ".": {
10:       "import": "./dist/index.js",
11:       "types": "./dist/index.d.ts"
12:     }
13:   },
14:   "scripts": {
15:     "build": "tsc",
16:     "dev": "tsc --watch",
17:     "test": "vitest run",
18:     "test:watch": "vitest --watch"
19:   },
20:   "devDependencies": {
21:     "typescript": "^5.7.0"
22:   }
23: }
````

## File: packages/eslint-plugin/package.json
````json
 1: {
 2:   "name": "eslint-plugin-boardsmith",
 3:   "version": "0.0.1",
 4:   "description": "ESLint security rules for BoardSmith game code - enforces sandboxing restrictions (no-network, no-filesystem, no-timers, no-eval, no-nondeterministic)",
 5:   "main": "dist/index.js",
 6:   "types": "dist/index.d.ts",
 7:   "type": "module",
 8:   "exports": {
 9:     ".": {
10:       "import": "./dist/index.js",
11:       "types": "./dist/index.d.ts"
12:     }
13:   },
14:   "scripts": {
15:     "build": "tsc",
16:     "dev": "tsc --watch"
17:   },
18:   "peerDependencies": {
19:     "eslint": ">=8.0.0"
20:   },
21:   "devDependencies": {
22:     "@types/eslint": "^8.56.0",
23:     "@types/node": "^20.10.0",
24:     "typescript": "^5.7.0"
25:   },
26:   "keywords": [
27:     "eslint",
28:     "eslintplugin",
29:     "boardsmith",
30:     "game",
31:     "security"
32:   ]
33: }
````

## File: packages/games/checkers/rules/src/ai.ts
````typescript
 1: import type { Game } from '@boardsmith/engine';
 2: import type { Objective } from '@boardsmith/ai';
 3: import type { CheckersGame } from './game.js';
 4: import type { CheckersPlayer } from './elements.js';
 5: 
 6: /**
 7:  * AI objectives for Checkers
 8:  * These guide the MCTS bot to prefer better positions during playouts
 9:  */
10: export function getCheckersObjectives(
11:   game: Game,
12:   playerIndex: number
13: ): Record<string, Objective> {
14:   const checkersGame = game as CheckersGame;
15:   const player = checkersGame.players[playerIndex] as CheckersPlayer;
16:   const opponent = checkersGame.players[1 - playerIndex] as CheckersPlayer;
17: 
18:   return {
19:     // Having more pieces is good
20:     'piece-advantage': {
21:       checker: () => {
22:         const myPieces = checkersGame.getPlayerPieces(player).length;
23:         const theirPieces = checkersGame.getPlayerPieces(opponent).length;
24:         return myPieces > theirPieces;
25:       },
26:       weight: 5,
27:     },
28: 
29:     // Having more kings is very good
30:     'king-advantage': {
31:       checker: () => {
32:         const myKings = checkersGame.getPlayerPieces(player).filter(p => p.isKing).length;
33:         const theirKings = checkersGame.getPlayerPieces(opponent).filter(p => p.isKing).length;
34:         return myKings > theirKings;
35:       },
36:       weight: 8,
37:     },
38: 
39:     // Control the center (squares in rows 3-4)
40:     'center-control': {
41:       checker: () => {
42:         const myPieces = checkersGame.getPlayerPieces(player);
43:         const centerPieces = myPieces.filter(p => {
44:           const square = checkersGame.getPieceSquare(p);
45:           return square && square.row >= 3 && square.row <= 4;
46:         });
47:         return centerPieces.length >= 2;
48:       },
49:       weight: 3,
50:     },
51: 
52:     // Advancing pieces toward king row is good
53:     'advancement': {
54:       checker: () => {
55:         const myPieces = checkersGame.getPlayerPieces(player).filter(p => !p.isKing);
56:         if (myPieces.length === 0) return false;
57: 
58:         const kingRow = player.position === 0 ? 7 : 0;
59:         const avgDistance = myPieces.reduce((sum, p) => {
60:           const square = checkersGame.getPieceSquare(p);
61:           if (!square) return sum;
62:           return sum + Math.abs(square.row - kingRow);
63:         }, 0) / myPieces.length;
64: 
65:         // Good if average distance to king row is less than 3
66:         return avgDistance < 3;
67:       },
68:       weight: 2,
69:     },
70: 
71:     // Protect the back row (prevent opponent kings)
72:     'back-row-defense': {
73:       checker: () => {
74:         const backRow = player.position === 0 ? 0 : 7;
75:         const myPieces = checkersGame.getPlayerPieces(player);
76:         const backRowPieces = myPieces.filter(p => {
77:           const square = checkersGame.getPieceSquare(p);
78:           return square && square.row === backRow;
79:         });
80:         return backRowPieces.length >= 1;
81:       },
82:       weight: 2,
83:     },
84: 
85:     // Having capture opportunities is good
86:     'capture-available': {
87:       checker: () => checkersGame.playerHasCaptures(player),
88:       weight: 4,
89:     },
90: 
91:     // Opponent having no moves is very good (near win)
92:     'opponent-blocked': {
93:       checker: () => checkersGame.getValidMoves(opponent).length === 0,
94:       weight: 20,
95:     },
96:   };
97: }
````

## File: packages/games/checkers/rules/src/elements.ts
````typescript
  1: import { Piece, Grid, GridCell, Player } from '@boardsmith/engine';
  2: import type { CheckersGame } from './game.js';
  3: 
  4: /**
  5:  * A checker piece that can be a regular piece or a king
  6:  */
  7: export class CheckerPiece extends Piece<CheckersGame, CheckersPlayer> {
  8:   /** Whether this piece has been crowned as a king */
  9:   isKing: boolean = false;
 10: 
 11:   /**
 12:    * Get the direction this piece can move (1 = down the board, -1 = up)
 13:    * Regular pieces move toward opponent's side, kings move both ways
 14:    */
 15:   get forwardDirection(): number {
 16:     // Player 0 (dark) starts at top, moves down (+1)
 17:     // Player 1 (light) starts at bottom, moves up (-1)
 18:     return this.player?.position === 0 ? 1 : -1;
 19:   }
 20: 
 21:   /**
 22:    * Crown this piece as a king
 23:    */
 24:   crown(): void {
 25:     this.isKing = true;
 26:   }
 27: }
 28: 
 29: /**
 30:  * A square on the checkerboard
 31:  * Only dark squares are playable in checkers
 32:  */
 33: export class Square extends GridCell<CheckersGame, CheckersPlayer> {
 34:   /** Row position (0-7, 0 is top) */
 35:   declare row: number;
 36:   /** Column position (0-7, 0 is left) */
 37:   col!: number;
 38:   /** Whether this is a dark (playable) square */
 39:   isDark!: boolean;
 40: 
 41:   /**
 42:    * Get the piece on this square, if any
 43:    */
 44:   getPiece(): CheckerPiece | undefined {
 45:     return this.first(CheckerPiece);
 46:   }
 47: 
 48:   /**
 49:    * Check if this square is empty
 50:    */
 51:   isEmpty(): boolean {
 52:     return this.count(CheckerPiece) === 0;
 53:   }
 54: 
 55:   /**
 56:    * Check if this square has an opponent's piece
 57:    */
 58:   hasOpponentPiece(player: CheckersPlayer): boolean {
 59:     const piece = this.getPiece();
 60:     return piece !== undefined && piece.player !== player;
 61:   }
 62: 
 63:   /**
 64:    * Check if this square has a friendly piece
 65:    */
 66:   hasFriendlyPiece(player: CheckersPlayer): boolean {
 67:     const piece = this.getPiece();
 68:     return piece !== undefined && piece.player === player;
 69:   }
 70: 
 71:   /**
 72:    * Get algebraic notation for this square (a1-h8 style)
 73:    */
 74:   get notation(): string {
 75:     const col = String.fromCharCode(97 + this.col); // a-h
 76:     const row = 8 - this.row; // 1-8 (row 0 = 8, row 7 = 1)
 77:     return `${col}${row}`;
 78:   }
 79: }
 80: 
 81: /**
 82:  * The checkerboard - contains all 64 squares
 83:  */
 84: export class Board extends Grid<CheckersGame, CheckersPlayer> {
 85:   // Set grid labels for AutoUI (chess-style notation)
 86:   $rowLabels = ['8', '7', '6', '5', '4', '3', '2', '1'];
 87:   $columnLabels = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
 88:   // Tell AutoUI which attributes represent coordinates
 89:   $rowCoord = 'row';
 90:   $colCoord = 'col';
 91: 
 92:   /**
 93:    * Get a square by row and column
 94:    */
 95:   getSquare(row: number, col: number): Square | undefined {
 96:     return this.first(Square, { row, col });
 97:   }
 98: 
 99:   /**
100:    * Get a square by algebraic notation (e.g., "a1")
101:    */
102:   getSquareByNotation(notation: string): Square | undefined {
103:     const col = notation.charCodeAt(0) - 97; // 'a' = 0
104:     const row = 8 - parseInt(notation[1]); // '8' = 0
105:     return this.getSquare(row, col);
106:   }
107: 
108:   /**
109:    * Get all dark (playable) squares
110:    */
111:   getDarkSquares(): Square[] {
112:     return [...this.all(Square, { isDark: true })];
113:   }
114: }
115: 
116: /**
117:  * Checkers player
118:  */
119: export class CheckersPlayer extends Player {
120:   /** Number of pieces captured by this player */
121:   capturedCount: number = 0;
122: }
123: 
124: /**
125:  * Represents a move in checkers (can be a sequence of jumps)
126:  */
127: export interface CheckersMove {
128:   /** The piece being moved */
129:   piece: CheckerPiece;
130:   /** Starting square */
131:   from: Square;
132:   /** Ending square */
133:   to: Square;
134:   /** Squares jumped over (for captures) */
135:   captures: Square[];
136:   /** Whether this move results in a king */
137:   becomesKing: boolean;
138: }
````

## File: packages/games/checkers/rules/src/index.ts
````typescript
 1: // Checkers game package
 2: export { CheckersGame, type CheckersOptions } from './game.js';
 3: export { Board, Square, CheckerPiece, CheckersPlayer, type CheckersMove } from './elements.js';
 4: export { createMoveAction } from './actions.js';
 5: export { createCheckersFlow } from './flow.js';
 6: export { getCheckersObjectives } from './ai.js';
 7: 
 8: import { CheckersGame } from './game.js';
 9: import { getCheckersObjectives } from './ai.js';
10: 
11: /**
12:  * Game definition for the worker to register this game.
13:  * Contains all metadata needed to run Checkers.
14:  */
15: export const gameDefinition = {
16:   gameClass: CheckersGame,
17:   gameType: 'checkers',
18:   displayName: 'Checkers',
19:   minPlayers: 2,
20:   maxPlayers: 2,
21:   ai: {
22:     objectives: getCheckersObjectives,
23:   },
24: } as const;
````

## File: packages/games/cribbage/rules/src/actions.ts
````typescript
  1: import { Action, type ActionDefinition } from '@boardsmith/engine';
  2: import type { CribbageGame } from './game.js';
  3: import { Card, CribbagePlayer } from './elements.js';
  4: 
  5: /**
  6:  * Create the "discard" action for Cribbage
  7:  * Players discard 2 cards to the crib
  8:  */
  9: export function createDiscardAction(game: CribbageGame): ActionDefinition {
 10:   return Action.create('discard')
 11:     .prompt('Discard 2 cards to the crib')
 12:     .chooseFrom<string>('card1', {
 13:       prompt: 'Choose first card to discard',
 14:       choices: (ctx) => {
 15:         const game = ctx.game as CribbageGame;
 16:         const player = ctx.player as CribbagePlayer;
 17:         const hand = game.getPlayerHand(player);
 18:         return [...hand.all(Card)].map(c => c.name).filter((n): n is string => n !== undefined);
 19:       },
 20:       display: (cardName) => {
 21:         const card = game.first(Card, cardName);
 22:         return card ? `${card.rank}${card.suit}` : cardName;
 23:       },
 24:       boardRefs: (cardName, ctx) => {
 25:         const card = game.first(Card, cardName);
 26:         return card ? { sourceRef: { id: card.id, name: card.name } } : {};
 27:       },
 28:     })
 29:     .chooseFrom<string>('card2', {
 30:       prompt: 'Choose second card to discard',
 31:       choices: (ctx) => {
 32:         const game = ctx.game as CribbageGame;
 33:         const player = ctx.player as CribbagePlayer;
 34:         const hand = game.getPlayerHand(player);
 35:         const firstCard = ctx.args.card1 as string;
 36:         return [...hand.all(Card)]
 37:           .map(c => c.name)
 38:           .filter((n): n is string => n !== undefined && n !== firstCard);
 39:       },
 40:       display: (cardName) => {
 41:         const card = game.first(Card, cardName);
 42:         return card ? `${card.rank}${card.suit}` : cardName;
 43:       },
 44:       boardRefs: (cardName, ctx) => {
 45:         const card = game.first(Card, cardName);
 46:         return card ? { sourceRef: { id: card.id, name: card.name } } : {};
 47:       },
 48:     })
 49:     .condition((ctx) => {
 50:       const game = ctx.game as CribbageGame;
 51:       const player = ctx.player as CribbagePlayer;
 52:       const hand = game.getPlayerHand(player);
 53:       return game.cribbagePhase === 'discarding' && hand.count(Card) === 6;
 54:     })
 55:     .execute((args, ctx) => {
 56:       const game = ctx.game as CribbageGame;
 57:       const player = ctx.player as CribbagePlayer;
 58:       const card1Name = args.card1 as string;
 59:       const card2Name = args.card2 as string;
 60: 
 61:       const card1 = game.first(Card, card1Name);
 62:       const card2 = game.first(Card, card2Name);
 63: 
 64:       if (!card1 || !card2) {
 65:         return { success: false, error: 'Card not found' };
 66:       }
 67: 
 68:       card1.putInto(game.crib);
 69:       card2.putInto(game.crib);
 70: 
 71:       game.message(`${player.name} discards ${card1.rank}${card1.suit} and ${card2.rank}${card2.suit} to the crib`);
 72: 
 73:       return {
 74:         success: true,
 75:         data: {
 76:           doneDiscarding: true,
 77:         },
 78:         message: `Discarded 2 cards to crib`,
 79:       };
 80:     });
 81: }
 82: 
 83: /**
 84:  * Create the "playCard" action for the play phase
 85:  */
 86: export function createPlayCardAction(game: CribbageGame): ActionDefinition {
 87:   return Action.create('playCard')
 88:     .prompt('Play a card')
 89:     .chooseElement('card', {
 90:       prompt: 'Choose a card to play',
 91:       elementClass: Card,
 92:       from: (ctx) => {
 93:         const game = ctx.game as CribbageGame;
 94:         const player = ctx.player as CribbagePlayer;
 95:         return game.getPlayerHand(player);
 96:       },
 97:       filter: (card, ctx) => {
 98:         const game = ctx.game as CribbageGame;
 99:         const player = ctx.player as CribbagePlayer;
100:         const playable = game.getPlayableCards(player);
101:         return playable.some(c => c.id === card.id);
102:       },
103:       display: (card) => {
104:         return `${card.rank}${card.suit} (${card.pointValue})`;
105:       },
106:     })
107:     .condition((ctx) => {
108:       const game = ctx.game as CribbageGame;
109:       const player = ctx.player as CribbagePlayer;
110:       // Can play if in play phase and has playable cards
111:       return game.cribbagePhase === 'play' && game.getPlayableCards(player).length > 0;
112:     })
113:     .execute((args, ctx) => {
114:       const game = ctx.game as CribbageGame;
115:       const player = ctx.player as CribbagePlayer;
116:       // args.card is resolved to the actual Card element by ActionExecutor.resolveArgs
117:       const card = args.card as Card;
118: 
119:       if (!card) {
120:         return { success: false, error: 'Card not found' };
121:       }
122: 
123:       if (!game.canPlayCard(player, card)) {
124:         return { success: false, error: 'Cannot play this card (would exceed 31)' };
125:       }
126: 
127:       const pointsScored = game.playCard(player, card);
128: 
129:       // Check if count hit 31 (auto-reset, which also resets Go flags)
130:       const hitThirtyOne = game.runningTotal === 31;
131:       if (hitThirtyOne) {
132:         game.resetCount();
133:       }
134: 
135:       // Note: Do NOT reset Go flags here - they only reset when count resets
136:       // If opponent said Go, current player continues until they can't play either
137: 
138:       return {
139:         success: true,
140:         data: {
141:           pointsScored,
142:           runningTotal: game.runningTotal,
143:           hitThirtyOne,
144:         },
145:         message: `Played ${card.rank}${card.suit}${pointsScored > 0 ? ` for ${pointsScored} points` : ''}`,
146:       };
147:     });
148: }
149: 
150: /**
151:  * Create the "sayGo" action when a player can't play
152:  */
153: export function createSayGoAction(game: CribbageGame): ActionDefinition {
154:   return Action.create('sayGo')
155:     .prompt('Say "Go" (cannot play)')
156:     .condition((ctx) => {
157:       const game = ctx.game as CribbageGame;
158:       const player = ctx.player as CribbagePlayer;
159:       // Must say Go if in play phase, has cards in hand, but none are playable
160:       return game.cribbagePhase === 'play' &&
161:              game.mustSayGo(player) &&
162:              !game.playerSaidGo[player.position];
163:     })
164:     .execute((args, ctx) => {
165:       const game = ctx.game as CribbageGame;
166:       const player = ctx.player as CribbagePlayer;
167:       game.playerSaidGo[player.position] = true;
168:       game.message(`${player.name} says "Go"`);
169: 
170:       // Check if both players have said Go
171:       const otherPlayer = game.players.find(p => p.position !== player.position) as CribbagePlayer;
172:       const otherSaidGo = game.playerSaidGo[otherPlayer.position];
173:       const otherCanPlay = game.getPlayableCards(otherPlayer).length > 0;
174:       const otherHasCards = game.getPlayerHand(otherPlayer).count(Card) > 0;
175: 
176:       // If other player already said Go or has no cards, last player to play gets 1 point
177:       if ((otherSaidGo && !otherCanPlay) || !otherHasCards) {
178:         // Award point for "Go" or "Last card"
179:         const lastPlayer = game.players[game.lastPlayerToPlay] as CribbagePlayer;
180:         if (lastPlayer) {
181:           game.addPoints(lastPlayer, 1, game.runningTotal === 31 ? 'Thirty-one' : 'Go');
182:         }
183:         game.resetCount();
184:       }
185: 
186:       return {
187:         success: true,
188:         data: {
189:           otherPlayerGo: otherSaidGo,
190:         },
191:         message: 'Go!',
192:       };
193:     });
194: }
195: 
196: /**
197:  * Create the "acknowledgeScore" action to continue after viewing a score
198:  * Either player can acknowledge to proceed
199:  */
200: export function createAcknowledgeScoreAction(game: CribbageGame): ActionDefinition {
201:   return Action.create('acknowledgeScore')
202:     .prompt('Continue')
203:     .condition((ctx) => {
204:       const game = ctx.game as CribbageGame;
205:       // Can acknowledge if there's an active scoring animation or round summary
206:       return game.cribbagePhase === 'scoring' && (game.scoringAnimation.active || game.roundSummary.active);
207:     })
208:     .execute((args, ctx) => {
209:       const game = ctx.game as CribbageGame;
210:       // Clear the scoring animation so the game can proceed
211:       game.clearScoringAnimation();
212: 
213:       return {
214:         success: true,
215:         message: 'Continuing...',
216:       };
217:     });
218: }
````

## File: packages/games/cribbage/rules/src/ai.ts
````typescript
 1: import type { Game } from '@boardsmith/engine';
 2: import type { Objective } from '@boardsmith/ai';
 3: import type { CribbageGame } from './game.js';
 4: import type { CribbagePlayer } from './elements.js';
 5: 
 6: /**
 7:  * AI objectives for Cribbage
 8:  * These guide the MCTS bot to prefer better positions during playouts
 9:  */
10: export function getCribbageObjectives(
11:   game: Game,
12:   playerIndex: number
13: ): Record<string, Objective> {
14:   const cribbageGame = game as CribbageGame;
15:   const player = cribbageGame.players[playerIndex] as CribbagePlayer;
16:   const opponent = cribbageGame.players[1 - playerIndex] as CribbagePlayer;
17: 
18:   return {
19:     // Having a score lead is good
20:     'score-lead': {
21:       checker: () => player.score > opponent.score,
22:       weight: 5,
23:     },
24: 
25:     // Being close to winning is very good
26:     'near-win': {
27:       checker: () => player.score >= 100,
28:       weight: 15,
29:     },
30: 
31:     // Being very close to winning (about to win)
32:     'winning-position': {
33:       checker: () => player.score >= 115,
34:       weight: 25,
35:     },
36: 
37:     // Preventing opponent from winning
38:     'block-opponent-win': {
39:       checker: () => opponent.score < 100,
40:       weight: 10,
41:     },
42: 
43:     // Being the dealer is a slight advantage (get crib)
44:     'is-dealer': {
45:       checker: () => player.isDealer,
46:       weight: 2,
47:     },
48: 
49:     // Large score lead (15+ points)
50:     'large-lead': {
51:       checker: () => player.score - opponent.score >= 15,
52:       weight: 8,
53:     },
54: 
55:     // In a close game, every point matters
56:     'close-game-ahead': {
57:       checker: () => {
58:         const diff = player.score - opponent.score;
59:         return diff > 0 && diff < 10 && player.score >= 90;
60:       },
61:       weight: 12,
62:     },
63: 
64:     // Opponent falling behind significantly
65:     'opponent-behind': {
66:       checker: () => opponent.score < player.score - 20,
67:       weight: 6,
68:     },
69: 
70:     // Already won
71:     'game-won': {
72:       checker: () => player.score >= cribbageGame.targetScore,
73:       weight: 50,
74:     },
75:   };
76: }
````

## File: packages/games/cribbage/rules/src/elements.ts
````typescript
 1: import { Card as BaseCard, Hand as BaseHand, Deck as BaseDeck, Space, Player } from '@boardsmith/engine';
 2: 
 3: /**
 4:  * Cribbage card with suit and rank
 5:  * In Cribbage:
 6:  * - Face cards (J, Q, K) = 10 points
 7:  * - Number cards = face value
 8:  * - Ace = 1 point
 9:  */
10: export class Card extends BaseCard<CribbageGame, CribbagePlayer> {
11:   suit!: 'H' | 'D' | 'C' | 'S';
12:   rank!: string; // 'A', '2'-'10', 'J', 'Q', 'K'
13: 
14:   /**
15:    * Get the point value for counting (pegging/fifteens)
16:    * A=1, 2-10=face value, J/Q/K=10
17:    */
18:   get pointValue(): number {
19:     if (this.rank === 'A') return 1;
20:     if (['J', 'Q', 'K'].includes(this.rank)) return 10;
21:     return parseInt(this.rank, 10);
22:   }
23: 
24:   /**
25:    * Get the numeric rank for run detection
26:    * A=1, 2=2, ..., 10=10, J=11, Q=12, K=13
27:    */
28:   get rankValue(): number {
29:     const values: Record<string, number> = {
30:       'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
31:       '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
32:     };
33:     return values[this.rank] ?? 0;
34:   }
35: 
36:   toString(): string {
37:     return `${this.rank}${this.suit}`;
38:   }
39: }
40: 
41: /**
42:  * A player's hand - visible only to the owner
43:  */
44: export class Hand extends BaseHand<CribbageGame, CribbagePlayer> {}
45: 
46: /**
47:  * The crib - 4 cards belonging to the dealer, hidden until scoring
48:  * Extends Deck so AutoUI renders it with card back visualization
49:  */
50: export class Crib extends BaseDeck<CribbageGame, CribbagePlayer> {}
51: 
52: /**
53:  * The deck (draw pile) - hidden from all players
54:  */
55: export class Deck extends BaseDeck<CribbageGame, CribbagePlayer> {}
56: 
57: /**
58:  * The play area - cards played during the play phase
59:  */
60: export class PlayArea extends Space<CribbageGame, CribbagePlayer> {}
61: 
62: /**
63:  * Played cards pile - cards already counted in play phase
64:  */
65: export class PlayedCards extends Space<CribbageGame, CribbagePlayer> {}
66: 
67: /**
68:  * Starter card area - the cut card
69:  */
70: export class StarterArea extends Space<CribbageGame, CribbagePlayer> {}
71: 
72: /**
73:  * Cribbage player with score tracking
74:  */
75: export class CribbagePlayer extends Player {
76:   /** Current score (0-121) */
77:   score: number = 0;
78: 
79:   /** Whether this player is the dealer this round */
80:   isDealer: boolean = false;
81: 
82:   /** Cards already played this round (for tracking during play phase) */
83:   cardsPlayedThisRound: number = 0;
84: 
85:   /** Original hand card IDs (stored after discard, before play phase for scoring) */
86:   originalHandCardIds: string[] = [];
87: }
88: 
89: // Forward declare for circular reference
90: import type { CribbageGame } from './game.js';
````

## File: packages/games/cribbage/rules/src/index.ts
````typescript
 1: // Cribbage game package
 2: export { CribbageGame, type CribbageOptions, type CribbagePhase } from './game.js';
 3: export { Card, Hand, Crib, Deck, PlayArea, PlayedCards, StarterArea, CribbagePlayer } from './elements.js';
 4: export { createDiscardAction, createPlayCardAction, createSayGoAction, createAcknowledgeScoreAction } from './actions.js';
 5: export { createCribbageFlow } from './flow.js';
 6: export {
 7:   scoreHand,
 8:   scoreHandDetailed,
 9:   scorePegging,
10:   countFifteens,
11:   countPairs,
12:   countRuns,
13:   countFlush,
14:   checkNobs,
15:   type ScoreBreakdown,
16:   type DetailedScoreBreakdown,
17:   type ScoringItem,
18:   type PeggingScore,
19: } from './scoring.js';
20: export { getCribbageObjectives } from './ai.js';
21: 
22: import { CribbageGame } from './game.js';
23: import { getCribbageObjectives } from './ai.js';
24: 
25: /**
26:  * Game definition for the worker to register this game.
27:  * Contains all metadata needed to run Cribbage.
28:  */
29: export const gameDefinition = {
30:   gameClass: CribbageGame,
31:   gameType: 'cribbage',
32:   displayName: 'Cribbage',
33:   minPlayers: 2,
34:   maxPlayers: 2,
35:   ai: {
36:     objectives: getCribbageObjectives,
37:   },
38: } as const;
````

## File: packages/games/cribbage/rules/src/scoring.ts
````typescript
  1: import { Card } from './elements.js';
  2: 
  3: /**
  4:  * Score breakdown for display purposes
  5:  */
  6: export interface ScoreBreakdown {
  7:   fifteens: number;      // 2 points per combination summing to 15
  8:   pairs: number;         // 2 points per pair
  9:   runs: number;          // 1 point per card in runs
 10:   flush: number;         // 4-5 points for flush
 11:   nobs: number;          // 1 point for Jack matching starter suit
 12:   total: number;
 13:   details: string[];     // Human-readable breakdown
 14: }
 15: 
 16: /**
 17:  * A single scoring item for animated reveal
 18:  */
 19: export interface ScoringItem {
 20:   category: 'fifteen' | 'pair' | 'run' | 'flush' | 'nobs';
 21:   points: number;
 22:   cards: Card[];
 23:   description: string;
 24: }
 25: 
 26: /**
 27:  * Detailed scoring result with individual combinations
 28:  */
 29: export interface DetailedScoreBreakdown {
 30:   items: ScoringItem[];
 31:   total: number;
 32: }
 33: 
 34: /**
 35:  * Calculate all fifteens in a set of cards
 36:  * Each combination of cards summing to 15 = 2 points
 37:  */
 38: export function countFifteens(cards: Card[]): { count: number; combinations: Card[][] } {
 39:   const combinations: Card[][] = [];
 40:   const n = cards.length;
 41: 
 42:   // Check all possible subsets (2^n - 1, excluding empty set)
 43:   for (let mask = 1; mask < (1 << n); mask++) {
 44:     const subset: Card[] = [];
 45:     let sum = 0;
 46: 
 47:     for (let i = 0; i < n; i++) {
 48:       if (mask & (1 << i)) {
 49:         subset.push(cards[i]);
 50:         sum += cards[i].pointValue;
 51:       }
 52:     }
 53: 
 54:     if (sum === 15) {
 55:       combinations.push(subset);
 56:     }
 57:   }
 58: 
 59:   return { count: combinations.length, combinations };
 60: }
 61: 
 62: /**
 63:  * Count pairs in a set of cards
 64:  * Pair = 2 points, Three of a kind = 6 points, Four of a kind = 12 points
 65:  */
 66: export function countPairs(cards: Card[]): { count: number; pairs: [Card, Card][] } {
 67:   const pairs: [Card, Card][] = [];
 68: 
 69:   for (let i = 0; i < cards.length; i++) {
 70:     for (let j = i + 1; j < cards.length; j++) {
 71:       if (cards[i].rank === cards[j].rank) {
 72:         pairs.push([cards[i], cards[j]]);
 73:       }
 74:     }
 75:   }
 76: 
 77:   return { count: pairs.length, pairs };
 78: }
 79: 
 80: /**
 81:  * Find all runs in a set of cards
 82:  * A run is 3+ cards in sequence (by rank value)
 83:  * Returns the total points from runs
 84:  */
 85: export function countRuns(cards: Card[]): { points: number; runs: Card[][] } {
 86:   const runs: Card[][] = [];
 87:   const n = cards.length;
 88: 
 89:   if (n < 3) return { points: 0, runs: [] };
 90: 
 91:   // Get rank values and count duplicates
 92:   const rankCounts = new Map<number, number>();
 93:   for (const card of cards) {
 94:     const rv = card.rankValue;
 95:     rankCounts.set(rv, (rankCounts.get(rv) ?? 0) + 1);
 96:   }
 97: 
 98:   // Get unique rank values sorted
 99:   const uniqueRanks = [...rankCounts.keys()].sort((a, b) => a - b);
100: 
101:   // Find consecutive sequences in unique ranks
102:   let runStart = 0;
103:   let maxRunLength = 0;
104:   let currentRunStart = 0;
105:   let currentRunLength = 1;
106: 
107:   for (let i = 1; i <= uniqueRanks.length; i++) {
108:     if (i < uniqueRanks.length && uniqueRanks[i] === uniqueRanks[i - 1] + 1) {
109:       currentRunLength++;
110:     } else {
111:       if (currentRunLength >= 3 && currentRunLength > maxRunLength) {
112:         maxRunLength = currentRunLength;
113:         runStart = currentRunStart;
114:       }
115:       currentRunStart = i;
116:       currentRunLength = 1;
117:     }
118:   }
119: 
120:   if (maxRunLength < 3) return { points: 0, runs: [] };
121: 
122:   // Calculate multiplier from duplicates within the run
123:   const runRanks = uniqueRanks.slice(runStart, runStart + maxRunLength);
124:   let multiplier = 1;
125:   for (const rank of runRanks) {
126:     multiplier *= rankCounts.get(rank)!;
127:   }
128: 
129:   // Generate all run combinations
130:   function generateRuns(rankIndex: number, currentRun: Card[]): void {
131:     if (rankIndex >= runRanks.length) {
132:       runs.push([...currentRun]);
133:       return;
134:     }
135: 
136:     const rank = runRanks[rankIndex];
137:     const cardsOfRank = cards.filter(c => c.rankValue === rank);
138:     for (const card of cardsOfRank) {
139:       currentRun.push(card);
140:       generateRuns(rankIndex + 1, currentRun);
141:       currentRun.pop();
142:     }
143:   }
144: 
145:   generateRuns(0, []);
146: 
147:   const points = maxRunLength * multiplier;
148:   return { points, runs };
149: }
150: 
151: /**
152:  * Check for flush
153:  * Hand flush: 4 cards same suit = 4 points
154:  * If starter also matches = 5 points
155:  * In crib, all 5 must match for 5 points (no 4-card flush)
156:  */
157: export function countFlush(
158:   handCards: Card[],
159:   starterCard: Card | null,
160:   isCrib: boolean
161: ): { points: number; cards: Card[] } {
162:   if (handCards.length !== 4) return { points: 0, cards: [] };
163: 
164:   const suit = handCards[0].suit;
165:   const allSameSuit = handCards.every(c => c.suit === suit);
166: 
167:   if (!allSameSuit) return { points: 0, cards: [] };
168: 
169:   // For crib, starter must also match
170:   if (isCrib) {
171:     if (starterCard && starterCard.suit === suit) {
172:       return { points: 5, cards: [...handCards, starterCard] };
173:     }
174:     return { points: 0, cards: [] };
175:   }
176: 
177:   // For hand, 4-card flush counts
178:   if (starterCard && starterCard.suit === suit) {
179:     return { points: 5, cards: [...handCards, starterCard] };
180:   }
181: 
182:   return { points: 4, cards: handCards };
183: }
184: 
185: /**
186:  * Check for "His Nobs" - Jack in hand matching starter suit
187:  */
188: export function checkNobs(handCards: Card[], starterCard: Card | null): { points: number; jack: Card | null } {
189:   if (!starterCard) return { points: 0, jack: null };
190: 
191:   const jack = handCards.find(c => c.rank === 'J' && c.suit === starterCard.suit);
192:   if (jack) {
193:     return { points: 1, jack };
194:   }
195: 
196:   return { points: 0, jack: null };
197: }
198: 
199: /**
200:  * Calculate total score for a hand (4 cards) with starter card
201:  */
202: export function scoreHand(
203:   handCards: Card[],
204:   starterCard: Card | null,
205:   isCrib: boolean = false
206: ): ScoreBreakdown {
207:   const allCards = starterCard ? [...handCards, starterCard] : [...handCards];
208:   const details: string[] = [];
209: 
210:   // Fifteens
211:   const fifteens = countFifteens(allCards);
212:   const fifteenPoints = fifteens.count * 2;
213:   if (fifteenPoints > 0) {
214:     details.push(`Fifteens: ${fifteens.count} x 2 = ${fifteenPoints}`);
215:   }
216: 
217:   // Pairs
218:   const pairs = countPairs(allCards);
219:   const pairPoints = pairs.count * 2;
220:   if (pairPoints > 0) {
221:     const pairType = pairs.count === 1 ? 'Pair' : pairs.count === 3 ? 'Three of a kind' : pairs.count === 6 ? 'Four of a kind' : `${pairs.count} pairs`;
222:     details.push(`${pairType}: ${pairPoints}`);
223:   }
224: 
225:   // Runs
226:   const runs = countRuns(allCards);
227:   if (runs.points > 0) {
228:     details.push(`Runs: ${runs.points}`);
229:   }
230: 
231:   // Flush
232:   const flush = countFlush(handCards, starterCard, isCrib);
233:   if (flush.points > 0) {
234:     details.push(`Flush: ${flush.points}`);
235:   }
236: 
237:   // Nobs
238:   const nobs = checkNobs(handCards, starterCard);
239:   if (nobs.points > 0) {
240:     details.push(`His Nobs: 1`);
241:   }
242: 
243:   const total = fifteenPoints + pairPoints + runs.points + flush.points + nobs.points;
244: 
245:   return {
246:     fifteens: fifteenPoints,
247:     pairs: pairPoints,
248:     runs: runs.points,
249:     flush: flush.points,
250:     nobs: nobs.points,
251:     total,
252:     details,
253:   };
254: }
255: 
256: /**
257:  * Get detailed scoring breakdown with individual combinations for animated reveal
258:  */
259: export function scoreHandDetailed(
260:   handCards: Card[],
261:   starterCard: Card | null,
262:   isCrib: boolean = false
263: ): DetailedScoreBreakdown {
264:   const allCards = starterCard ? [...handCards, starterCard] : [...handCards];
265:   const items: ScoringItem[] = [];
266:   let total = 0;
267: 
268:   // Fifteens - each combination individually
269:   const fifteens = countFifteens(allCards);
270:   for (const combo of fifteens.combinations) {
271:     const cardStr = combo.map(c => c.toString()).join(' + ');
272:     items.push({
273:       category: 'fifteen',
274:       points: 2,
275:       cards: combo,
276:       description: `Fifteen: ${cardStr} = 2`,
277:     });
278:     total += 2;
279:   }
280: 
281:   // Pairs - each pair individually
282:   const pairs = countPairs(allCards);
283:   for (const [card1, card2] of pairs.pairs) {
284:     items.push({
285:       category: 'pair',
286:       points: 2,
287:       cards: [card1, card2],
288:       description: `Pair: ${card1.toString()} + ${card2.toString()} = 2`,
289:     });
290:     total += 2;
291:   }
292: 
293:   // Runs - each run individually
294:   const runs = countRuns(allCards);
295:   for (const run of runs.runs) {
296:     const runLength = run.length;
297:     const cardStr = run.map(c => c.toString()).join('-');
298:     items.push({
299:       category: 'run',
300:       points: runLength,
301:       cards: run,
302:       description: `Run: ${cardStr} = ${runLength}`,
303:     });
304:     total += runLength;
305:   }
306: 
307:   // Flush
308:   const flush = countFlush(handCards, starterCard, isCrib);
309:   if (flush.points > 0) {
310:     const cardStr = flush.cards.map(c => c.toString()).join(', ');
311:     items.push({
312:       category: 'flush',
313:       points: flush.points,
314:       cards: flush.cards,
315:       description: `Flush: ${cardStr} = ${flush.points}`,
316:     });
317:     total += flush.points;
318:   }
319: 
320:   // Nobs
321:   const nobs = checkNobs(handCards, starterCard);
322:   if (nobs.points > 0 && nobs.jack) {
323:     items.push({
324:       category: 'nobs',
325:       points: 1,
326:       cards: [nobs.jack],
327:       description: `His Nobs: ${nobs.jack.toString()} = 1`,
328:     });
329:     total += 1;
330:   }
331: 
332:   return { items, total };
333: }
334: 
335: /**
336:  * Pegging scoring during play phase
337:  */
338: export interface PeggingScore {
339:   points: number;
340:   reasons: string[];
341: }
342: 
343: /**
344:  * Calculate points for a card played during pegging
345:  * @param playedCards Cards already played this count (including the new card)
346:  * @param runningTotal Current running total
347:  */
348: export function scorePegging(playedCards: Card[], runningTotal: number): PeggingScore {
349:   const points: number[] = [];
350:   const reasons: string[] = [];
351: 
352:   // Check for fifteen
353:   if (runningTotal === 15) {
354:     points.push(2);
355:     reasons.push('Fifteen for 2');
356:   }
357: 
358:   // Check for thirty-one
359:   if (runningTotal === 31) {
360:     points.push(2);
361:     reasons.push('Thirty-one for 2');
362:   }
363: 
364:   if (playedCards.length >= 2) {
365:     // Check for pairs/triples/quads (consecutive same rank at end)
366:     let pairCount = 1;
367:     const lastRank = playedCards[playedCards.length - 1].rank;
368:     for (let i = playedCards.length - 2; i >= 0; i--) {
369:       if (playedCards[i].rank === lastRank) {
370:         pairCount++;
371:       } else {
372:         break;
373:       }
374:     }
375: 
376:     if (pairCount === 2) {
377:       points.push(2);
378:       reasons.push('Pair for 2');
379:     } else if (pairCount === 3) {
380:       points.push(6);
381:       reasons.push('Three of a kind for 6');
382:     } else if (pairCount === 4) {
383:       points.push(12);
384:       reasons.push('Four of a kind for 12');
385:     }
386: 
387:     // Check for runs (3+ cards at end that form a run)
388:     if (playedCards.length >= 3) {
389:       for (let runLength = playedCards.length; runLength >= 3; runLength--) {
390:         const lastN = playedCards.slice(-runLength);
391:         const ranks = lastN.map(c => c.rankValue).sort((a, b) => a - b);
392: 
393:         // Check if consecutive
394:         let isRun = true;
395:         for (let i = 1; i < ranks.length; i++) {
396:           if (ranks[i] !== ranks[i - 1] + 1) {
397:             isRun = false;
398:             break;
399:           }
400:         }
401: 
402:         if (isRun) {
403:           points.push(runLength);
404:           reasons.push(`Run of ${runLength} for ${runLength}`);
405:           break; // Only count longest run
406:         }
407:       }
408:     }
409:   }
410: 
411:   return {
412:     points: points.reduce((a, b) => a + b, 0),
413:     reasons,
414:   };
415: }
````

## File: packages/games/go-fish/rules/src/actions.ts
````typescript
  1: import { Action, type ActionDefinition } from '@boardsmith/engine';
  2: import type { GoFishGame } from './game.js';
  3: import { Card, GoFishPlayer, Hand } from './elements.js';
  4: 
  5: /**
  6:  * Format a hand as a readable string showing all cards
  7:  */
  8: function formatHand(hand: Hand): string {
  9:   const cards = [...hand.all(Card)];
 10:   if (cards.length === 0) return '(empty)';
 11:   return cards.map(c => `${c.rank}${c.suit}`).sort().join(', ');
 12: }
 13: 
 14: /**
 15:  * Format cards of a specific rank
 16:  */
 17: function formatCards(cards: Card[]): string {
 18:   if (cards.length === 0) return '(none)';
 19:   return cards.map(c => `${c.rank}${c.suit}`).join(', ');
 20: }
 21: 
 22: /**
 23:  * Create the "ask" action for Go Fish
 24:  *
 25:  * The ask action allows a player to:
 26:  * 1. Choose another player (target)
 27:  * 2. Choose a rank they hold in their hand
 28:  * 3. If target has cards of that rank, they give all of them
 29:  * 4. If not, the asking player "goes fish" (draws from pond)
 30:  * 5. If the drawn card matches the requested rank, they get another turn
 31:  */
 32: export function createAskAction(game: GoFishGame): ActionDefinition {
 33:   return Action.create('ask')
 34:     .prompt('Ask another player for cards')
 35:     .choosePlayer('target', {
 36:       prompt: 'Choose a player to ask',
 37:       filter: (player, ctx) => player !== ctx.player,
 38:       skipIfOnlyOne: true, // Auto-select in 2-player games
 39:       boardRefs: (player, ctx) => {
 40:         const targetPlayer = player as GoFishPlayer;
 41:         const hand = game.getPlayerHand(targetPlayer);
 42:         return {
 43:           targetRef: {
 44:             id: hand.id,
 45:           },
 46:         };
 47:       },
 48:     })
 49:     .chooseFrom<string>('rank', {
 50:       prompt: 'Choose a rank to ask for',
 51:       choices: (ctx) => game.getPlayerRanks(ctx.player as GoFishPlayer),
 52:       display: (rank) => {
 53:         const names: Record<string, string> = {
 54:           'A': 'Aces', '2': 'Twos', '3': 'Threes', '4': 'Fours',
 55:           '5': 'Fives', '6': 'Sixes', '7': 'Sevens', '8': 'Eights',
 56:           '9': 'Nines', '10': 'Tens', 'J': 'Jacks', 'Q': 'Queens', 'K': 'Kings'
 57:         };
 58:         return names[rank] ?? rank;
 59:       },
 60:       boardRefs: (rank, ctx) => {
 61:         const player = ctx.player as GoFishPlayer;
 62:         const hand = game.getPlayerHand(player);
 63:         const cards = [...hand.all(Card)].filter(c => c.rank === rank);
 64:         // Link to the first card of this rank (all cards of same rank are equivalent)
 65:         if (cards.length > 0) {
 66:           return {
 67:             targetRef: {
 68:               id: cards[0].id,
 69:             },
 70:           };
 71:         }
 72:         // Return empty refs if no cards found (shouldn't happen since choices are based on player's ranks)
 73:         return {};
 74:       },
 75:     })
 76:     .condition((ctx) => game.canPlayerTakeAction(ctx.player as GoFishPlayer))
 77:     .execute((args, ctx) => {
 78:       const player = ctx.player as GoFishPlayer;
 79:       const target = args.target as GoFishPlayer;
 80:       const rank = args.rank as string;
 81: 
 82:       // Get hands for logging
 83:       const playerHand = game.getPlayerHand(player);
 84:       const targetHand = game.getPlayerHand(target);
 85: 
 86:       // LOG: Action being taken
 87:       game.message(`--- ACTION: ${player.name} asks ${target.name} for ${rank}s ---`);
 88: 
 89:       // LOG: Both hands BEFORE the action
 90:       game.message(`BEFORE - ${player.name}'s hand (${playerHand.count(Card)} cards): ${formatHand(playerHand)}`);
 91:       game.message(`BEFORE - ${target.name}'s hand (${targetHand.count(Card)} cards): ${formatHand(targetHand)}`);
 92: 
 93:       // Check if target has the requested rank
 94:       const targetCards = game.getCardsOfRank(target, rank);
 95: 
 96:       // LOG: What target has of requested rank
 97:       game.message(`${target.name}'s ${rank}s: ${formatCards(targetCards)} (${targetCards.length} total)`);
 98: 
 99:       if (targetCards.length > 0) {
100:         // Target has the cards - transfer them
101:         game.message(`TRANSFER: Moving ${targetCards.length} card(s) from ${target.name} to ${player.name}`);
102: 
103:         for (const card of targetCards) {
104:           game.message(`  Moving ${card.rank}${card.suit} to ${player.name}`);
105:           card.putInto(playerHand);
106:         }
107: 
108:         // LOG: Both hands AFTER the transfer
109:         game.message(`AFTER - ${player.name}'s hand (${playerHand.count(Card)} cards): ${formatHand(playerHand)}`);
110:         game.message(`AFTER - ${target.name}'s hand (${targetHand.count(Card)} cards): ${formatHand(targetHand)}`);
111: 
112:         game.message(`RESULT: ${player.name} got ${targetCards.length} ${rank}(s) from ${target.name}!`);
113: 
114:         // Check for books after receiving cards
115:         const books = game.checkForBooks(player);
116: 
117:         if (books.length > 0) {
118:           game.message(`AFTER BOOKS - ${player.name}'s hand (${playerHand.count(Card)} cards): ${formatHand(playerHand)}`);
119:         }
120: 
121:         return {
122:           success: true,
123:           data: {
124:             gotCards: true,
125:             cardsReceived: targetCards.length,
126:             formedBooks: books,
127:             extraTurn: true,
128:           },
129:           message: `Got ${targetCards.length} ${rank}(s) from ${target.name}`,
130:         };
131:       } else {
132:         // Go Fish!
133:         game.message(`GO FISH: ${target.name} has no ${rank}s`);
134: 
135:         const pondCount = game.pond.count(Card);
136:         game.message(`Pond has ${pondCount} cards remaining`);
137: 
138:         const drawnCard = game.drawFromPond(player);
139: 
140:         if (drawnCard) {
141:           const drewMatch = drawnCard.rank === rank;
142:           game.message(`DRAW: ${player.name} drew ${drawnCard.rank}${drawnCard.suit} from pond`);
143: 
144:           // LOG: Hand AFTER drawing
145:           game.message(`AFTER DRAW - ${player.name}'s hand (${playerHand.count(Card)} cards): ${formatHand(playerHand)}`);
146: 
147:           if (drewMatch) {
148:             game.message(`LUCKY: Drew the requested rank! ${player.name} gets another turn.`);
149:           } else {
150:             game.message(`RESULT: No match. Turn passes to next player.`);
151:           }
152: 
153:           // Check for books after drawing
154:           const books = game.checkForBooks(player);
155: 
156:           if (books.length > 0) {
157:             game.message(`AFTER BOOKS - ${player.name}'s hand (${playerHand.count(Card)} cards): ${formatHand(playerHand)}`);
158:           }
159: 
160:           return {
161:             success: true,
162:             data: {
163:               gotCards: false,
164:               goFish: true,
165:               drewMatch,
166:               formedBooks: books,
167:               extraTurn: drewMatch,
168:             },
169:             message: drewMatch
170:               ? `Go Fish! Drew a ${rank} - another turn!`
171:               : `Go Fish! Drew from the pond.`,
172:           };
173:         } else {
174:           // Pond is empty
175:           game.message(`POND EMPTY: ${player.name}'s turn ends with no draw.`);
176: 
177:           return {
178:             success: true,
179:             data: {
180:               gotCards: false,
181:               goFish: true,
182:               pondEmpty: true,
183:               extraTurn: false,
184:             },
185:             message: 'Go Fish! But the pond is empty.',
186:           };
187:         }
188:       }
189:     });
190: }
````

## File: packages/games/go-fish/rules/src/ai.ts
````typescript
 1: import type { Game } from '@boardsmith/engine';
 2: import type { Objective } from '@boardsmith/ai';
 3: import type { GoFishGame } from './game.js';
 4: import type { GoFishPlayer } from './elements.js';
 5: import { Card } from './elements.js';
 6: 
 7: /**
 8:  * AI objectives for Go Fish
 9:  * These guide the MCTS bot to prefer better positions during playouts
10:  */
11: export function getGoFishObjectives(
12:   game: Game,
13:   playerIndex: number
14: ): Record<string, Objective> {
15:   const goFishGame = game as GoFishGame;
16:   const player = goFishGame.players[playerIndex] as GoFishPlayer;
17: 
18:   return {
19:     // Having more books is the main goal
20:     'book-lead': {
21:       checker: () => {
22:         const myBooks = player.bookCount;
23:         const maxOpponentBooks = Math.max(
24:           ...goFishGame.players
25:             .filter(p => p !== player)
26:             .map(p => (p as GoFishPlayer).bookCount)
27:         );
28:         return myBooks > maxOpponentBooks;
29:       },
30:       weight: 10,
31:     },
32: 
33:     // Having a large hand means more options
34:     'large-hand': {
35:       checker: () => {
36:         const hand = goFishGame.getPlayerHand(player);
37:         return hand.all(Card).length >= 5;
38:       },
39:       weight: 2,
40:     },
41: 
42:     // Having multiple cards of the same rank (close to a book)
43:     'near-book': {
44:       checker: () => {
45:         const hand = goFishGame.getPlayerHand(player);
46:         const rankCounts = new Map<string, number>();
47:         for (const card of hand.all(Card)) {
48:           rankCounts.set(card.rank, (rankCounts.get(card.rank) ?? 0) + 1);
49:         }
50:         // Check if we have 3 of any rank
51:         for (const count of rankCounts.values()) {
52:           if (count >= 3) return true;
53:         }
54:         return false;
55:       },
56:       weight: 5,
57:     },
58: 
59:     // Having diverse ranks means more asking options
60:     'rank-diversity': {
61:       checker: () => {
62:         const ranks = goFishGame.getPlayerRanks(player);
63:         return ranks.length >= 4;
64:       },
65:       weight: 2,
66:     },
67: 
68:     // Winning or being close to winning
69:     'near-win': {
70:       checker: () => {
71:         // Having 7+ books out of 13 means likely win
72:         return player.bookCount >= 7;
73:       },
74:       weight: 15,
75:     },
76: 
77:     // Opponent running out of cards
78:     'opponent-low-cards': {
79:       checker: () => {
80:         for (const p of goFishGame.players) {
81:           if (p === player) continue;
82:           const hand = goFishGame.getPlayerHand(p as GoFishPlayer);
83:           if (hand.all(Card).length <= 2) return true;
84:         }
85:         return false;
86:       },
87:       weight: 3,
88:     },
89:   };
90: }
````

## File: packages/games/go-fish/rules/src/elements.ts
````typescript
 1: import { Card as BaseCard, Hand as BaseHand, Deck, Space, Game, Player } from '@boardsmith/engine';
 2: 
 3: /**
 4:  * Go Fish card with suit and rank
 5:  */
 6: export class Card extends BaseCard<GoFishGame, GoFishPlayer> {
 7:   suit!: 'H' | 'D' | 'C' | 'S';
 8:   rank!: string; // 'A', '2'-'10', 'J', 'Q', 'K'
 9: 
10:   /**
11:    * Get the numeric value for sorting (Ace high)
12:    */
13:   get value(): number {
14:     const values: Record<string, number> = {
15:       'A': 14, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
16:       '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
17:     };
18:     return values[this.rank] ?? 0;
19:   }
20: }
21: 
22: /**
23:  * A player's hand - visible only to the owner
24:  */
25: export class Hand extends BaseHand<GoFishGame, GoFishPlayer> {}
26: 
27: /**
28:  * The pond (draw pile) - hidden from all players
29:  */
30: export class Pond extends Deck<GoFishGame, GoFishPlayer> {}
31: 
32: /**
33:  * A player's collection of books (4 of a kind) - visible to all
34:  */
35: export class Books extends Space<GoFishGame, GoFishPlayer> {}
36: 
37: /**
38:  * Go Fish player with reference to their spaces
39:  */
40: export class GoFishPlayer extends Player {
41:   /** Number of completed books */
42:   bookCount: number = 0;
43: }
44: 
45: // Forward declare for circular reference
46: import type { GoFishGame } from './game.js';
````

## File: packages/games/go-fish/rules/src/flow.ts
````typescript
  1: import {
  2:   loop,
  3:   eachPlayer,
  4:   actionStep,
  5:   execute,
  6:   ifThen,
  7:   sequence,
  8:   setVar,
  9:   type FlowDefinition,
 10: } from '@boardsmith/engine';
 11: import type { GoFishGame } from './game.js';
 12: import { Card } from './elements.js';
 13: 
 14: /**
 15:  * Create the Go Fish game flow
 16:  *
 17:  * Flow structure:
 18:  * 1. Main game loop (while not all 13 books formed)
 19:  * 2. Each player takes a turn
 20:  * 3. Player turn: ask action, then repeat if got extra turn
 21:  * 4. Skip players who have no cards in hand
 22:  */
 23: export function createGoFishFlow(): FlowDefinition {
 24:   // A single turn where the player asks for cards
 25:   const playerTurn = sequence(
 26:     // Reset turn state at start of each turn
 27:     setVar('extraTurn', false),
 28:     setVar('turnEnded', false),
 29: 
 30:     // The turn loop - keep playing as long as player gets extra turns
 31:     loop({
 32:       name: 'turn-loop',
 33:       while: (ctx) => {
 34:         // Continue while turn hasn't ended
 35:         if (ctx.get('turnEnded')) return false;
 36: 
 37:         // Check if game is finished
 38:         const game = ctx.game as GoFishGame;
 39:         if (game.isFinished()) return false;
 40: 
 41:         // Check if player can still act
 42:         const player = ctx.player;
 43:         if (!player) return false;
 44: 
 45:         const hand = game.getPlayerHand(player as any);
 46:         if (hand.count(Card) === 0) {
 47:           // Player has no cards - try to draw
 48:           const drawnCard = game.drawFromPond(player as any);
 49:           if (!drawnCard) {
 50:             // No cards in pond either - turn ends
 51:             return false;
 52:           }
 53:           game.message(`${player.name} has no cards, drew from pond.`);
 54:           game.checkForBooks(player as any);
 55:         }
 56: 
 57:         return true;
 58:       },
 59:       maxIterations: 52, // Safety limit
 60:       do: sequence(
 61:         // Reset extra turn flag for this ask
 62:         setVar('extraTurn', false),
 63: 
 64:         // Player takes the ask action
 65:         actionStep({
 66:           name: 'ask-step',
 67:           actions: ['ask'],
 68:           prompt: 'Ask another player for a rank you hold',
 69:           skipIf: (ctx) => {
 70:             // Skip if game is over
 71:             const game = ctx.game as GoFishGame;
 72:             return game.isFinished();
 73:           },
 74:         }),
 75: 
 76:         // Check if turn should continue based on action result
 77:         execute((ctx) => {
 78:           const extraTurn = ctx.lastActionResult?.data?.extraTurn;
 79:           if (!extraTurn) {
 80:             ctx.set('turnEnded', true);
 81:           }
 82:         }),
 83:       ),
 84:     }),
 85:   );
 86: 
 87:   return {
 88:     root: loop({
 89:       name: 'game-loop',
 90:       while: (ctx) => {
 91:         const game = ctx.game as GoFishGame;
 92:         return !game.isFinished();
 93:       },
 94:       maxIterations: 1000, // Safety limit for very long games
 95:       do: eachPlayer({
 96:         name: 'player-turns',
 97:         filter: (player, ctx) => {
 98:           // Skip players who can't act
 99:           const game = ctx.game as GoFishGame;
100:           const hand = game.getPlayerHand(player as any);
101:           // Even if hand is empty, they can draw - only skip if both are empty
102:           return hand.count(Card) > 0 || game.pond.count(Card) > 0;
103:         },
104:         do: playerTurn,
105:       }),
106:     }),
107: 
108:     isComplete: (ctx) => {
109:       const game = ctx.game as GoFishGame;
110:       return game.isFinished();
111:     },
112: 
113:     getWinners: (ctx) => {
114:       const game = ctx.game as GoFishGame;
115:       return game.getWinners();
116:     },
117:   };
118: }
````

## File: packages/games/go-fish/rules/src/index.ts
````typescript
 1: // Go Fish game package
 2: export { GoFishGame, type GoFishOptions } from './game.js';
 3: export { Card, Hand, Pond, Books, GoFishPlayer } from './elements.js';
 4: export { createAskAction } from './actions.js';
 5: export { createGoFishFlow } from './flow.js';
 6: export { getGoFishObjectives } from './ai.js';
 7: 
 8: import { GoFishGame } from './game.js';
 9: import { getGoFishObjectives } from './ai.js';
10: 
11: /**
12:  * Game definition for the worker to register this game.
13:  * Contains all metadata needed to run Go Fish.
14:  */
15: export const gameDefinition = {
16:   gameClass: GoFishGame,
17:   gameType: 'go-fish',
18:   displayName: 'Go Fish',
19:   minPlayers: 2,
20:   maxPlayers: 6,
21:   ai: {
22:     objectives: getGoFishObjectives,
23:   },
24: } as const;
````

## File: packages/games/hex/rules/src/actions.ts
````typescript
 1: import { Action, type ActionDefinition } from '@boardsmith/engine';
 2: import type { HexGame } from './game.js';
 3: import { Cell, Stone, HexPlayer } from './elements.js';
 4: 
 5: /**
 6:  * Create the "place stone" action
 7:  * Player selects an empty cell to place their stone
 8:  */
 9: export function createPlaceStoneAction(game: HexGame): ActionDefinition {
10:   return Action.create('placeStone')
11:     .prompt('Place a stone on an empty cell')
12:     .chooseElement<Cell>('cell', {
13:       prompt: 'Select a cell',
14:       elementClass: Cell,
15:       filter: (element, ctx) => {
16:         const cell = element as Cell;
17:         return cell.isEmpty();
18:       },
19:       display: (cell, ctx) => {
20:         return cell.notation;
21:       },
22:       boardRef: (cell, ctx) => {
23:         return {
24:           id: cell.id,
25:           notation: cell.notation,
26:         };
27:       },
28:     })
29:     .execute((args, ctx) => {
30:       const player = ctx.player as HexPlayer;
31:       const cell = args.cell as Cell;
32: 
33:       // Create a stone for this player
34:       const stone = cell.create(Stone, `stone-${player.position}-${player.stonesPlaced}`, {
35:         player: player,
36:       });
37: 
38:       player.stonesPlaced++;
39: 
40:       // Add game message
41:       game.message(`${player.name} placed a ${player.getColor()} stone at (${cell.q}, ${cell.r})`);
42: 
43:       // Check for win
44:       const board = game.board;
45:       if (board && board.checkWin(player)) {
46:         game.message(`${player.name} wins by connecting their edges!`);
47:         game.setWinner(player);
48:       }
49: 
50:       return {
51:         success: true,
52:         data: {
53:           cell: cell.notation,
54:           player: player.name,
55:         },
56:         message: `Placed stone at (${cell.q}, ${cell.r})`,
57:       };
58:     });
59: }
````

## File: packages/games/hex/rules/src/ai.ts
````typescript
 1: import type { HexGame } from './game.js';
 2: import { Board, Cell, HexPlayer } from './elements.js';
 3: 
 4: /**
 5:  * AI objectives for Hex
 6:  * Used by MCTS bot to evaluate game states
 7:  */
 8: export function getHexObjectives(game: HexGame, player: HexPlayer) {
 9:   const board = game.board;
10:   if (!board) return { score: 0 };
11: 
12:   const size = board.boardSize;
13:   const isRed = player.position === 0;
14: 
15:   // Check for win/loss
16:   if (game.winner) {
17:     return { score: game.winner === player ? 1000 : -1000 };
18:   }
19: 
20:   // Heuristic: count connected components and proximity to goal
21:   let score = 0;
22: 
23:   // Get all cells with player's stones
24:   const playerCells = [...board.all(Cell)].filter(cell =>
25:     cell.hasFriendlyStone(player)
26:   );
27: 
28:   // Score based on number of stones placed
29:   score += playerCells.length * 10;
30: 
31:   // Score based on proximity to goal edges
32:   for (const cell of playerCells) {
33:     if (isRed) {
34:       // Red wants to connect top (r=0) to bottom (r=size-1)
35:       // Score cells closer to both edges
36:       const topDist = cell.r;
37:       const bottomDist = size - 1 - cell.r;
38:       const minDist = Math.min(topDist, bottomDist);
39:       score += (size - minDist) * 2;
40: 
41:       // Bonus for cells on edges
42:       if (cell.isRedStartEdge()) score += 5;
43:       if (cell.isRedGoalEdge(size)) score += 5;
44:     } else {
45:       // Blue wants to connect left (q=0) to right (q=size-1)
46:       const leftDist = cell.q;
47:       const rightDist = size - 1 - cell.q;
48:       const minDist = Math.min(leftDist, rightDist);
49:       score += (size - minDist) * 2;
50: 
51:       // Bonus for cells on edges
52:       if (cell.isBlueStartEdge()) score += 5;
53:       if (cell.isBlueGoalEdge(size)) score += 5;
54:     }
55:   }
56: 
57:   // Center control bonus (center cells are more valuable)
58:   const center = Math.floor(size / 2);
59:   for (const cell of playerCells) {
60:     const distFromCenter = Math.abs(cell.q - center) + Math.abs(cell.r - center);
61:     score += Math.max(0, size - distFromCenter);
62:   }
63: 
64:   // Penalize opponent's progress
65:   const opponentCells = [...board.all(Cell)].filter(cell =>
66:     cell.hasOpponentStone(player)
67:   );
68:   score -= opponentCells.length * 5;
69: 
70:   return { score };
71: }
````

## File: packages/games/hex/rules/src/elements.ts
````typescript
  1: import { Piece, HexGrid, HexCell, Player } from '@boardsmith/engine';
  2: import type { HexGame } from './game.js';
  3: 
  4: /**
  5:  * A stone piece in Hex - either Red or Blue
  6:  */
  7: export class Stone extends Piece<HexGame, HexPlayer> {
  8:   /** Color of this stone (matches player) */
  9:   getColor(): 'red' | 'blue' {
 10:     return this.player?.position === 0 ? 'red' : 'blue';
 11:   }
 12: }
 13: 
 14: /**
 15:  * A hex cell on the board
 16:  * Uses axial coordinates (q, r)
 17:  */
 18: export class Cell extends HexCell<HexGame, HexPlayer> {
 19:   /** Q coordinate (column-ish, diagonal axis) */
 20:   q!: number;
 21:   /** R coordinate (row-ish) */
 22:   r!: number;
 23: 
 24:   /**
 25:    * Get the stone on this cell, if any
 26:    */
 27:   getStone(): Stone | undefined {
 28:     return this.first(Stone);
 29:   }
 30: 
 31:   /**
 32:    * Check if this cell is empty
 33:    */
 34:   isEmpty(): boolean {
 35:     return this.count(Stone) === 0;
 36:   }
 37: 
 38:   /**
 39:    * Check if this cell has an opponent's stone
 40:    */
 41:   hasOpponentStone(player: HexPlayer): boolean {
 42:     const stone = this.getStone();
 43:     return stone !== undefined && stone.player !== player;
 44:   }
 45: 
 46:   /**
 47:    * Check if this cell has a friendly stone
 48:    */
 49:   hasFriendlyStone(player: HexPlayer): boolean {
 50:     const stone = this.getStone();
 51:     return stone !== undefined && stone.player === player;
 52:   }
 53: 
 54:   /**
 55:    * Get algebraic-style notation for this cell
 56:    */
 57:   get notation(): string {
 58:     return `${this.q},${this.r}`;
 59:   }
 60: 
 61:   /**
 62:    * Check if this cell is on Red's starting edge (top-left, r=0)
 63:    */
 64:   isRedStartEdge(): boolean {
 65:     return this.r === 0;
 66:   }
 67: 
 68:   /**
 69:    * Check if this cell is on Red's goal edge (bottom-right)
 70:    */
 71:   isRedGoalEdge(boardSize: number): boolean {
 72:     return this.r === boardSize - 1;
 73:   }
 74: 
 75:   /**
 76:    * Check if this cell is on Blue's starting edge (top-right, q=0)
 77:    */
 78:   isBlueStartEdge(): boolean {
 79:     return this.q === 0;
 80:   }
 81: 
 82:   /**
 83:    * Check if this cell is on Blue's goal edge (bottom-left)
 84:    */
 85:   isBlueGoalEdge(boardSize: number): boolean {
 86:     return this.q === boardSize - 1;
 87:   }
 88: }
 89: 
 90: /**
 91:  * The hex board - a rhombus-shaped hex grid
 92:  */
 93: export class Board extends HexGrid<HexGame, HexPlayer> {
 94:   /** Board size (number of cells per edge) */
 95:   boardSize!: number;
 96: 
 97:   // Configure hex grid for AutoUI
 98:   override $hexOrientation: 'flat' | 'pointy' = 'pointy';
 99:   override $coordSystem: 'offset' | 'axial' | 'cube' = 'axial';
100:   override $qCoord = 'q';
101:   override $rCoord = 'r';
102:   override $hexSize = 150;
103: 
104:   /**
105:    * Get a cell by axial coordinates
106:    */
107:   getCell(q: number, r: number): Cell | undefined {
108:     return this.first(Cell, { q, r });
109:   }
110: 
111:   /**
112:    * Get all empty cells
113:    */
114:   getEmptyCells(): Cell[] {
115:     return [...this.all(Cell)].filter(cell => cell.isEmpty());
116:   }
117: 
118:   /**
119:    * Get all neighboring cells for a given cell (up to 6 in a hex grid)
120:    */
121:   getNeighbors(cell: Cell): Cell[] {
122:     // Axial coordinate neighbor offsets
123:     const directions = [
124:       [1, 0], [1, -1], [0, -1],
125:       [-1, 0], [-1, 1], [0, 1]
126:     ];
127: 
128:     const neighbors: Cell[] = [];
129:     for (const [dq, dr] of directions) {
130:       const neighbor = this.getCell(cell.q + dq, cell.r + dr);
131:       if (neighbor) neighbors.push(neighbor);
132:     }
133:     return neighbors;
134:   }
135: 
136:   /**
137:    * Check if a player has won by connecting their two edges
138:    * Uses flood fill / BFS from starting edge
139:    */
140:   checkWin(player: HexPlayer): boolean {
141:     const isRed = player.position === 0;
142:     const size = this.boardSize;
143: 
144:     // Get all cells on player's starting edge that have their stone
145:     const startCells = [...this.all(Cell)].filter(cell => {
146:       if (!cell.hasFriendlyStone(player)) return false;
147:       return isRed ? cell.isRedStartEdge() : cell.isBlueStartEdge();
148:     });
149: 
150:     if (startCells.length === 0) return false;
151: 
152:     // BFS to find path to goal edge
153:     const visited = new Set<string>();
154:     const queue: Cell[] = [...startCells];
155: 
156:     for (const cell of startCells) {
157:       visited.add(`${cell.q},${cell.r}`);
158:     }
159: 
160:     while (queue.length > 0) {
161:       const current = queue.shift()!;
162: 
163:       // Check if we reached the goal edge
164:       if (isRed ? current.isRedGoalEdge(size) : current.isBlueGoalEdge(size)) {
165:         return true;
166:       }
167: 
168:       // Explore neighbors
169:       for (const neighbor of this.getNeighbors(current)) {
170:         const key = `${neighbor.q},${neighbor.r}`;
171:         if (visited.has(key)) continue;
172:         if (!neighbor.hasFriendlyStone(player)) continue;
173: 
174:         visited.add(key);
175:         queue.push(neighbor);
176:       }
177:     }
178: 
179:     return false;
180:   }
181: }
182: 
183: /**
184:  * Hex player
185:  */
186: export class HexPlayer extends Player {
187:   /** Number of stones this player has placed */
188:   stonesPlaced: number = 0;
189: 
190:   /** Player color */
191:   getColor(): 'red' | 'blue' {
192:     return this.position === 0 ? 'red' : 'blue';
193:   }
194: }
````

## File: packages/games/hex/rules/src/flow.ts
````typescript
 1: import {
 2:   loop,
 3:   eachPlayer,
 4:   actionStep,
 5:   type FlowDefinition,
 6: } from '@boardsmith/engine';
 7: import type { HexGame } from './game.js';
 8: 
 9: /**
10:  * Create the game flow for Hex
11:  *
12:  * Flow:
13:  * - Players alternate placing stones
14:  * - Game ends when someone connects their two edges
15:  * - Simple alternating turns - no multi-step actions needed
16:  */
17: export function createHexFlow(game: HexGame): FlowDefinition {
18:   return {
19:     root: loop({
20:       name: 'game-loop',
21:       while: (ctx) => {
22:         return !game.isFinished();
23:       },
24:       maxIterations: 100, // 7x7 board = 49 cells max
25:       do: eachPlayer({
26:         name: 'player-turns',
27:         filter: (player, ctx) => {
28:           // Skip if game is over
29:           return !game.isFinished();
30:         },
31:         do: actionStep({
32:           name: 'place-stone',
33:           actions: ['placeStone'],
34:           skipIf: (ctx) => {
35:             return game.isFinished();
36:           },
37:         }),
38:       }),
39:     }),
40: 
41:     isComplete: (ctx) => {
42:       return game.isFinished();
43:     },
44: 
45:     getWinners: (ctx) => {
46:       return game.winner ? [game.winner] : [];
47:     },
48:   };
49: }
````

## File: packages/games/hex/rules/src/index.ts
````typescript
 1: // Hex game package
 2: export { HexGame, type HexOptions } from './game.js';
 3: export { Board, Cell, Stone, HexPlayer } from './elements.js';
 4: export { createPlaceStoneAction } from './actions.js';
 5: export { createHexFlow } from './flow.js';
 6: export { getHexObjectives } from './ai.js';
 7: 
 8: import { HexGame } from './game.js';
 9: import { getHexObjectives } from './ai.js';
10: 
11: /**
12:  * Game definition for the worker to register this game.
13:  * Contains all metadata needed to run Hex.
14:  */
15: export const gameDefinition = {
16:   gameClass: HexGame,
17:   gameType: 'hex',
18:   displayName: 'Hex',
19:   minPlayers: 2,
20:   maxPlayers: 2,
21:   ai: {
22:     objectives: getHexObjectives,
23:   },
24: } as const;
````

## File: packages/runtime/src/index.ts
````typescript
 1: // Re-export serialization utilities from engine
 2: export {
 3:   serializeValue,
 4:   deserializeValue,
 5:   serializeAction,
 6:   deserializeAction,
 7:   isSerializedReference,
 8:   type SerializedReference,
 9:   type SerializeOptions,
10: } from '@boardsmith/engine';
11: 
12: // Re-export state snapshots from engine
13: export {
14:   createSnapshot,
15:   createPlayerView,
16:   createAllPlayerViews,
17:   computeDiff,
18:   type GameStateSnapshot,
19:   type PlayerStateView,
20:   type StateDiff,
21: } from '@boardsmith/engine';
22: 
23: // Re-export replay types from engine
24: export {
25:   createReplayFile,
26:   validateReplayFile,
27:   parseReplayFile,
28:   type ReplayFile,
29: } from '@boardsmith/engine';
30: 
31: // Game runner (runtime-specific)
32: export {
33:   GameRunner,
34:   type GameRunnerOptions,
35:   type ActionExecutionResult,
36: } from './runner.js';
````

## File: packages/runtime/package.json
````json
 1: {
 2:   "name": "@boardsmith/runtime",
 3:   "version": "0.0.1",
 4:   "description": "Game execution runtime for BoardSmith - provides GameRunner for executing games, managing action history, state snapshots, and player views",
 5:   "type": "module",
 6:   "main": "./dist/index.js",
 7:   "types": "./dist/index.d.ts",
 8:   "scripts": {
 9:     "build": "tsc",
10:     "test": "vitest run"
11:   },
12:   "dependencies": {
13:     "@boardsmith/engine": "workspace:*"
14:   },
15:   "devDependencies": {
16:     "typescript": "^5.6.3",
17:     "vitest": "^2.1.9"
18:   }
19: }
````

## File: packages/server/package.json
````json
 1: {
 2:   "name": "@boardsmith/server",
 3:   "version": "0.0.1",
 4:   "description": "Platform-agnostic server core for BoardSmith games - shared HTTP routing and WebSocket handling",
 5:   "type": "module",
 6:   "main": "./dist/index.js",
 7:   "types": "./dist/index.d.ts",
 8:   "scripts": {
 9:     "build": "tsc"
10:   },
11:   "dependencies": {
12:     "@boardsmith/session": "workspace:*"
13:   },
14:   "devDependencies": {
15:     "typescript": "^5.7.0"
16:   }
17: }
````

## File: packages/session/src/ai-controller.ts
````typescript
  1: /**
  2:  * AI controller for managing AI player moves
  3:  */
  4: 
  5: import type { Game, SerializedAction } from '@boardsmith/engine';
  6: import type { GameRunner } from '@boardsmith/runtime';
  7: import { createBot, parseAILevel } from '@boardsmith/ai';
  8: import type { GameClass, AIConfig } from './types.js';
  9: 
 10: /**
 11:  * Controller for AI player moves
 12:  *
 13:  * Manages which players are AI-controlled and handles their turn execution.
 14:  * Works with both turn-based and simultaneous action flows.
 15:  */
 16: export class AIController<G extends Game = Game> {
 17:   readonly #aiPlayers: Set<number>;
 18:   readonly #aiLevel: string;
 19:   readonly #GameClass: GameClass<G>;
 20:   readonly #gameType: string;
 21:   #thinking = false;
 22: 
 23:   constructor(
 24:     GameClass: GameClass<G>,
 25:     gameType: string,
 26:     playerCount: number,
 27:     config: AIConfig
 28:   ) {
 29:     this.#GameClass = GameClass;
 30:     this.#gameType = gameType;
 31:     this.#aiLevel = config.level;
 32:     this.#aiPlayers = new Set(
 33:       config.players.filter(p => p >= 0 && p < playerCount)
 34:     );
 35:   }
 36: 
 37:   /**
 38:    * Check if any AI players are configured
 39:    */
 40:   hasAIPlayers(): boolean {
 41:     return this.#aiPlayers.size > 0;
 42:   }
 43: 
 44:   /**
 45:    * Check if a specific player is AI-controlled
 46:    */
 47:   isAIPlayer(playerIndex: number): boolean {
 48:     return this.#aiPlayers.has(playerIndex);
 49:   }
 50: 
 51:   /**
 52:    * Check if the AI is currently thinking
 53:    */
 54:   isThinking(): boolean {
 55:     return this.#thinking;
 56:   }
 57: 
 58:   /**
 59:    * Check if an AI player should act and make a move if so.
 60:    *
 61:    * @param runner - The game runner
 62:    * @param actionHistory - History of actions for MCTS
 63:    * @param onMove - Callback to execute the move (should return true if successful)
 64:    * @returns The move made, or null if no AI action was taken
 65:    */
 66:   async checkAndPlay(
 67:     runner: GameRunner<G>,
 68:     actionHistory: SerializedAction[],
 69:     onMove: (action: string, player: number, args: Record<string, unknown>) => Promise<boolean>
 70:   ): Promise<{ action: string; player: number; args: Record<string, unknown> } | null> {
 71:     // Prevent concurrent AI thinking
 72:     if (this.#thinking) return null;
 73: 
 74:     const flowState = runner.getFlowState();
 75:     if (!flowState?.awaitingInput || flowState.complete) return null;
 76: 
 77:     // Find which AI player should act
 78:     let aiPlayer: number | undefined;
 79: 
 80:     // Check for simultaneous actions first (awaitingPlayers)
 81:     if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
 82:       for (const playerState of flowState.awaitingPlayers) {
 83:         if (!playerState.completed &&
 84:             playerState.availableActions.length > 0 &&
 85:             this.#aiPlayers.has(playerState.playerIndex)) {
 86:           aiPlayer = playerState.playerIndex;
 87:           break;
 88:         }
 89:       }
 90:     } else if (flowState.currentPlayer !== undefined) {
 91:       // Regular turn-based action - check currentPlayer
 92:       if (this.#aiPlayers.has(flowState.currentPlayer)) {
 93:         aiPlayer = flowState.currentPlayer;
 94:       }
 95:     }
 96: 
 97:     // No AI player needs to act
 98:     if (aiPlayer === undefined) return null;
 99: 
100:     this.#thinking = true;
101: 
102:     try {
103:       // Small delay so humans can see the state change
104:       await new Promise(resolve => setTimeout(resolve, 300));
105: 
106:       // Create bot for this player
107:       const difficulty = parseAILevel(this.#aiLevel);
108:       const bot = createBot(
109:         runner.game,
110:         this.#GameClass,
111:         this.#gameType,
112:         aiPlayer,
113:         actionHistory,
114:         difficulty
115:       );
116: 
117:       // Get the AI's move
118:       const move = await bot.play();
119: 
120:       // Execute the move via callback
121:       const success = await onMove(move.action, aiPlayer, move.args);
122: 
123:       if (success) {
124:         return { action: move.action, player: aiPlayer, args: move.args };
125:       }
126:     } catch (error) {
127:       console.error(`AI error for player ${aiPlayer}:`, error);
128:     } finally {
129:       this.#thinking = false;
130:     }
131: 
132:     return null;
133:   }
134: }
````

## File: packages/session/package.json
````json
 1: {
 2:   "name": "@boardsmith/session",
 3:   "version": "0.0.1",
 4:   "description": "Game session management - provides GameSession for managing game instances, AI controllers, and platform adapters",
 5:   "type": "module",
 6:   "main": "./dist/index.js",
 7:   "types": "./dist/index.d.ts",
 8:   "scripts": {
 9:     "build": "tsc"
10:   },
11:   "dependencies": {
12:     "@boardsmith/engine": "workspace:*",
13:     "@boardsmith/runtime": "workspace:*",
14:     "@boardsmith/ai": "workspace:*"
15:   },
16:   "devDependencies": {
17:     "typescript": "^5.7.0"
18:   }
19: }
````

## File: packages/testing/src/index.ts
````typescript
 1: // Test game utilities
 2: export {
 3:   TestGame,
 4:   createTestGame,
 5:   type TestGameOptions,
 6: } from './test-game.js';
 7: 
 8: // Action simulation
 9: export {
10:   simulateAction,
11:   simulateActions,
12:   assertActionSucceeds,
13:   assertActionFails,
14:   type SimulateActionResult,
15: } from './simulate-action.js';
16: 
17: // Random game simulation
18: export {
19:   simulateRandomGames,
20:   type SimulateRandomGamesOptions,
21:   type SingleGameResult,
22:   type SimulationResults,
23: } from './random-simulation.js';
````

## File: packages/testing/src/random-simulation.ts
````typescript
  1: import type { Game, GameOptions, FlowState } from '@boardsmith/engine';
  2: import { createTestGame, type TestGame, type TestGameOptions } from './test-game.js';
  3: 
  4: /**
  5:  * Options for random game simulation
  6:  */
  7: export interface SimulateRandomGamesOptions {
  8:   /** Number of games to simulate */
  9:   count: number;
 10:   /** Player counts to test (will run games with each count) */
 11:   playerCounts: number[];
 12:   /** Timeout per game in milliseconds */
 13:   timeout?: number;
 14:   /** Maximum actions per game before considering it hung */
 15:   maxActions?: number;
 16:   /** Called after each game completes (for progress reporting) */
 17:   onGameComplete?: (result: SingleGameResult, progress: { completed: number; total: number }) => void;
 18: }
 19: 
 20: /**
 21:  * Result of a single simulated game
 22:  */
 23: export interface SingleGameResult {
 24:   /** Whether the game completed successfully */
 25:   completed: boolean;
 26:   /** Whether the game crashed with an error */
 27:   crashed: boolean;
 28:   /** Whether the game timed out */
 29:   timedOut: boolean;
 30:   /** Whether the game exceeded max actions */
 31:   exceededMaxActions: boolean;
 32:   /** Error message if crashed */
 33:   error?: string;
 34:   /** Number of actions taken */
 35:   actionCount: number;
 36:   /** Time taken in milliseconds */
 37:   duration: number;
 38:   /** Player count for this game */
 39:   playerCount: number;
 40:   /** Seed used for this game */
 41:   seed: string;
 42:   /** Winner indices (if completed) */
 43:   winners?: number[];
 44: }
 45: 
 46: /**
 47:  * Aggregated results from random game simulation
 48:  */
 49: export interface SimulationResults {
 50:   /** Number of games that completed successfully */
 51:   completed: number;
 52:   /** Number of games that crashed */
 53:   crashed: number;
 54:   /** Number of games that timed out */
 55:   timedOut: number;
 56:   /** Number of games that exceeded max actions */
 57:   exceededMaxActions: number;
 58:   /** Total games run */
 59:   total: number;
 60:   /** Individual game results */
 61:   games: SingleGameResult[];
 62:   /** Average actions per completed game */
 63:   averageActions: number;
 64:   /** Average duration per completed game */
 65:   averageDuration: number;
 66:   /** Errors encountered (deduplicated) */
 67:   errors: string[];
 68: }
 69: 
 70: /**
 71:  * Simple random number generator for reproducible simulations
 72:  */
 73: class SeededRandom {
 74:   private seed: number;
 75: 
 76:   constructor(seed: string) {
 77:     // Simple hash function
 78:     this.seed = 0;
 79:     for (let i = 0; i < seed.length; i++) {
 80:       this.seed = ((this.seed << 5) - this.seed + seed.charCodeAt(i)) | 0;
 81:     }
 82:   }
 83: 
 84:   next(): number {
 85:     this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
 86:     return this.seed / 0x7fffffff;
 87:   }
 88: 
 89:   nextInt(max: number): number {
 90:     return Math.floor(this.next() * max);
 91:   }
 92: 
 93:   pick<T>(array: T[]): T {
 94:     return array[this.nextInt(array.length)];
 95:   }
 96: 
 97:   shuffle<T>(array: T[]): T[] {
 98:     const result = [...array];
 99:     for (let i = result.length - 1; i > 0; i--) {
100:       const j = this.nextInt(i + 1);
101:       [result[i], result[j]] = [result[j], result[i]];
102:     }
103:     return result;
104:   }
105: }
106: 
107: /**
108:  * Run a single random game simulation
109:  */
110: async function simulateSingleGame<G extends Game>(
111:   GameClass: new (options: GameOptions) => G,
112:   playerCount: number,
113:   seed: string,
114:   timeout: number,
115:   maxActions: number
116: ): Promise<SingleGameResult> {
117:   const startTime = Date.now();
118:   const rng = new SeededRandom(seed);
119: 
120:   let testGame: TestGame<G>;
121:   let actionCount = 0;
122:   let timedOut = false;
123:   let exceededMaxActions = false;
124: 
125:   try {
126:     testGame = createTestGame(GameClass, {
127:       playerCount,
128:       seed,
129:       autoStart: true,
130:     });
131: 
132:     // Run game until complete or limits reached
133:     while (!testGame.isComplete()) {
134:       // Check timeout
135:       if (Date.now() - startTime > timeout) {
136:         timedOut = true;
137:         break;
138:       }
139: 
140:       // Check max actions
141:       if (actionCount >= maxActions) {
142:         exceededMaxActions = true;
143:         break;
144:       }
145: 
146:       // Check if awaiting input
147:       if (!testGame.isAwaitingInput()) {
148:         // Game is not complete but not awaiting input - might be stuck
149:         break;
150:       }
151: 
152:       // Get available actions and pick one randomly
153:       const flowState = testGame.getFlowState();
154:       if (!flowState) break;
155: 
156:       // Determine which player should act
157:       const currentPlayer = flowState.currentPlayer;
158:       if (currentPlayer === undefined) break;
159: 
160:       // Get available actions for this player
161:       // This is a simplified version - real implementation would introspect the game
162:       const player = testGame.getPlayer(currentPlayer);
163: 
164:       // Try to perform a random valid action
165:       // In a real implementation, we'd enumerate valid actions
166:       // For now, we'll try common action patterns
167:       const possibleActions = getAvailableActions(testGame, currentPlayer);
168: 
169:       if (possibleActions.length === 0) {
170:         // No actions available - might be stuck
171:         break;
172:       }
173: 
174:       const action = rng.pick(possibleActions);
175:       const result = testGame.doAction(currentPlayer, action.name, action.args);
176: 
177:       if (result.success) {
178:         actionCount++;
179:       } else {
180:         // Failed action - try another or give up after too many failures
181:         // This is simplified; real impl would track failures better
182:       }
183:     }
184: 
185:     const duration = Date.now() - startTime;
186: 
187:     return {
188:       completed: testGame.isComplete(),
189:       crashed: false,
190:       timedOut,
191:       exceededMaxActions,
192:       actionCount,
193:       duration,
194:       playerCount,
195:       seed,
196:       winners: testGame.isComplete()
197:         ? testGame.getWinners().map(p => p.position)
198:         : undefined,
199:     };
200: 
201:   } catch (error) {
202:     return {
203:       completed: false,
204:       crashed: true,
205:       timedOut: false,
206:       exceededMaxActions: false,
207:       error: error instanceof Error ? error.message : String(error),
208:       actionCount,
209:       duration: Date.now() - startTime,
210:       playerCount,
211:       seed,
212:     };
213:   }
214: }
215: 
216: /**
217:  * Get available actions for a player
218:  * This is a simplified heuristic - games should provide this introspection
219:  */
220: function getAvailableActions<G extends Game>(
221:   testGame: TestGame<G>,
222:   playerIndex: number
223: ): Array<{ name: string; args: Record<string, unknown> }> {
224:   const flowState = testGame.getFlowState();
225:   if (!flowState) return [];
226: 
227:   // Look at the awaiting actions if available
228:   const awaitingPlayers = flowState.awaitingPlayers;
229:   if (awaitingPlayers) {
230:     const playerState = awaitingPlayers[playerIndex];
231:     if (playerState?.availableActions) {
232:       // Return actions with empty args - real impl would generate valid args
233:       return playerState.availableActions.map((name: string) => ({ name, args: {} }));
234:     }
235:   }
236: 
237:   return [];
238: }
239: 
240: /**
241:  * Simulate multiple random games to verify game completeness
242:  *
243:  * @example
244:  * ```typescript
245:  * const results = await simulateRandomGames(GoFishGame, {
246:  *   count: 100,
247:  *   playerCounts: [2, 3, 4],
248:  *   timeout: 5000,
249:  * });
250:  *
251:  * expect(results.completed).toBe(100);
252:  * expect(results.crashed).toBe(0);
253:  * ```
254:  */
255: export async function simulateRandomGames<G extends Game>(
256:   GameClass: new (options: GameOptions) => G,
257:   options: SimulateRandomGamesOptions
258: ): Promise<SimulationResults> {
259:   const {
260:     count,
261:     playerCounts,
262:     timeout = 5000,
263:     maxActions = 10000,
264:     onGameComplete,
265:   } = options;
266: 
267:   const games: SingleGameResult[] = [];
268:   const errors = new Set<string>();
269:   let total = 0;
270: 
271:   // Distribute games across player counts
272:   const gamesPerPlayerCount = Math.ceil(count / playerCounts.length);
273: 
274:   for (const playerCount of playerCounts) {
275:     for (let i = 0; i < gamesPerPlayerCount && total < count; i++) {
276:       const seed = `sim-${playerCount}-${i}-${Date.now()}`;
277: 
278:       const result = await simulateSingleGame(
279:         GameClass,
280:         playerCount,
281:         seed,
282:         timeout,
283:         maxActions
284:       );
285: 
286:       games.push(result);
287:       total++;
288: 
289:       if (result.error) {
290:         errors.add(result.error);
291:       }
292: 
293:       if (onGameComplete) {
294:         onGameComplete(result, { completed: total, total: count });
295:       }
296:     }
297:   }
298: 
299:   // Calculate aggregates
300:   const completed = games.filter(g => g.completed).length;
301:   const crashed = games.filter(g => g.crashed).length;
302:   const timedOut = games.filter(g => g.timedOut).length;
303:   const exceededMaxActions = games.filter(g => g.exceededMaxActions).length;
304: 
305:   const completedGames = games.filter(g => g.completed);
306:   const averageActions = completedGames.length > 0
307:     ? completedGames.reduce((sum, g) => sum + g.actionCount, 0) / completedGames.length
308:     : 0;
309:   const averageDuration = completedGames.length > 0
310:     ? completedGames.reduce((sum, g) => sum + g.duration, 0) / completedGames.length
311:     : 0;
312: 
313:   return {
314:     completed,
315:     crashed,
316:     timedOut,
317:     exceededMaxActions,
318:     total,
319:     games,
320:     averageActions,
321:     averageDuration,
322:     errors: [...errors],
323:   };
324: }
````

## File: packages/testing/src/simulate-action.ts
````typescript
  1: import type { Game } from '@boardsmith/engine';
  2: import type { TestGame } from './test-game.js';
  3: import type { ActionExecutionResult } from '@boardsmith/runtime';
  4: 
  5: /**
  6:  * Result of simulating an action, with additional test utilities
  7:  */
  8: export interface SimulateActionResult extends ActionExecutionResult {
  9:   /** The action that was attempted */
 10:   action: string;
 11:   /** The player who attempted the action */
 12:   playerIndex: number;
 13:   /** The arguments passed to the action */
 14:   args: Record<string, unknown>;
 15: }
 16: 
 17: /**
 18:  * Simulate a player action and return the result
 19:  *
 20:  * @example
 21:  * ```typescript
 22:  * const result = simulateAction(testGame, 0, 'ask', {
 23:  *   target: 1,
 24:  *   rank: '8',
 25:  * });
 26:  *
 27:  * expect(result.success).toBe(true);
 28:  * ```
 29:  */
 30: export function simulateAction<G extends Game>(
 31:   testGame: TestGame<G>,
 32:   playerIndex: number,
 33:   actionName: string,
 34:   args: Record<string, unknown> = {}
 35: ): SimulateActionResult {
 36:   const result = testGame.doAction(playerIndex, actionName, args);
 37: 
 38:   return {
 39:     ...result,
 40:     action: actionName,
 41:     playerIndex,
 42:     args,
 43:   };
 44: }
 45: 
 46: /**
 47:  * Simulate multiple actions in sequence
 48:  *
 49:  * @example
 50:  * ```typescript
 51:  * const results = simulateActions(testGame, [
 52:  *   [0, 'ask', { target: 1, rank: '8' }],
 53:  *   [1, 'ask', { target: 0, rank: 'K' }],
 54:  * ]);
 55:  *
 56:  * expect(results.every(r => r.success)).toBe(true);
 57:  * ```
 58:  */
 59: export function simulateActions<G extends Game>(
 60:   testGame: TestGame<G>,
 61:   actions: Array<[playerIndex: number, actionName: string, args?: Record<string, unknown>]>
 62: ): SimulateActionResult[] {
 63:   return actions.map(([playerIndex, actionName, args]) =>
 64:     simulateAction(testGame, playerIndex, actionName, args ?? {})
 65:   );
 66: }
 67: 
 68: /**
 69:  * Assert that an action succeeds
 70:  * Throws an error with details if the action fails
 71:  */
 72: export function assertActionSucceeds<G extends Game>(
 73:   testGame: TestGame<G>,
 74:   playerIndex: number,
 75:   actionName: string,
 76:   args: Record<string, unknown> = {}
 77: ): SimulateActionResult {
 78:   const result = simulateAction(testGame, playerIndex, actionName, args);
 79: 
 80:   if (!result.success) {
 81:     throw new Error(
 82:       `Expected action '${actionName}' by player ${playerIndex} to succeed, but it failed: ${result.error}`
 83:     );
 84:   }
 85: 
 86:   return result;
 87: }
 88: 
 89: /**
 90:  * Assert that an action fails
 91:  * Throws an error if the action succeeds
 92:  */
 93: export function assertActionFails<G extends Game>(
 94:   testGame: TestGame<G>,
 95:   playerIndex: number,
 96:   actionName: string,
 97:   args: Record<string, unknown> = {},
 98:   expectedError?: string | RegExp
 99: ): SimulateActionResult {
100:   const result = simulateAction(testGame, playerIndex, actionName, args);
101: 
102:   if (result.success) {
103:     throw new Error(
104:       `Expected action '${actionName}' by player ${playerIndex} to fail, but it succeeded`
105:     );
106:   }
107: 
108:   if (expectedError) {
109:     const errorMatches = typeof expectedError === 'string'
110:       ? result.error?.includes(expectedError)
111:       : expectedError.test(result.error ?? '');
112: 
113:     if (!errorMatches) {
114:       throw new Error(
115:         `Expected error to match ${expectedError}, but got: ${result.error}`
116:       );
117:     }
118:   }
119: 
120:   return result;
121: }
````

## File: packages/testing/src/test-game.ts
````typescript
  1: import {
  2:   Game,
  3:   type GameOptions,
  4:   type FlowState,
  5:   type Player,
  6: } from '@boardsmith/engine';
  7: import { GameRunner, type ActionExecutionResult } from '@boardsmith/runtime';
  8: 
  9: /**
 10:  * Options for creating a test game
 11:  */
 12: export interface TestGameOptions {
 13:   /** Number of players */
 14:   playerCount: number;
 15:   /** Player names (optional) */
 16:   playerNames?: string[];
 17:   /** Random seed for deterministic tests */
 18:   seed?: string;
 19:   /** Whether to auto-start the game */
 20:   autoStart?: boolean;
 21: }
 22: 
 23: /**
 24:  * A test game wrapper that provides convenient testing utilities
 25:  */
 26: export class TestGame<G extends Game = Game> {
 27:   readonly runner: GameRunner<G>;
 28:   readonly game: G;
 29: 
 30:   private constructor(runner: GameRunner<G>) {
 31:     this.runner = runner;
 32:     this.game = runner.game;
 33:   }
 34: 
 35:   /**
 36:    * Create a new test game instance
 37:    */
 38:   static create<G extends Game>(
 39:     GameClass: new (options: GameOptions) => G,
 40:     options: TestGameOptions
 41:   ): TestGame<G> {
 42:     const seed = options.seed ?? `test-${Date.now()}`;
 43:     const playerNames = options.playerNames ??
 44:       Array.from({ length: options.playerCount }, (_, i) => `Player ${i + 1}`);
 45: 
 46:     const runner = new GameRunner({
 47:       GameClass,
 48:       gameType: GameClass.name.toLowerCase(),
 49:       gameOptions: {
 50:         playerCount: options.playerCount,
 51:         playerNames,
 52:         seed,
 53:       },
 54:     });
 55: 
 56:     const testGame = new TestGame(runner);
 57: 
 58:     if (options.autoStart !== false) {
 59:       testGame.start();
 60:     }
 61: 
 62:     return testGame;
 63:   }
 64: 
 65:   /**
 66:    * Start the game flow
 67:    */
 68:   start(): FlowState {
 69:     return this.runner.start();
 70:   }
 71: 
 72:   /**
 73:    * Get current flow state
 74:    */
 75:   getFlowState(): FlowState | undefined {
 76:     return this.runner.getFlowState();
 77:   }
 78: 
 79:   /**
 80:    * Check if game is complete
 81:    */
 82:   isComplete(): boolean {
 83:     return this.runner.isComplete();
 84:   }
 85: 
 86:   /**
 87:    * Check if game is awaiting player input
 88:    */
 89:   isAwaitingInput(): boolean {
 90:     return this.game.isAwaitingInput();
 91:   }
 92: 
 93:   /**
 94:    * Get the current player (if any)
 95:    */
 96:   getCurrentPlayer(): Player | undefined {
 97:     const flowState = this.getFlowState();
 98:     if (flowState?.currentPlayer !== undefined) {
 99:       return this.game.players[flowState.currentPlayer];
100:     }
101:     return undefined;
102:   }
103: 
104:   /**
105:    * Get all players
106:    */
107:   getPlayers(): Player[] {
108:     return [...this.game.players];
109:   }
110: 
111:   /**
112:    * Get a player by index
113:    */
114:   getPlayer(index: number): Player {
115:     const player = this.game.players[index];
116:     if (!player) {
117:       throw new Error(`Player ${index} not found`);
118:     }
119:     return player;
120:   }
121: 
122:   /**
123:    * Perform an action
124:    */
125:   doAction(
126:     playerIndex: number,
127:     actionName: string,
128:     args: Record<string, unknown> = {}
129:   ): ActionExecutionResult {
130:     return this.runner.performAction(actionName, playerIndex, args);
131:   }
132: 
133:   /**
134:    * Get the winners (if game is complete)
135:    */
136:   getWinners(): Player[] {
137:     return this.runner.getWinners();
138:   }
139: 
140:   /**
141:    * Get action history
142:    */
143:   getActionHistory() {
144:     return [...this.runner.actionHistory];
145:   }
146: 
147:   /**
148:    * Get a snapshot of the current game state
149:    */
150:   getSnapshot() {
151:     return this.runner.getSnapshot();
152:   }
153: 
154:   /**
155:    * Get a player's view of the game
156:    */
157:   getPlayerView(playerIndex: number) {
158:     return this.runner.getPlayerView(playerIndex);
159:   }
160: }
161: 
162: /**
163:  * Create a test game with the given configuration
164:  * Convenience function that wraps TestGame.create
165:  */
166: export function createTestGame<G extends Game>(
167:   GameClass: new (options: GameOptions) => G,
168:   options: TestGameOptions
169: ): TestGame<G> {
170:   return TestGame.create(GameClass, options);
171: }
````

## File: packages/testing/package.json
````json
 1: {
 2:   "name": "@boardsmith/testing",
 3:   "version": "0.0.1",
 4:   "description": "Testing utilities for BoardSmith games - provides createTestGame, simulateAction, assertActionSucceeds/Fails, and simulateRandomGames for game logic verification",
 5:   "main": "dist/index.js",
 6:   "types": "dist/index.d.ts",
 7:   "type": "module",
 8:   "exports": {
 9:     ".": {
10:       "import": "./dist/index.js",
11:       "types": "./dist/index.d.ts"
12:     }
13:   },
14:   "scripts": {
15:     "build": "tsc",
16:     "dev": "tsc --watch"
17:   },
18:   "dependencies": {
19:     "@boardsmith/engine": "workspace:*",
20:     "@boardsmith/runtime": "workspace:*"
21:   },
22:   "devDependencies": {
23:     "@types/node": "^20.10.0",
24:     "typescript": "^5.7.0"
25:   },
26:   "peerDependencies": {
27:     "vitest": ">=1.0.0"
28:   },
29:   "peerDependenciesMeta": {
30:     "vitest": {
31:       "optional": true
32:     }
33:   },
34:   "keywords": [
35:     "boardsmith",
36:     "testing",
37:     "board-game",
38:     "card-game"
39:   ]
40: }
````

## File: packages/ui/src/composables/useCardDisplay.ts
````typescript
  1: /**
  2:  * useCardDisplay - Utilities for displaying playing cards
  3:  *
  4:  * Provides common functions for rendering playing cards with suit symbols,
  5:  * colors, and rank names. Used by custom game UIs.
  6:  *
  7:  * ## Usage
  8:  *
  9:  * ```typescript
 10:  * import { useCardDisplay, getSuitSymbol, getSuitColor, getRankName } from '@boardsmith/ui';
 11:  *
 12:  * // Use individual functions
 13:  * const symbol = getSuitSymbol('H'); // '♥'
 14:  * const color = getSuitColor('H'); // '#e74c3c' (red)
 15:  * const name = getRankName('K'); // 'King'
 16:  *
 17:  * // Or use the composable
 18:  * const { getSuitSymbol, getSuitColor, getRankName } = useCardDisplay();
 19:  * ```
 20:  *
 21:  * ## In Vue Templates
 22:  *
 23:  * ```vue
 24:  * <script setup>
 25:  * import { getSuitSymbol, getSuitColor } from '@boardsmith/ui';
 26:  * </script>
 27:  *
 28:  * <template>
 29:  *   <div :style="{ color: getSuitColor(card.suit) }">
 30:  *     {{ card.rank }}{{ getSuitSymbol(card.suit) }}
 31:  *   </div>
 32:  * </template>
 33:  * ```
 34:  */
 35: 
 36: /** Standard suit abbreviations */
 37: export type SuitAbbreviation = 'H' | 'D' | 'C' | 'S';
 38: 
 39: /** Standard rank abbreviations */
 40: export type RankAbbreviation = 'A' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | 'J' | 'Q' | 'K';
 41: 
 42: /** Map of suit abbreviations to Unicode symbols */
 43: const SUIT_SYMBOLS: Record<string, string> = {
 44:   H: '\u2665', // ♥
 45:   D: '\u2666', // ♦
 46:   C: '\u2663', // ♣
 47:   S: '\u2660', // ♠
 48: };
 49: 
 50: /** Map of suit abbreviations to colors (red for hearts/diamonds, dark for clubs/spades) */
 51: const SUIT_COLORS: Record<string, string> = {
 52:   H: '#e74c3c', // red
 53:   D: '#e74c3c', // red
 54:   C: '#2c3e50', // dark
 55:   S: '#2c3e50', // dark
 56: };
 57: 
 58: /** Map of rank abbreviations to full names */
 59: const RANK_NAMES: Record<string, string> = {
 60:   A: 'Ace',
 61:   J: 'Jack',
 62:   Q: 'Queen',
 63:   K: 'King',
 64: };
 65: 
 66: /**
 67:  * Get the Unicode symbol for a suit.
 68:  *
 69:  * @param suit - Suit abbreviation ('H', 'D', 'C', 'S')
 70:  * @returns Unicode suit symbol (♥, ♦, ♣, ♠) or the input if not recognized
 71:  */
 72: export function getSuitSymbol(suit: string): string {
 73:   return SUIT_SYMBOLS[suit] ?? suit;
 74: }
 75: 
 76: /**
 77:  * Get the color for a suit.
 78:  * Hearts and Diamonds are red, Clubs and Spades are dark.
 79:  *
 80:  * @param suit - Suit abbreviation ('H', 'D', 'C', 'S')
 81:  * @returns CSS color string
 82:  */
 83: export function getSuitColor(suit: string): string {
 84:   return SUIT_COLORS[suit] ?? '#2c3e50';
 85: }
 86: 
 87: /**
 88:  * Get the full name for a rank.
 89:  * Face cards (A, J, Q, K) are converted to full names.
 90:  * Number cards return the number as-is.
 91:  *
 92:  * @param rank - Rank abbreviation ('A', '2'-'10', 'J', 'Q', 'K')
 93:  * @returns Full rank name ('Ace', 'King', etc.) or the number
 94:  */
 95: export function getRankName(rank: string): string {
 96:   return RANK_NAMES[rank] ?? rank;
 97: }
 98: 
 99: /**
100:  * Get the point value for a card (standard playing card values).
101:  * Ace = 1, Number cards = face value, Face cards (J/Q/K) = 10.
102:  *
103:  * @param rank - Rank abbreviation
104:  * @returns Point value (1-10)
105:  */
106: export function getCardPointValue(rank: string): number {
107:   if (rank === 'A') return 1;
108:   if (['J', 'Q', 'K'].includes(rank)) return 10;
109:   return parseInt(rank, 10) || 0;
110: }
111: 
112: /**
113:  * Check if a suit is red (Hearts or Diamonds).
114:  *
115:  * @param suit - Suit abbreviation
116:  * @returns true if the suit is red
117:  */
118: export function isRedSuit(suit: string): boolean {
119:   return suit === 'H' || suit === 'D';
120: }
121: 
122: /**
123:  * Check if a suit is black (Clubs or Spades).
124:  *
125:  * @param suit - Suit abbreviation
126:  * @returns true if the suit is black
127:  */
128: export function isBlackSuit(suit: string): boolean {
129:   return suit === 'C' || suit === 'S';
130: }
131: 
132: /**
133:  * Composable that provides card display utilities.
134:  * Use this if you prefer the composable pattern.
135:  */
136: export function useCardDisplay() {
137:   return {
138:     getSuitSymbol,
139:     getSuitColor,
140:     getRankName,
141:     getCardPointValue,
142:     isRedSuit,
143:     isBlackSuit,
144:   };
145: }
````

## File: packages/ui/src/composables/useCardFlip.ts
````typescript
  1: /**
  2:  * useCardFlip - Composable for 3D card flip animations
  3:  *
  4:  * Provides reactive state and CSS classes for smooth card flip animations
  5:  * when a card's visibility changes (face-up to face-down or vice versa).
  6:  *
  7:  * Usage:
  8:  * ```vue
  9:  * <script setup>
 10:  * import { useCardFlip } from '@boardsmith/ui';
 11:  * import { computed } from 'vue';
 12:  *
 13:  * const props = defineProps<{ card: { faceUp: boolean } }>();
 14:  * const { flipClass, isFlipping } = useCardFlip(() => props.card.faceUp);
 15:  * </script>
 16:  *
 17:  * <template>
 18:  *   <div class="card-flip-container">
 19:  *     <div :class="flipClass">
 20:  *       <div class="card-front">{{ card.name }}</div>
 21:  *       <div class="card-back"></div>
 22:  *     </div>
 23:  *   </div>
 24:  * </template>
 25:  * ```
 26:  */
 27: import { ref, watch, computed, type Ref, type ComputedRef } from 'vue';
 28: import { prefersReducedMotion } from './useElementAnimation.js';
 29: 
 30: export interface CardFlipOptions {
 31:   /** Duration of the flip animation in ms (default: 400) */
 32:   duration?: number;
 33: }
 34: 
 35: export interface CardFlipReturn {
 36:   /** Whether the card is currently flipping */
 37:   isFlipping: Ref<boolean>;
 38:   /** The visual face-up state (may lag behind actual state during animation) */
 39:   showFaceUp: Ref<boolean>;
 40:   /** CSS classes to apply to the flippable element */
 41:   flipClass: ComputedRef<Record<string, boolean>>;
 42:   /** Manually trigger a flip animation */
 43:   triggerFlip: () => void;
 44: }
 45: 
 46: const DEFAULT_FLIP_DURATION = 400;
 47: 
 48: /**
 49:  * Create card flip animation state
 50:  * @param isFaceUp - Getter function or ref that returns true when card is face-up
 51:  * @param options - Animation options
 52:  */
 53: export function useCardFlip(
 54:   isFaceUp: (() => boolean) | Ref<boolean> | ComputedRef<boolean>,
 55:   options: CardFlipOptions = {}
 56: ): CardFlipReturn {
 57:   const duration = options.duration ?? DEFAULT_FLIP_DURATION;
 58:   const halfDuration = duration / 2;
 59: 
 60:   // Normalize to a getter function
 61:   const getFaceUp = typeof isFaceUp === 'function'
 62:     ? isFaceUp
 63:     : () => isFaceUp.value;
 64: 
 65:   const isFlipping = ref(false);
 66:   const showFaceUp = ref(getFaceUp());
 67: 
 68:   // Watch for visibility changes and trigger flip
 69:   watch(
 70:     getFaceUp,
 71:     (newValue, oldValue) => {
 72:       // Skip if same value or if reduced motion is preferred
 73:       if (newValue === oldValue) return;
 74: 
 75:       if (prefersReducedMotion.value) {
 76:         // Instant change for reduced motion
 77:         showFaceUp.value = newValue;
 78:         return;
 79:       }
 80: 
 81:       // Start flip animation
 82:       isFlipping.value = true;
 83: 
 84:       // Update displayed face at midpoint of animation (when card is edge-on)
 85:       setTimeout(() => {
 86:         showFaceUp.value = newValue;
 87:       }, halfDuration);
 88: 
 89:       // End flip animation
 90:       setTimeout(() => {
 91:         isFlipping.value = false;
 92:       }, duration);
 93:     }
 94:   );
 95: 
 96:   // Sync initial state
 97:   watch(
 98:     getFaceUp,
 99:     (newValue) => {
100:       if (!isFlipping.value) {
101:         showFaceUp.value = newValue;
102:       }
103:     },
104:     { immediate: true }
105:   );
106: 
107:   const flipClass = computed(() => ({
108:     'card-flippable': true,
109:     'card-flipping': isFlipping.value,
110:     'card-face-down': !showFaceUp.value,
111:     'card-face-up': showFaceUp.value,
112:   }));
113: 
114:   function triggerFlip() {
115:     if (prefersReducedMotion.value) {
116:       showFaceUp.value = !showFaceUp.value;
117:       return;
118:     }
119: 
120:     isFlipping.value = true;
121: 
122:     setTimeout(() => {
123:       showFaceUp.value = !showFaceUp.value;
124:     }, halfDuration);
125: 
126:     setTimeout(() => {
127:       isFlipping.value = false;
128:     }, duration);
129:   }
130: 
131:   return {
132:     isFlipping,
133:     showFaceUp,
134:     flipClass,
135:     triggerFlip,
136:   };
137: }
138: 
139: /**
140:  * Simple hook to detect if a card was just revealed (became visible)
141:  * Useful for triggering flip animations in AutoUI when cards appear
142:  */
143: export function useCardReveal(
144:   isVisible: (() => boolean) | Ref<boolean> | ComputedRef<boolean>
145: ) {
146:   const getVisible = typeof isVisible === 'function'
147:     ? isVisible
148:     : () => isVisible.value;
149: 
150:   const wasRevealed = ref(false);
151:   const previousVisible = ref(getVisible());
152: 
153:   watch(
154:     getVisible,
155:     (newValue, oldValue) => {
156:       // Card was revealed (went from hidden to visible)
157:       wasRevealed.value = !oldValue && newValue;
158:       previousVisible.value = newValue;
159: 
160:       // Reset after animation duration
161:       if (wasRevealed.value) {
162:         setTimeout(() => {
163:           wasRevealed.value = false;
164:         }, DEFAULT_FLIP_DURATION);
165:       }
166:     }
167:   );
168: 
169:   return {
170:     wasRevealed,
171:   };
172: }
````

## File: packages/ui/src/composables/useFLIPAnimation.ts
````typescript
  1: /**
  2:  * useFLIPAnimation - FLIP animation pattern for smooth element transitions
  3:  *
  4:  * FLIP stands for First-Last-Invert-Play:
  5:  * 1. First: Capture the initial position of elements
  6:  * 2. Last: Let the DOM update to the final position
  7:  * 3. Invert: Calculate the delta and apply a transform to appear in original position
  8:  * 4. Play: Animate from inverted position to final position
  9:  *
 10:  * This creates smooth animations when elements move around in the DOM,
 11:  * such as cards being reordered in a hand or moving between zones.
 12:  *
 13:  * ## Usage
 14:  *
 15:  * ```typescript
 16:  * import { useFLIPAnimation } from '@boardsmith/ui';
 17:  *
 18:  * const boardRef = ref<HTMLElement | null>(null);
 19:  * const { capturePositions, animateToNewPositions } = useFLIPAnimation({
 20:  *   containerRef: boardRef,
 21:  *   selector: '[data-card-id]',
 22:  *   duration: 300,
 23:  *   easing: 'ease-out',
 24:  * });
 25:  *
 26:  * // In a watcher
 27:  * watch(
 28:  *   () => props.gameView,
 29:  *   async (newView, oldView) => {
 30:  *     if (!oldView) return;
 31:  *
 32:  *     // First: Capture positions before DOM update
 33:  *     capturePositions();
 34:  *
 35:  *     // Wait for DOM to update (Last position is now set)
 36:  *     await nextTick();
 37:  *
 38:  *     // Invert + Play: Animate from old to new positions
 39:  *     animateToNewPositions();
 40:  *   },
 41:  *   { deep: false }
 42:  * );
 43:  * ```
 44:  */
 45: 
 46: import { ref, type Ref } from 'vue';
 47: import { prefersReducedMotion } from './useElementAnimation.js';
 48: 
 49: export interface FLIPAnimationOptions {
 50:   /** Ref to the container element */
 51:   containerRef: Ref<HTMLElement | null>;
 52:   /** CSS selector to find animated elements (default: '[data-card-id]') */
 53:   selector?: string;
 54:   /** Animation duration in ms (default: 300) */
 55:   duration?: number;
 56:   /** CSS easing function (default: 'ease-out') */
 57:   easing?: string;
 58:   /** Minimum distance (px) to trigger animation (default: 1) */
 59:   threshold?: number;
 60:   /** Callback when animation starts */
 61:   onAnimationStart?: () => void;
 62:   /** Callback when all animations complete */
 63:   onAnimationEnd?: () => void;
 64: }
 65: 
 66: export interface FLIPAnimationReturn {
 67:   /** Capture current positions (call before DOM update) */
 68:   capturePositions: () => void;
 69:   /** Animate elements from captured positions to current positions */
 70:   animateToNewPositions: () => Promise<void>;
 71:   /** Check if any animations are currently running */
 72:   isAnimating: Ref<boolean>;
 73:   /** Clear captured positions */
 74:   clear: () => void;
 75: }
 76: 
 77: /**
 78:  * Create a FLIP animation handler.
 79:  *
 80:  * @param options - Configuration options
 81:  * @returns FLIP animation utilities
 82:  */
 83: export function useFLIPAnimation(options: FLIPAnimationOptions): FLIPAnimationReturn {
 84:   const {
 85:     containerRef,
 86:     selector = '[data-card-id]',
 87:     duration = 300,
 88:     easing = 'ease-out',
 89:     threshold = 1,
 90:     onAnimationStart,
 91:     onAnimationEnd,
 92:   } = options;
 93: 
 94:   const positions = new Map<string, DOMRect>();
 95:   const isAnimating = ref(false);
 96: 
 97:   /**
 98:    * Capture current positions of all matching elements.
 99:    * Call this BEFORE the DOM update happens.
100:    */
101:   function capturePositions(): void {
102:     positions.clear();
103:     if (!containerRef.value) return;
104: 
105:     const elements = containerRef.value.querySelectorAll(selector);
106:     elements.forEach((el) => {
107:       const id = getElementId(el);
108:       if (id) {
109:         positions.set(id, el.getBoundingClientRect());
110:       }
111:     });
112:   }
113: 
114:   /**
115:    * Get a unique identifier for an element.
116:    * Tries data-card-id, data-element-id, then id.
117:    */
118:   function getElementId(el: Element): string | null {
119:     return (
120:       el.getAttribute('data-card-id') ||
121:       el.getAttribute('data-element-id') ||
122:       el.getAttribute('id') ||
123:       null
124:     );
125:   }
126: 
127:   /**
128:    * Animate elements from their captured positions to their current positions.
129:    * Call this AFTER the DOM has updated (after nextTick).
130:    */
131:   async function animateToNewPositions(): Promise<void> {
132:     // Skip if reduced motion is preferred
133:     if (prefersReducedMotion.value) {
134:       positions.clear();
135:       return;
136:     }
137: 
138:     if (!containerRef.value || positions.size === 0) {
139:       return;
140:     }
141: 
142:     const animations: Animation[] = [];
143:     const elements = containerRef.value.querySelectorAll(selector);
144: 
145:     elements.forEach((el) => {
146:       const id = getElementId(el);
147:       if (!id) return;
148: 
149:       const oldRect = positions.get(id);
150:       if (!oldRect) return;
151: 
152:       const newRect = el.getBoundingClientRect();
153:       const deltaX = oldRect.left - newRect.left;
154:       const deltaY = oldRect.top - newRect.top;
155: 
156:       // Only animate if movement exceeds threshold
157:       if (Math.abs(deltaX) < threshold && Math.abs(deltaY) < threshold) {
158:         return;
159:       }
160: 
161:       // Create FLIP animation
162:       const animation = (el as HTMLElement).animate(
163:         [
164:           { transform: `translate(${deltaX}px, ${deltaY}px)` },
165:           { transform: 'translate(0, 0)' },
166:         ],
167:         {
168:           duration,
169:           easing,
170:           fill: 'backwards',
171:         }
172:       );
173: 
174:       animations.push(animation);
175:     });
176: 
177:     if (animations.length > 0) {
178:       isAnimating.value = true;
179:       onAnimationStart?.();
180: 
181:       // Wait for all animations to complete
182:       await Promise.all(animations.map((a) => a.finished));
183: 
184:       isAnimating.value = false;
185:       onAnimationEnd?.();
186:     }
187: 
188:     // Clear captured positions
189:     positions.clear();
190:   }
191: 
192:   /**
193:    * Clear captured positions without animating.
194:    */
195:   function clear(): void {
196:     positions.clear();
197:   }
198: 
199:   return {
200:     capturePositions,
201:     animateToNewPositions,
202:     isAnimating,
203:     clear,
204:   };
205: }
206: 
207: /**
208:  * Simplified FLIP animation for a single update cycle.
209:  * Use this for one-off animations without tracking state.
210:  *
211:  * @param containerRef - Ref to container element
212:  * @param selector - CSS selector for elements to animate
213:  * @param options - Animation options
214:  * @returns A function that captures positions and returns an animate function
215:  */
216: export function createFLIPSnapshot(
217:   containerRef: Ref<HTMLElement | null>,
218:   selector: string = '[data-card-id]',
219:   options: { duration?: number; easing?: string } = {}
220: ): { animate: () => Promise<void> } {
221:   const { duration = 300, easing = 'ease-out' } = options;
222:   const positions = new Map<string, DOMRect>();
223: 
224:   // Capture positions immediately
225:   if (containerRef.value) {
226:     const elements = containerRef.value.querySelectorAll(selector);
227:     elements.forEach((el) => {
228:       const id =
229:         el.getAttribute('data-card-id') ||
230:         el.getAttribute('data-element-id') ||
231:         el.getAttribute('id');
232:       if (id) {
233:         positions.set(id, el.getBoundingClientRect());
234:       }
235:     });
236:   }
237: 
238:   return {
239:     async animate(): Promise<void> {
240:       if (prefersReducedMotion.value || !containerRef.value || positions.size === 0) {
241:         return;
242:       }
243: 
244:       const animations: Animation[] = [];
245:       const elements = containerRef.value.querySelectorAll(selector);
246: 
247:       elements.forEach((el) => {
248:         const id =
249:           el.getAttribute('data-card-id') ||
250:           el.getAttribute('data-element-id') ||
251:           el.getAttribute('id');
252:         if (!id) return;
253: 
254:         const oldRect = positions.get(id);
255:         if (!oldRect) return;
256: 
257:         const newRect = el.getBoundingClientRect();
258:         const deltaX = oldRect.left - newRect.left;
259:         const deltaY = oldRect.top - newRect.top;
260: 
261:         if (Math.abs(deltaX) < 1 && Math.abs(deltaY) < 1) {
262:           return;
263:         }
264: 
265:         animations.push(
266:           (el as HTMLElement).animate(
267:             [
268:               { transform: `translate(${deltaX}px, ${deltaY}px)` },
269:               { transform: 'translate(0, 0)' },
270:             ],
271:             { duration, easing, fill: 'backwards' }
272:           )
273:         );
274:       });
275: 
276:       await Promise.all(animations.map((a) => a.finished));
277:     },
278:   };
279: }
````

## File: packages/ui/src/composables/useFlyOnAppear.ts
````typescript
  1: /**
  2:  * useFlyOnAppear - Composable for flying cards when they appear
  3:  *
  4:  * Watches for an element to become visible and automatically triggers
  5:  * a fly animation from a source element to a target element.
  6:  *
  7:  * Common use cases:
  8:  * - Starter card appearing from deck
  9:  * - Cards being dealt from deck to hands
 10:  * - Cards moving from one zone to another
 11:  *
 12:  * Usage:
 13:  * ```typescript
 14:  * const deckRef = ref<HTMLElement | null>(null);
 15:  * const starterRef = ref<HTMLElement | null>(null);
 16:  * const starterCard = computed(() => findFirstCard(starterElement));
 17:  *
 18:  * const { isFlying } = useFlyOnAppear({
 19:  *   sourceRef: deckRef,
 20:  *   targetRef: starterRef,
 21:  *   element: starterCard,
 22:  *   getCardData: (el) => ({ rank: el.attributes.rank, suit: el.attributes.suit }),
 23:  *   flip: true,
 24:  * });
 25:  *
 26:  * // In template, hide actual element while flying:
 27:  * // <div v-if="starterCard && !isFlying">...</div>
 28:  * ```
 29:  */
 30: import { ref, watch, type Ref, type ComputedRef } from 'vue';
 31: import { useFlyingCards, type FlyCardOptions } from './useFlyingCards.js';
 32: import { prefersReducedMotion } from './useElementAnimation.js';
 33: 
 34: export interface FlyOnAppearOptions<T> {
 35:   /** Ref to the source element (where the card flies from) */
 36:   sourceRef: Ref<HTMLElement | null>;
 37:   /** Ref to the target element (where the card flies to) */
 38:   targetRef: Ref<HTMLElement | null>;
 39:   /** Reactive element that triggers the animation when it becomes truthy */
 40:   element: ComputedRef<T | null | undefined> | Ref<T | null | undefined>;
 41:   /** Function to extract card data from the element */
 42:   getCardData: (element: T) => { rank?: string; suit?: string };
 43:   /** Whether to flip the card during flight (default: true) */
 44:   flip?: boolean;
 45:   /** Whether the card starts face up (default: false - starts face down) */
 46:   startFaceUp?: boolean;
 47:   /** Animation duration in ms (default: 500) */
 48:   duration?: number;
 49:   /** Card dimensions (default: { width: 60, height: 84 }) */
 50:   cardSize?: { width: number; height: number };
 51:   /** Callback when animation starts */
 52:   onStart?: () => void;
 53:   /** Callback when animation completes */
 54:   onComplete?: () => void;
 55: }
 56: 
 57: export interface FlyOnAppearReturn {
 58:   /** Whether an animation is currently in progress */
 59:   isFlying: Ref<boolean>;
 60:   /** The flyingCards array from useFlyingCards (for rendering overlay) */
 61:   flyingCards: ReturnType<typeof useFlyingCards>['flyingCards'];
 62: }
 63: 
 64: const DEFAULT_CARD_SIZE = { width: 60, height: 84 };
 65: const DEFAULT_DURATION = 500;
 66: 
 67: export function useFlyOnAppear<T>(options: FlyOnAppearOptions<T>): FlyOnAppearReturn {
 68:   const {
 69:     sourceRef,
 70:     targetRef,
 71:     element,
 72:     getCardData,
 73:     flip = true,
 74:     startFaceUp = false,
 75:     duration = DEFAULT_DURATION,
 76:     cardSize = DEFAULT_CARD_SIZE,
 77:     onStart,
 78:     onComplete,
 79:   } = options;
 80: 
 81:   const isFlying = ref(false);
 82:   const { flyingCards, flyCard } = useFlyingCards();
 83: 
 84:   // Watch for element appearing
 85:   watch(
 86:     () => element.value,
 87:     async (newElement, oldElement) => {
 88:       // Only trigger when element becomes truthy (appears)
 89:       if (!newElement || oldElement) return;
 90: 
 91:       // Skip if reduced motion preferred
 92:       if (prefersReducedMotion.value) return;
 93: 
 94:       // Get source and target rects
 95:       const sourceRect = sourceRef.value?.getBoundingClientRect();
 96:       const targetRect = targetRef.value?.getBoundingClientRect();
 97: 
 98:       if (!sourceRect || !targetRect) return;
 99: 
100:       // Extract card data
101:       const cardData = getCardData(newElement);
102: 
103:       isFlying.value = true;
104:       onStart?.();
105: 
106:       await flyCard({
107:         id: `fly-appear-${Date.now()}`,
108:         startRect: sourceRect,
109:         endRect: () => targetRef.value?.getBoundingClientRect() ?? targetRect,
110:         cardData: {
111:           ...cardData,
112:           faceUp: startFaceUp,
113:         },
114:         flip,
115:         duration,
116:         cardSize,
117:       });
118: 
119:       isFlying.value = false;
120:       onComplete?.();
121:     }
122:   );
123: 
124:   return {
125:     isFlying,
126:     flyingCards,
127:   };
128: }
````

## File: packages/ui/src/composables/usePlayerStatAnimation.ts
````typescript
  1: /**
  2:  * usePlayerStatAnimation - Utilities for animating elements to player stats in the panel
  3:  *
  4:  * Provides helpers for flying cards/tokens to player stat displays (scores, books, resources, etc.)
  5:  *
  6:  * ## Setup
  7:  *
  8:  * Add data attributes to your player stat elements in the #player-stats slot:
  9:  * ```vue
 10:  * <template #player-stats="{ player }">
 11:  *   <div class="stat">
 12:  *     <span>Score:</span>
 13:  *     <span :data-player-stat="'score'" :data-player-position="player.position">
 14:  *       {{ player.score }}
 15:  *     </span>
 16:  *   </div>
 17:  * </template>
 18:  * ```
 19:  *
 20:  * ## Usage in Custom UI
 21:  *
 22:  * ```typescript
 23:  * import { usePlayerStatAnimation, useFlyingCards } from '@boardsmith/ui';
 24:  *
 25:  * const { flyingCards, flyCards } = useFlyingCards();
 26:  * const { flyToPlayerStat, getPlayerStatElement } = usePlayerStatAnimation();
 27:  *
 28:  * // Fly cards to a player's stat
 29:  * flyToPlayerStat(flyCards, {
 30:  *   cards: removedCards.map(c => ({ rect: c.rect, rank: c.rank, suit: c.suit })),
 31:  *   playerPosition: 0,
 32:  *   statName: 'books',
 33:  * });
 34:  * ```
 35:  */
 36: 
 37: import type { FlyCardOptions } from './useFlyingCards.js';
 38: 
 39: export interface CardForAnimation {
 40:   /** Bounding rect of the card's original position */
 41:   rect: DOMRect;
 42:   /** Card rank (optional, for display) */
 43:   rank?: string;
 44:   /** Card suit (optional, for display) */
 45:   suit?: string;
 46:   /** Whether card is face up (default: true) */
 47:   faceUp?: boolean;
 48: }
 49: 
 50: export interface FlyToStatOptions {
 51:   /** Cards to animate */
 52:   cards: CardForAnimation[];
 53:   /** Player position to target */
 54:   playerPosition: number;
 55:   /** Name of the stat (e.g., 'score', 'books', 'resources') */
 56:   statName: string;
 57:   /** Animation duration in ms (default: 500) */
 58:   duration?: number;
 59:   /** Stagger delay between cards in ms (default: 50) */
 60:   stagger?: number;
 61:   /** Card dimensions (default: { width: 70, height: 100 }) */
 62:   cardSize?: { width: number; height: number };
 63:   /** Whether to flip cards during animation (default: false) */
 64:   flip?: boolean;
 65: }
 66: 
 67: /**
 68:  * Get a player stat element by position and stat name.
 69:  * Looks for elements with data-player-stat and data-player-position attributes.
 70:  */
 71: export function getPlayerStatElement(
 72:   playerPosition: number,
 73:   statName: string
 74: ): HTMLElement | null {
 75:   return document.querySelector(
 76:     `[data-player-stat="${statName}"][data-player-position="${playerPosition}"]`
 77:   );
 78: }
 79: 
 80: /**
 81:  * Fly cards to a player's stat display in the player panel.
 82:  *
 83:  * @param flyCards - The flyCards function from useFlyingCards
 84:  * @param options - Animation options
 85:  * @returns true if animation was started, false if target not found or no cards
 86:  */
 87: export function flyToPlayerStat(
 88:   flyCards: (options: FlyCardOptions[], staggerMs?: number) => Promise<void>,
 89:   options: FlyToStatOptions
 90: ): boolean {
 91:   const {
 92:     cards,
 93:     playerPosition,
 94:     statName,
 95:     duration = 500,
 96:     stagger = 50,
 97:     cardSize = { width: 70, height: 100 },
 98:     flip = false,
 99:   } = options;
100: 
101:   if (cards.length === 0) return false;
102: 
103:   const targetEl = getPlayerStatElement(playerPosition, statName);
104:   if (!targetEl) {
105:     console.warn(
106:       `[usePlayerStatAnimation] Target element not found for player ${playerPosition}, stat "${statName}". ` +
107:       `Make sure the element has data-player-stat="${statName}" and data-player-position="${playerPosition}".`
108:     );
109:     return false;
110:   }
111: 
112:   flyCards(
113:     cards.map((card, i) => ({
114:       id: `fly-stat-${statName}-${playerPosition}-${Date.now()}-${i}`,
115:       startRect: card.rect,
116:       endRect: () => targetEl.getBoundingClientRect(),
117:       cardData: {
118:         rank: card.rank || '',
119:         suit: card.suit || '',
120:         faceUp: card.faceUp ?? true,
121:       },
122:       flip,
123:       duration,
124:       cardSize,
125:     })),
126:     stagger
127:   );
128: 
129:   return true;
130: }
131: 
132: /**
133:  * Composable that provides player stat animation utilities.
134:  */
135: export function usePlayerStatAnimation() {
136:   return {
137:     getPlayerStatElement,
138:     flyToPlayerStat,
139:   };
140: }
````

## File: packages/ui/src/types.ts
````typescript
  1: /**
  2:  * Shared types for @boardsmith/ui
  3:  *
  4:  * This file contains the canonical type definitions used throughout the UI package.
  5:  * All other type definitions should import from here to ensure consistency.
  6:  */
  7: 
  8: /**
  9:  * Player reference commonly found in element attributes.
 10:  */
 11: export interface PlayerRef {
 12:   position: number;
 13:   name: string;
 14: }
 15: 
 16: /**
 17:  * Common attributes that appear on game elements.
 18:  * This interface can be extended for game-specific attributes.
 19:  */
 20: export interface BaseElementAttributes {
 21:   /** Special type identifier (used by auto-ui for special handling) */
 22:   $type?: string;
 23:   /** Hex size for hex grid boards */
 24:   $hexSize?: number;
 25:   /** Hex orientation for hex grid boards */
 26:   $hexOrientation?: 'pointy' | 'flat';
 27:   /** Player owner of this element */
 28:   player?: PlayerRef;
 29:   /** Grid row coordinate */
 30:   row?: number;
 31:   /** Grid column coordinate */
 32:   col?: number;
 33:   /** Hex q coordinate (axial) */
 34:   q?: number;
 35:   /** Hex r coordinate (axial) */
 36:   r?: number;
 37:   /** Card rank (e.g., 'A', '2', 'K') */
 38:   rank?: string;
 39:   /** Card suit (e.g., 'hearts', 'spades') */
 40:   suit?: string;
 41: }
 42: 
 43: /**
 44:  * Core game element type representing a node in the game view tree.
 45:  *
 46:  * This is the serialized representation of game state elements as sent
 47:  * to the UI from the game engine.
 48:  */
 49: export interface GameElement<TAttributes extends BaseElementAttributes = BaseElementAttributes> {
 50:   /** Unique identifier for this element instance */
 51:   id: number;
 52:   /** Optional display name */
 53:   name?: string;
 54:   /** The class name (type) of this element */
 55:   className: string;
 56:   /** Element-specific attributes */
 57:   attributes?: TAttributes & Record<string, unknown>;
 58:   /** Child elements (visible to this player) */
 59:   children?: GameElement<TAttributes>[];
 60:   /** Count of children (used when contents are hidden) */
 61:   childCount?: number;
 62:   /** Internal flag indicating element should be hidden */
 63:   __hidden?: boolean;
 64: }
 65: 
 66: /**
 67:  * Options for matching/finding elements by various criteria.
 68:  */
 69: export interface ElementMatchOptions {
 70:   /** Match by element ID */
 71:   id?: number;
 72:   /** Match by $type attribute (most reliable, handles bundler mangling) */
 73:   type?: string;
 74:   /** Match by element name */
 75:   name?: string;
 76:   /** Match by className (may be mangled by bundlers) */
 77:   className?: string;
 78: }
 79: 
 80: /**
 81:  * Selection type for action parameters.
 82:  */
 83: export interface Selection {
 84:   name: string;
 85:   type: 'choice' | 'player' | 'element' | 'number' | 'text';
 86:   prompt?: string;
 87:   optional?: boolean;
 88:   choices?: Array<{ value: unknown; display: string }>;
 89:   min?: number;
 90:   max?: number;
 91:   integer?: boolean;
 92:   pattern?: string;
 93:   minLength?: number;
 94:   maxLength?: number;
 95:   elementClassName?: string;
 96: }
 97: 
 98: /**
 99:  * Metadata for an available action.
100:  */
101: export interface ActionMetadata {
102:   name: string;
103:   prompt?: string;
104:   selections: Selection[];
105: }
106: 
107: /**
108:  * Player information.
109:  */
110: export interface Player {
111:   position: number;
112:   name: string;
113: }
````

## File: packages/ui/package.json
````json
 1: {
 2:   "name": "@boardsmith/ui",
 3:   "version": "0.1.0",
 4:   "description": "Vue.js UI component library for BoardSmith games - includes GameShell, game state management, and reusable components like Draggable, DiceRoller, and CardFan",
 5:   "type": "module",
 6:   "main": "./src/index.ts",
 7:   "module": "./src/index.ts",
 8:   "types": "./src/index.ts",
 9:   "exports": {
10:     ".": {
11:       "types": "./src/index.ts",
12:       "import": "./src/index.ts"
13:     },
14:     "./auto-ui": {
15:       "types": "./src/components/auto-ui/index.ts",
16:       "import": "./src/components/auto-ui/index.ts"
17:     }
18:   },
19:   "files": [
20:     "dist",
21:     "src"
22:   ],
23:   "scripts": {
24:     "build": "vue-tsc && vite build",
25:     "dev": "vite build --watch"
26:   },
27:   "dependencies": {
28:     "@boardsmith/client": "workspace:*",
29:     "vue": "^3.4.0"
30:   },
31:   "devDependencies": {
32:     "@vitejs/plugin-vue": "^5.0.0",
33:     "typescript": "^5.3.0",
34:     "vite": "^5.0.0",
35:     "vite-plugin-dts": "^3.0.0",
36:     "vue-tsc": "^2.0.0"
37:   },
38:   "peerDependencies": {
39:     "vue": ">=3.0.0"
40:   }
41: }
````

## File: packages/cli/src/commands/dev.ts
````typescript
  1: import { existsSync, readFileSync, mkdirSync, rmSync, watch } from 'node:fs';
  2: import { join, resolve } from 'node:path';
  3: import { createServer as createViteServer } from 'vite';
  4: import { build } from 'esbuild';
  5: import { pathToFileURL } from 'node:url';
  6: import chalk from 'chalk';
  7: import open from 'open';
  8: 
  9: import { createLocalServer, type LocalServer, type GameDefinition } from '../local-server.js';
 10: 
 11: interface DevOptions {
 12:   port: string;
 13:   players: string;
 14:   workerPort: string;
 15:   ai?: string[];
 16:   aiLevel?: string;
 17: }
 18: 
 19: interface BoardSmithConfig {
 20:   name: string;
 21:   displayName?: string;
 22:   minPlayers?: number;
 23:   maxPlayers?: number;
 24:   playerCount?: { min: number; max: number };
 25:   rulesPackage?: string;
 26:   paths?: {
 27:     rules?: string;
 28:     ui?: string;
 29:   };
 30: }
 31: 
 32: async function createGame(workerPort: number, gameType: string, playerCount: number, playerNames: string[]): Promise<string | null> {
 33:   console.log(chalk.dim(`  Creating game (type: ${gameType}, players: ${playerCount})...`));
 34:   try {
 35:     const controller = new AbortController();
 36:     const timeout = setTimeout(() => controller.abort(), 5000);
 37: 
 38:     const response = await fetch(`http://localhost:${workerPort}/games`, {
 39:       method: 'POST',
 40:       headers: { 'Content-Type': 'application/json' },
 41:       body: JSON.stringify({
 42:         gameType,
 43:         playerCount,
 44:         playerNames,
 45:       }),
 46:       signal: controller.signal,
 47:     });
 48: 
 49:     clearTimeout(timeout);
 50: 
 51:     const data = await response.json() as { success: boolean; gameId?: string; error?: string };
 52:     if (data.success && data.gameId) {
 53:       return data.gameId;
 54:     }
 55:     if (data.error) {
 56:       console.error(chalk.red(`  Failed to create game: ${data.error}`));
 57:     } else {
 58:       console.error(chalk.red(`  Unexpected response: ${JSON.stringify(data)}`));
 59:     }
 60:   } catch (error) {
 61:     if (error instanceof Error && error.name === 'AbortError') {
 62:       console.error(chalk.red('  Game creation timed out'));
 63:     } else {
 64:       console.error(chalk.red('Failed to create game:'), error);
 65:     }
 66:   }
 67:   return null;
 68: }
 69: 
 70: /**
 71:  * Bundle and load the game rules dynamically
 72:  */
 73: async function loadGameDefinition(rulesPath: string, tempDir: string): Promise<GameDefinition> {
 74:   const rulesIndexPath = join(rulesPath, 'index.ts');
 75:   const bundlePath = join(tempDir, 'rules-bundle.mjs');
 76: 
 77:   // Bundle the rules with esbuild
 78:   // Bundle everything - no externals since the temp bundle won't have
 79:   // access to node_modules from the game project
 80:   await build({
 81:     entryPoints: [rulesIndexPath],
 82:     bundle: true,
 83:     format: 'esm',
 84:     platform: 'node',
 85:     outfile: bundlePath,
 86:     logLevel: 'silent',
 87:   });
 88: 
 89:   // Import the bundled module
 90:   const moduleUrl = pathToFileURL(bundlePath).href;
 91:   const module = await import(moduleUrl);
 92: 
 93:   if (!module.gameDefinition) {
 94:     throw new Error('Rules module must export a gameDefinition');
 95:   }
 96: 
 97:   return module.gameDefinition;
 98: }
 99: 
100: export async function devCommand(options: DevOptions): Promise<void> {
101:   const port = parseInt(options.port, 10);
102:   const playerCount = parseInt(options.players, 10);
103:   const workerPort = parseInt(options.workerPort, 10);
104:   const cwd = process.cwd();
105: 
106:   // Parse AI options
107:   const aiPlayers = options.ai
108:     ? options.ai.flatMap(s => s.split(',').map(n => parseInt(n.trim(), 10))).filter(n => !isNaN(n))
109:     : [];
110:   const aiLevel = options.aiLevel ?? 'medium';
111: 
112:   const configPath = join(cwd, 'boardsmith.json');
113:   if (!existsSync(configPath)) {
114:     console.error(chalk.red('Error: boardsmith.json not found'));
115:     console.error(chalk.dim('Make sure you are in a BoardSmith game project directory'));
116:     process.exit(1);
117:   }
118: 
119:   const config: BoardSmithConfig = JSON.parse(readFileSync(configPath, 'utf-8'));
120:   console.log(chalk.cyan(`\nStarting development server for ${config.displayName || config.name}...`));
121: 
122:   // Determine paths
123:   const uiPath = config.paths?.ui ? resolve(cwd, config.paths.ui) : cwd;
124:   const rulesPath = config.paths?.rules ? resolve(cwd, config.paths.rules) : join(cwd, 'src', 'rules');
125: 
126:   if (!existsSync(uiPath)) {
127:     console.error(chalk.red(`Error: UI path not found: ${uiPath}`));
128:     process.exit(1);
129:   }
130: 
131:   // Check for rules
132:   const rulesIndexPath = join(rulesPath, 'index.ts');
133:   if (!existsSync(rulesIndexPath)) {
134:     console.error(chalk.red(`Error: Rules not found at ${rulesIndexPath}`));
135:     console.error(chalk.dim('Make sure your game has a src/rules/index.ts that exports gameDefinition'));
136:     process.exit(1);
137:   }
138: 
139:   // Create temp directory
140:   const tempDir = join(cwd, '.boardsmith');
141:   if (!existsSync(tempDir)) {
142:     mkdirSync(tempDir, { recursive: true });
143:   }
144: 
145:   console.log(chalk.dim(`  Loading game rules from ${rulesPath}...`));
146: 
147:   // Load the game definition
148:   let gameDefinition: GameDefinition;
149:   try {
150:     gameDefinition = await loadGameDefinition(rulesPath, tempDir);
151: 
152:     // Apply fallback config from boardsmith.json if needed
153:     const minPlayers = gameDefinition.minPlayers ?? config.playerCount?.min ?? config.minPlayers ?? 2;
154:     const maxPlayers = gameDefinition.maxPlayers ?? config.playerCount?.max ?? config.maxPlayers ?? 4;
155: 
156:     gameDefinition = {
157:       ...gameDefinition,
158:       minPlayers,
159:       maxPlayers,
160:     };
161: 
162:     console.log(chalk.dim(`  Loaded game: ${gameDefinition.displayName || gameDefinition.gameType}`));
163:   } catch (error) {
164:     console.error(chalk.red('Failed to load game rules:'), error);
165:     process.exit(1);
166:   }
167: 
168:   // Start the local game server
169:   let server: LocalServer | null = null;
170: 
171:   console.log(chalk.dim(`  Starting game server on port ${workerPort}...`));
172: 
173:   try {
174:     server = createLocalServer({
175:       port: workerPort,
176:       definitions: [gameDefinition],
177:       onReady: (p) => {
178:         console.log(chalk.green(`  Game server ready on http://localhost:${p}`));
179:       },
180:       aiConfig: aiPlayers.length > 0 ? { players: aiPlayers, level: aiLevel } : undefined,
181:     });
182: 
183:     // Wait for server to be ready before continuing
184:     await server.ready;
185: 
186:     if (aiPlayers.length > 0) {
187:       console.log(chalk.cyan(`  AI players enabled: ${aiPlayers.join(', ')} (level: ${aiLevel})`));
188:     }
189:   } catch (error) {
190:     console.error(chalk.red('Failed to start game server:'), error);
191:     process.exit(1);
192:   }
193: 
194:   // Start Vite dev server for UI
195:   try {
196:     const vite = await createViteServer({
197:       root: uiPath,
198:       server: {
199:         port,
200:         open: false,
201:       },
202:     });
203: 
204:     await vite.listen();
205:     console.log(chalk.green(`  UI server running on http://localhost:${port}`));
206: 
207:     // Create a game with appropriate names for AI and human players
208:     const playerNames = Array.from({ length: playerCount }, (_, i) =>
209:       aiPlayers.includes(i) ? 'Bot' : `Player ${i + 1}`
210:     );
211:     const gameId = await createGame(workerPort, gameDefinition.gameType, playerCount, playerNames);
212: 
213:     if (gameId) {
214:       console.log(chalk.cyan(`\n  Game created: ${gameId}`));
215: 
216:       // Only open browser tabs for human players
217:       const humanPlayers = Array.from({ length: playerCount }, (_, i) => i)
218:         .filter(i => !aiPlayers.includes(i));
219: 
220:       if (humanPlayers.length > 0) {
221:         console.log(chalk.cyan(`  Opening ${humanPlayers.length} player tab(s)...`));
222:         for (const i of humanPlayers) {
223:           const url = `http://localhost:${port}/game/${gameId}/${i}`;
224:           await open(url);
225:           console.log(chalk.dim(`  Player ${i + 1}: ${url}`));
226:         }
227:       }
228: 
229:       // Log AI player info
230:       for (const i of aiPlayers) {
231:         if (i < playerCount) {
232:           console.log(chalk.dim(`  Player ${i + 1}: AI (${aiLevel})`));
233:         }
234:       }
235:     } else {
236:       console.log(chalk.yellow('\n  Could not auto-create game. Open the UI manually.'));
237:       await open(`http://localhost:${port}`);
238:     }
239: 
240:     console.log(chalk.green('\n  Ready! Press Ctrl+C to stop.\n'));
241: 
242:     // Watch for rules changes and hot reload
243:     let reloadDebounce: NodeJS.Timeout | null = null;
244:     const watcher = watch(rulesPath, { recursive: true }, async (eventType, filename) => {
245:       if (!filename || !filename.endsWith('.ts')) return;
246: 
247:       // Debounce to avoid multiple reloads for rapid changes
248:       if (reloadDebounce) clearTimeout(reloadDebounce);
249: 
250:       reloadDebounce = setTimeout(async () => {
251:         console.log(chalk.yellow(`\n  Rules changed: ${filename}`));
252:         console.log(chalk.dim('  Reloading game rules...'));
253: 
254:         try {
255:           // Reload the game definition
256:           const newGameDefinition = await loadGameDefinition(rulesPath, tempDir);
257:           const minPlayers = newGameDefinition.minPlayers ?? config.playerCount?.min ?? config.minPlayers ?? 2;
258:           const maxPlayers = newGameDefinition.maxPlayers ?? config.playerCount?.max ?? config.maxPlayers ?? 4;
259: 
260:           const updatedDefinition = {
261:             ...newGameDefinition,
262:             minPlayers,
263:             maxPlayers,
264:           };
265: 
266:           // Update the server with new rules
267:           if (server) {
268:             server.updateDefinition(updatedDefinition);
269:             console.log(chalk.green('  Rules reloaded successfully!'));
270:           }
271:         } catch (error) {
272:           console.error(chalk.red('  Failed to reload rules:'), error);
273:         }
274:       }, 100);
275:     });
276: 
277:     // Cleanup on exit
278:     const cleanup = async () => {
279:       console.log(chalk.dim('\n  Shutting down...'));
280:       watcher.close();
281:       await vite.close();
282:       if (server) {
283:         await server.close();
284:       }
285:       // Clean up temp files
286:       try {
287:         rmSync(tempDir, { recursive: true, force: true });
288:       } catch {
289:         // Ignore cleanup errors
290:       }
291:       process.exit(0);
292:     };
293: 
294:     process.on('SIGINT', cleanup);
295:     process.on('SIGTERM', cleanup);
296: 
297:   } catch (error) {
298:     console.error(chalk.red('Failed to start Vite dev server:'), error);
299:     if (server) {
300:       await server.close();
301:     }
302:     process.exit(1);
303:   }
304: }
````

## File: packages/cli/src/commands/init.ts
````typescript
  1: import { mkdir, writeFile, readdir, copyFile } from 'node:fs/promises';
  2: import { existsSync } from 'node:fs';
  3: import { join, dirname } from 'node:path';
  4: import { fileURLToPath } from 'node:url';
  5: import chalk from 'chalk';
  6: import ora from 'ora';
  7: 
  8: const __dirname = dirname(fileURLToPath(import.meta.url));
  9: 
 10: // Detect if running from local dev (npm link) by checking if we're in the monorepo
 11: function getMonorepoRoot(): string | null {
 12:   // __dirname is like /path/to/BoardSmith/packages/cli/dist/commands
 13:   // Go up: commands -> dist -> cli -> packages -> BoardSmith
 14:   const potentialRoot = join(__dirname, '..', '..', '..', '..');
 15:   const enginePath = join(potentialRoot, 'packages', 'engine', 'package.json');
 16:   const uiPath = join(potentialRoot, 'packages', 'ui', 'package.json');
 17: 
 18:   if (existsSync(enginePath) && existsSync(uiPath)) {
 19:     return potentialRoot;
 20:   }
 21:   return null;
 22: }
 23: 
 24: interface InitOptions {
 25:   template: string;
 26: }
 27: 
 28: export async function initCommand(name: string, options: InitOptions): Promise<void> {
 29:   const projectPath = join(process.cwd(), name);
 30: 
 31:   if (existsSync(projectPath)) {
 32:     console.error(chalk.red(`Error: Directory "${name}" already exists`));
 33:     process.exit(1);
 34:   }
 35: 
 36:   const spinner = ora(`Creating ${name}...`).start();
 37: 
 38:   try {
 39:     await mkdir(projectPath);
 40:     await mkdir(join(projectPath, 'src'));
 41:     await mkdir(join(projectPath, 'src', 'rules'));
 42:     await mkdir(join(projectPath, 'src', 'ui'));
 43:     await mkdir(join(projectPath, 'src', 'ui', 'components'));
 44:     await mkdir(join(projectPath, 'src', 'ui', 'assets'));
 45:     await mkdir(join(projectPath, 'tests'));
 46:     await mkdir(join(projectPath, 'public'));
 47: 
 48:     const config = {
 49:       '$schema': 'https://boardsmith.io/schemas/game.json',
 50:       name: name,
 51:       displayName: toDisplayName(name),
 52:       description: 'A fun game for 2-4 players',
 53:       playerCount: { min: 2, max: 4 },
 54:       estimatedDuration: '15-30 minutes',
 55:       complexity: 2,
 56:       categories: ['card-game'],
 57:       thumbnail: './public/thumbnail.png',
 58:       scoreboard: { stats: ['score'] },
 59:     };
 60:     await writeFile(join(projectPath, 'boardsmith.json'), JSON.stringify(config, null, 2));
 61: 
 62:     // Check if we're running from local dev environment
 63:     const monorepoRoot = getMonorepoRoot();
 64:     const isLocalDev = monorepoRoot !== null;
 65: 
 66:     const engineDep = isLocalDev
 67:       ? `file:${join(monorepoRoot!, 'packages', 'engine')}`
 68:       : '^0.0.1';
 69:     const uiDep = isLocalDev
 70:       ? `file:${join(monorepoRoot!, 'packages', 'ui')}`
 71:       : '^0.0.1';
 72:     const cliDep = isLocalDev
 73:       ? `file:${join(monorepoRoot!, 'packages', 'cli')}`
 74:       : '^0.0.1';
 75: 
 76:     if (isLocalDev) {
 77:       console.log(chalk.dim(`  Using local packages from ${monorepoRoot}`));
 78:     }
 79: 
 80:     const packageJson = {
 81:       name: `@mygames/${name}`,
 82:       version: '0.0.1',
 83:       type: 'module',
 84:       scripts: {
 85:         dev: 'boardsmith dev',
 86:         build: 'boardsmith build',
 87:         test: 'vitest',
 88:         validate: 'boardsmith validate',
 89:       },
 90:       dependencies: {
 91:         '@boardsmith/engine': engineDep,
 92:         '@boardsmith/ui': uiDep,
 93:         vue: '^3.4.0',
 94:       },
 95:       devDependencies: {
 96:         '@boardsmith/cli': cliDep,
 97:         typescript: '^5.7.0',
 98:         vitest: '^2.0.0',
 99:         '@vitejs/plugin-vue': '^5.0.0',
100:       },
101:     };
102:     await writeFile(join(projectPath, 'package.json'), JSON.stringify(packageJson, null, 2));
103: 
104:     const tsconfig = {
105:       compilerOptions: {
106:         target: 'ES2022',
107:         module: 'ESNext',
108:         moduleResolution: 'bundler',
109:         lib: ['ES2022', 'DOM', 'DOM.Iterable'],
110:         strict: true,
111:         esModuleInterop: true,
112:         skipLibCheck: true,
113:         forceConsistentCasingInFileNames: true,
114:         resolveJsonModule: true,
115:         jsx: 'preserve',
116:         declaration: true,
117:         declarationMap: true,
118:         sourceMap: true,
119:         outDir: './dist',
120:         rootDir: './src',
121:       },
122:       include: ['src/**/*'],
123:       exclude: ['node_modules', 'dist'],
124:     };
125:     await writeFile(join(projectPath, 'tsconfig.json'), JSON.stringify(tsconfig, null, 2));
126: 
127:     await writeFile(join(projectPath, 'src', 'rules', 'game.ts'), generateGameTs(name));
128:     await writeFile(join(projectPath, 'src', 'rules', 'elements.ts'), generateElementsTs());
129:     await writeFile(join(projectPath, 'src', 'rules', 'actions.ts'), generateActionsTs(name));
130:     await writeFile(join(projectPath, 'src', 'rules', 'flow.ts'), generateFlowTs(name));
131:     await writeFile(join(projectPath, 'src', 'rules', 'index.ts'), generateRulesIndexTs(name));
132:     await writeFile(join(projectPath, 'src', 'ui', 'App.vue'), generateAppVue(name));
133:     await writeFile(join(projectPath, 'src', 'ui', 'components', 'GameBoard.vue'), generateGameBoardVue());
134:     await writeFile(join(projectPath, 'src', 'ui', 'index.ts'), generateUiIndexTs());
135:     await writeFile(join(projectPath, 'tests', 'game.test.ts'), generateTestTs(name));
136:     await writeFile(join(projectPath, '.gitignore'), 'node_modules/\ndist/\n.DS_Store\n*.log\n');
137:     await writeFile(join(projectPath, 'vite.config.ts'), generateViteConfig());
138:     await writeFile(join(projectPath, 'index.html'), generateIndexHtml(name));
139:     await writeFile(join(projectPath, 'src', 'main.ts'), generateMainTs());
140: 
141:     spinner.succeed(chalk.green(`Created ${name} successfully!`));
142:     console.log(`
143: ${chalk.cyan('Next steps:')}
144: 
145:   cd ${name}
146:   npm install
147:   boardsmith dev
148: 
149: ${chalk.dim('This will start the development server and open player tabs in your browser.')}
150: `);
151:   } catch (error) {
152:     spinner.fail(chalk.red('Failed to create project'));
153:     console.error(error);
154:     process.exit(1);
155:   }
156: }
157: 
158: function toPascalCase(str: string): string {
159:   return str.split(/[-_]/).map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
160: }
161: 
162: function toDisplayName(str: string): string {
163:   return str.split(/[-_]/).map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
164: }
165: 
166: function generateGameTs(name: string): string {
167:   const pascal = toPascalCase(name);
168:   return `import { Game, Player, type GameOptions } from '@boardsmith/engine';
169: import { Card, Hand, Deck } from './elements.js';
170: import { createGameFlow } from './flow.js';
171: import { createDrawAction, createPlayAction } from './actions.js';
172: 
173: export interface ${pascal}Options extends GameOptions {
174:   seed?: string;
175: }
176: 
177: export class ${pascal}Game extends Game<${pascal}Game, ${pascal}Player> {
178:   deck!: Deck;
179: 
180:   constructor(options: ${pascal}Options) {
181:     super(options);
182: 
183:     // Register element classes
184:     this.registerElements([Card, Hand, Deck]);
185: 
186:     // Create deck
187:     this.deck = this.create(Deck, 'deck');
188:     this.deck.setOrder('stacking');
189: 
190:     // Create standard 52-card deck
191:     const suits = ['H', 'D', 'C', 'S'] as const;
192:     const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] as const;
193:     for (const suit of suits) {
194:       for (const rank of ranks) {
195:         this.deck.create(Card, \`\${rank}\${suit}\`, { suit, rank });
196:       }
197:     }
198: 
199:     // Shuffle and deal
200:     this.deck.shuffle();
201:     for (const player of this.players) {
202:       for (let i = 0; i < 5; i++) {
203:         const card = this.deck.first(Card);
204:         if (card) {
205:           const hand = this.getPlayerHand(player);
206:           card.putInto(hand);
207:         }
208:       }
209:     }
210: 
211:     // Register actions
212:     this.registerAction(createDrawAction(this));
213:     this.registerAction(createPlayAction(this));
214: 
215:     // Set up game flow
216:     this.setFlow(createGameFlow(this));
217:   }
218: 
219:   protected override createPlayer(position: number, name: string): ${pascal}Player {
220:     return new ${pascal}Player(position, name, this);
221:   }
222: 
223:   getPlayerHand(player: ${pascal}Player): Hand {
224:     return this.first(Hand, \`hand-\${player.position}\`)!;
225:   }
226: 
227:   override isFinished(): boolean {
228:     return this.deck.count(Card) === 0;
229:   }
230: 
231:   override getWinners(): ${pascal}Player[] {
232:     if (!this.isFinished()) return [];
233:     let winner = this.players[0];
234:     for (const player of this.players) {
235:       if (player.score > winner.score) {
236:         winner = player;
237:       }
238:     }
239:     return [winner];
240:   }
241: }
242: 
243: export class ${pascal}Player extends Player<${pascal}Game, ${pascal}Player> {
244:   hand!: Hand;
245:   score: number = 0;
246: 
247:   constructor(position: number, name: string, game: ${pascal}Game) {
248:     super(position, name);
249:     this.game = game;
250:     // Create player's hand
251:     this.hand = game.create(Hand, \`hand-\${position}\`);
252:     this.hand.player = this;
253:     this.hand.contentsVisibleToOwner();
254:   }
255: }
256: `;
257: }
258: 
259: function generateElementsTs(): string {
260:   return `import { Card as BaseCard, Hand as BaseHand, Deck as BaseDeck, Space } from '@boardsmith/engine';
261: 
262: export type Suit = 'H' | 'D' | 'C' | 'S';
263: export type Rank = 'A' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | 'J' | 'Q' | 'K';
264: 
265: export class Card extends BaseCard {
266:   suit!: Suit;
267:   rank!: Rank;
268: }
269: 
270: export class Hand extends BaseHand {
271: }
272: 
273: export class Deck extends BaseDeck {
274: }
275: 
276: export class PlayArea extends Space {
277: }
278: `;
279: }
280: 
281: function generateActionsTs(name: string): string {
282:   const pascal = toPascalCase(name);
283:   return `import { Action, type ActionDefinition } from '@boardsmith/engine';
284: import type { ${pascal}Game, ${pascal}Player } from './game.js';
285: import { Card } from './elements.js';
286: 
287: export function createDrawAction(game: ${pascal}Game): ActionDefinition {
288:   return Action.create('draw')
289:     .prompt('Draw a card from the deck')
290:     .execute((args, ctx) => {
291:       const player = ctx.player as ${pascal}Player;
292:       const card = game.deck.first(Card);
293:       if (card) {
294:         card.putInto(player.hand);
295:         return { success: true, message: 'Drew a card' };
296:       }
297:       return { success: false, message: 'No cards left in deck' };
298:     });
299: }
300: 
301: export function createPlayAction(game: ${pascal}Game): ActionDefinition {
302:   return Action.create('play')
303:     .prompt('Play a card from your hand')
304:     .chooseFrom<Card>('card', {
305:       prompt: 'Select a card to play',
306:       choices: (ctx) => {
307:         const player = ctx.player as ${pascal}Player;
308:         return [...player.hand.all(Card)];
309:       },
310:     })
311:     .execute((args, ctx) => {
312:       const player = ctx.player as ${pascal}Player;
313:       const card = args.card as Card;
314:       card.remove();
315:       player.score += 1;
316:       return { success: true, message: 'Played a card' };
317:     });
318: }
319: `;
320: }
321: 
322: function generateFlowTs(name: string): string {
323:   const pascal = toPascalCase(name);
324:   return `import {
325:   loop,
326:   eachPlayer,
327:   actionStep,
328:   sequence,
329:   type FlowDefinition,
330: } from '@boardsmith/engine';
331: import type { ${pascal}Game, ${pascal}Player } from './game.js';
332: import { Card } from './elements.js';
333: 
334: export function createGameFlow(game: ${pascal}Game): FlowDefinition {
335:   // Player turn: draw a card, then play a card
336:   const playerTurn = sequence(
337:     actionStep({
338:       name: 'draw-step',
339:       actions: ['draw'],
340:       prompt: 'Draw a card from the deck',
341:       skipIf: () => game.deck.count(Card) === 0,
342:     }),
343:     actionStep({
344:       name: 'play-step',
345:       actions: ['play'],
346:       prompt: 'Play a card from your hand',
347:       skipIf: (ctx) => {
348:         const player = ctx.player as ${pascal}Player;
349:         return player.hand.count(Card) === 0;
350:       },
351:     }),
352:   );
353: 
354:   return {
355:     root: loop({
356:       name: 'game-loop',
357:       while: () => game.deck.count(Card) > 0,
358:       maxIterations: 100,
359:       do: eachPlayer({
360:         name: 'player-turns',
361:         do: playerTurn,
362:       }),
363:     }),
364:     isComplete: () => game.deck.count(Card) === 0,
365:     getWinners: () => game.getWinners(),
366:   };
367: }
368: `;
369: }
370: 
371: function generateRulesIndexTs(name: string): string {
372:   const pascal = toPascalCase(name);
373:   const display = toDisplayName(name);
374:   return `export { ${pascal}Game, ${pascal}Player } from './game.js';
375: export { Card, Hand, Deck, PlayArea } from './elements.js';
376: export { createDrawAction, createPlayAction } from './actions.js';
377: export { createGameFlow } from './flow.js';
378: 
379: import { ${pascal}Game } from './game.js';
380: 
381: export const gameDefinition = {
382:   gameClass: ${pascal}Game,
383:   gameType: '${name}',
384:   displayName: '${display}',
385:   minPlayers: 2,
386:   maxPlayers: 4,
387: } as const;
388: `;
389: }
390: 
391: function generateAppVue(name: string): string {
392:   const display = toDisplayName(name);
393:   return `<script setup lang="ts">
394: import { GameShell, AutoUI } from '@boardsmith/ui';
395: import GameBoard from './components/GameBoard.vue';
396: <\/script>
397: 
398: <template>
399:   <GameShell
400:     game-type="${name}"
401:     display-name="${display}"
402:     :player-count="2"
403:   >
404:     <template #game-board="{ state, gameView, playerPosition, isMyTurn, availableActions, action, actionArgs, executeAction, setBoardPrompt }">
405:       <div class="board-comparison">
406:         <div class="board-section">
407:           <h2 class="board-title">Custom UI</h2>
408:           <GameBoard
409:             :game-view="gameView"
410:             :player-position="playerPosition"
411:             :is-my-turn="isMyTurn"
412:             :available-actions="availableActions"
413:             :action="action"
414:             :action-args="actionArgs"
415:             :execute-action="executeAction"
416:             :set-board-prompt="setBoardPrompt"
417:           />
418:         </div>
419:         <div class="board-section">
420:           <h2 class="board-title">Auto-Generated UI</h2>
421:           <AutoUI
422:             :game-view="gameView || null"
423:             :player-position="playerPosition"
424:             :flow-state="state?.flowState as any"
425:           />
426:         </div>
427:       </div>
428:     </template>
429: 
430:     <template #player-stats="{ player, gameView }">
431:       <div class="player-stat">
432:         <span class="stat-label">Cards:</span>
433:         <span class="stat-value">
434:           {{
435:             gameView?.children?.find((c: any) =>
436:               c.attributes?.$type === 'hand' && c.attributes?.player?.position === player.position
437:             )?.children?.length || 0
438:           }}
439:         </span>
440:       </div>
441:       <div class="player-stat">
442:         <span class="stat-label">Score:</span>
443:         <span class="stat-value">{{ (player as any).score || 0 }}</span>
444:       </div>
445:     </template>
446:   </GameShell>
447: </template>
448: 
449: <style scoped>
450: .board-comparison {
451:   display: grid;
452:   grid-template-columns: 1fr 1fr;
453:   gap: 20px;
454:   width: 100%;
455:   height: 100%;
456: }
457: 
458: .board-section {
459:   display: flex;
460:   flex-direction: column;
461:   min-height: 0;
462: }
463: 
464: .board-title {
465:   font-size: 1.2rem;
466:   margin: 0 0 12px 0;
467:   padding: 8px 12px;
468:   background: rgba(255, 255, 255, 0.05);
469:   border-radius: 8px;
470:   text-align: center;
471: }
472: 
473: .player-stat {
474:   display: flex;
475:   justify-content: space-between;
476:   font-size: 0.85rem;
477:   margin-top: 8px;
478: }
479: 
480: .stat-label {
481:   color: #888;
482: }
483: 
484: .stat-value {
485:   font-weight: bold;
486:   color: #00d9ff;
487: }
488: </style>
489: `;
490: }
491: 
492: function generateGameBoardVue(): string {
493:   return `<script setup lang="ts">
494: import { computed } from 'vue';
495: 
496: interface Card {
497:   id: string;
498:   name: string;
499:   attributes?: {
500:     rank?: string;
501:     suit?: string;
502:   };
503: }
504: 
505: const props = defineProps<{
506:   gameView: any;
507:   playerPosition: number;
508:   isMyTurn: boolean;
509:   availableActions: string[];
510:   action: (name: string, args: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>;
511:   actionArgs: Record<string, unknown>;
512:   executeAction: (name: string) => Promise<void>;
513:   setBoardPrompt: (prompt: string | null) => void;
514: }>();
515: 
516: // Computed properties to extract data from gameView
517: const myHand = computed<Card[]>(() => {
518:   if (!props.gameView) return [];
519:   const handElement = props.gameView.children?.find(
520:     (c: any) => c.attributes?.$type === 'hand' && c.attributes?.player?.position === props.playerPosition
521:   );
522:   return handElement?.children?.filter((c: any) => c.attributes?.rank) || [];
523: });
524: 
525: const deckCount = computed(() => {
526:   if (!props.gameView) return 0;
527:   const deck = props.gameView.children?.find((c: any) => c.attributes?.$type === 'deck');
528:   return deck?.children?.length || deck?.childCount || 0;
529: });
530: 
531: // Helpers
532: function getSuitSymbol(suit: string): string {
533:   const symbols: Record<string, string> = {
534:     'H': '\\u2665', 'D': '\\u2666', 'C': '\\u2663', 'S': '\\u2660',
535:     'hearts': '\\u2665', 'diamonds': '\\u2666', 'clubs': '\\u2663', 'spades': '\\u2660',
536:   };
537:   return symbols[suit] || suit;
538: }
539: 
540: function getSuitColor(suit: string): string {
541:   return suit === 'H' || suit === 'D' || suit === 'hearts' || suit === 'diamonds' ? '#e74c3c' : '#2c3e50';
542: }
543: 
544: // Actions
545: async function drawCard() {
546:   if (!props.isMyTurn || !props.availableActions.includes('draw')) return;
547:   await props.action('draw', {});
548: }
549: 
550: async function playCard(card: Card) {
551:   if (!props.isMyTurn || !props.availableActions.includes('play')) return;
552:   await props.action('play', { card: card.id });
553: }
554: <\/script>
555: 
556: <template>
557:   <div class="game-board">
558:     <!-- Deck Area -->
559:     <div class="deck-area">
560:       <div
561:         class="deck"
562:         :class="{ clickable: isMyTurn && availableActions.includes('draw') }"
563:         @click="drawCard"
564:       >
565:         <span v-if="deckCount > 0">{{ deckCount }} cards</span>
566:         <span v-else>Empty</span>
567:       </div>
568:       <div class="deck-label">Deck</div>
569:     </div>
570: 
571:     <!-- My Hand -->
572:     <div class="hand-area">
573:       <div class="area-header">
574:         <span class="area-title">Your Hand</span>
575:         <span class="card-count">{{ myHand.length }} cards</span>
576:       </div>
577:       <div class="cards">
578:         <div
579:           v-for="card in myHand"
580:           :key="card.id"
581:           class="card"
582:           :class="{ clickable: isMyTurn && availableActions.includes('play') }"
583:           :style="{ color: getSuitColor(card.attributes?.suit || '') }"
584:           @click="playCard(card)"
585:         >
586:           <span class="rank">{{ card.attributes?.rank }}</span>
587:           <span class="suit">{{ getSuitSymbol(card.attributes?.suit || '') }}</span>
588:         </div>
589:         <div v-if="myHand.length === 0" class="no-cards">No cards in hand</div>
590:       </div>
591:     </div>
592: 
593:     <!-- Turn indicator -->
594:     <div v-if="isMyTurn" class="turn-indicator">
595:       Your Turn
596:     </div>
597:   </div>
598: </template>
599: 
600: <style scoped>
601: .game-board {
602:   display: flex;
603:   flex-direction: column;
604:   align-items: center;
605:   gap: 30px;
606:   padding: 20px;
607: }
608: 
609: .deck-area {
610:   display: flex;
611:   flex-direction: column;
612:   align-items: center;
613:   gap: 8px;
614: }
615: 
616: .deck {
617:   width: 100px;
618:   height: 140px;
619:   background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
620:   border-radius: 8px;
621:   display: flex;
622:   align-items: center;
623:   justify-content: center;
624:   color: white;
625:   font-weight: bold;
626:   box-shadow: 0 4px 6px rgba(0,0,0,0.3);
627:   transition: transform 0.2s;
628: }
629: 
630: .deck.clickable {
631:   cursor: pointer;
632: }
633: 
634: .deck.clickable:hover {
635:   transform: translateY(-4px);
636: }
637: 
638: .deck-label {
639:   color: #888;
640:   font-size: 0.9rem;
641: }
642: 
643: .hand-area {
644:   background: rgba(255, 255, 255, 0.05);
645:   padding: 20px;
646:   border-radius: 12px;
647:   width: 100%;
648:   max-width: 600px;
649: }
650: 
651: .area-header {
652:   display: flex;
653:   gap: 20px;
654:   margin-bottom: 15px;
655:   align-items: center;
656: }
657: 
658: .area-title {
659:   font-weight: bold;
660:   font-size: 1.1rem;
661: }
662: 
663: .card-count {
664:   font-size: 0.9rem;
665:   color: #aaa;
666: }
667: 
668: .cards {
669:   display: flex;
670:   flex-wrap: wrap;
671:   gap: 8px;
672:   justify-content: center;
673: }
674: 
675: .no-cards {
676:   color: #666;
677:   font-style: italic;
678: }
679: 
680: .card {
681:   width: 60px;
682:   height: 84px;
683:   background: #fff;
684:   border-radius: 8px;
685:   display: flex;
686:   flex-direction: column;
687:   align-items: center;
688:   justify-content: center;
689:   font-weight: bold;
690:   transition: all 0.2s;
691:   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
692: }
693: 
694: .card.clickable {
695:   cursor: pointer;
696: }
697: 
698: .card.clickable:hover {
699:   transform: translateY(-8px);
700:   box-shadow: 0 8px 20px rgba(0, 217, 255, 0.4);
701: }
702: 
703: .card .rank {
704:   font-size: 1.5rem;
705: }
706: 
707: .card .suit {
708:   font-size: 1.8rem;
709: }
710: 
711: .turn-indicator {
712:   background: linear-gradient(90deg, #00d9ff, #00ff88);
713:   color: #1a1a2e;
714:   padding: 8px 24px;
715:   border-radius: 20px;
716:   font-weight: bold;
717: }
718: </style>
719: `;
720: }
721: 
722: function generateUiIndexTs(): string {
723:   return `import App from './App.vue';
724: export { App };
725: export { default as GameBoard } from './components/GameBoard.vue';
726: `;
727: }
728: 
729: function generateTestTs(name: string): string {
730:   const pascal = toPascalCase(name);
731:   return `import { describe, it, expect } from 'vitest';
732: import { ${pascal}Game } from '../src/rules/game.js';
733: 
734: describe('${pascal}Game', () => {
735:   it('should create a game with correct number of cards', () => {
736:     const game = new ${pascal}Game({ playerCount: 2, seed: 'test' });
737:     game.setup();
738:     expect(game.deck.all().length).toBe(52);
739:   });
740: 
741:   it('should deal 5 cards to each player', () => {
742:     const game = new ${pascal}Game({ playerCount: 2, seed: 'test' });
743:     game.setup();
744:     game.start();
745:     for (const player of game.players) {
746:       expect(player.hand.all().length).toBe(5);
747:     }
748:   });
749: });
750: `;
751: }
752: 
753: function generateViteConfig(): string {
754:   return `import { defineConfig } from 'vite';
755: import vue from '@vitejs/plugin-vue';
756: 
757: export default defineConfig({
758:   plugins: [vue()],
759: });
760: `;
761: }
762: 
763: function generateIndexHtml(name: string): string {
764:   const display = toDisplayName(name);
765:   return `<!DOCTYPE html>
766: <html lang="en">
767:   <head>
768:     <meta charset="UTF-8" />
769:     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
770:     <title>${display}</title>
771:     <style>
772:       * { margin: 0; padding: 0; box-sizing: border-box; }
773:       html, body { height: 100%; }
774:     </style>
775:   </head>
776:   <body>
777:     <div id="app"></div>
778:     <script type="module" src="/src/main.ts"><\/script>
779:   </body>
780: </html>
781: `;
782: }
783: 
784: function generateMainTs(): string {
785:   return `import { createApp } from 'vue';
786: import { App } from './ui/index.js';
787: 
788: const app = createApp(App);
789: app.mount('#app');
790: `;
791: }
````

## File: packages/cli/package.json
````json
 1: {
 2:   "name": "@boardsmith/cli",
 3:   "version": "0.0.1",
 4:   "description": "Command-line tools for BoardSmith game development - provides boardsmith init, dev, build, test, and validate commands with an embedded local development server",
 5:   "type": "module",
 6:   "bin": {
 7:     "boardsmith": "./dist/cli.js"
 8:   },
 9:   "scripts": {
10:     "build": "tsc",
11:     "dev": "tsc --watch",
12:     "prepublishOnly": "npm run build"
13:   },
14:   "dependencies": {
15:     "@boardsmith/ai": "workspace:*",
16:     "@boardsmith/engine": "workspace:*",
17:     "@boardsmith/server": "workspace:*",
18:     "@boardsmith/session": "workspace:*",
19:     "@boardsmith/runtime": "workspace:*",
20:     "commander": "^12.0.0",
21:     "chalk": "^5.3.0",
22:     "ora": "^8.0.0",
23:     "prompts": "^2.4.2",
24:     "open": "^10.0.0",
25:     "vite": "^5.4.0",
26:     "express": "^4.18.0",
27:     "ws": "^8.16.0",
28:     "chokidar": "^3.6.0",
29:     "esbuild": "^0.24.0"
30:   },
31:   "devDependencies": {
32:     "@types/node": "^22.0.0",
33:     "@types/prompts": "^2.4.9",
34:     "@types/express": "^4.17.21",
35:     "@types/ws": "^8.5.10",
36:     "typescript": "^5.7.0"
37:   },
38:   "files": [
39:     "dist",
40:     "templates"
41:   ]
42: }
````

## File: packages/engine/src/element/deck.ts
````typescript
 1: import { Space } from './space.js';
 2: import type { ElementContext } from './types.js';
 3: import type { Player } from '../player/player.js';
 4: import type { Game } from './game.js';
 5: 
 6: /**
 7:  * Deck - A stack of cards, typically face-down
 8:  *
 9:  * Decks are spaces that:
10:  * - Contain cards in a stacked order
11:  * - Usually have hidden contents (draw pile)
12:  * - Support shuffling
13:  * - Use "stacking" order (new cards go on top)
14:  *
15:  * Examples: draw pile, discard pile, stock pile
16:  *
17:  * Usage:
18:  * ```ts
19:  * const deck = game.create(Deck, 'draw-pile');
20:  * deck.setOrder('stacking'); // Cards stack on top
21:  * deck.contentsHidden(); // No one sees the cards
22:  * deck.shuffle(); // Randomize order
23:  * ```
24:  */
25: export class Deck<G extends Game = any, P extends Player = any> extends Space<G, P> {
26:   /**
27:    * System property to identify this element type for AutoUI
28:    * $ prefix indicates this is a system property
29:    */
30:   $type!: 'deck';
31: 
32:   constructor(ctx: Partial<ElementContext>) {
33:     super(ctx);
34:     // Explicitly set as instance property for serialization
35:     this.$type = 'deck';
36: 
37:     // Decks default to stacking order (new items go on top)
38:     this.setOrder('stacking');
39: 
40:     // Default layout: stacked with heavy overlap (deck appearance)
41:     this.$direction = 'vertical';
42:     this.$overlap = 0.95;
43:     this.$align = 'center';
44:   }
45: }
````

## File: packages/engine/src/element/hand.ts
````typescript
 1: import { Space } from './space.js';
 2: import type { ElementContext } from './types.js';
 3: import type { Player } from '../player/player.js';
 4: import type { Game } from './game.js';
 5: 
 6: /**
 7:  * Hand - A collection of cards held by a player
 8:  *
 9:  * Hands are spaces that:
10:  * - Are owned by a specific player
11:  * - Typically contain cards
12:  * - Have visibility rules (usually visible only to owner)
13:  * - Often displayed in a fan or row
14:  *
15:  * Examples: player's hand in card games, tiles in tile-based games
16:  *
17:  * Usage:
18:  * ```ts
19:  * const hand = game.create(Hand, `hand-${player.position}`);
20:  * hand.player = player;
21:  * hand.contentsVisibleToOwner(); // Only owner sees cards
22:  * ```
23:  */
24: export class Hand<G extends Game = any, P extends Player = any> extends Space<G, P> {
25:   /**
26:    * System property to identify this element type for AutoUI
27:    * $ prefix indicates this is a system property
28:    */
29:   $type!: 'hand';
30: 
31:   constructor(ctx: Partial<ElementContext>) {
32:     super(ctx);
33:     // Explicitly set as instance property for serialization
34:     this.$type = 'hand';
35: 
36:     // Default layout: horizontal fan with overlap
37:     this.$direction = 'horizontal';
38:     this.$fan = true;
39:     this.$fanAngle = 30;
40:     this.$overlap = 0.5;
41:     this.$align = 'center';
42:   }
43: }
````

## File: packages/engine/src/element/space.ts
````typescript
  1: import { GameElement } from './game-element.js';
  2: import type { ElementClass, ElementAttributes, ElementContext } from './types.js';
  3: import type { Player } from '../player/player.js';
  4: import type { Game } from './game.js';
  5: import type { VisibilityMode, VisibilityState } from '../command/visibility.js';
  6: import { visibilityFromMode } from '../command/visibility.js';
  7: 
  8: /**
  9:  * Event handler for element enter/exit events
 10:  */
 11: export type ElementEventHandler<T extends GameElement> = {
 12:   callback: (element: T) => void;
 13:   elementClass?: ElementClass;
 14: };
 15: 
 16: /**
 17:  * Layout direction for Space children
 18:  */
 19: export type LayoutDirection = 'horizontal' | 'vertical';
 20: 
 21: /**
 22:  * Alignment options for Space children
 23:  */
 24: export type LayoutAlignment = 'start' | 'center' | 'end' | 'stretch';
 25: 
 26: /**
 27:  * Spaces are static areas of the game board. They act as containers for Pieces
 28:  * and other elements. Spaces are created during setup and their structure
 29:  * doesn't change during play (though their contents do).
 30:  *
 31:  * Zone-based visibility: Space defines default visibility for its contents.
 32:  * The Space itself is always visible - only the contents get the visibility rules.
 33:  * Children inherit the zone visibility unless they explicitly override it.
 34:  *
 35:  * Layout properties: Spaces can define how their children are arranged using
 36:  * $ prefixed properties that AutoUI reads for rendering.
 37:  *
 38:  * Examples: a deck, a player's hand, a discard pile, a board region
 39:  */
 40: export class Space<G extends Game = any, P extends Player = any> extends GameElement<G, P> {
 41:   // ============================================
 42:   // Layout Properties (for AutoUI rendering)
 43:   // ============================================
 44: 
 45:   /**
 46:    * Layout direction for children
 47:    * @default 'horizontal'
 48:    */
 49:   $direction?: LayoutDirection;
 50: 
 51:   /**
 52:    * Gap between children (CSS value like '8px' or '0.5rem')
 53:    */
 54:   $gap?: string;
 55: 
 56:   /**
 57:    * Overlap ratio for stacked elements (0-1)
 58:    * 0 = no overlap, 0.5 = 50% overlap, 0.9 = 90% overlap (deck-like)
 59:    */
 60:   $overlap?: number;
 61: 
 62:   /**
 63:    * Whether to fan children (like a hand of cards)
 64:    * When true, children are rotated around a central point
 65:    */
 66:   $fan?: boolean;
 67: 
 68:   /**
 69:    * Fan angle in degrees for the entire spread
 70:    * @default 30
 71:    */
 72:   $fanAngle?: number;
 73: 
 74:   /**
 75:    * Alignment of children within the space
 76:    * @default 'center'
 77:    */
 78:   $align?: LayoutAlignment;
 79: 
 80:   // ============================================
 81:   // Internal State
 82:   // ============================================
 83: 
 84:   /** Event handlers for enter/exit events */
 85:   private _eventHandlers: {
 86:     enter: ElementEventHandler<GameElement>[];
 87:     exit: ElementEventHandler<GameElement>[];
 88:   } = { enter: [], exit: [] };
 89: 
 90:   /** Visibility mode for contents (not the space itself) */
 91:   private _zoneVisibility?: VisibilityState;
 92: 
 93:   static override unserializableAttributes = [
 94:     ...GameElement.unserializableAttributes,
 95:     '_eventHandlers',
 96:     '_zoneVisibility',
 97:   ];
 98: 
 99:   constructor(ctx: Partial<ElementContext>) {
100:     super(ctx);
101:   }
102: 
103:   // ============================================
104:   // Zone Visibility Configuration
105:   // ============================================
106: 
107:   /**
108:    * Set the visibility mode for this zone's contents (not the zone itself)
109:    * Children will inherit this unless they explicitly override
110:    */
111:   setZoneVisibility(mode: VisibilityMode): void {
112:     this._zoneVisibility = visibilityFromMode(mode);
113:   }
114: 
115:   /**
116:    * Get the zone visibility (for children to inherit)
117:    */
118:   getZoneVisibility(): VisibilityState | undefined {
119:     return this._zoneVisibility;
120:   }
121: 
122:   /**
123:    * Make contents visible to all players (default)
124:    */
125:   contentsVisible(): void {
126:     this.setZoneVisibility('all');
127:   }
128: 
129:   /**
130:    * Make contents visible only to the owner of this space
131:    */
132:   contentsVisibleToOwner(): void {
133:     this.setZoneVisibility('owner');
134:   }
135: 
136:   /**
137:    * Make contents hidden from all players
138:    */
139:   contentsHidden(): void {
140:     this.setZoneVisibility('hidden');
141:   }
142: 
143:   /**
144:    * Make contents show only count (e.g., opponent's hand size)
145:    */
146:   contentsCountOnly(): void {
147:     this.setZoneVisibility('count-only');
148:   }
149: 
150:   /**
151:    * Add specific players who can see contents (beyond zone default)
152:    */
153:   addZoneVisibleTo(...players: (P | number)[]): void {
154:     const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
155:     if (!this._zoneVisibility) {
156:       this._zoneVisibility = { mode: 'all', explicit: true };
157:     }
158:     this._zoneVisibility.addPlayers = Array.from(
159:       new Set([...(this._zoneVisibility.addPlayers ?? []), ...positions])
160:     );
161:   }
162: 
163:   /**
164:    * Set players who cannot see contents (with 'all' mode)
165:    */
166:   hideContentsFrom(...players: (P | number)[]): void {
167:     if (!this._zoneVisibility) {
168:       this._zoneVisibility = { mode: 'all', explicit: true };
169:     }
170:     const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
171:     this._zoneVisibility.exceptPlayers = Array.from(
172:       new Set([...(this._zoneVisibility.exceptPlayers ?? []), ...positions])
173:     );
174:   }
175: 
176:   // ============================================
177:   // Event Handlers
178:   // ============================================
179: 
180:   /**
181:    * Register a callback for when elements enter this space
182:    */
183:   onEnter<T extends GameElement>(
184:     callback: (element: T) => void,
185:     elementClass?: ElementClass<T>
186:   ): void {
187:     this._eventHandlers.enter.push({ callback: callback as (element: GameElement) => void, elementClass });
188:   }
189: 
190:   /**
191:    * Register a callback for when elements exit this space
192:    */
193:   onExit<T extends GameElement>(
194:     callback: (element: T) => void,
195:     elementClass?: ElementClass<T>
196:   ): void {
197:     this._eventHandlers.exit.push({ callback: callback as (element: GameElement) => void, elementClass });
198:   }
199: 
200:   /**
201:    * Trigger an event for an element
202:    */
203:   triggerEvent(type: 'enter' | 'exit', element: GameElement): void {
204:     for (const handler of this._eventHandlers[type]) {
205:       if (!handler.elementClass || element instanceof handler.elementClass) {
206:         handler.callback(element);
207:       }
208:     }
209:   }
210: 
211:   // ============================================
212:   // Element Creation (override to trigger events)
213:   // ============================================
214: 
215:   override create<T extends GameElement>(
216:     elementClass: ElementClass<T>,
217:     name: string,
218:     attributes?: ElementAttributes<T>
219:   ): T {
220:     const element = super.create(elementClass, name, attributes);
221: 
222:     // Trigger enter event
223:     this.triggerEvent('enter', element);
224: 
225:     return element;
226:   }
227: 
228:   // ============================================
229:   // Shuffle
230:   // ============================================
231: 
232:   /**
233:    * Shuffle the direct children of this space
234:    */
235:   shuffle(): void {
236:     this.shuffleInternal();
237:   }
238: 
239:   /**
240:    * Internal shuffle method called by command executor
241:    */
242:   shuffleInternal(): void {
243:     const random = this._ctx.random ?? Math.random;
244: 
245:     // Fisher-Yates shuffle
246:     for (let i = this._t.children.length - 1; i > 0; i--) {
247:       const j = Math.floor(random() * (i + 1));
248:       [this._t.children[i], this._t.children[j]] = [
249:         this._t.children[j],
250:         this._t.children[i],
251:       ];
252:     }
253:   }
254: 
255:   // ============================================
256:   // Type guard
257:   // ============================================
258: 
259:   /**
260:    * Check if this element is a Space
261:    */
262:   isSpace(): boolean {
263:     return true;
264:   }
265: }
````

## File: packages/engine/src/flow/builders.ts
````typescript
  1: import type { Player } from '../player/player.js';
  2: import type {
  3:   FlowNode,
  4:   FlowContext,
  5:   SequenceConfig,
  6:   LoopConfig,
  7:   EachPlayerConfig,
  8:   ForEachConfig,
  9:   ActionStepConfig,
 10:   SimultaneousActionStepConfig,
 11:   SwitchConfig,
 12:   IfConfig,
 13:   FlowDefinition,
 14:   PhaseConfig,
 15: } from './types.js';
 16: 
 17: /**
 18:  * Create a sequence of steps executed in order
 19:  *
 20:  * @example
 21:  * ```typescript
 22:  * sequence(
 23:  *   actionStep({ actions: ['draw'] }),
 24:  *   actionStep({ actions: ['play'] })
 25:  * )
 26:  * ```
 27:  */
 28: export function sequence(...steps: FlowNode[]): FlowNode {
 29:   return {
 30:     type: 'sequence',
 31:     config: { steps },
 32:   };
 33: }
 34: 
 35: /**
 36:  * Create a sequence with a name
 37:  */
 38: export function namedSequence(name: string, ...steps: FlowNode[]): FlowNode {
 39:   return {
 40:     type: 'sequence',
 41:     config: { name, steps },
 42:   };
 43: }
 44: 
 45: /**
 46:  * Create a named game phase
 47:  *
 48:  * Phases are named sections of the flow that can be displayed in the UI
 49:  * (e.g., "Combat Phase", "Income Phase"). The onEnterPhase/onExitPhase
 50:  * hooks in defineFlow will be called when entering/exiting phases.
 51:  *
 52:  * @example
 53:  * ```typescript
 54:  * sequence(
 55:  *   phase('setup', {
 56:  *     do: simultaneousActionStep({ actions: ['chooseCharacter'] })
 57:  *   }),
 58:  *   phase('combat', {
 59:  *     do: eachPlayer({ do: actionStep({ actions: ['attack', 'defend'] }) })
 60:  *   }),
 61:  *   phase('income', {
 62:  *     do: execute({ fn: ctx => ctx.game.distributeIncome() })
 63:  *   })
 64:  * )
 65:  * ```
 66:  */
 67: export function phase(name: string, config: { do: FlowNode }): FlowNode {
 68:   return {
 69:     type: 'phase',
 70:     config: {
 71:       name,
 72:       do: config.do,
 73:     },
 74:   };
 75: }
 76: 
 77: /**
 78:  * Create a loop that repeats while a condition is true
 79:  *
 80:  * @example
 81:  * ```typescript
 82:  * loop({
 83:  *   while: (ctx) => !ctx.game.isFinished(),
 84:  *   do: eachPlayer({ do: playerTurn })
 85:  * })
 86:  * ```
 87:  */
 88: export function loop(config: {
 89:   name?: string;
 90:   while?: (context: FlowContext) => boolean;
 91:   maxIterations?: number;
 92:   do: FlowNode;
 93: }): FlowNode {
 94:   return {
 95:     type: 'loop',
 96:     config: {
 97:       name: config.name,
 98:       while: config.while,
 99:       maxIterations: config.maxIterations,
100:       do: config.do,
101:     },
102:   };
103: }
104: 
105: /**
106:  * Create a loop that repeats a fixed number of times
107:  *
108:  * @example
109:  * ```typescript
110:  * repeat(3, actionStep({ actions: ['draw'] }))
111:  * ```
112:  */
113: export function repeat(times: number, body: FlowNode): FlowNode {
114:   let count = 0;
115:   return loop({
116:     while: () => {
117:       count++;
118:       return count <= times;
119:     },
120:     maxIterations: times,
121:     do: body,
122:   });
123: }
124: 
125: /**
126:  * Iterate through each player
127:  *
128:  * @example
129:  * ```typescript
130:  * eachPlayer({
131:  *   do: actionStep({ actions: ['takeTurn'] })
132:  * })
133:  * ```
134:  */
135: export function eachPlayer(config: {
136:   name?: string;
137:   filter?: (player: Player, context: FlowContext) => boolean;
138:   direction?: 'forward' | 'backward';
139:   startingPlayer?: (context: FlowContext) => Player;
140:   do: FlowNode;
141: }): FlowNode {
142:   return {
143:     type: 'each-player',
144:     config: {
145:       name: config.name,
146:       filter: config.filter,
147:       direction: config.direction,
148:       startingPlayer: config.startingPlayer,
149:       do: config.do,
150:     },
151:   };
152: }
153: 
154: /**
155:  * Iterate through a collection of items
156:  *
157:  * @example
158:  * ```typescript
159:  * forEach({
160:  *   collection: (ctx) => ctx.game.all(Card),
161:  *   as: 'card',
162:  *   do: actionStep({ ... })
163:  * })
164:  * ```
165:  */
166: export function forEach<T>(config: {
167:   name?: string;
168:   collection: T[] | ((context: FlowContext) => T[]);
169:   as: string;
170:   do: FlowNode;
171: }): FlowNode {
172:   return {
173:     type: 'for-each',
174:     config: {
175:       name: config.name,
176:       collection: config.collection as unknown[] | ((context: FlowContext) => unknown[]),
177:       as: config.as,
178:       do: config.do,
179:     },
180:   };
181: }
182: 
183: /**
184:  * Pause for player action
185:  *
186:  * @example
187:  * ```typescript
188:  * actionStep({
189:  *   actions: ['ask'],
190:  *   prompt: 'Ask another player for cards'
191:  * })
192:  * ```
193:  *
194:  * @example
195:  * ```typescript
196:  * // With move limits (action points)
197:  * actionStep({
198:  *   actions: ['move', 'attack', 'heal'],
199:  *   minMoves: 1,  // Must take at least 1 action
200:  *   maxMoves: 3,  // Can take at most 3 actions
201:  * })
202:  * ```
203:  */
204: export function actionStep(config: {
205:   name?: string;
206:   player?: (context: FlowContext) => Player;
207:   actions: string[] | ((context: FlowContext) => string[]);
208:   prompt?: string | ((context: FlowContext) => string);
209:   repeatUntil?: (context: FlowContext) => boolean;
210:   skipIf?: (context: FlowContext) => boolean;
211:   timeout?: number;
212:   minMoves?: number;
213:   maxMoves?: number;
214: }): FlowNode {
215:   return {
216:     type: 'action-step',
217:     config: {
218:       name: config.name,
219:       player: config.player,
220:       actions: config.actions,
221:       prompt: config.prompt,
222:       repeatUntil: config.repeatUntil,
223:       skipIf: config.skipIf,
224:       timeout: config.timeout,
225:       minMoves: config.minMoves,
226:       maxMoves: config.maxMoves,
227:     },
228:   };
229: }
230: 
231: /**
232:  * Shorthand for a single repeating action step
233:  *
234:  * @example
235:  * ```typescript
236:  * playerActions({
237:  *   actions: ['ask'],
238:  *   repeatUntil: (ctx) => ctx.get('turnEnded')
239:  * })
240:  * ```
241:  */
242: export function playerActions(config: {
243:   name?: string;
244:   actions: string[] | ((context: FlowContext) => string[]);
245:   prompt?: string | ((context: FlowContext) => string);
246:   repeatUntil?: (context: FlowContext) => boolean;
247:   skipIf?: (context: FlowContext) => boolean;
248: }): FlowNode {
249:   return actionStep({
250:     name: config.name,
251:     actions: config.actions,
252:     prompt: config.prompt,
253:     repeatUntil: config.repeatUntil,
254:     skipIf: config.skipIf,
255:   });
256: }
257: 
258: /**
259:  * Pause for multiple players to act simultaneously
260:  *
261:  * All specified players can take actions in any order until each has completed.
262:  * The step completes when all players have finished (determined by playerDone or allDone).
263:  *
264:  * @example
265:  * ```typescript
266:  * simultaneousActionStep({
267:  *   actions: ['discard'],
268:  *   playerDone: (ctx, player) => player.hand.count() <= 4,
269:  *   prompt: 'Discard 2 cards to the crib'
270:  * })
271:  * ```
272:  */
273: export function simultaneousActionStep(config: {
274:   name?: string;
275:   players?: (context: FlowContext) => Player[];
276:   actions: string[] | ((context: FlowContext, player: Player) => string[]);
277:   prompt?: string | ((context: FlowContext) => string);
278:   playerDone?: (context: FlowContext, player: Player) => boolean;
279:   allDone?: (context: FlowContext) => boolean;
280:   skipPlayer?: (context: FlowContext, player: Player) => boolean;
281:   timeout?: number;
282: }): FlowNode {
283:   return {
284:     type: 'simultaneous-action-step',
285:     config: {
286:       name: config.name,
287:       players: config.players,
288:       actions: config.actions,
289:       prompt: config.prompt,
290:       playerDone: config.playerDone,
291:       allDone: config.allDone,
292:       skipPlayer: config.skipPlayer,
293:       timeout: config.timeout,
294:     },
295:   };
296: }
297: 
298: /**
299:  * Branch based on a value
300:  *
301:  * @example
302:  * ```typescript
303:  * switchOn({
304:  *   on: (ctx) => ctx.get('phase'),
305:  *   cases: {
306:  *     'draw': drawPhase,
307:  *     'play': playPhase
308:  *   },
309:  *   default: endTurn
310:  * })
311:  * ```
312:  */
313: export function switchOn(config: {
314:   name?: string;
315:   on: (context: FlowContext) => unknown;
316:   cases: Record<string, FlowNode>;
317:   default?: FlowNode;
318: }): FlowNode {
319:   return {
320:     type: 'switch',
321:     config: {
322:       name: config.name,
323:       on: config.on,
324:       cases: config.cases,
325:       default: config.default,
326:     },
327:   };
328: }
329: 
330: /**
331:  * Conditional execution
332:  *
333:  * @example
334:  * ```typescript
335:  * ifThen({
336:  *   condition: (ctx) => ctx.player.hand.isEmpty(),
337:  *   then: drawCards,
338:  *   else: playCard
339:  * })
340:  * ```
341:  */
342: export function ifThen(config: {
343:   name?: string;
344:   condition: (context: FlowContext) => boolean;
345:   then: FlowNode;
346:   else?: FlowNode;
347: }): FlowNode {
348:   return {
349:     type: 'if',
350:     config: {
351:       name: config.name,
352:       condition: config.condition,
353:       then: config.then,
354:       else: config.else,
355:     },
356:   };
357: }
358: 
359: /**
360:  * Create a complete flow definition
361:  *
362:  * @example
363:  * ```typescript
364:  * defineFlow({
365:  *   setup: (ctx) => {
366:  *     ctx.game.create(Deck, 'deck');
367:  *     // ... deal cards
368:  *   },
369:  *   root: loop({
370:  *     while: (ctx) => !ctx.game.isFinished(),
371:  *     do: eachPlayer({ do: playerTurn })
372:  *   }),
373:  *   isComplete: (ctx) => allBooksCollected(ctx),
374:  *   getWinners: (ctx) => findPlayersWithMostBooks(ctx)
375:  * })
376:  * ```
377:  *
378:  * @example
379:  * ```typescript
380:  * // With phase hooks
381:  * defineFlow({
382:  *   root: sequence(
383:  *     phase('setup', { do: ... }),
384:  *     phase('main', { do: ... })
385:  *   ),
386:  *   onEnterPhase: (phaseName, ctx) => {
387:  *     ctx.game.message(`Entering ${phaseName} phase`);
388:  *   },
389:  *   onExitPhase: (phaseName, ctx) => {
390:  *     ctx.game.message(`Exiting ${phaseName} phase`);
391:  *   }
392:  * })
393:  * ```
394:  */
395: export function defineFlow(config: {
396:   setup?: (context: FlowContext) => void;
397:   root: FlowNode;
398:   isComplete?: (context: FlowContext) => boolean;
399:   getWinners?: (context: FlowContext) => Player[];
400:   onEnterPhase?: (phaseName: string, context: FlowContext) => void;
401:   onExitPhase?: (phaseName: string, context: FlowContext) => void;
402: }): FlowDefinition {
403:   return {
404:     setup: config.setup,
405:     root: config.root,
406:     isComplete: config.isComplete,
407:     getWinners: config.getWinners,
408:     onEnterPhase: config.onEnterPhase,
409:     onExitPhase: config.onExitPhase,
410:   };
411: }
412: 
413: /**
414:  * Create a "do nothing" node (useful as placeholder or in conditionals)
415:  */
416: export function noop(): FlowNode {
417:   return sequence();
418: }
419: 
420: /**
421:  * Execute a function during flow (for side effects)
422:  *
423:  * @example
424:  * ```typescript
425:  * sequence(
426:  *   execute((ctx) => ctx.game.message('Starting turn')),
427:  *   actionStep({ actions: ['play'] })
428:  * )
429:  * ```
430:  */
431: export function execute(fn: (context: FlowContext) => void): FlowNode {
432:   return {
433:     type: 'execute',
434:     config: { fn },
435:   };
436: }
437: 
438: /**
439:  * Set a flow variable
440:  *
441:  * @example
442:  * ```typescript
443:  * setVar('turnCount', (ctx) => (ctx.get('turnCount') ?? 0) + 1)
444:  * ```
445:  */
446: export function setVar(
447:   name: string,
448:   value: unknown | ((context: FlowContext) => unknown)
449: ): FlowNode {
450:   return execute((ctx) => {
451:     const resolvedValue = typeof value === 'function' ? (value as Function)(ctx) : value;
452:     ctx.set(name, resolvedValue);
453:   });
454: }
````

## File: packages/engine/src/utils/serializer.ts
````typescript
  1: import type { Game } from '../element/game.js';
  2: import type { GameElement } from '../element/game-element.js';
  3: import type { Player } from '../player/player.js';
  4: import type { SerializedAction } from '../action/types.js';
  5: 
  6: /**
  7:  * Reference types used in serialized actions
  8:  */
  9: export type SerializedReference =
 10:   | { __elementRef: string }  // Element reference by branch path
 11:   | { __elementId: number }   // Element reference by ID
 12:   | { __playerRef: number };  // Player reference by position
 13: 
 14: /**
 15:  * Options for serialization
 16:  */
 17: export interface SerializeOptions {
 18:   /** Use branch paths instead of IDs (more stable across serialization) */
 19:   useBranchPaths?: boolean;
 20: }
 21: 
 22: /**
 23:  * Serialize a value that may contain game elements or players
 24:  * Converts elements to `{ __elementRef: "0/2/5" }` or `{ __elementId: 123 }`
 25:  * Converts players to `{ __playerRef: 0 }`
 26:  */
 27: export function serializeValue(
 28:   value: unknown,
 29:   game: Game,
 30:   options: SerializeOptions = {}
 31: ): unknown {
 32:   if (value === null || value === undefined) {
 33:     return value;
 34:   }
 35: 
 36:   // Handle GameElement references
 37:   if (value instanceof Object && 'branch' in value && typeof (value as GameElement).branch === 'function') {
 38:     const element = value as GameElement;
 39:     if (options.useBranchPaths) {
 40:       return { __elementRef: element.branch() };
 41:     }
 42:     return { __elementId: element.id };
 43:   }
 44: 
 45:   // Handle Player references
 46:   if (value instanceof Object && 'position' in value && typeof (value as Player).position === 'number') {
 47:     const player = value as Player;
 48:     return { __playerRef: player.position };
 49:   }
 50: 
 51:   // Handle arrays
 52:   if (Array.isArray(value)) {
 53:     return value.map(item => serializeValue(item, game, options));
 54:   }
 55: 
 56:   // Handle plain objects
 57:   if (typeof value === 'object' && value !== null) {
 58:     const result: Record<string, unknown> = {};
 59:     for (const [key, val] of Object.entries(value)) {
 60:       result[key] = serializeValue(val, game, options);
 61:     }
 62:     return result;
 63:   }
 64: 
 65:   // Primitives pass through
 66:   return value;
 67: }
 68: 
 69: /**
 70:  * Deserialize a value that may contain element/player references
 71:  * Converts `{ __elementRef: "0/2/5" }` back to GameElement
 72:  * Converts `{ __playerRef: 0 }` back to Player
 73:  */
 74: export function deserializeValue(
 75:   value: unknown,
 76:   game: Game
 77: ): unknown {
 78:   if (value === null || value === undefined) {
 79:     return value;
 80:   }
 81: 
 82:   // Handle element reference by branch path
 83:   if (typeof value === 'object' && value !== null && '__elementRef' in value) {
 84:     const ref = value as { __elementRef: string };
 85:     return game.atBranch(ref.__elementRef);
 86:   }
 87: 
 88:   // Handle element reference by ID
 89:   if (typeof value === 'object' && value !== null && '__elementId' in value) {
 90:     const ref = value as { __elementId: number };
 91:     return game.first({ id: ref.__elementId } as Record<string, unknown>);
 92:   }
 93: 
 94:   // Handle player reference
 95:   if (typeof value === 'object' && value !== null && '__playerRef' in value) {
 96:     const ref = value as { __playerRef: number };
 97:     return game.players[ref.__playerRef];
 98:   }
 99: 
100:   // Handle arrays
101:   if (Array.isArray(value)) {
102:     return value.map(item => deserializeValue(item, game));
103:   }
104: 
105:   // Handle plain objects
106:   if (typeof value === 'object' && value !== null) {
107:     const result: Record<string, unknown> = {};
108:     for (const [key, val] of Object.entries(value)) {
109:       result[key] = deserializeValue(val, game);
110:     }
111:     return result;
112:   }
113: 
114:   // Primitives pass through
115:   return value;
116: }
117: 
118: /**
119:  * Serialize an action with its arguments
120:  */
121: export function serializeAction(
122:   actionName: string,
123:   player: Player,
124:   args: Record<string, unknown>,
125:   game: Game,
126:   options: SerializeOptions = {},
127:   undoable?: boolean
128: ): SerializedAction {
129:   const serialized: SerializedAction = {
130:     name: actionName,
131:     player: player.position,
132:     args: serializeValue(args, game, options) as Record<string, unknown>,
133:     timestamp: Date.now(),
134:   };
135: 
136:   // Only include undoable if explicitly false (default is true)
137:   if (undoable === false) {
138:     serialized.undoable = false;
139:   }
140: 
141:   return serialized;
142: }
143: 
144: /**
145:  * Deserialize an action and resolve its arguments
146:  */
147: export function deserializeAction(
148:   serialized: SerializedAction,
149:   game: Game
150: ): { actionName: string; player: Player; args: Record<string, unknown> } {
151:   const player = game.players[serialized.player];
152:   if (!player) {
153:     throw new Error(`Player ${serialized.player} not found`);
154:   }
155: 
156:   return {
157:     actionName: serialized.name,
158:     player,
159:     args: deserializeValue(serialized.args, game) as Record<string, unknown>,
160:   };
161: }
162: 
163: /**
164:  * Check if a value is a serialized reference
165:  */
166: export function isSerializedReference(value: unknown): value is SerializedReference {
167:   if (typeof value !== 'object' || value === null) {
168:     return false;
169:   }
170:   return '__elementRef' in value || '__elementId' in value || '__playerRef' in value;
171: }
````

## File: packages/games/checkers/rules/src/actions.ts
````typescript
  1: import { Action, type ActionDefinition } from '@boardsmith/engine';
  2: import type { CheckersGame } from './game.js';
  3: import { CheckerPiece, Square, CheckersPlayer, type CheckersMove } from './elements.js';
  4: 
  5: /**
  6:  * Create the endTurn action for Checkers
  7:  *
  8:  * This action is available after a player has made a move (and is not in a multi-jump).
  9:  * It allows the player to confirm their turn is complete, enabling undo before confirmation.
 10:  */
 11: export function createEndTurnAction(game: CheckersGame): ActionDefinition {
 12:   return Action.create('endTurn')
 13:     .prompt('End Turn')
 14:     .condition((ctx) => {
 15:       // Only available if player has made a move this turn
 16:       // and is not in a multi-jump continuation
 17:       const player = ctx.player as CheckersPlayer;
 18: 
 19:       // Can't end turn during a multi-jump
 20:       if (game.continuingPlayer === player && game.continuingPiece) {
 21:         return false;
 22:       }
 23: 
 24:       // Check if hasMovedThisTurn is set
 25:       return game.hasMovedThisTurn === true;
 26:     })
 27:     .execute((args, ctx) => {
 28:       const player = ctx.player as CheckersPlayer;
 29: 
 30:       // Clear the moved flag
 31:       game.hasMovedThisTurn = false;
 32: 
 33:       return {
 34:         success: true,
 35:         data: { turnEnded: true },
 36:         message: `${player.name} ended their turn.`,
 37:       };
 38:     });
 39: }
 40: 
 41: /**
 42:  * Destination choice value - includes piece ID for filtering
 43:  */
 44: interface DestinationChoice {
 45:   pieceId: number;
 46:   fromNotation: string;
 47:   toNotation: string;
 48:   isCapture: boolean;
 49:   becomesKing: boolean;
 50: }
 51: 
 52: /**
 53:  * Create the move action for Checkers
 54:  *
 55:  * This action uses two-step selection:
 56:  * 1. Choose a piece to move (element selection)
 57:  * 2. Choose a destination (choice selection, filtered by selected piece)
 58:  *
 59:  * When captures are available, they are mandatory.
 60:  * After a capture, if the piece can make additional captures,
 61:  * the turn continues with that piece.
 62:  */
 63: export function createMoveAction(game: CheckersGame): ActionDefinition {
 64:   // Helper to get valid moves for a player or continuing piece
 65:   function getMovesForPlayer(player: CheckersPlayer): CheckersMove[] {
 66:     if (game.continuingPiece && game.continuingPlayer === player) {
 67:       return game.getValidMovesForPiece(game.continuingPiece);
 68:     }
 69:     return game.getValidMoves(player);
 70:   }
 71: 
 72:   // Helper to get pieces with valid moves
 73:   function getPiecesWithMoves(player: CheckersPlayer): CheckerPiece[] {
 74:     // If continuing a multi-jump, only that piece can move
 75:     if (game.continuingPiece && game.continuingPlayer === player) {
 76:       return [game.continuingPiece];
 77:     }
 78: 
 79:     const moves = game.getValidMoves(player);
 80:     const pieceIds = new Set(moves.map(m => m.piece.id));
 81:     return [...pieceIds].map(id => game.getElementById(id) as CheckerPiece).filter(Boolean);
 82:   }
 83: 
 84:   return Action.create('move')
 85:     .prompt('Move')
 86:     // Step 1: Select a piece to move
 87:     .chooseElement<CheckerPiece>('piece', {
 88:       prompt: 'Select a piece to move',
 89:       elementClass: CheckerPiece,
 90:       filter: (element, ctx) => {
 91:         const piece = element as CheckerPiece;
 92:         const player = ctx.player as CheckersPlayer;
 93: 
 94:         // Only allow selecting pieces that belong to the current player and have moves
 95:         if (piece.player !== player) return false;
 96: 
 97:         // If continuing a multi-jump, only the continuing piece can be selected
 98:         if (game.continuingPiece && game.continuingPlayer === player) {
 99:           return piece === game.continuingPiece;
100:         }
101: 
102:         // Check if this piece has any valid moves
103:         const moves = game.getValidMoves(player);
104:         return moves.some(m => m.piece.id === piece.id);
105:       },
106:       display: (piece, ctx) => {
107:         // Display the notation of the square the piece is on
108:         const square = game.getPieceSquare(piece);
109:         return square?.notation || String(piece.id);
110:       },
111:       boardRef: (piece, ctx) => {
112:         const square = game.getPieceSquare(piece);
113:         return {
114:           id: piece.id,
115:           notation: square?.notation,
116:         };
117:       },
118:       skipIfOnlyOne: true,
119:     })
120:     // Step 2: Select a destination
121:     .chooseFrom<DestinationChoice>('destination', {
122:       prompt: 'Select destination',
123:       choices: (ctx) => {
124:         const player = ctx.player as CheckersPlayer;
125:         const moves = getMovesForPlayer(player);
126: 
127:         // Return all valid destinations with their piece IDs for filtering
128:         return moves.map(m => ({
129:           pieceId: m.piece.id,
130:           fromNotation: m.from.notation,
131:           toNotation: m.to.notation,
132:           isCapture: m.captures.length > 0,
133:           becomesKing: m.becomesKing,
134:         }));
135:       },
136:       display: (choice) => {
137:         let text = choice.toNotation;
138:         if (choice.isCapture) text += ' (capture)';
139:         if (choice.becomesKing) text += ' → King';
140:         return text;
141:       },
142:       boardRefs: (choice) => {
143:         const toSquare = game.board.getSquareByNotation(choice.toNotation);
144:         return {
145:           sourceRef: {
146:             id: choice.pieceId,
147:             notation: choice.fromNotation,
148:           },
149:           targetRef: {
150:             id: toSquare?.id,
151:             notation: choice.toNotation,
152:           },
153:         };
154:       },
155:       // Filter destinations based on selected piece
156:       filterBy: {
157:         key: 'pieceId',
158:         selectionName: 'piece',
159:       },
160:     })
161:     .condition((ctx) => {
162:       const player = ctx.player as CheckersPlayer;
163: 
164:       // If continuing multi-jump, only this player can act
165:       if (game.continuingPlayer && game.continuingPlayer !== player) {
166:         return false;
167:       }
168: 
169:       // If player already moved this turn (and not in multi-jump), they can't move again
170:       // They must click "End Turn" to pass to opponent
171:       if (game.hasMovedThisTurn && !game.continuingPiece) {
172:         return false;
173:       }
174: 
175:       // Check if player has any valid moves
176:       if (game.continuingPiece) {
177:         return game.getValidMovesForPiece(game.continuingPiece).length > 0;
178:       }
179: 
180:       return game.getValidMoves(player).length > 0;
181:     })
182:     .execute((args, ctx) => {
183:       const player = ctx.player as CheckersPlayer;
184:       const piece = args.piece as CheckerPiece;
185:       const destination = args.destination as DestinationChoice;
186: 
187:       // Find the actual move
188:       const moves = getMovesForPlayer(player);
189:       const move = moves.find(
190:         m => m.piece.id === piece.id && m.to.notation === destination.toNotation
191:       );
192: 
193:       if (!move) {
194:         return {
195:           success: false,
196:           error: 'Invalid move',
197:         };
198:       }
199: 
200:       // Log the move
201:       const pieceType = move.piece.isKing ? 'King' : 'Piece';
202:       const isCapture = move.captures.length > 0;
203: 
204:       game.message(`${player.name}: ${pieceType} ${move.from.notation} -> ${move.to.notation}`);
205: 
206:       // Execute the move
207:       game.executeMove(move);
208: 
209:       // Check for multi-jump continuation
210:       // Note: In American checkers, when crowned the turn ends immediately
211:       if (isCapture && !move.becomesKing) {
212:         const additionalCaptures = game.getCaptureMoves(move.piece);
213:         if (additionalCaptures.length > 0) {
214:           // Must continue capturing with this piece
215:           game.continuingPlayer = player;
216:           game.continuingPiece = move.piece;
217: 
218:           game.message(`${player.name} must continue capturing!`);
219: 
220:           return {
221:             success: true,
222:             data: {
223:               captured: true,
224:               mustContinue: true,
225:               from: move.from.notation,
226:               to: move.to.notation,
227:               crowned: false,
228:             },
229:             message: `Captured! Must continue jumping.`,
230:           };
231:         }
232:       }
233: 
234:       // Turn can end - clear continuation state and mark that player has moved
235:       game.continuingPlayer = null;
236:       game.continuingPiece = null;
237:       game.hasMovedThisTurn = true;
238: 
239:       return {
240:         success: true,
241:         data: {
242:           captured: isCapture,
243:           mustContinue: false,
244:           canEndTurn: true, // Signal that player can now end their turn
245:           from: move.from.notation,
246:           to: move.to.notation,
247:           crowned: move.becomesKing,
248:         },
249:         message: move.becomesKing
250:           ? `Moved and crowned!`
251:           : isCapture
252:             ? `Captured!`
253:             : `Moved ${move.from.notation} to ${move.to.notation}`,
254:       };
255:     });
256: }
````

## File: packages/games/checkers/rules/src/flow.ts
````typescript
  1: import {
  2:   loop,
  3:   eachPlayer,
  4:   actionStep,
  5:   execute,
  6:   sequence,
  7:   setVar,
  8:   type FlowDefinition,
  9: } from '@boardsmith/engine';
 10: import type { CheckersGame } from './game.js';
 11: import type { CheckersPlayer } from './elements.js';
 12: 
 13: /**
 14:  * Create the Checkers game flow
 15:  *
 16:  * Flow structure:
 17:  * 1. Main game loop (while game not finished)
 18:  * 2. Each player takes a turn
 19:  * 3. Player turn: move action, with multi-jump continuation
 20:  * 4. After a move (non-multi-jump), player can undo or confirm with endTurn
 21:  * 5. Game ends when a player has no pieces or no valid moves
 22:  */
 23: export function createCheckersFlow(game: CheckersGame): FlowDefinition {
 24:   // A single turn where the player moves a piece
 25:   const playerTurn = sequence(
 26:     // Reset turn state at start of each turn
 27:     setVar('turnComplete', false),
 28:     execute(() => {
 29:       game.hasMovedThisTurn = false;
 30:     }),
 31: 
 32:     // The turn loop - keeps going for multi-jump captures OR until endTurn
 33:     loop({
 34:       name: 'move-loop',
 35:       while: (ctx) => {
 36:         // Continue while turn hasn't ended
 37:         if (ctx.get('turnComplete')) return false;
 38: 
 39:         // Check if game is finished
 40:         if (game.isFinished()) return false;
 41: 
 42:         const player = ctx.player as CheckersPlayer;
 43:         if (!player) return false;
 44: 
 45:         // Check if this player can make a move
 46:         if (game.continuingPlayer && game.continuingPlayer !== player) {
 47:           // Another player must continue their multi-jump
 48:           return false;
 49:         }
 50: 
 51:         // If player has moved and is not in multi-jump, they need to endTurn
 52:         if (game.hasMovedThisTurn && !game.continuingPiece) {
 53:           return true; // Keep loop going to offer endTurn action
 54:         }
 55: 
 56:         if (game.continuingPiece) {
 57:           // Multi-jump in progress - check if more captures available
 58:           return game.getValidMovesForPiece(game.continuingPiece).length > 0;
 59:         }
 60: 
 61:         return game.getValidMoves(player).length > 0;
 62:       },
 63:       maxIterations: 20, // Safety limit for multi-jumps
 64:       do: sequence(
 65:         // Player makes a move or ends turn
 66:         actionStep({
 67:           name: 'move-step',
 68:           actions: ['move', 'endTurn'], // Both actions available
 69:           skipIf: (ctx) => {
 70:             // Skip if game is over
 71:             return game.isFinished();
 72:           },
 73:         }),
 74: 
 75:         // Check if turn should continue (multi-jump), end, or await confirmation
 76:         execute((ctx) => {
 77:           // If endTurn was executed, turn is complete
 78:           if (ctx.lastActionResult?.data?.turnEnded) {
 79:             ctx.set('turnComplete', true);
 80:             return;
 81:           }
 82: 
 83:           // If move resulted in multi-jump, don't end turn yet
 84:           const mustContinue = ctx.lastActionResult?.data?.mustContinue;
 85:           if (mustContinue) {
 86:             // Multi-jump: keep going
 87:             return;
 88:           }
 89: 
 90:           // If move can end turn but player hasn't confirmed, wait for endTurn
 91:           // (turnComplete remains false, loop continues to offer endTurn)
 92:         }),
 93:       ),
 94:     }),
 95:   );
 96: 
 97:   return {
 98:     root: loop({
 99:       name: 'game-loop',
100:       while: (ctx) => {
101:         return !game.isFinished();
102:       },
103:       maxIterations: 500, // Safety limit for long games
104:       do: eachPlayer({
105:         name: 'player-turns',
106:         filter: (player, ctx) => {
107:           // Skip players who can't move
108:           // Also skip if another player is in a multi-jump
109:           if (game.continuingPlayer && game.continuingPlayer !== player) {
110:             return false;
111:           }
112:           return game.canCurrentPlayerMove(player as CheckersPlayer);
113:         },
114:         do: playerTurn,
115:       }),
116:     }),
117: 
118:     isComplete: (ctx) => {
119:       return game.isFinished();
120:     },
121: 
122:     getWinners: (ctx) => {
123:       return game.getWinners();
124:     },
125:   };
126: }
````

## File: packages/games/cribbage/rules/src/flow.ts
````typescript
  1: import {
  2:   loop,
  3:   actionStep,
  4:   simultaneousActionStep,
  5:   execute,
  6:   sequence,
  7:   phase,
  8:   type FlowDefinition,
  9:   type FlowContext,
 10: } from '@boardsmith/engine';
 11: import type { CribbageGame } from './game.js';
 12: import { Card, CribbagePlayer } from './elements.js';
 13: 
 14: /**
 15:  * Create the Cribbage game flow
 16:  *
 17:  * Flow structure:
 18:  * 1. Initialize (create deck, start first round)
 19:  * 2. Round loop:
 20:  *    a. Deal phase (automatic)
 21:  *    b. Discard phase - each player discards 2 cards
 22:  *    c. Cut starter card
 23:  *    d. Play phase - alternate playing cards, pegging
 24:  *    e. Show phase - score hands and crib
 25:  *    f. Rotate dealer and repeat
 26:  */
 27: export function createCribbageFlow(): FlowDefinition {
 28:   // Discard phase - both players discard 2 cards simultaneously
 29:   const discardPhase = phase('discarding', {
 30:     do: simultaneousActionStep({
 31:       name: 'simultaneous-discard',
 32:       actions: ['discard'],
 33:       prompt: 'Discard 2 cards to the crib',
 34:       // Player is done when they have 4 cards left (discarded 2)
 35:       playerDone: (ctx, player) => {
 36:         const game = ctx.game as CribbageGame;
 37:         const hand = game.getPlayerHand(player as CribbagePlayer);
 38:         return hand.count(Card) <= 4;
 39:       },
 40:       // All done when all players have discarded
 41:       allDone: (ctx) => {
 42:         const game = ctx.game as CribbageGame;
 43:         return game.allPlayersDiscarded() || game.isFinished();
 44:       },
 45:     }),
 46:   });
 47: 
 48:   // Play phase - players alternate playing cards ONE AT A TIME
 49:   const playPhase = phase('play', {
 50:     do: sequence(
 51:       // Initialize play state
 52:       execute((ctx) => {
 53:         const game = ctx.game as CribbageGame;
 54:         game.runningTotal = 0;
 55:         game.currentPlayCards = [];
 56:         game.playerSaidGo = [false, false];
 57:         // Non-dealer plays first
 58:         game.currentPlayTurn = game.getNonDealer().position;
 59:       }),
 60: 
 61:       // Main play loop - continues until all cards played
 62:       loop({
 63:       name: 'play-loop',
 64:       while: (ctx) => {
 65:         const game = ctx.game as CribbageGame;
 66:         return !game.allCardsPlayed() && !game.isFinished();
 67:       },
 68:       maxIterations: 100,
 69:       do: sequence(
 70:         // Check if we need to reset the count
 71:         // This happens when both players have said Go (or have no playable cards)
 72:         execute((ctx) => {
 73:           const game = ctx.game as CribbageGame;
 74:           const currentPlayer = game.getCurrentPlayPlayer();
 75:           const otherPlayer = game.players[1 - game.currentPlayTurn] as CribbagePlayer;
 76: 
 77:           const currentCanPlay = game.getPlayableCards(currentPlayer).length > 0;
 78:           const currentHasCards = game.getPlayerHand(currentPlayer).count(Card) > 0;
 79:           const currentSaidGo = game.playerSaidGo[currentPlayer.position];
 80: 
 81:           const otherCanPlay = game.getPlayableCards(otherPlayer).length > 0;
 82:           const otherHasCards = game.getPlayerHand(otherPlayer).count(Card) > 0;
 83:           const otherSaidGo = game.playerSaidGo[otherPlayer.position];
 84: 
 85:           // Check if current player is stuck (said Go or can't play)
 86:           const currentStuck = currentSaidGo || !currentCanPlay;
 87:           // Check if other player is stuck (said Go or can't play)
 88:           const otherStuck = otherSaidGo || !otherCanPlay;
 89: 
 90:           // If both players are stuck but at least one still has cards, reset count
 91:           if (currentStuck && otherStuck && (currentHasCards || otherHasCards)) {
 92:             // Award "Go" point to last player who played a card (if not already at 31)
 93:             if (game.lastPlayerToPlay >= 0 && game.runningTotal > 0 && game.runningTotal < 31) {
 94:               const lastPlayer = game.players[game.lastPlayerToPlay] as CribbagePlayer;
 95:               game.addPoints(lastPlayer, 1, 'Go');
 96:             }
 97:             game.resetCount();
 98:             // Player who didn't play last leads the new count
 99:             if (game.lastPlayerToPlay >= 0) {
100:               game.currentPlayTurn = 1 - game.lastPlayerToPlay;
101:             }
102:           }
103:         }),
104: 
105:         // Single player action - the current player plays one card or says Go
106:         actionStep({
107:           name: 'play-or-go-step',
108:           player: (ctx) => {
109:             const game = ctx.game as CribbageGame;
110:             return game.getCurrentPlayPlayer();
111:           },
112:           actions: ['playCard', 'sayGo'],
113:           prompt: 'Play a card',
114:           skipIf: (ctx) => {
115:             const game = ctx.game as CribbageGame;
116:             if (game.isFinished()) return true;
117: 
118:             const currentPlayer = game.getCurrentPlayPlayer();
119:             const hasCards = game.getPlayerHand(currentPlayer).count(Card) > 0;
120: 
121:             // Skip if player has no cards
122:             if (!hasCards) return true;
123: 
124:             const alreadySaidGo = game.playerSaidGo[currentPlayer.position];
125: 
126:             // Skip if already said Go - once you say Go, you're out until count resets
127:             if (alreadySaidGo) return true;
128: 
129:             return false;
130:           },
131:         }),
132: 
133:         // After each action, switch to the other player (unless they've said Go)
134:         // Once a player says "Go", they're out for the rest of this count
135:         execute((ctx) => {
136:           const game = ctx.game as CribbageGame;
137:           if (game.isFinished() || game.allCardsPlayed()) return;
138: 
139:           const otherPosition = 1 - game.currentPlayTurn;
140:           const otherPlayer = game.players[otherPosition] as CribbagePlayer;
141:           const otherHasCards = game.getPlayerHand(otherPlayer).count(Card) > 0;
142:           const otherSaidGo = game.playerSaidGo[otherPosition];
143: 
144:           // Switch to other player only if they have cards AND haven't said Go
145:           // Once you say Go, you're done until count resets (even if you could now play)
146:           if (otherHasCards && !otherSaidGo) {
147:             game.switchPlayTurn();
148:           }
149:           // Otherwise stay with current player (they continue until they can't)
150:         }),
151:       ),
152:     }),
153: 
154:       // Award last card point if not already at 31
155:       execute((ctx) => {
156:         const game = ctx.game as CribbageGame;
157:         if (game.lastPlayerToPlay >= 0 && game.runningTotal > 0 && game.runningTotal < 31) {
158:           const lastPlayer = game.players[game.lastPlayerToPlay] as CribbagePlayer;
159:           game.addPoints(lastPlayer, 1, 'Last card');
160:         }
161:         // Final reset
162:         game.resetCount();
163:       }),
164:     ),
165:   });
166: 
167:   // One complete round
168:   const playRound = sequence(
169:     // Initialize round
170:     execute((ctx) => {
171:       const game = ctx.game as CribbageGame;
172:       game.startNewRound();
173:     }),
174: 
175:     // Discard phase
176:     discardPhase,
177: 
178:     // Store original hands before play (needed for scoring after cards move)
179:     execute((ctx) => {
180:       const game = ctx.game as CribbageGame;
181:       game.storeOriginalHands();
182:     }),
183: 
184:     // Cut starter
185:     execute((ctx) => {
186:       const game = ctx.game as CribbageGame;
187:       game.cutStarterCard();
188:       if (game.isFinished()) return;
189:     }),
190: 
191:     // Play phase
192:     playPhase,
193: 
194:     // Scoring phase - score all hands and show combined summary
195:     phase('scoring', {
196:       do: sequence(
197:         execute((ctx) => {
198:           const game = ctx.game as CribbageGame;
199:           if (game.isFinished()) {
200:             game.message('Game ended during play!');
201:             return;
202:           }
203:           // Score all hands and crib, build round summary for UI
204:           game.scoreRoundAndBuildSummary();
205:         }),
206: 
207:         // Wait for acknowledgment of round summary (either player can continue)
208:         simultaneousActionStep({
209:           name: 'acknowledge-round-summary',
210:           actions: ['acknowledgeScore'],
211:           prompt: 'View round scores and continue',
212:           allDone: (ctx) => {
213:             const game = ctx.game as CribbageGame;
214:             return game.isFinished() || !game.roundSummary.active;
215:           },
216:         }),
217:       ),
218:     }),
219: 
220:     // Rotate dealer for next round
221:     execute((ctx) => {
222:       const game = ctx.game as CribbageGame;
223:       if (!game.isFinished()) {
224:         game.rotateDealer();
225:         game.crib.contentsHidden(); // Hide crib again
226:       }
227:     }),
228:   );
229: 
230:   return {
231:     root: sequence(
232:       // Initialize game
233:       execute((ctx) => {
234:         const game = ctx.game as CribbageGame;
235:         game.createDeck();
236:         game.message(`=== CRIBBAGE ===`);
237:         game.message(`First to ${game.targetScore} wins!`);
238:       }),
239: 
240:       // Main game loop
241:       loop({
242:         name: 'game-loop',
243:         while: (ctx) => {
244:           const game = ctx.game as CribbageGame;
245:           return !game.isFinished();
246:         },
247:         maxIterations: 100, // Safety limit
248:         do: playRound,
249:       }),
250: 
251:       // Game over
252:       execute((ctx) => {
253:         const game = ctx.game as CribbageGame;
254:         const winners = game.getWinners();
255:         if (winners.length > 0) {
256:           game.message(`=== GAME OVER ===`);
257:           game.message(`${winners[0].name} wins with ${winners[0].score} points!`);
258: 
259:           // Check for skunk (opponent < 91) or double skunk (< 61)
260:           const loser = game.players.find(p => !winners.includes(p as CribbagePlayer)) as CribbagePlayer;
261:           if (loser) {
262:             if (loser.score < 61) {
263:               game.message(`Double skunk! ${loser.name} didn't pass 60.`);
264:             } else if (loser.score < 91) {
265:               game.message(`Skunk! ${loser.name} didn't pass 90.`);
266:             }
267:           }
268:         }
269:       }),
270:     ),
271: 
272:     isComplete: (ctx) => {
273:       const game = ctx.game as CribbageGame;
274:       return game.isFinished();
275:     },
276: 
277:     getWinners: (ctx) => {
278:       const game = ctx.game as CribbageGame;
279:       return game.getWinners();
280:     },
281: 
282:     // Phase lifecycle hooks
283:     onEnterPhase: (phaseName, ctx) => {
284:       const game = ctx.game as CribbageGame;
285: 
286:       // Set the game's cribbagePhase property (used by actions and UI)
287:       if (phaseName === 'discarding' || phaseName === 'play' || phaseName === 'scoring') {
288:         game.cribbagePhase = phaseName;
289:       }
290: 
291:       // Announce the phase
292:       const phaseNames: Record<string, string> = {
293:         discarding: 'DISCARD PHASE',
294:         play: 'PLAY PHASE',
295:         scoring: 'SCORING PHASE',
296:       };
297:       const displayName = phaseNames[phaseName];
298:       if (displayName) {
299:         game.message(`=== ${displayName} ===`);
300:       }
301:       if (phaseName === 'discarding') {
302:         game.message('Each player must discard 2 cards to the crib');
303:       }
304:     },
305:   };
306: }
````

## File: packages/games/cribbage/rules/src/game.ts
````typescript
  1: import { Game, type GameOptions } from '@boardsmith/engine';
  2: import { Card, Hand, Crib, Deck, PlayArea, PlayedCards, StarterArea, CribbagePlayer } from './elements.js';
  3: import { createDiscardAction, createPlayCardAction, createSayGoAction, createAcknowledgeScoreAction } from './actions.js';
  4: import { createCribbageFlow } from './flow.js';
  5: import { scoreHand, scoreHandDetailed, scorePegging, type ScoreBreakdown, type DetailedScoreBreakdown } from './scoring.js';
  6: 
  7: /**
  8:  * Cribbage game options
  9:  */
 10: export interface CribbageOptions extends GameOptions {
 11:   /** Random seed for deterministic gameplay */
 12:   seed?: string;
 13:   /** Target score to win (default 121) */
 14:   targetScore?: number;
 15: }
 16: 
 17: /**
 18:  * Cribbage-specific phase tracking (separate from base Game phase)
 19:  */
 20: export type CribbagePhase = 'dealing' | 'discarding' | 'play' | 'scoring' | 'gameOver';
 21: 
 22: /**
 23:  * Cribbage game implementation
 24:  *
 25:  * Rules:
 26:  * - 2 players, race to 121 points
 27:  * - Deal 6 cards each, discard 2 to crib (dealer's)
 28:  * - Cut starter card (Jack = 2 pts "His Heels")
 29:  * - Play phase: alternate playing, count to 31, score for 15s/pairs/runs
 30:  * - Show phase: score hands (non-dealer first, then dealer, then crib)
 31:  * - Rotate dealer and repeat
 32:  */
 33: export class CribbageGame extends Game<CribbageGame, CribbagePlayer> {
 34:   /** The deck */
 35:   deck!: Deck;
 36: 
 37:   /** The crib (4 discarded cards) */
 38:   crib!: Crib;
 39: 
 40:   /** Play area for current count */
 41:   playArea!: PlayArea;
 42: 
 43:   /** Cards played this round (cleared after both players play all cards) */
 44:   playedCards!: PlayedCards;
 45: 
 46:   /** Starter card area */
 47:   starterArea!: StarterArea;
 48: 
 49:   /** Current running total during play phase */
 50:   runningTotal: number = 0;
 51: 
 52:   /** Cards played in current count sequence */
 53:   currentPlayCards: string[] = []; // Card IDs for tracking
 54: 
 55:   /** Current cribbage phase */
 56:   cribbagePhase: CribbagePhase = 'dealing';
 57: 
 58:   /** Target score to win */
 59:   targetScore: number;
 60: 
 61:   /** Current dealer position (alternates each round) */
 62:   dealerPosition: number = 0;
 63: 
 64:   /** Track who said "Go" */
 65:   playerSaidGo: boolean[] = [false, false];
 66: 
 67:   /** Last player to play a card (for "Go" and "Last card" points) */
 68:   lastPlayerToPlay: number = -1;
 69: 
 70:   /** Current player's turn during play phase (position) */
 71:   currentPlayTurn: number = 0;
 72: 
 73:   /** Current scoring animation state (for UI to animate) - DEPRECATED, use roundSummary */
 74:   scoringAnimation: {
 75:     active: boolean;
 76:     type: 'hand' | 'crib' | null;
 77:     playerPosition: number;
 78:     playerName: string;
 79:     handCards: string[];
 80:     starterCard: string | null;
 81:     items: Array<{
 82:       category: string;
 83:       points: number;
 84:       cardIds: string[];
 85:       description: string;
 86:     }>;
 87:     currentItemIndex: number;
 88:     totalPoints: number;
 89:   } = {
 90:     active: false,
 91:     type: null,
 92:     playerPosition: -1,
 93:     playerName: '',
 94:     handCards: [],
 95:     starterCard: null,
 96:     items: [],
 97:     currentItemIndex: -1,
 98:     totalPoints: 0,
 99:   };
100: 
101:   /** End-of-round summary showing all scores (for UI to display) */
102:   roundSummary: {
103:     active: boolean;
104:     starterCard: string | null;
105:     nonDealerHand: {
106:       playerName: string;
107:       playerPosition: number;
108:       cardIds: string[];
109:       items: Array<{ category: string; points: number; cardIds: string[]; description: string }>;
110:       totalPoints: number;
111:     } | null;
112:     dealerHand: {
113:       playerName: string;
114:       playerPosition: number;
115:       cardIds: string[];
116:       items: Array<{ category: string; points: number; cardIds: string[]; description: string }>;
117:       totalPoints: number;
118:     } | null;
119:     crib: {
120:       playerName: string;
121:       cardIds: string[];
122:       items: Array<{ category: string; points: number; cardIds: string[]; description: string }>;
123:       totalPoints: number;
124:     } | null;
125:     roundTotal: number;
126:   } = {
127:     active: false,
128:     starterCard: null,
129:     nonDealerHand: null,
130:     dealerHand: null,
131:     crib: null,
132:     roundTotal: 0,
133:   };
134: 
135:   /** All ranks in a standard deck */
136:   static readonly RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] as const;
137: 
138:   /** All suits in a standard deck */
139:   static readonly SUITS = ['H', 'D', 'C', 'S'] as const;
140: 
141:   constructor(options: CribbageOptions) {
142:     super(options);
143: 
144:     this.targetScore = options.targetScore ?? 121;
145: 
146:     // Register element classes
147:     this.registerElements([Card, Hand, Crib, Deck, PlayArea, PlayedCards, StarterArea]);
148: 
149:     // Create deck
150:     this.deck = this.create(Deck, 'deck');
151:     this.deck.setOrder('stacking');
152:     this.deck.contentsHidden();
153: 
154:     // Create crib
155:     this.crib = this.create(Crib, 'crib');
156:     this.crib.contentsHidden(); // Hidden until scoring
157: 
158:     // Create play area
159:     this.playArea = this.create(PlayArea, 'play-area');
160:     this.playArea.contentsVisible();
161: 
162:     // Create played cards pile
163:     this.playedCards = this.create(PlayedCards, 'played-cards');
164:     this.playedCards.contentsVisible();
165: 
166:     // Create starter area
167:     this.starterArea = this.create(StarterArea, 'starter');
168:     this.starterArea.contentsVisible();
169: 
170:     // Create hands for each player
171:     for (const player of this.players) {
172:       const hand = this.create(Hand, `hand-${player.position}`);
173:       hand.player = player;
174:       hand.contentsVisibleToOwner();
175:     }
176: 
177:     // Randomly determine first dealer (simulates cutting for deal)
178:     this.dealerPosition = this.random() < 0.5 ? 0 : 1;
179:     (this.players[this.dealerPosition] as CribbagePlayer).isDealer = true;
180: 
181:     // Register actions
182:     this.registerAction(createDiscardAction(this));
183:     this.registerAction(createPlayCardAction(this));
184:     this.registerAction(createSayGoAction(this));
185:     this.registerAction(createAcknowledgeScoreAction(this));
186: 
187:     // Set up the game flow
188:     this.setFlow(createCribbageFlow());
189:   }
190: 
191:   /**
192:    * Override to create CribbagePlayer instances
193:    */
194:   protected override createPlayer(position: number, name: string): CribbagePlayer {
195:     return new CribbagePlayer(position, name);
196:   }
197: 
198:   /**
199:    * Create a standard 52-card deck
200:    */
201:   createDeck(): void {
202:     for (const suit of CribbageGame.SUITS) {
203:       for (const rank of CribbageGame.RANKS) {
204:         this.deck.create(Card, `${rank}${suit}`, { suit, rank });
205:       }
206:     }
207:   }
208: 
209:   /**
210:    * Start a new round - shuffle and deal
211:    */
212:   startNewRound(): void {
213:     this.cribbagePhase = 'dealing';
214: 
215:     // Clear all areas
216:     this.moveAllToArea(this.crib, this.deck);
217:     this.moveAllToArea(this.playArea, this.deck);
218:     this.moveAllToArea(this.playedCards, this.deck);
219:     this.moveAllToArea(this.starterArea, this.deck);
220: 
221:     for (const player of this.players) {
222:       const hand = this.getPlayerHand(player as CribbagePlayer);
223:       this.moveAllToArea(hand, this.deck);
224:       (player as CribbagePlayer).cardsPlayedThisRound = 0;
225:     }
226: 
227:     // Shuffle
228:     this.deck.shuffle();
229: 
230:     // Deal 6 cards to each player
231:     this.dealCards();
232: 
233:     this.cribbagePhase = 'discarding';
234:     this.message(`New round! ${this.getDealer().name} is the dealer.`);
235:   }
236: 
237:   /**
238:    * Move all cards from one area to another
239:    */
240:   private moveAllToArea(from: Hand | Crib | PlayArea | PlayedCards | StarterArea, to: Deck | Hand): void {
241:     for (const card of [...from.all(Card)]) {
242:       card.putInto(to);
243:     }
244:   }
245: 
246:   /**
247:    * Deal 6 cards to each player
248:    */
249:   dealCards(): void {
250:     // Deal alternating, starting with non-dealer
251:     const nonDealer = this.getNonDealer();
252:     const dealer = this.getDealer();
253: 
254:     for (let i = 0; i < 6; i++) {
255:       // Non-dealer first
256:       const card1 = this.deck.first(Card);
257:       if (card1) {
258:         card1.putInto(this.getPlayerHand(nonDealer));
259:       }
260: 
261:       // Then dealer
262:       const card2 = this.deck.first(Card);
263:       if (card2) {
264:         card2.putInto(this.getPlayerHand(dealer));
265:       }
266:     }
267:   }
268: 
269:   /**
270:    * Get a player's hand space
271:    */
272:   getPlayerHand(player: CribbagePlayer): Hand {
273:     return this.first(Hand, `hand-${player.position}`)!;
274:   }
275: 
276:   /**
277:    * Get the dealer
278:    */
279:   getDealer(): CribbagePlayer {
280:     return this.players[this.dealerPosition] as CribbagePlayer;
281:   }
282: 
283:   /**
284:    * Get the non-dealer
285:    */
286:   getNonDealer(): CribbagePlayer {
287:     return this.players[1 - this.dealerPosition] as CribbagePlayer;
288:   }
289: 
290:   /**
291:    * Rotate dealer for next round
292:    */
293:   rotateDealer(): void {
294:     (this.players[this.dealerPosition] as CribbagePlayer).isDealer = false;
295:     this.dealerPosition = 1 - this.dealerPosition;
296:     (this.players[this.dealerPosition] as CribbagePlayer).isDealer = true;
297:   }
298: 
299:   /**
300:    * Get the current player during play phase
301:    */
302:   getCurrentPlayPlayer(): CribbagePlayer {
303:     return this.players[this.currentPlayTurn] as CribbagePlayer;
304:   }
305: 
306:   /**
307:    * Switch to the other player's turn
308:    */
309:   switchPlayTurn(): void {
310:     this.currentPlayTurn = 1 - this.currentPlayTurn;
311:   }
312: 
313:   /**
314:    * Cut the starter card
315:    */
316:   cutStarterCard(): void {
317:     const starter = this.deck.first(Card);
318:     if (starter) {
319:       starter.putInto(this.starterArea);
320:       this.message(`Starter card: ${starter.rank}${starter.suit}`);
321: 
322:       // His Heels: Jack as starter = 2 points for dealer
323:       if (starter.rank === 'J') {
324:         this.addPoints(this.getDealer(), 2, 'His Heels');
325:       }
326:     }
327:   }
328: 
329:   /**
330:    * Get the starter card
331:    */
332:   getStarterCard(): Card | null {
333:     return this.starterArea.first(Card) ?? null;
334:   }
335: 
336:   /**
337:    * Store original hand cards for each player (call after discard, before play)
338:    * This is needed because cards move during play phase but we need originals for scoring
339:    */
340:   storeOriginalHands(): void {
341:     for (const player of this.players) {
342:       const p = player as CribbagePlayer;
343:       const hand = this.getPlayerHand(p);
344:       p.originalHandCardIds = [...hand.all(Card)].map(c => c.name!);
345:     }
346:   }
347: 
348:   /**
349:    * Get a player's original hand cards (for scoring after play phase)
350:    */
351:   getOriginalHandCards(player: CribbagePlayer): Card[] {
352:     return player.originalHandCardIds
353:       .map(id => this.first(Card, id))
354:       .filter((c): c is Card => c !== undefined);
355:   }
356: 
357:   /**
358:    * Add points to a player
359:    */
360:   addPoints(player: CribbagePlayer, points: number, reason: string): void {
361:     player.score += points;
362:     this.message(`${player.name} scores ${points} (${reason}) - Total: ${player.score}`);
363: 
364:     if (player.score >= this.targetScore) {
365:       this.cribbagePhase = 'gameOver';
366:     }
367:   }
368: 
369:   /**
370:    * Check if a player can play a card without exceeding 31
371:    */
372:   canPlayCard(player: CribbagePlayer, card: Card): boolean {
373:     return this.runningTotal + card.pointValue <= 31;
374:   }
375: 
376:   /**
377:    * Get cards a player can legally play
378:    */
379:   getPlayableCards(player: CribbagePlayer): Card[] {
380:     const hand = this.getPlayerHand(player);
381:     return [...hand.all(Card)].filter(c => this.canPlayCard(player, c));
382:   }
383: 
384:   /**
385:    * Check if player must say "Go" (can't play any card)
386:    */
387:   mustSayGo(player: CribbagePlayer): boolean {
388:     return this.getPlayableCards(player).length === 0 && this.getPlayerHand(player).count(Card) > 0;
389:   }
390: 
391:   /**
392:    * Play a card during the play phase
393:    */
394:   playCard(player: CribbagePlayer, card: Card): number {
395:     const hand = this.getPlayerHand(player);
396: 
397:     // Move card to play area
398:     card.putInto(this.playArea);
399:     if (card.name) {
400:       this.currentPlayCards.push(card.name);
401:     }
402:     this.runningTotal += card.pointValue;
403:     this.lastPlayerToPlay = player.position;
404:     player.cardsPlayedThisRound++;
405: 
406:     this.message(`${player.name} plays ${card.rank}${card.suit} (count: ${this.runningTotal})`);
407: 
408:     // Score the play
409:     const playedCardsInOrder = this.currentPlayCards.map(id => this.first(Card, id)!);
410:     const score = scorePegging(playedCardsInOrder, this.runningTotal);
411: 
412:     if (score.points > 0) {
413:       this.addPoints(player, score.points, score.reasons.join(', '));
414:     }
415: 
416:     return score.points;
417:   }
418: 
419:   /**
420:    * Reset the count (after 31 or both players can't play)
421:    */
422:   resetCount(): void {
423:     // Move play area cards to played cards pile
424:     for (const card of [...this.playArea.all(Card)]) {
425:       card.putInto(this.playedCards);
426:     }
427:     this.runningTotal = 0;
428:     this.currentPlayCards = [];
429:     this.playerSaidGo = [false, false];
430:     this.message('Count reset to 0');
431:   }
432: 
433:   /**
434:    * Score a player's hand with animated reveal of each combination
435:    */
436:   scorePlayerHand(player: CribbagePlayer): DetailedScoreBreakdown {
437:     // Use original hand cards (stored before play phase) since cards have moved
438:     const handCards = this.getOriginalHandCards(player);
439:     const starter = this.getStarterCard();
440: 
441:     const score = scoreHandDetailed(handCards, starter, false);
442: 
443:     // Set up scoring animation state for UI
444:     this.scoringAnimation = {
445:       active: true,
446:       type: 'hand',
447:       playerPosition: player.position,
448:       playerName: player.name,
449:       handCards: handCards.map(c => c.name!),
450:       starterCard: starter?.name ?? null,
451:       items: score.items.map(item => ({
452:         category: item.category,
453:         points: item.points,
454:         cardIds: item.cards.map(c => c.name!),
455:         description: item.description,
456:       })),
457:       currentItemIndex: 0,
458:       totalPoints: score.total,
459:     };
460: 
461:     // Show the hand being scored (for game log)
462:     const handStr = handCards.map(c => c.toString()).join(', ');
463:     const starterStr = starter ? ` + ${starter.toString()}` : '';
464:     this.message(`${player.name}'s hand: ${handStr}${starterStr}`);
465: 
466:     // Announce each scoring combination individually (for game log)
467:     let runningTotal = 0;
468:     for (const item of score.items) {
469:       runningTotal += item.points;
470:       this.message(`  ${item.description} (${runningTotal} total)`);
471:     }
472: 
473:     // Award the total points
474:     if (score.total > 0) {
475:       this.addPoints(player, score.total, 'Hand');
476:     } else {
477:       this.message(`  No points`);
478:     }
479: 
480:     return score;
481:   }
482: 
483:   /**
484:    * Score the crib (dealer only) with animated reveal
485:    */
486:   scoreCrib(): DetailedScoreBreakdown {
487:     const cribCards = [...this.crib.all(Card)];
488:     const starter = this.getStarterCard();
489:     const dealer = this.getDealer();
490: 
491:     const score = scoreHandDetailed(cribCards, starter, true);
492: 
493:     // Set up scoring animation state for UI
494:     this.scoringAnimation = {
495:       active: true,
496:       type: 'crib',
497:       playerPosition: dealer.position,
498:       playerName: dealer.name,
499:       handCards: cribCards.map(c => c.name!),
500:       starterCard: starter?.name ?? null,
501:       items: score.items.map(item => ({
502:         category: item.category,
503:         points: item.points,
504:         cardIds: item.cards.map(c => c.name!),
505:         description: item.description,
506:       })),
507:       currentItemIndex: 0,
508:       totalPoints: score.total,
509:     };
510: 
511:     // Show the crib being scored (for game log)
512:     const cribStr = cribCards.map(c => c.toString()).join(', ');
513:     const starterStr = starter ? ` + ${starter.toString()}` : '';
514:     this.message(`${dealer.name}'s crib: ${cribStr}${starterStr}`);
515: 
516:     // Announce each scoring combination individually (for game log)
517:     let runningTotal = 0;
518:     for (const item of score.items) {
519:       runningTotal += item.points;
520:       this.message(`  ${item.description} (${runningTotal} total)`);
521:     }
522: 
523:     // Award the total points
524:     if (score.total > 0) {
525:       this.addPoints(dealer, score.total, 'Crib');
526:     } else {
527:       this.message(`  No points`);
528:     }
529: 
530:     return score;
531:   }
532: 
533:   /**
534:    * Clear the scoring animation state (called by UI when animation completes)
535:    */
536:   clearScoringAnimation(): void {
537:     this.scoringAnimation = {
538:       active: false,
539:       type: null,
540:       playerPosition: -1,
541:       playerName: '',
542:       handCards: [],
543:       starterCard: null,
544:       items: [],
545:       currentItemIndex: -1,
546:       totalPoints: 0,
547:     };
548:     // Also clear round summary
549:     this.roundSummary = {
550:       active: false,
551:       starterCard: null,
552:       nonDealerHand: null,
553:       dealerHand: null,
554:       crib: null,
555:       roundTotal: 0,
556:     };
557:   }
558: 
559:   /**
560:    * Score all hands and crib, then build round summary for UI display
561:    */
562:   scoreRoundAndBuildSummary(): void {
563:     const nonDealer = this.getNonDealer();
564:     const dealer = this.getDealer();
565:     const starter = this.getStarterCard();
566: 
567:     // Score non-dealer's hand
568:     const nonDealerCards = this.getOriginalHandCards(nonDealer);
569:     const nonDealerScore = scoreHandDetailed(nonDealerCards, starter, false);
570: 
571:     this.message(`--- ${nonDealer.name}'s hand ---`);
572:     const nonDealerHandStr = nonDealerCards.map(c => c.toString()).join(', ');
573:     this.message(`${nonDealer.name}'s hand: ${nonDealerHandStr}`);
574:     let runningTotal = 0;
575:     for (const item of nonDealerScore.items) {
576:       runningTotal += item.points;
577:       this.message(`  ${item.description} (${runningTotal} total)`);
578:     }
579:     if (nonDealerScore.total > 0) {
580:       this.addPoints(nonDealer, nonDealerScore.total, 'Hand');
581:     } else {
582:       this.message(`  No points`);
583:     }
584: 
585:     // Check for win after non-dealer scores
586:     if (this.isFinished()) {
587:       this.buildRoundSummary(nonDealerCards, nonDealerScore, null, null, null, null);
588:       return;
589:     }
590: 
591:     // Score dealer's hand
592:     const dealerCards = this.getOriginalHandCards(dealer);
593:     const dealerScore = scoreHandDetailed(dealerCards, starter, false);
594: 
595:     this.message(`--- ${dealer.name}'s hand ---`);
596:     const dealerHandStr = dealerCards.map(c => c.toString()).join(', ');
597:     this.message(`${dealer.name}'s hand: ${dealerHandStr}`);
598:     runningTotal = 0;
599:     for (const item of dealerScore.items) {
600:       runningTotal += item.points;
601:       this.message(`  ${item.description} (${runningTotal} total)`);
602:     }
603:     if (dealerScore.total > 0) {
604:       this.addPoints(dealer, dealerScore.total, 'Hand');
605:     } else {
606:       this.message(`  No points`);
607:     }
608: 
609:     // Check for win after dealer scores hand
610:     if (this.isFinished()) {
611:       this.buildRoundSummary(nonDealerCards, nonDealerScore, dealerCards, dealerScore, null, null);
612:       return;
613:     }
614: 
615:     // Score crib
616:     const cribCards = [...this.crib.all(Card)];
617:     this.crib.contentsVisible();
618:     const cribScore = scoreHandDetailed(cribCards, starter, true);
619: 
620:     this.message(`--- ${dealer.name}'s crib ---`);
621:     const cribStr = cribCards.map(c => c.toString()).join(', ');
622:     this.message(`${dealer.name}'s crib: ${cribStr}`);
623:     runningTotal = 0;
624:     for (const item of cribScore.items) {
625:       runningTotal += item.points;
626:       this.message(`  ${item.description} (${runningTotal} total)`);
627:     }
628:     if (cribScore.total > 0) {
629:       this.addPoints(dealer, cribScore.total, 'Crib');
630:     } else {
631:       this.message(`  No points`);
632:     }
633: 
634:     // Build the round summary for UI
635:     this.buildRoundSummary(nonDealerCards, nonDealerScore, dealerCards, dealerScore, cribCards, cribScore);
636:   }
637: 
638:   /**
639:    * Build the round summary state for UI display
640:    */
641:   private buildRoundSummary(
642:     nonDealerCards: Card[],
643:     nonDealerScore: DetailedScoreBreakdown,
644:     dealerCards: Card[] | null,
645:     dealerScore: DetailedScoreBreakdown | null,
646:     cribCards: Card[] | null,
647:     cribScore: DetailedScoreBreakdown | null
648:   ): void {
649:     const nonDealer = this.getNonDealer();
650:     const dealer = this.getDealer();
651:     const starter = this.getStarterCard();
652: 
653:     this.roundSummary = {
654:       active: true,
655:       starterCard: starter?.name ?? null,
656:       nonDealerHand: {
657:         playerName: nonDealer.name,
658:         playerPosition: nonDealer.position,
659:         cardIds: nonDealerCards.map(c => c.name!),
660:         items: nonDealerScore.items.map(item => ({
661:           category: item.category,
662:           points: item.points,
663:           cardIds: item.cards.map(c => c.name!),
664:           description: item.description,
665:         })),
666:         totalPoints: nonDealerScore.total,
667:       },
668:       dealerHand: dealerCards && dealerScore ? {
669:         playerName: dealer.name,
670:         playerPosition: dealer.position,
671:         cardIds: dealerCards.map(c => c.name!),
672:         items: dealerScore.items.map(item => ({
673:           category: item.category,
674:           points: item.points,
675:           cardIds: item.cards.map(c => c.name!),
676:           description: item.description,
677:         })),
678:         totalPoints: dealerScore.total,
679:       } : null,
680:       crib: cribCards && cribScore ? {
681:         playerName: dealer.name,
682:         cardIds: cribCards.map(c => c.name!),
683:         items: cribScore.items.map(item => ({
684:           category: item.category,
685:           points: item.points,
686:           cardIds: item.cards.map(c => c.name!),
687:           description: item.description,
688:         })),
689:         totalPoints: cribScore.total,
690:       } : null,
691:       roundTotal: nonDealerScore.total + (dealerScore?.total ?? 0) + (cribScore?.total ?? 0),
692:     };
693:   }
694: 
695:   /**
696:    * Check if both players have played all their cards
697:    */
698:   allCardsPlayed(): boolean {
699:     for (const player of this.players) {
700:       const hand = this.getPlayerHand(player as CribbagePlayer);
701:       if (hand.count(Card) > 0) return false;
702:     }
703:     return true;
704:   }
705: 
706:   /**
707:    * Check if the game is complete
708:    */
709:   override isFinished(): boolean {
710:     return this.cribbagePhase === 'gameOver' || this.players.some(p => (p as CribbagePlayer).score >= this.targetScore);
711:   }
712: 
713:   /**
714:    * Get the winners
715:    */
716:   override getWinners(): CribbagePlayer[] {
717:     if (!this.isFinished()) return [];
718: 
719:     // Winner is first to reach target score
720:     const winners = this.players.filter(p => (p as CribbagePlayer).score >= this.targetScore);
721:     if (winners.length > 0) {
722:       return winners as CribbagePlayer[];
723:     }
724: 
725:     // Shouldn't reach here normally
726:     return [];
727:   }
728: 
729:   /**
730:    * Get how many cards each player has discarded to crib
731:    */
732:   getDiscardCounts(): Map<number, number> {
733:     const counts = new Map<number, number>();
734:     for (const player of this.players) {
735:       const p = player as CribbagePlayer;
736:       const hand = this.getPlayerHand(p);
737:       // Started with 6, discarded = 6 - current hand size (during discard phase)
738:       // During discard, hand goes from 6 to 4
739:       counts.set(p.position, Math.max(0, 6 - hand.count(Card)));
740:     }
741:     return counts;
742:   }
743: 
744:   /**
745:    * Check if all players have finished discarding
746:    */
747:   allPlayersDiscarded(): boolean {
748:     const counts = this.getDiscardCounts();
749:     for (const count of counts.values()) {
750:       if (count < 2) return false;
751:     }
752:     return true;
753:   }
754: }
````

## File: packages/games/go-fish/rules/src/game.ts
````typescript
  1: import { Game, type GameOptions } from '@boardsmith/engine';
  2: import { Card, Hand, Pond, Books, GoFishPlayer } from './elements.js';
  3: import { createAskAction } from './actions.js';
  4: import { createGoFishFlow } from './flow.js';
  5: 
  6: /**
  7:  * Go Fish game options
  8:  */
  9: export interface GoFishOptions extends GameOptions {
 10:   /** Random seed for deterministic gameplay */
 11:   seed?: string;
 12: }
 13: 
 14: /**
 15:  * Go Fish game implementation
 16:  *
 17:  * Rules:
 18:  * - 2-3 players: 7 cards each
 19:  * - 4-6 players: 5 cards each
 20:  * - Ask another player for a rank you hold
 21:  * - If they have cards of that rank, they give all of them to you
 22:  * - If not, you "Go Fish" (draw from pond)
 23:  * - If drawn card matches requested rank, you get another turn
 24:  * - When you collect 4 of a kind, you form a "book"
 25:  * - Game ends when all 13 books are formed
 26:  * - Player with most books wins
 27:  */
 28: export class GoFishGame extends Game<GoFishGame, GoFishPlayer> {
 29:   /** The pond (draw pile) */
 30:   pond!: Pond;
 31: 
 32:   /** All ranks in a standard deck */
 33:   static readonly RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] as const;
 34: 
 35:   /** All suits in a standard deck */
 36:   static readonly SUITS = ['H', 'D', 'C', 'S'] as const;
 37: 
 38:   constructor(options: GoFishOptions) {
 39:     super(options);
 40: 
 41:     // Register element classes
 42:     this.registerElements([Card, Hand, Pond, Books]);
 43: 
 44:     // Create pond
 45:     this.pond = this.create(Pond, 'pond');
 46:     this.pond.setOrder('stacking');
 47:     this.pond.contentsHidden(); // Cards in pond are hidden from all
 48: 
 49:     // Create hands and books for each player
 50:     for (const player of this.players) {
 51:       const hand = this.create(Hand, `hand-${player.position}`);
 52:       hand.player = player;
 53:       hand.contentsVisibleToOwner(); // Only owner sees their hand
 54: 
 55:       const books = this.create(Books, `books-${player.position}`);
 56:       books.player = player;
 57:       books.contentsVisible(); // Everyone sees books
 58:     }
 59: 
 60:     // Create and shuffle the deck
 61:     this.createDeck();
 62:     this.pond.shuffle();
 63: 
 64:     // Deal cards
 65:     this.dealCards();
 66: 
 67:     // Register actions
 68:     this.registerAction(createAskAction(this));
 69: 
 70:     // Set up the game flow
 71:     this.setFlow(createGoFishFlow());
 72:   }
 73: 
 74:   /**
 75:    * Override to create GoFishPlayer instances
 76:    */
 77:   protected override createPlayer(position: number, name: string): GoFishPlayer {
 78:     return new GoFishPlayer(position, name);
 79:   }
 80: 
 81:   /**
 82:    * Create a standard 52-card deck in the pond
 83:    */
 84:   private createDeck(): void {
 85:     for (const suit of GoFishGame.SUITS) {
 86:       for (const rank of GoFishGame.RANKS) {
 87:         this.pond.create(Card, `${rank}${suit}`, { suit, rank });
 88:       }
 89:     }
 90:   }
 91: 
 92:   /**
 93:    * Deal initial cards to each player
 94:    * 2-3 players: 7 cards each
 95:    * 4-6 players: 5 cards each
 96:    */
 97:   private dealCards(): void {
 98:     const cardsPerPlayer = this.players.length <= 3 ? 7 : 5;
 99: 
100:     for (let i = 0; i < cardsPerPlayer; i++) {
101:       for (const player of this.players) {
102:         const card = this.pond.first(Card);
103:         if (card) {
104:           const hand = this.getPlayerHand(player);
105:           card.putInto(hand);
106:         }
107:       }
108:     }
109:   }
110: 
111:   /**
112:    * Get a player's hand space
113:    */
114:   getPlayerHand(player: GoFishPlayer): Hand {
115:     return this.first(Hand, `hand-${player.position}`)!;
116:   }
117: 
118:   /**
119:    * Get a player's books space
120:    */
121:   getPlayerBooks(player: GoFishPlayer): Books {
122:     return this.first(Books, `books-${player.position}`)!;
123:   }
124: 
125:   /**
126:    * Get the ranks that a player holds in their hand
127:    */
128:   getPlayerRanks(player: GoFishPlayer): string[] {
129:     const hand = this.getPlayerHand(player);
130:     const ranks = new Set<string>();
131:     for (const card of hand.all(Card)) {
132:       ranks.add(card.rank);
133:     }
134:     return Array.from(ranks).sort((a, b) => {
135:       const valueA = GoFishGame.RANKS.indexOf(a as any);
136:       const valueB = GoFishGame.RANKS.indexOf(b as any);
137:       return valueA - valueB;
138:     });
139:   }
140: 
141:   /**
142:    * Check if a player has any cards of a given rank
143:    */
144:   playerHasRank(player: GoFishPlayer, rank: string): boolean {
145:     const hand = this.getPlayerHand(player);
146:     return hand.all(Card, { rank }).length > 0;
147:   }
148: 
149:   /**
150:    * Get all cards of a rank from a player's hand
151:    */
152:   getCardsOfRank(player: GoFishPlayer, rank: string): Card[] {
153:     const hand = this.getPlayerHand(player);
154:     return [...hand.all(Card, { rank })];
155:   }
156: 
157:   /**
158:    * Check for and form books (4 of a kind) for a player
159:    * Returns the ranks that formed books
160:    */
161:   checkForBooks(player: GoFishPlayer): string[] {
162:     const hand = this.getPlayerHand(player);
163:     const books = this.getPlayerBooks(player);
164:     const formedBooks: string[] = [];
165: 
166:     // Count cards by rank
167:     const rankCounts = new Map<string, Card[]>();
168:     for (const card of hand.all(Card)) {
169:       const cards = rankCounts.get(card.rank) ?? [];
170:       cards.push(card);
171:       rankCounts.set(card.rank, cards);
172:     }
173: 
174:     // Form books for any rank with 4 cards
175:     for (const [rank, cards] of rankCounts) {
176:       if (cards.length === 4) {
177:         // Move all 4 cards to books pile
178:         for (const card of cards) {
179:           card.putInto(books);
180:         }
181:         (player as GoFishPlayer).bookCount++;
182:         formedBooks.push(rank);
183:         this.message(`${player.name} formed a book of ${rank}s!`);
184:       }
185:     }
186: 
187:     return formedBooks;
188:   }
189: 
190:   /**
191:    * Draw a card from the pond for a player
192:    * Returns the drawn card, or undefined if pond is empty
193:    */
194:   drawFromPond(player: GoFishPlayer): Card | undefined {
195:     const card = this.pond.first(Card);
196:     if (card) {
197:       const hand = this.getPlayerHand(player);
198:       card.putInto(hand);
199:     }
200:     return card;
201:   }
202: 
203:   /**
204:    * Get total number of books formed
205:    */
206:   getTotalBooks(): number {
207:     let total = 0;
208:     for (const player of this.players) {
209:       total += (player as GoFishPlayer).bookCount;
210:     }
211:     return total;
212:   }
213: 
214:   /**
215:    * Check if the game is complete (all 13 books formed)
216:    */
217:   override isFinished(): boolean {
218:     return this.getTotalBooks() >= 13;
219:   }
220: 
221:   /**
222:    * Get the winners (players with most books)
223:    */
224:   override getWinners(): GoFishPlayer[] {
225:     if (!this.isFinished()) return [];
226: 
227:     let maxBooks = 0;
228:     const winners: GoFishPlayer[] = [];
229: 
230:     for (const player of this.players) {
231:       const p = player as GoFishPlayer;
232:       if (p.bookCount > maxBooks) {
233:         maxBooks = p.bookCount;
234:         winners.length = 0;
235:         winners.push(p);
236:       } else if (p.bookCount === maxBooks) {
237:         winners.push(p);
238:       }
239:     }
240: 
241:     return winners;
242:   }
243: 
244:   /**
245:    * Check if a player can take any actions (has cards in hand or pond is not empty)
246:    */
247:   canPlayerTakeAction(player: GoFishPlayer): boolean {
248:     const hand = this.getPlayerHand(player);
249:     return hand.count(Card) > 0;
250:   }
251: }
````

## File: packages/games/hex/rules/src/game.ts
````typescript
  1: import { Game, type GameOptions } from '@boardsmith/engine';
  2: import { Board, Cell, Stone, HexPlayer } from './elements.js';
  3: import { createPlaceStoneAction } from './actions.js';
  4: import { createHexFlow } from './flow.js';
  5: 
  6: /**
  7:  * Configuration options for a Hex game
  8:  */
  9: export interface HexOptions extends GameOptions {
 10:   /** Board size (default: 7 for testing, standard is 11) */
 11:   boardSize?: number;
 12: }
 13: 
 14: /**
 15:  * Hex Game
 16:  *
 17:  * A connection game played on a rhombus-shaped hex grid.
 18:  * - Red player (0) tries to connect top to bottom (r=0 to r=size-1)
 19:  * - Blue player (1) tries to connect left to right (q=0 to q=size-1)
 20:  * - Players alternate placing one stone per turn
 21:  * - First to connect their two edges wins
 22:  * - No draws possible (mathematically proven)
 23:  */
 24: export class HexGame extends Game<HexGame, HexPlayer> {
 25:   // Game configuration
 26:   boardSize: number = 7;
 27: 
 28:   /** The game board */
 29:   board!: Board;
 30: 
 31:   /** Track the winner */
 32:   winner?: HexPlayer;
 33: 
 34:   constructor(options: HexOptions) {
 35:     super(options);
 36: 
 37:     // Apply options
 38:     this.boardSize = options.boardSize ?? 7;
 39: 
 40:     // Register element classes
 41:     this.registerElements([Board, Cell, Stone]);
 42: 
 43:     // Create the hex board
 44:     this.board = this.create(Board, 'board', {
 45:       boardSize: this.boardSize,
 46:     });
 47:     this.board.contentsVisible();
 48: 
 49:     // Create all cells in a rhombus pattern
 50:     // For a size N board, we have N rows and N columns in axial coords
 51:     for (let r = 0; r < this.boardSize; r++) {
 52:       for (let q = 0; q < this.boardSize; q++) {
 53:         const cell = this.board.create(Cell, `cell-${q}-${r}`, { q, r });
 54:         cell.contentsVisible();
 55:       }
 56:     }
 57: 
 58:     // Register actions
 59:     this.registerAction(createPlaceStoneAction(this));
 60: 
 61:     // Set up the flow
 62:     this.setFlow(createHexFlow(this));
 63: 
 64:     this.message('Hex game started!');
 65:     this.message(`Board size: ${this.boardSize}x${this.boardSize}`);
 66:     this.message('Red connects top to bottom, Blue connects left to right.');
 67:   }
 68: 
 69:   /**
 70:    * Override to create HexPlayer instances
 71:    */
 72:   protected override createPlayer(position: number, name: string): HexPlayer {
 73:     return new HexPlayer(position, name);
 74:   }
 75: 
 76:   /**
 77:    * Set the winner and mark game as finished
 78:    */
 79:   setWinner(player: HexPlayer): void {
 80:     this.winner = player;
 81:   }
 82: 
 83:   /**
 84:    * Check if the game is over
 85:    */
 86:   override isFinished(): boolean {
 87:     // Game ends when there's a winner
 88:     if (this.winner) return true;
 89: 
 90:     // Game also ends if board is full (but this shouldn't happen in Hex
 91:     // since someone always wins before the board fills)
 92:     const emptyCells = this.board.getEmptyCells();
 93:     return emptyCells.length === 0;
 94:   }
 95: 
 96:   /**
 97:    * Get the winner(s)
 98:    */
 99:   override getWinners(): HexPlayer[] {
100:     return this.winner ? [this.winner] : [];
101:   }
102: }
````

## File: packages/runtime/src/runner.ts
````typescript
  1: import {
  2:   serializeAction,
  3:   deserializeAction,
  4:   createSnapshot,
  5:   createPlayerView,
  6:   createAllPlayerViews,
  7:   type Game,
  8:   type GameOptions,
  9:   type Player,
 10:   type SerializedAction,
 11:   type ActionResult,
 12:   type FlowState,
 13:   type SerializeOptions,
 14:   type GameStateSnapshot,
 15:   type PlayerStateView,
 16: } from '@boardsmith/engine';
 17: 
 18: /**
 19:  * Options for creating a game runner
 20:  */
 21: export interface GameRunnerOptions<G extends Game> {
 22:   /** Game class constructor */
 23:   GameClass: new (options: GameOptions) => G;
 24:   /** Game type identifier */
 25:   gameType: string;
 26:   /** Options passed to game constructor */
 27:   gameOptions: GameOptions;
 28:   /** Serialization options */
 29:   serializeOptions?: SerializeOptions;
 30: }
 31: 
 32: /**
 33:  * Result of performing an action through the runner
 34:  */
 35: export interface ActionExecutionResult {
 36:   /** Whether the action succeeded */
 37:   success: boolean;
 38:   /** Error message if failed */
 39:   error?: string;
 40:   /** The serialized action (for history) */
 41:   serializedAction?: SerializedAction;
 42:   /** Updated flow state */
 43:   flowState?: FlowState;
 44:   /** Player views after the action */
 45:   playerViews?: PlayerStateView[];
 46: }
 47: 
 48: /**
 49:  * GameRunner manages game execution with action history tracking
 50:  * and provides serialization utilities for client-server sync
 51:  */
 52: export class GameRunner<G extends Game = Game> {
 53:   /** The game instance */
 54:   readonly game: G;
 55: 
 56:   /** Game type identifier */
 57:   readonly gameType: string;
 58: 
 59:   /** History of serialized actions */
 60:   readonly actionHistory: SerializedAction[] = [];
 61: 
 62:   /** Random seed (for deterministic replay) */
 63:   readonly seed?: string;
 64: 
 65:   /** Serialization options */
 66:   private readonly serializeOptions: SerializeOptions;
 67: 
 68:   constructor(options: GameRunnerOptions<G>) {
 69:     this.gameType = options.gameType;
 70:     this.seed = options.gameOptions.seed;
 71:     this.serializeOptions = options.serializeOptions ?? { useBranchPaths: true };
 72: 
 73:     this.game = new options.GameClass(options.gameOptions);
 74:   }
 75: 
 76:   /**
 77:    * Start the game flow
 78:    */
 79:   start(): FlowState {
 80:     return this.game.startFlow();
 81:   }
 82: 
 83:   /**
 84:    * Perform an action and record it in history
 85:    */
 86:   performAction(
 87:     actionName: string,
 88:     player: Player | number,
 89:     args: Record<string, unknown>
 90:   ): ActionExecutionResult {
 91:     const playerObj = typeof player === 'number'
 92:       ? this.game.players[player]
 93:       : player;
 94: 
 95:     if (!playerObj) {
 96:       return {
 97:         success: false,
 98:         error: `Player not found`,
 99:       };
100:     }
101: 
102:     const playerIndex = playerObj.position;
103: 
104:     // Check if game is awaiting input
105:     if (!this.game.isAwaitingInput()) {
106:       return {
107:         success: false,
108:         error: 'Game is not awaiting input',
109:       };
110:     }
111: 
112:     // Check if this player can act (supports both single-player and simultaneous actions)
113:     if (!this.game.canPlayerAct(playerIndex)) {
114:       return {
115:         success: false,
116:         error: `Not ${playerObj.name}'s turn`,
117:       };
118:     }
119: 
120:     // Get the action's undoable flag from its definition
121:     const actionDef = (this.game as any)._actions?.get(actionName);
122:     const isUndoable = actionDef?.undoable;
123: 
124:     // Serialize the action before executing (captures current element refs)
125:     const serializedAction = serializeAction(
126:       actionName,
127:       playerObj,
128:       args,
129:       this.game,
130:       this.serializeOptions,
131:       isUndoable
132:     );
133: 
134:     // Execute through flow (pass player index for simultaneous actions)
135:     let flowState: FlowState;
136:     try {
137:       flowState = this.game.continueFlow(actionName, args, playerIndex);
138:     } catch (error) {
139:       return {
140:         success: false,
141:         error: error instanceof Error ? error.message : String(error),
142:       };
143:     }
144: 
145:     // Record in history
146:     this.actionHistory.push(serializedAction);
147: 
148:     return {
149:       success: true,
150:       serializedAction,
151:       flowState,
152:       playerViews: createAllPlayerViews(this.game),
153:     };
154:   }
155: 
156:   /**
157:    * Get the current flow state
158:    */
159:   getFlowState(): FlowState | undefined {
160:     return this.game.getFlowState() ?? undefined;
161:   }
162: 
163:   /**
164:    * Get a complete snapshot of the game state
165:    */
166:   getSnapshot(): GameStateSnapshot {
167:     return createSnapshot(
168:       this.game,
169:       this.gameType,
170:       this.actionHistory,
171:       this.seed
172:     );
173:   }
174: 
175:   /**
176:    * Get the game state from a player's perspective
177:    */
178:   getPlayerView(playerPosition: number): PlayerStateView {
179:     return createPlayerView(this.game, playerPosition);
180:   }
181: 
182:   /**
183:    * Get views for all players
184:    */
185:   getAllPlayerViews(): PlayerStateView[] {
186:     return createAllPlayerViews(this.game);
187:   }
188: 
189:   /**
190:    * Check if the game is complete
191:    */
192:   isComplete(): boolean {
193:     return this.game.getFlowState()?.complete ?? false;
194:   }
195: 
196:   /**
197:    * Get winners (if game is complete)
198:    */
199:   getWinners(): Player[] {
200:     return this.game.getWinners();
201:   }
202: 
203:   /**
204:    * Replay a game from a list of serialized actions
205:    */
206:   static replay<G extends Game>(
207:     options: GameRunnerOptions<G>,
208:     actions: SerializedAction[]
209:   ): GameRunner<G> {
210:     const runner = new GameRunner(options);
211:     runner.start();
212: 
213:     for (const action of actions) {
214:       const { actionName, player, args } = deserializeAction(action, runner.game);
215:       const result = runner.performAction(actionName, player, args);
216: 
217:       if (!result.success) {
218:         throw new Error(`Replay failed at action ${action.name}: ${result.error}`);
219:       }
220:     }
221: 
222:     return runner;
223:   }
224: 
225:   /**
226:    * Restore a game from a snapshot
227:    * Note: This creates a new game and replays commands, not a full restore
228:    */
229:   static fromSnapshot<G extends Game>(
230:     snapshot: GameStateSnapshot,
231:     GameClass: new (options: GameOptions) => G
232:   ): GameRunner<G> {
233:     const runner = new GameRunner({
234:       GameClass,
235:       gameType: snapshot.gameType,
236:       gameOptions: {
237:         playerCount: snapshot.state.players.length,
238:         playerNames: snapshot.state.players.map(p => p.name as string),
239:         seed: snapshot.seed,
240:       },
241:     });
242: 
243:     // Replay commands to restore state
244:     runner.game.replayCommands(snapshot.commandHistory);
245: 
246:     // Restore action history
247:     runner.actionHistory.push(...snapshot.actionHistory);
248: 
249:     // Start flow and replay actions to restore flow state
250:     runner.start();
251:     for (const action of snapshot.actionHistory) {
252:       const { actionName, args } = deserializeAction(action, runner.game);
253:       runner.game.continueFlow(actionName, args);
254:     }
255: 
256:     return runner;
257:   }
258: }
````

## File: packages/session/src/index.ts
````typescript
 1: /**
 2:  * @boardsmith/session - Game session management
 3:  *
 4:  * This package provides a unified API for managing game sessions across different platforms
 5:  * (local development, Cloudflare Workers, etc.) while keeping game designers
 6:  * isolated from implementation details.
 7:  *
 8:  * @example
 9:  * ```typescript
10:  * import {
11:  *   GameSession,
12:  *   generateGameId,
13:  *   type GameDefinition,
14:  *   type StorageAdapter,
15:  *   type BroadcastAdapter,
16:  * } from '@boardsmith/session';
17:  *
18:  * // Create a game session
19:  * const session = GameSession.create({
20:  *   gameType: 'checkers',
21:  *   GameClass: CheckersGame,
22:  *   playerCount: 2,
23:  *   playerNames: ['Alice', 'Bob'],
24:  * });
25:  *
26:  * // Get state for a player
27:  * const { flowState, state } = session.getState(0);
28:  *
29:  * // Perform an action
30:  * const result = await session.performAction('move', 0, { from: 'a3', to: 'b4' });
31:  * ```
32:  */
33: 
34: // ============================================
35: // Types
36: // ============================================
37: 
38: export type {
39:   GameClass,
40:   GameDefinition,
41:   GameConfig,
42:   StoredGameState,
43:   PlayerGameState,
44:   SessionInfo,
45:   StateUpdate,
46:   AIConfig,
47:   StorageAdapter,
48:   BroadcastAdapter,
49:   CreateGameRequest,
50:   ActionRequest,
51:   WebSocketMessage,
52: } from './types.js';
53: 
54: // ============================================
55: // Utilities
56: // ============================================
57: 
58: export {
59:   generateGameId,
60:   isPlayersTurn,
61:   buildPlayerState,
62: } from './utils.js';
63: 
64: // ============================================
65: // Core Classes
66: // ============================================
67: 
68: export {
69:   GameSession,
70:   type GameSessionOptions,
71:   type ActionResult,
72:   type UndoResult,
73: } from './game-session.js';
74: 
75: export { AIController } from './ai-controller.js';
````

## File: packages/session/src/types.ts
````typescript
  1: /**
  2:  * Shared types for game hosting
  3:  */
  4: 
  5: import type { FlowState, SerializedAction, Game } from '@boardsmith/engine';
  6: 
  7: // ============================================
  8: // Game Class Types
  9: // ============================================
 10: 
 11: /**
 12:  * Game class constructor type
 13:  */
 14: export type GameClass<G extends Game = Game> = new (options: {
 15:   playerCount: number;
 16:   playerNames?: string[];
 17:   seed?: string;
 18: }) => G;
 19: 
 20: /**
 21:  * Game definition for registering games
 22:  */
 23: export interface GameDefinition {
 24:   gameClass: GameClass;
 25:   gameType: string;
 26:   minPlayers: number;
 27:   maxPlayers: number;
 28:   displayName?: string;
 29: }
 30: 
 31: /**
 32:  * Game configuration (player count limits)
 33:  */
 34: export interface GameConfig {
 35:   minPlayers: number;
 36:   maxPlayers: number;
 37: }
 38: 
 39: // ============================================
 40: // Game State Types
 41: // ============================================
 42: 
 43: /**
 44:  * Persisted game state - stored in database/storage
 45:  */
 46: export interface StoredGameState {
 47:   gameType: string;
 48:   playerCount: number;
 49:   playerNames: string[];
 50:   playerIds?: string[];
 51:   seed?: string;
 52:   actionHistory: SerializedAction[];
 53:   createdAt: number;
 54:   aiConfig?: AIConfig;
 55: }
 56: 
 57: /**
 58:  * Reference to a board element for highlighting
 59:  */
 60: export interface ElementRef {
 61:   id?: number;
 62:   name?: string;
 63:   notation?: string;
 64: }
 65: 
 66: /**
 67:  * Choice with optional board references for highlighting
 68:  */
 69: export interface ChoiceWithRefs {
 70:   value: unknown;
 71:   display: string;
 72:   /** Element reference for source highlighting (e.g., piece being moved) */
 73:   sourceRef?: ElementRef;
 74:   /** Element reference for target highlighting (e.g., destination square) */
 75:   targetRef?: ElementRef;
 76: }
 77: 
 78: /**
 79:  * Valid element for element selection
 80:  */
 81: export interface ValidElement {
 82:   id: number;
 83:   /** Display label for this element */
 84:   display?: string;
 85:   /** Element reference for board highlighting */
 86:   ref?: ElementRef;
 87: }
 88: 
 89: /**
 90:  * Filter configuration for dependent selections
 91:  */
 92: export interface SelectionFilter {
 93:   /** Key in the choice value object to filter by */
 94:   key: string;
 95:   /** Name of the previous selection to match against */
 96:   selectionName: string;
 97: }
 98: 
 99: /**
100:  * Selection metadata for auto-UI generation
101:  */
102: export interface SelectionMetadata {
103:   name: string;
104:   type: 'choice' | 'player' | 'element' | 'number' | 'text';
105:   prompt?: string;
106:   optional?: boolean;
107:   skipIfOnlyOne?: boolean;
108:   // Type-specific properties
109:   choices?: ChoiceWithRefs[];
110:   min?: number;
111:   max?: number;
112:   integer?: boolean;
113:   pattern?: string;
114:   minLength?: number;
115:   maxLength?: number;
116:   elementClassName?: string;
117:   /** For element selections: list of valid element IDs the user can select */
118:   validElements?: ValidElement[];
119:   /** For choice selections: filter choices based on a previous selection */
120:   filterBy?: SelectionFilter;
121:   /** For player selections with boardRefs: list of players with their board element references */
122:   playerChoices?: Array<{
123:     position: number;
124:     name: string;
125:     sourceRef?: ElementRef;
126:     targetRef?: ElementRef;
127:   }>;
128: }
129: 
130: /**
131:  * Action metadata for auto-UI generation
132:  */
133: export interface ActionMetadata {
134:   name: string;
135:   prompt?: string;
136:   selections: SelectionMetadata[];
137: }
138: 
139: /**
140:  * Player-facing game state - what clients receive
141:  */
142: export interface PlayerGameState {
143:   phase: string;
144:   players: Array<{ name: string; position: number }>;
145:   currentPlayer?: number;
146:   availableActions?: string[];
147:   isMyTurn: boolean;
148:   view: unknown;
149:   /** Action metadata for auto-UI generation (optional) */
150:   actionMetadata?: Record<string, ActionMetadata>;
151:   /** Whether the player can undo (has made actions this turn) */
152:   canUndo?: boolean;
153:   /** Number of actions made by this player since turn start */
154:   actionsThisTurn?: number;
155:   /** Action index where this player's current turn started */
156:   turnStartActionIndex?: number;
157: }
158: 
159: // ============================================
160: // Session Types
161: // ============================================
162: 
163: /**
164:  * Session identity for broadcasting
165:  */
166: export interface SessionInfo {
167:   playerId?: string;
168:   playerPosition: number;
169:   isSpectator: boolean;
170: }
171: 
172: /**
173:  * State update message sent to clients
174:  */
175: export interface StateUpdate {
176:   type: 'state';
177:   flowState: FlowState | undefined;
178:   state: PlayerGameState;
179:   playerPosition: number;
180:   isSpectator: boolean;
181: }
182: 
183: // ============================================
184: // AI Types
185: // ============================================
186: 
187: /**
188:  * AI player configuration
189:  */
190: export interface AIConfig {
191:   players: number[];
192:   level: string;
193: }
194: 
195: // ============================================
196: // Adapter Interfaces
197: // ============================================
198: 
199: /**
200:  * Storage adapter interface for persisting game state
201:  */
202: export interface StorageAdapter {
203:   save(state: StoredGameState): Promise<void>;
204:   load(): Promise<StoredGameState | null>;
205: }
206: 
207: /**
208:  * Broadcast adapter interface for real-time updates
209:  */
210: export interface BroadcastAdapter<TSession = SessionInfo> {
211:   getSessions(): TSession[];
212:   send(session: TSession, message: unknown): void;
213: }
214: 
215: // ============================================
216: // Request/Response Types
217: // ============================================
218: 
219: /**
220:  * Request to create a new game
221:  */
222: export interface CreateGameRequest {
223:   gameType: string;
224:   playerCount: number;
225:   playerNames?: string[];
226:   playerIds?: string[];
227:   seed?: string;
228:   aiPlayers?: number[];
229:   aiLevel?: string;
230: }
231: 
232: /**
233:  * Request to perform an action
234:  */
235: export interface ActionRequest {
236:   action: string;
237:   player: number;
238:   args: Record<string, unknown>;
239: }
240: 
241: /**
242:  * WebSocket message from client
243:  */
244: export interface WebSocketMessage {
245:   type: 'action' | 'ping' | 'getState';
246:   action?: string;
247:   args?: Record<string, unknown>;
248: }
````

## File: packages/session/src/utils.ts
````typescript
  1: /**
  2:  * Shared utility functions for game hosting
  3:  */
  4: 
  5: import type { FlowState, Game, Player, Selection, ActionDefinition } from '@boardsmith/engine';
  6: import type { GameRunner } from '@boardsmith/runtime';
  7: import type { PlayerGameState, ActionMetadata, SelectionMetadata } from './types.js';
  8: 
  9: /**
 10:  * Generate a random 8-character game ID
 11:  */
 12: export function generateGameId(): string {
 13:   const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
 14:   let id = '';
 15:   for (let i = 0; i < 8; i++) {
 16:     id += chars[Math.floor(Math.random() * chars.length)];
 17:   }
 18:   return id;
 19: }
 20: 
 21: /**
 22:  * Check if it's a specific player's turn
 23:  */
 24: export function isPlayersTurn(flowState: FlowState | undefined, playerPosition: number): boolean {
 25:   if (!flowState?.awaitingInput) return false;
 26: 
 27:   // Handle simultaneous action flows (awaitingPlayers)
 28:   if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
 29:     const playerState = flowState.awaitingPlayers.find(p => p.playerIndex === playerPosition);
 30:     return playerState ? !playerState.completed && playerState.availableActions.length > 0 : false;
 31:   }
 32: 
 33:   // Handle regular turn-based flows
 34:   return flowState.currentPlayer === playerPosition;
 35: }
 36: 
 37: /**
 38:  * Build action metadata for auto-UI generation
 39:  */
 40: export function buildActionMetadata(
 41:   game: Game,
 42:   player: Player,
 43:   availableActionNames: string[]
 44: ): Record<string, ActionMetadata> {
 45:   const metadata: Record<string, ActionMetadata> = {};
 46: 
 47:   for (const actionName of availableActionNames) {
 48:     // Access registered actions via the game's internal API
 49:     const actions = (game as any)._actions as Map<string, ActionDefinition>;
 50:     const actionDef = actions?.get(actionName);
 51: 
 52:     if (!actionDef) {
 53:       console.warn(`[buildActionMetadata] Action "${actionName}" not found in game._actions`);
 54:       continue;
 55:     }
 56: 
 57:     const selectionMetas: SelectionMetadata[] = [];
 58:     const collectedArgs: Record<string, unknown> = {};
 59: 
 60:     for (const selection of actionDef.selections) {
 61:       const selMeta = buildSelectionMetadata(game, player, selection, collectedArgs);
 62:       selectionMetas.push(selMeta);
 63:     }
 64: 
 65:     metadata[actionName] = {
 66:       name: actionName,
 67:       prompt: actionDef.prompt,
 68:       selections: selectionMetas,
 69:     };
 70:   }
 71: 
 72:   return metadata;
 73: }
 74: 
 75: /**
 76:  * Build metadata for a single selection
 77:  */
 78: function buildSelectionMetadata(
 79:   game: Game,
 80:   player: Player,
 81:   selection: Selection,
 82:   args: Record<string, unknown>
 83: ): SelectionMetadata {
 84:   const base: SelectionMetadata = {
 85:     name: selection.name,
 86:     type: selection.type,
 87:     prompt: selection.prompt,
 88:     optional: selection.optional,
 89:     skipIfOnlyOne: selection.skipIfOnlyOne,
 90:   };
 91: 
 92:   const ctx = { game, player, args };
 93: 
 94:   // Type-specific properties
 95:   switch (selection.type) {
 96:     case 'choice': {
 97:       const choiceSel = selection as any;
 98: 
 99:       // Get choices (static array or function result)
100:       let choices: unknown[];
101:       if (typeof choiceSel.choices === 'function') {
102:         try {
103:           choices = choiceSel.choices(ctx);
104:         } catch (error) {
105:           console.error(`[buildSelectionMetadata] Error getting choices for selection "${selection.name}":`, error);
106:           choices = [];
107:         }
108:       } else {
109:         choices = choiceSel.choices || [];
110:       }
111: 
112:       // Convert to display format with board refs
113:       base.choices = choices.map(value => {
114:         const choice: any = {
115:           value,
116:           display: choiceSel.display ? choiceSel.display(value) : String(value),
117:         };
118: 
119:         // Add board refs if provided
120:         if (choiceSel.boardRefs) {
121:           try {
122:             const refs = choiceSel.boardRefs(value, ctx);
123:             if (refs.sourceRef) choice.sourceRef = refs.sourceRef;
124:             if (refs.targetRef) choice.targetRef = refs.targetRef;
125:           } catch {
126:             // Ignore errors in boardRefs
127:           }
128:         }
129: 
130:         return choice;
131:       });
132: 
133:       // Add filterBy if present
134:       if (choiceSel.filterBy) {
135:         base.filterBy = choiceSel.filterBy;
136:       }
137:       break;
138:     }
139: 
140:     case 'player': {
141:       const playerSel = selection as any;
142: 
143:       // If boardRefs provided, evaluate them for each player
144:       if (playerSel.boardRefs) {
145:         const players = game.players.filter((p: Player) => {
146:           // Apply filter if provided
147:           if (playerSel.filter) {
148:             return playerSel.filter(p, ctx);
149:           }
150:           return true;
151:         });
152: 
153:         // Build player choices with their board refs
154:         // IMPORTANT: Convert to plain array first, then map to plain objects for proper JSON serialization
155:         const playerArray = Array.from(players);
156:         const choices = [];
157: 
158:         for (const p of playerArray) {
159:           try {
160:             const refs = playerSel.boardRefs(p, ctx);
161: 
162:             // Create a plain object with all properties
163:             const choice: any = {
164:               position: p.position,
165:               name: p.name,
166:             };
167: 
168:             if (refs.sourceRef) choice.sourceRef = refs.sourceRef;
169:             if (refs.targetRef) choice.targetRef = refs.targetRef;
170: 
171:             choices.push(choice);
172:           } catch (err) {
173:             choices.push({
174:               position: p.position,
175:               name: p.name,
176:             });
177:           }
178:         }
179: 
180:         base.playerChoices = choices;
181:       }
182:       break;
183:     }
184: 
185:     case 'element': {
186:       const elemSel = selection as any;
187:       if (elemSel.elementClass?.name) {
188:         base.elementClassName = elemSel.elementClass.name;
189:       }
190: 
191:       // Compute valid elements for the UI
192:       const from = typeof elemSel.from === 'function'
193:         ? elemSel.from(ctx)
194:         : elemSel.from ?? game;
195: 
196:       let elements: any[];
197:       if (elemSel.elementClass) {
198:         elements = [...from.all(elemSel.elementClass)];
199:       } else {
200:         elements = [...from.all()];
201:       }
202: 
203:       if (elemSel.filter) {
204:         elements = elements.filter((e: any) => elemSel.filter!(e, ctx));
205:       }
206: 
207:       // Build validElements list with display and refs
208:       base.validElements = elements.map((element: any) => {
209:         const validElem: any = { id: element.id };
210: 
211:         // Add display text if display function provided
212:         if (elemSel.display) {
213:           try {
214:             validElem.display = elemSel.display(element, ctx);
215:           } catch {
216:             validElem.display = element.name || String(element.id);
217:           }
218:         } else {
219:           // Default display: use element's name or notation if available
220:           validElem.display = element.notation || element.name || String(element.id);
221:         }
222: 
223:         // Add board ref if provided
224:         if (elemSel.boardRef) {
225:           try {
226:             validElem.ref = elemSel.boardRef(element, ctx);
227:           } catch {
228:             // Ignore errors
229:           }
230:         } else {
231:           // Default ref: use element ID and notation if available
232:           validElem.ref = { id: element.id };
233:           if (element.notation) {
234:             validElem.ref.notation = element.notation;
235:           }
236:         }
237: 
238:         return validElem;
239:       });
240:       break;
241:     }
242: 
243:     case 'number': {
244:       const numSel = selection as any;
245:       base.min = numSel.min;
246:       base.max = numSel.max;
247:       base.integer = numSel.integer;
248:       break;
249:     }
250: 
251:     case 'text': {
252:       const textSel = selection as any;
253:       base.pattern = textSel.pattern?.source;
254:       base.minLength = textSel.minLength;
255:       base.maxLength = textSel.maxLength;
256:       break;
257:     }
258:   }
259: 
260:   return base;
261: }
262: 
263: /**
264:  * Compute turn start action index and actions this turn for a player.
265:  * Scans action history backwards to find when the current player's turn started.
266:  * Also checks if any non-undoable action was taken this turn (disables undo).
267:  */
268: export function computeUndoInfo(
269:   actionHistory: Array<{ player: number; undoable?: boolean }>,
270:   currentPlayer: number | undefined
271: ): { turnStartActionIndex: number; actionsThisTurn: number; hasNonUndoableAction: boolean } {
272:   if (currentPlayer === undefined || actionHistory.length === 0) {
273:     return { turnStartActionIndex: 0, actionsThisTurn: 0, hasNonUndoableAction: false };
274:   }
275: 
276:   // Scan backwards through action history to find where current player's turn started
277:   // Turn started when we find an action by a DIFFERENT player
278:   let actionsThisTurn = 0;
279:   let hasNonUndoableAction = false;
280: 
281:   for (let i = actionHistory.length - 1; i >= 0; i--) {
282:     if (actionHistory[i].player === currentPlayer) {
283:       actionsThisTurn++;
284:       // Check if this action was non-undoable
285:       if (actionHistory[i].undoable === false) {
286:         hasNonUndoableAction = true;
287:       }
288:     } else {
289:       // Found action by different player - turn started after this action
290:       return { turnStartActionIndex: i + 1, actionsThisTurn, hasNonUndoableAction };
291:     }
292:   }
293: 
294:   // All actions in history are by current player - turn started at beginning
295:   return { turnStartActionIndex: 0, actionsThisTurn, hasNonUndoableAction };
296: }
297: 
298: /**
299:  * Build a player's view of the game state
300:  */
301: export function buildPlayerState(
302:   runner: GameRunner,
303:   playerNames: string[],
304:   playerPosition: number,
305:   options?: { includeActionMetadata?: boolean }
306: ): PlayerGameState {
307:   const flowState = runner.getFlowState();
308:   const view = runner.getPlayerView(playerPosition);
309: 
310:   // Get available actions - check awaitingPlayers first (for simultaneous actions)
311:   let availableActions: string[];
312:   if (flowState?.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
313:     const playerState = flowState.awaitingPlayers.find(p => p.playerIndex === playerPosition);
314:     availableActions = playerState?.availableActions ?? [];
315:   } else {
316:     availableActions = flowState?.availableActions ?? [];
317:   }
318: 
319:   const isMyTurn = isPlayersTurn(flowState, playerPosition);
320: 
321:   // Compute undo info
322:   const { turnStartActionIndex, actionsThisTurn, hasNonUndoableAction } = computeUndoInfo(
323:     runner.actionHistory,
324:     flowState?.currentPlayer
325:   );
326: 
327:   // Can undo if: it's my turn AND I've made at least one action this turn AND no non-undoable action was taken
328:   const canUndo = isMyTurn && actionsThisTurn > 0 && flowState?.currentPlayer === playerPosition && !hasNonUndoableAction;
329: 
330:   const state: PlayerGameState = {
331:     phase: runner.game.phase,
332:     players: playerNames.map((name, i) => ({ name, position: i })),
333:     currentPlayer: flowState?.currentPlayer,
334:     availableActions,
335:     isMyTurn,
336:     view: view.state,
337:     canUndo,
338:     actionsThisTurn: isMyTurn ? actionsThisTurn : 0,
339:     turnStartActionIndex: isMyTurn ? turnStartActionIndex : undefined,
340:   };
341: 
342:   // Optionally include action metadata for auto-UI
343:   if (options?.includeActionMetadata && availableActions.length > 0) {
344:     const player = runner.game.players[playerPosition];
345:     if (player) {
346:       state.actionMetadata = buildActionMetadata(runner.game, player, availableActions);
347:     }
348:   }
349: 
350:   return state;
351: }
````

## File: packages/ui/src/composables/useElementAnimation.ts
````typescript
  1: /**
  2:  * useElementAnimation - Animation composable for smooth element movements
  3:  *
  4:  * Uses requestAnimationFrame to animate elements from their old positions
  5:  * to their new positions, tracking both in real-time. This handles cases
  6:  * where the target position changes during animation (e.g., layout shifts).
  7:  *
  8:  * Usage:
  9:  * ```typescript
 10:  * const { capturePositions, animateToCurrentPositions } = useElementAnimation();
 11:  *
 12:  * // Before state change - capture where elements are now
 13:  * capturePositions(containerEl);
 14:  *
 15:  * // After state change - animate from old positions to new positions
 16:  * // Elements will track their targets if they keep moving
 17:  * animateToCurrentPositions(containerEl);
 18:  * ```
 19:  */
 20: import { ref } from 'vue';
 21: 
 22: export interface AnimationOptions {
 23:   /** Duration in milliseconds (default: 300) */
 24:   duration?: number;
 25:   /** Selector for animatable elements (default: '[data-animatable="true"]') */
 26:   selector?: string;
 27: }
 28: 
 29: const DEFAULT_DURATION = 300;
 30: const DEFAULT_SELECTOR = '[data-animatable="true"]';
 31: 
 32: // Easing function (ease-out cubic)
 33: function easeOutCubic(t: number): number {
 34:   return 1 - Math.pow(1 - t, 3);
 35: }
 36: 
 37: // Check reduced motion preference (reactive, singleton)
 38: export const prefersReducedMotion = ref(
 39:   typeof window !== 'undefined'
 40:     ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
 41:     : false
 42: );
 43: 
 44: // Listen for preference changes
 45: if (typeof window !== 'undefined') {
 46:   window.matchMedia('(prefers-reduced-motion: reduce)')
 47:     .addEventListener('change', (e) => {
 48:       prefersReducedMotion.value = e.matches;
 49:     });
 50: }
 51: 
 52: export function useElementAnimation() {
 53:   // Map of element ID -> captured start position
 54:   const positions = new Map<string | number, { left: number; top: number; width: number; height: number }>();
 55:   // Track active animations so we can cancel them
 56:   const activeAnimations = new Map<string | number, { cancel: () => void }>();
 57: 
 58:   /**
 59:    * Capture current positions of all animatable elements within a container.
 60:    * Call this BEFORE state changes.
 61:    */
 62:   function capturePositions(container: HTMLElement | null, options: AnimationOptions = {}) {
 63:     positions.clear();
 64:     if (!container) return;
 65: 
 66:     const selector = options.selector ?? DEFAULT_SELECTOR;
 67:     const elements = container.querySelectorAll(selector);
 68: 
 69:     elements.forEach((el) => {
 70:       const id = el.getAttribute('data-element-id');
 71:       if (id) {
 72:         const rect = el.getBoundingClientRect();
 73:         positions.set(id, {
 74:           left: rect.left,
 75:           top: rect.top,
 76:           width: rect.width,
 77:           height: rect.height,
 78:         });
 79:       }
 80:     });
 81:   }
 82: 
 83:   /**
 84:    * Animate elements from their captured positions to their current positions.
 85:    * Uses requestAnimationFrame to track moving targets in real-time.
 86:    * Call this AFTER state changes.
 87:    */
 88:   function animateToCurrentPositions(container: HTMLElement | null, options: AnimationOptions = {}) {
 89:     if (prefersReducedMotion.value) {
 90:       positions.clear();
 91:       return;
 92:     }
 93:     if (!container) {
 94:       positions.clear();
 95:       return;
 96:     }
 97: 
 98:     const duration = options.duration ?? DEFAULT_DURATION;
 99:     const selector = options.selector ?? DEFAULT_SELECTOR;
100:     const elements = container.querySelectorAll(selector);
101: 
102:     elements.forEach((el) => {
103:       const id = el.getAttribute('data-element-id');
104:       if (!id) return;
105: 
106:       const startPos = positions.get(id);
107:       if (!startPos) return;
108: 
109:       const htmlEl = el as HTMLElement;
110: 
111:       // Cancel any existing animation on this element
112:       const existing = activeAnimations.get(id);
113:       if (existing) {
114:         existing.cancel();
115:       }
116: 
117:       // Check if element actually moved
118:       const currentRect = htmlEl.getBoundingClientRect();
119:       const deltaX = Math.abs(startPos.left - currentRect.left);
120:       const deltaY = Math.abs(startPos.top - currentRect.top);
121: 
122:       if (deltaX < 1 && deltaY < 1) {
123:         return; // No significant movement
124:       }
125: 
126:       // Start the animation
127:       const startTime = performance.now();
128:       let animationFrameId: number;
129:       let cancelled = false;
130: 
131:       const cancel = () => {
132:         cancelled = true;
133:         if (animationFrameId) {
134:           cancelAnimationFrame(animationFrameId);
135:         }
136:         htmlEl.style.transform = '';
137:         activeAnimations.delete(id);
138:       };
139: 
140:       activeAnimations.set(id, { cancel });
141: 
142:       const capturedStartPos = startPos; // Capture for closure
143: 
144:       function animate(currentTime: number) {
145:         if (cancelled) return;
146: 
147:         const elapsed = currentTime - startTime;
148:         const rawProgress = Math.min(elapsed / duration, 1);
149:         const progress = easeOutCubic(rawProgress);
150: 
151:         // Get the element's CURRENT position in the DOM (may have moved)
152:         const currentRect = htmlEl.getBoundingClientRect();
153: 
154:         // Calculate where we want to visually appear
155:         // Interpolate from start position towards current DOM position
156:         const visualLeft = capturedStartPos.left + (currentRect.left - capturedStartPos.left) * progress;
157:         const visualTop = capturedStartPos.top + (currentRect.top - capturedStartPos.top) * progress;
158: 
159:         // Calculate the transform needed to move from current DOM position to visual position
160:         const offsetX = visualLeft - currentRect.left;
161:         const offsetY = visualTop - currentRect.top;
162: 
163:         if (Math.abs(offsetX) > 0.5 || Math.abs(offsetY) > 0.5) {
164:           htmlEl.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
165:         } else {
166:           htmlEl.style.transform = '';
167:         }
168: 
169:         if (rawProgress < 1) {
170:           animationFrameId = requestAnimationFrame(animate);
171:         } else {
172:           // Animation complete
173:           htmlEl.style.transform = '';
174:           activeAnimations.delete(id!);
175:         }
176:       }
177: 
178:       animationFrameId = requestAnimationFrame(animate);
179:     });
180: 
181:     positions.clear();
182:   }
183: 
184:   /**
185:    * Cancel all active animations
186:    */
187:   function cancelAll() {
188:     for (const { cancel } of activeAnimations.values()) {
189:       cancel();
190:     }
191:     activeAnimations.clear();
192:     positions.clear();
193:   }
194: 
195:   return {
196:     capturePositions,
197:     animateToCurrentPositions,
198:     cancelAll,
199:     prefersReducedMotion,
200:   };
201: }
````

## File: packages/ui/src/composables/useFlyingCards.ts
````typescript
  1: /**
  2:  * useFlyingCards - Composable for animating cards flying between positions
  3:  *
  4:  * Creates temporary "ghost" cards that animate from one position to another,
  5:  * optionally flipping during the animation. Useful for:
  6:  * - Discarding cards to a crib/pile
  7:  * - Dealing cards to players
  8:  * - Moving cards between zones
  9:  *
 10:  * The animation tracks moving targets in real-time using requestAnimationFrame,
 11:  * so if the target element moves during the animation, the card will follow.
 12:  *
 13:  * ## Flip Animation
 14:  *
 15:  * The `flip` option controls whether the card rotates during flight.
 16:  * The `cardData.faceUp` controls the STARTING state:
 17:  *
 18:  * - `faceUp: true` + `flip: true` → Public to Private (front → back)
 19:  *   Card starts showing front, flips to show back at end
 20:  *
 21:  * - `faceUp: false` + `flip: true` → Private to Public (back → front)
 22:  *   Card starts showing back, flips to show front at end
 23:  *
 24:  * Usage:
 25:  * ```typescript
 26:  * const { flyingCards, flyCard } = useFlyingCards();
 27:  *
 28:  * // Drawing from deck (private → public): card starts face down, flips to face up
 29:  * await flyCard({
 30:  *   id: 'draw-card',
 31:  *   startRect: deckElement.getBoundingClientRect(),
 32:  *   endRect: () => handElement.getBoundingClientRect(),
 33:  *   cardData: { rank: 'A', suit: 'S', faceUp: false },
 34:  *   flip: true,
 35:  * });
 36:  *
 37:  * // Discarding to crib (public → private): card starts face up, flips to face down
 38:  * await flyCard({
 39:  *   id: 'discard-card',
 40:  *   startRect: cardElement.getBoundingClientRect(),
 41:  *   endRect: () => cribElement.getBoundingClientRect(),
 42:  *   cardData: { rank: 'A', suit: 'S', faceUp: true },
 43:  *   flip: true,
 44:  * });
 45:  * ```
 46:  *
 47:  * In template:
 48:  * ```vue
 49:  * <FlyingCardsOverlay :flying-cards="flyingCards" />
 50:  * ```
 51:  */
 52: import { ref, computed, type ComputedRef } from 'vue';
 53: import { prefersReducedMotion } from './useElementAnimation.js';
 54: 
 55: export interface FlyingCardData {
 56:   /** Card rank (e.g., 'A', '2', 'K') */
 57:   rank?: string;
 58:   /** Card suit (e.g., 'H', 'D', 'C', 'S') */
 59:   suit?: string;
 60:   /** Whether the card starts face up */
 61:   faceUp?: boolean;
 62:   /** Any additional data for custom rendering */
 63:   [key: string]: unknown;
 64: }
 65: 
 66: export interface FlyingCard {
 67:   /** Unique identifier for this flying card */
 68:   id: string;
 69:   /** Card data for rendering */
 70:   cardData: FlyingCardData;
 71:   /** Current position/transform style */
 72:   style: {
 73:     position: 'fixed';
 74:     left: string;
 75:     top: string;
 76:     width: string;
 77:     height: string;
 78:     transform: string;
 79:     transition: string;
 80:     zIndex: number;
 81:     pointerEvents: 'none';
 82:   };
 83:   /** Whether the card is currently flipped (face down) */
 84:   isFlipped: boolean;
 85:   /** Animation progress (0-1) */
 86:   progress: number;
 87: }
 88: 
 89: export interface FlyCardOptions {
 90:   /** Unique identifier for tracking this animation */
 91:   id: string;
 92:   /** Starting position (DOMRect or element to get rect from) */
 93:   startRect: DOMRect | HTMLElement;
 94:   /** Ending position - use a function to track moving targets */
 95:   endRect: DOMRect | HTMLElement | (() => DOMRect | HTMLElement | null);
 96:   /** Card data for rendering the flying card */
 97:   cardData: FlyingCardData;
 98:   /** Whether to flip the card during flight (default: false) */
 99:   flip?: boolean;
100:   /** Animation duration in ms (default: 400) */
101:   duration?: number;
102:   /** Z-index for the flying card (default: 1000) */
103:   zIndex?: number;
104:   /** Explicit card dimensions (if not provided, uses startRect dimensions) */
105:   cardSize?: { width: number; height: number };
106: }
107: 
108: export interface FlyingCardsReturn {
109:   /** Reactive array of currently flying cards (read-only) */
110:   flyingCards: ComputedRef<FlyingCard[]>;
111:   /** Start a single card flying animation */
112:   flyCard: (options: FlyCardOptions) => Promise<void>;
113:   /** Start multiple cards flying (staggered) */
114:   flyCards: (options: FlyCardOptions[], staggerMs?: number) => Promise<void>;
115:   /** Cancel all flying animations */
116:   cancelAll: () => void;
117: }
118: 
119: const DEFAULT_DURATION = 400;
120: const DEFAULT_Z_INDEX = 1000;
121: 
122: // Easing function (ease-out cubic)
123: function easeOutCubic(t: number): number {
124:   return 1 - Math.pow(1 - t, 3);
125: }
126: 
127: function getRect(target: DOMRect | HTMLElement | (() => DOMRect | HTMLElement | null)): DOMRect | null {
128:   if (typeof target === 'function') {
129:     const result = target();
130:     if (!result) return null;
131:     return result instanceof DOMRect ? result : result.getBoundingClientRect();
132:   }
133:   return target instanceof DOMRect ? target : target.getBoundingClientRect();
134: }
135: 
136: export function useFlyingCards(): FlyingCardsReturn {
137:   const flyingCards = ref<FlyingCard[]>([]);
138:   const activeAnimations = new Map<string, { cancel: () => void }>();
139: 
140:   /**
141:    * Start a single card flying animation
142:    */
143:   async function flyCard(options: FlyCardOptions): Promise<void> {
144:     // Skip animation if reduced motion preferred
145:     if (prefersReducedMotion.value) {
146:       return;
147:     }
148: 
149:     const {
150:       id,
151:       startRect: startTarget,
152:       endRect: endTarget,
153:       cardData,
154:       flip = false,
155:       duration = DEFAULT_DURATION,
156:       zIndex = DEFAULT_Z_INDEX,
157:       cardSize,
158:     } = options;
159: 
160:     const startRect = getRect(startTarget);
161:     if (!startRect) return;
162: 
163:     // Use explicit card size if provided, otherwise use startRect dimensions
164:     const cardWidth = cardSize?.width ?? startRect.width;
165:     const cardHeight = cardSize?.height ?? startRect.height;
166: 
167:     // Calculate start position - center the card on the start rect's center
168:     const startCenterX = startRect.left + startRect.width / 2;
169:     const startCenterY = startRect.top + startRect.height / 2;
170:     const startX = startCenterX - cardWidth / 2;
171:     const startY = startCenterY - cardHeight / 2;
172: 
173:     // Determine starting flip state based on cardData.faceUp
174:     // If card starts face DOWN (faceUp=false), we start flipped so back is visible
175:     // The rotation animation (0→180) will then flip it to show the front
176:     // If card starts face UP (faceUp=true), we start not flipped so front is visible
177:     // The rotation animation (0→180) will then flip it to show the back
178:     const startFlipped = cardData.faceUp === false;
179: 
180:     // Create the flying card at start position
181:     const flyingCard: FlyingCard = {
182:       id,
183:       cardData,
184:       style: {
185:         position: 'fixed',
186:         left: `${startX}px`,
187:         top: `${startY}px`,
188:         width: `${cardWidth}px`,
189:         height: `${cardHeight}px`,
190:         transform: 'rotateY(0deg)',
191:         transition: 'none',
192:         zIndex,
193:         pointerEvents: 'none',
194:       },
195:       isFlipped: startFlipped,
196:       progress: 0,
197:     };
198: 
199:     flyingCards.value = [...flyingCards.value, flyingCard];
200: 
201:     return new Promise<void>((resolve) => {
202:       let cancelled = false;
203:       let animationFrameId: number;
204:       const startTime = performance.now();
205: 
206:       const cancel = () => {
207:         cancelled = true;
208:         if (animationFrameId) {
209:           cancelAnimationFrame(animationFrameId);
210:         }
211:         flyingCards.value = flyingCards.value.filter(c => c.id !== id);
212:         activeAnimations.delete(id);
213:         resolve();
214:       };
215: 
216:       activeAnimations.set(id, { cancel });
217: 
218:       function animate(currentTime: number) {
219:         if (cancelled) return;
220: 
221:         const elapsed = currentTime - startTime;
222:         const rawProgress = Math.min(elapsed / duration, 1);
223:         const progress = easeOutCubic(rawProgress);
224: 
225:         // Get current end position (may have moved)
226:         const endRect = getRect(endTarget);
227:         if (!endRect) {
228:           // Target disappeared, complete the animation
229:           flyingCards.value = flyingCards.value.filter(c => c.id !== id);
230:           activeAnimations.delete(id);
231:           resolve();
232:           return;
233:         }
234: 
235:         // Calculate current position (interpolate from start to current end)
236:         // Use center-to-center positioning (startCenterX/Y captured from outer scope)
237:         const endCenterX = endRect.left + endRect.width / 2;
238:         const endCenterY = endRect.top + endRect.height / 2;
239: 
240:         // Current position based on progress
241:         const currentCenterX = startCenterX + (endCenterX - startCenterX) * progress;
242:         const currentCenterY = startCenterY + (endCenterY - startCenterY) * progress;
243: 
244:         // Convert back to top-left position
245:         const currentX = currentCenterX - cardWidth / 2;
246:         const currentY = currentCenterY - cardHeight / 2;
247: 
248:         // Flip rotation
249:         const flipRotation = flip ? progress * 180 : 0;
250: 
251:         // Update the card
252:         // Note: isFlipped stays constant - it determines starting state
253:         // The rotation animation (0→180) handles the visual flip
254:         const cardIndex = flyingCards.value.findIndex(c => c.id === id);
255:         if (cardIndex >= 0) {
256:           const updated = [...flyingCards.value];
257:           updated[cardIndex] = {
258:             ...updated[cardIndex],
259:             style: {
260:               ...updated[cardIndex].style,
261:               left: `${currentX}px`,
262:               top: `${currentY}px`,
263:               transform: `rotateY(${flipRotation}deg)`,
264:             },
265:             progress,
266:           };
267:           flyingCards.value = updated;
268:         }
269: 
270:         if (rawProgress < 1) {
271:           animationFrameId = requestAnimationFrame(animate);
272:         } else {
273:           // Animation complete
274:           flyingCards.value = flyingCards.value.filter(c => c.id !== id);
275:           activeAnimations.delete(id);
276:           resolve();
277:         }
278:       }
279: 
280:       animationFrameId = requestAnimationFrame(animate);
281:     });
282:   }
283: 
284:   /**
285:    * Start multiple cards flying with optional stagger
286:    */
287:   async function flyCards(options: FlyCardOptions[], staggerMs = 50): Promise<void> {
288:     if (prefersReducedMotion.value) {
289:       return;
290:     }
291: 
292:     const promises: Promise<void>[] = [];
293: 
294:     for (let i = 0; i < options.length; i++) {
295:       if (staggerMs > 0 && i > 0) {
296:         await new Promise(r => setTimeout(r, staggerMs));
297:       }
298:       promises.push(flyCard(options[i]));
299:     }
300: 
301:     await Promise.all(promises);
302:   }
303: 
304:   /**
305:    * Cancel all active flying animations
306:    */
307:   function cancelAll(): void {
308:     for (const { cancel } of activeAnimations.values()) {
309:       cancel();
310:     }
311:     activeAnimations.clear();
312:     flyingCards.value = [];
313:   }
314: 
315:   return {
316:     flyingCards: computed(() => flyingCards.value),
317:     flyCard,
318:     flyCards,
319:     cancelAll,
320:   };
321: }
````

## File: packages/ui/src/composables/useGameGrid.ts
````typescript
  1: /**
  2:  * useGameGrid - Utilities for 2D grid-based game boards
  3:  *
  4:  * Provides helpers for working with grid-based games like Chess, Checkers,
  5:  * Go, Tic-Tac-Toe, Connect Four, etc.
  6:  *
  7:  * ## Usage
  8:  *
  9:  * ```typescript
 10:  * import { useGameGrid } from '@boardsmith/ui';
 11:  *
 12:  * const props = defineProps<{ gameView: GameElement; playerPosition: number }>();
 13:  *
 14:  * const {
 15:  *   grid,
 16:  *   getCell,
 17:  *   getCellAt,
 18:  *   getChildAt,
 19:  *   toNotation,
 20:  *   fromNotation,
 21:  *   iterateCells,
 22:  * } = useGameGrid({
 23:  *   gameView: () => props.gameView,
 24:  *   boardClassName: 'Board',
 25:  *   cellClassName: 'Square',
 26:  *   rowAttr: 'row',
 27:  *   colAttr: 'col',
 28:  * });
 29:  *
 30:  * // Get cell at position
 31:  * const cell = getCellAt(3, 4);
 32:  *
 33:  * // Get piece on a cell
 34:  * const piece = getChildAt(3, 4, 'CheckerPiece');
 35:  *
 36:  * // Convert to algebraic notation
 37:  * const notation = toNotation(0, 0); // 'a8' for chess-style
 38:  * ```
 39:  */
 40: 
 41: import { computed, type ComputedRef } from 'vue';
 42: import { findElement } from './useGameViewHelpers.js';
 43: import type { GameElement, BaseElementAttributes } from '../types.js';
 44: 
 45: // Re-export GameElement for backwards compatibility
 46: export type { GameElement };
 47: 
 48: export interface GameGridOptions {
 49:   /** Function that returns the current game view */
 50:   gameView: () => GameElement | null | undefined;
 51:   /** Class name of the board element (default: 'Board') */
 52:   boardClassName?: string;
 53:   /** Class name of cell elements (default: 'Square') */
 54:   cellClassName?: string;
 55:   /** Attribute name for row index (default: 'row') */
 56:   rowAttr?: string;
 57:   /** Attribute name for column index (default: 'col') */
 58:   colAttr?: string;
 59:   /** Number of rows (default: 8) */
 60:   rows?: number;
 61:   /** Number of columns (default: 8) */
 62:   cols?: number;
 63:   /** Whether row 0 is at the top (default: true) */
 64:   rowZeroAtTop?: boolean;
 65: }
 66: 
 67: export interface GameGridReturn<TCell = GameElement> {
 68:   /** The board element */
 69:   board: ComputedRef<GameElement | null | undefined>;
 70:   /** Map of cells keyed by "row-col" */
 71:   grid: ComputedRef<Map<string, TCell>>;
 72:   /** Get the key for a row/col position */
 73:   getKey: (row: number, col: number) => string;
 74:   /** Get cell at row/col */
 75:   getCellAt: (row: number, col: number) => TCell | undefined;
 76:   /** Get first child of a specific class at row/col */
 77:   getChildAt: (row: number, col: number, className: string) => GameElement | undefined;
 78:   /** Get all children of a specific class at row/col */
 79:   getChildrenAt: (row: number, col: number, className: string) => GameElement[];
 80:   /** Convert row/col to algebraic notation (a1-h8 style) */
 81:   toNotation: (row: number, col: number) => string;
 82:   /** Convert algebraic notation to row/col */
 83:   fromNotation: (notation: string) => { row: number; col: number } | null;
 84:   /** Iterate over all cells */
 85:   iterateCells: () => IterableIterator<[string, TCell]>;
 86:   /** Find all cells matching a predicate */
 87:   findCells: (predicate: (cell: TCell, row: number, col: number) => boolean) => TCell[];
 88:   /** Check if position is within bounds */
 89:   isInBounds: (row: number, col: number) => boolean;
 90: }
 91: 
 92: /**
 93:  * Create grid utilities for a 2D game board.
 94:  */
 95: export function useGameGrid<TCell = GameElement>(
 96:   options: GameGridOptions
 97: ): GameGridReturn<TCell> {
 98:   const {
 99:     gameView,
100:     boardClassName = 'Board',
101:     cellClassName = 'Square',
102:     rowAttr = 'row',
103:     colAttr = 'col',
104:     rows = 8,
105:     cols = 8,
106:     rowZeroAtTop = true,
107:   } = options;
108: 
109:   // Find the board element
110:   const board = computed(() => {
111:     const view = gameView();
112:     if (!view) return null;
113:     return findElement(view, { className: boardClassName });
114:   });
115: 
116:   /** Helper to get typed attributes */
117:   function getAttrs(element: GameElement): BaseElementAttributes & Record<string, unknown> {
118:     return (element.attributes ?? {}) as BaseElementAttributes & Record<string, unknown>;
119:   }
120: 
121:   // Build a map of cells keyed by "row-col"
122:   const grid = computed<Map<string, TCell>>(() => {
123:     const map = new Map<string, TCell>();
124:     if (!board.value?.children) return map;
125: 
126:     for (const child of board.value.children) {
127:       if (child.className === cellClassName) {
128:         const attrs = getAttrs(child);
129:         const row = attrs[rowAttr as keyof typeof attrs];
130:         const col = attrs[colAttr as keyof typeof attrs];
131:         if (row !== undefined && col !== undefined) {
132:           map.set(`${row}-${col}`, child as unknown as TCell);
133:         }
134:       }
135:     }
136:     return map;
137:   });
138: 
139:   function getKey(row: number, col: number): string {
140:     return `${row}-${col}`;
141:   }
142: 
143:   function getCellAt(row: number, col: number): TCell | undefined {
144:     return grid.value.get(getKey(row, col));
145:   }
146: 
147:   function getChildAt(row: number, col: number, className: string): GameElement | undefined {
148:     const cell = getCellAt(row, col) as GameElement | undefined;
149:     if (!cell?.children) return undefined;
150:     return cell.children.find((c) => c.className === className);
151:   }
152: 
153:   function getChildrenAt(row: number, col: number, className: string): GameElement[] {
154:     const cell = getCellAt(row, col) as GameElement | undefined;
155:     if (!cell?.children) return [];
156:     return cell.children.filter((c) => c.className === className);
157:   }
158: 
159:   /**
160:    * Convert row/col to algebraic notation (chess-style: a1-h8).
161:    * Column 0 = 'a', Column 7 = 'h'
162:    * Row depends on rowZeroAtTop: if true, row 0 = '8', row 7 = '1'
163:    */
164:   function toNotation(row: number, col: number): string {
165:     const colLetter = String.fromCharCode(97 + col); // a-h
166:     const rowNumber = rowZeroAtTop ? rows - row : row + 1;
167:     return `${colLetter}${rowNumber}`;
168:   }
169: 
170:   /**
171:    * Convert algebraic notation to row/col.
172:    */
173:   function fromNotation(notation: string): { row: number; col: number } | null {
174:     if (notation.length < 2) return null;
175: 
176:     const colLetter = notation[0].toLowerCase();
177:     const rowNumber = parseInt(notation.slice(1), 10);
178: 
179:     if (colLetter < 'a' || colLetter > String.fromCharCode(96 + cols)) return null;
180:     if (isNaN(rowNumber) || rowNumber < 1 || rowNumber > rows) return null;
181: 
182:     const col = colLetter.charCodeAt(0) - 97;
183:     const row = rowZeroAtTop ? rows - rowNumber : rowNumber - 1;
184: 
185:     return { row, col };
186:   }
187: 
188:   function* iterateCells(): IterableIterator<[string, TCell]> {
189:     yield* grid.value.entries();
190:   }
191: 
192:   function findCells(predicate: (cell: TCell, row: number, col: number) => boolean): TCell[] {
193:     const results: TCell[] = [];
194:     for (const [key, cell] of grid.value) {
195:       const [rowStr, colStr] = key.split('-');
196:       const row = parseInt(rowStr, 10);
197:       const col = parseInt(colStr, 10);
198:       if (predicate(cell, row, col)) {
199:         results.push(cell);
200:       }
201:     }
202:     return results;
203:   }
204: 
205:   function isInBounds(row: number, col: number): boolean {
206:     return row >= 0 && row < rows && col >= 0 && col < cols;
207:   }
208: 
209:   return {
210:     board,
211:     grid,
212:     getKey,
213:     getCellAt,
214:     getChildAt,
215:     getChildrenAt,
216:     toNotation,
217:     fromNotation,
218:     iterateCells,
219:     findCells,
220:     isInBounds,
221:   };
222: }
223: 
224: /**
225:  * Standalone algebraic notation utilities (for use without the full composable).
226:  */
227: export function toAlgebraicNotation(
228:   row: number,
229:   col: number,
230:   options: { rows?: number; rowZeroAtTop?: boolean } = {}
231: ): string {
232:   const { rows = 8, rowZeroAtTop = true } = options;
233:   const colLetter = String.fromCharCode(97 + col);
234:   const rowNumber = rowZeroAtTop ? rows - row : row + 1;
235:   return `${colLetter}${rowNumber}`;
236: }
237: 
238: export function fromAlgebraicNotation(
239:   notation: string,
240:   options: { rows?: number; cols?: number; rowZeroAtTop?: boolean } = {}
241: ): { row: number; col: number } | null {
242:   const { rows = 8, cols = 8, rowZeroAtTop = true } = options;
243: 
244:   if (notation.length < 2) return null;
245: 
246:   const colLetter = notation[0].toLowerCase();
247:   const rowNumber = parseInt(notation.slice(1), 10);
248: 
249:   if (colLetter < 'a' || colLetter > String.fromCharCode(96 + cols)) return null;
250:   if (isNaN(rowNumber) || rowNumber < 1 || rowNumber > rows) return null;
251: 
252:   const col = colLetter.charCodeAt(0) - 97;
253:   const row = rowZeroAtTop ? rows - rowNumber : rowNumber - 1;
254: 
255:   return { row, col };
256: }
````

## File: packages/ui/src/composables/useHexGrid.ts
````typescript
  1: /**
  2:  * useHexGrid - Utilities for hexagonal grid-based game boards
  3:  *
  4:  * Provides helpers for working with hex-based games like Hex, Settlers of Catan,
  5:  * Hive, and other games using hexagonal tiles.
  6:  *
  7:  * Supports both coordinate systems:
  8:  * - Axial coordinates (q, r) - most common for hex grids
  9:  * - Cube coordinates (x, y, z) where x + y + z = 0
 10:  *
 11:  * And both orientations:
 12:  * - Pointy-top (flat sides on left/right)
 13:  * - Flat-top (flat sides on top/bottom)
 14:  *
 15:  * ## Usage
 16:  *
 17:  * ```typescript
 18:  * import { useHexGrid } from '@boardsmith/ui';
 19:  *
 20:  * const props = defineProps<{ gameView: GameElement; playerPosition: number }>();
 21:  *
 22:  * const {
 23:  *   board,
 24:  *   cells,
 25:  *   hexSize,
 26:  *   getHexPosition,
 27:  *   getHexPoints,
 28:  *   hexGridBounds,
 29:  *   getCellAt,
 30:  * } = useHexGrid({
 31:  *   gameView: () => props.gameView,
 32:  *   boardClassName: 'Board',
 33:  *   cellClassName: 'Cell',
 34:  *   qAttr: 'q',
 35:  *   rAttr: 'r',
 36:  * });
 37:  *
 38:  * // Get pixel position for a hex cell
 39:  * const pos = getHexPosition(2, 3);
 40:  *
 41:  * // Get SVG polygon points for rendering
 42:  * const points = getHexPoints(); // or getHexPoints(0.85) for inner hex
 43:  * ```
 44:  */
 45: 
 46: import { computed, type ComputedRef } from 'vue';
 47: import { findElement } from './useGameViewHelpers.js';
 48: import type { GameElement, BaseElementAttributes } from '../types.js';
 49: 
 50: // Re-export GameElement for backwards compatibility
 51: export type { GameElement };
 52: 
 53: export type HexOrientation = 'pointy' | 'flat';
 54: 
 55: export interface HexGridOptions {
 56:   /** Function that returns the current game view */
 57:   gameView: () => GameElement | null | undefined;
 58:   /** Class name of the board element (default: 'Board') */
 59:   boardClassName?: string;
 60:   /** Class name of cell elements (default: 'Cell') */
 61:   cellClassName?: string;
 62:   /** Attribute name for q coordinate (default: 'q') */
 63:   qAttr?: string;
 64:   /** Attribute name for r coordinate (default: 'r') */
 65:   rAttr?: string;
 66:   /** Default hex size in pixels (default: 50, can be overridden by board attributes) */
 67:   defaultHexSize?: number;
 68:   /** Default orientation (default: 'pointy', can be overridden by board attributes) */
 69:   defaultOrientation?: HexOrientation;
 70: }
 71: 
 72: export interface HexPosition {
 73:   x: number;
 74:   y: number;
 75: }
 76: 
 77: export interface HexBounds {
 78:   minX: number;
 79:   minY: number;
 80:   width: number;
 81:   height: number;
 82: }
 83: 
 84: export interface HexGridReturn<TCell = GameElement> {
 85:   /** The board element */
 86:   board: ComputedRef<GameElement | null | undefined>;
 87:   /** All cell elements */
 88:   cells: ComputedRef<TCell[]>;
 89:   /** Current hex size (from board attributes or default) */
 90:   hexSize: ComputedRef<number>;
 91:   /** Current orientation (from board attributes or default) */
 92:   orientation: ComputedRef<HexOrientation>;
 93:   /** Map of cells keyed by "q,r" */
 94:   cellMap: ComputedRef<Map<string, TCell>>;
 95:   /** Get the key for a q/r position */
 96:   getKey: (q: number, r: number) => string;
 97:   /** Get cell at q/r coordinates */
 98:   getCellAt: (q: number, r: number) => TCell | undefined;
 99:   /** Get first child of a specific class at q/r */
100:   getChildAt: (q: number, r: number, className: string) => GameElement | undefined;
101:   /** Get all children of a specific class at q/r */
102:   getChildrenAt: (q: number, r: number, className: string) => GameElement[];
103:   /** Convert axial coordinates to pixel position */
104:   getHexPosition: (q: number, r: number) => HexPosition;
105:   /** Generate SVG polygon points for a hex (scale 1.0 = full size) */
106:   getHexPoints: (scale?: number) => string;
107:   /** Calculate SVG viewBox bounds for all cells */
108:   hexGridBounds: ComputedRef<HexBounds>;
109:   /** Convert axial to cube coordinates */
110:   axialToCube: (q: number, r: number) => { x: number; y: number; z: number };
111:   /** Convert cube to axial coordinates */
112:   cubeToAxial: (x: number, y: number, z: number) => { q: number; r: number };
113:   /** Get hex distance between two cells (in hex steps) */
114:   hexDistance: (q1: number, r1: number, q2: number, r2: number) => number;
115:   /** Get neighboring hex coordinates */
116:   getNeighbors: (q: number, r: number) => Array<{ q: number; r: number }>;
117:   /** Iterate over all cells */
118:   iterateCells: () => IterableIterator<[string, TCell]>;
119:   /** Find all cells matching a predicate */
120:   findCells: (predicate: (cell: TCell, q: number, r: number) => boolean) => TCell[];
121: }
122: 
123: // Neighbor offsets for axial coordinates
124: const POINTY_NEIGHBORS = [
125:   { q: 1, r: 0 },
126:   { q: 1, r: -1 },
127:   { q: 0, r: -1 },
128:   { q: -1, r: 0 },
129:   { q: -1, r: 1 },
130:   { q: 0, r: 1 },
131: ];
132: 
133: const FLAT_NEIGHBORS = POINTY_NEIGHBORS; // Same offsets work for both orientations
134: 
135: /**
136:  * Create hex grid utilities for a hexagonal game board.
137:  */
138: export function useHexGrid<TCell = GameElement>(
139:   options: HexGridOptions
140: ): HexGridReturn<TCell> {
141:   const {
142:     gameView,
143:     boardClassName = 'Board',
144:     cellClassName = 'Cell',
145:     qAttr = 'q',
146:     rAttr = 'r',
147:     defaultHexSize = 50,
148:     defaultOrientation = 'pointy',
149:   } = options;
150: 
151:   // Find the board element
152:   const board = computed(() => {
153:     const view = gameView();
154:     if (!view) return null;
155:     return findElement(view, { className: boardClassName });
156:   });
157: 
158:   /** Helper to get typed attributes */
159:   function getAttrs(element: GameElement): BaseElementAttributes & Record<string, unknown> {
160:     return (element.attributes ?? {}) as BaseElementAttributes & Record<string, unknown>;
161:   }
162: 
163:   // Get hex properties from board attributes
164:   const hexSize = computed(() => {
165:     if (!board.value) return defaultHexSize;
166:     const attrs = getAttrs(board.value);
167:     return attrs.$hexSize ?? defaultHexSize;
168:   });
169: 
170:   const orientation = computed<HexOrientation>(() => {
171:     if (!board.value) return defaultOrientation;
172:     const attrs = getAttrs(board.value);
173:     return attrs.$hexOrientation ?? defaultOrientation;
174:   });
175: 
176:   // Get all cells
177:   const cells = computed<TCell[]>(() => {
178:     if (!board.value?.children) return [];
179:     return board.value.children.filter(
180:       (c) => c.className === cellClassName
181:     ) as unknown as TCell[];
182:   });
183: 
184:   // Build a map of cells keyed by "q,r"
185:   const cellMap = computed<Map<string, TCell>>(() => {
186:     const map = new Map<string, TCell>();
187:     for (const cell of cells.value) {
188:       const attrs = getAttrs(cell as unknown as GameElement);
189:       const q = attrs[qAttr as keyof typeof attrs];
190:       const r = attrs[rAttr as keyof typeof attrs];
191:       if (q !== undefined && r !== undefined) {
192:         map.set(`${q},${r}`, cell);
193:       }
194:     }
195:     return map;
196:   });
197: 
198:   function getKey(q: number, r: number): string {
199:     return `${q},${r}`;
200:   }
201: 
202:   function getCellAt(q: number, r: number): TCell | undefined {
203:     return cellMap.value.get(getKey(q, r));
204:   }
205: 
206:   function getChildAt(q: number, r: number, className: string): GameElement | undefined {
207:     const cell = getCellAt(q, r) as GameElement | undefined;
208:     if (!cell?.children) return undefined;
209:     return cell.children.find((c) => c.className === className);
210:   }
211: 
212:   function getChildrenAt(q: number, r: number, className: string): GameElement[] {
213:     const cell = getCellAt(q, r) as GameElement | undefined;
214:     if (!cell?.children) return [];
215:     return cell.children.filter((c) => c.className === className);
216:   }
217: 
218:   /**
219:    * Convert axial coordinates (q, r) to pixel position.
220:    * Uses the current hexSize and orientation from board attributes.
221:    */
222:   function getHexPosition(q: number, r: number): HexPosition {
223:     const size = hexSize.value;
224:     const orient = orientation.value;
225: 
226:     if (orient === 'pointy') {
227:       return {
228:         x: size * (Math.sqrt(3) * q + (Math.sqrt(3) / 2) * r),
229:         y: size * ((3 / 2) * r),
230:       };
231:     } else {
232:       // flat-top
233:       return {
234:         x: size * ((3 / 2) * q),
235:         y: size * ((Math.sqrt(3) / 2) * q + Math.sqrt(3) * r),
236:       };
237:     }
238:   }
239: 
240:   /**
241:    * Generate SVG polygon points for a hexagon.
242:    * @param scale - Scale factor (1.0 = full size, 0.85 = inner hex for borders)
243:    */
244:   function getHexPoints(scale: number = 1): string {
245:     const size = hexSize.value * scale;
246:     const orient = orientation.value;
247:     const points: string[] = [];
248: 
249:     for (let i = 0; i < 6; i++) {
250:       const angleDeg = orient === 'pointy' ? 60 * i - 30 : 60 * i;
251:       const angleRad = (Math.PI / 180) * angleDeg;
252:       const x = size * Math.cos(angleRad);
253:       const y = size * Math.sin(angleRad);
254:       points.push(`${x},${y}`);
255:     }
256: 
257:     return points.join(' ');
258:   }
259: 
260:   /**
261:    * Calculate SVG viewBox bounds that contain all cells.
262:    */
263:   const hexGridBounds = computed<HexBounds>(() => {
264:     const cellList = cells.value;
265:     if (!cellList.length) {
266:       return { minX: 0, minY: 0, width: 400, height: 400 };
267:     }
268: 
269:     const size = hexSize.value;
270:     let minX = Infinity;
271:     let maxX = -Infinity;
272:     let minY = Infinity;
273:     let maxY = -Infinity;
274: 
275:     for (const cell of cellList) {
276:       const attrs = getAttrs(cell as unknown as GameElement);
277:       const q = (attrs[qAttr as keyof typeof attrs] as number | undefined) ?? 0;
278:       const r = (attrs[rAttr as keyof typeof attrs] as number | undefined) ?? 0;
279:       const pos = getHexPosition(q, r);
280: 
281:       minX = Math.min(minX, pos.x - size);
282:       maxX = Math.max(maxX, pos.x + size);
283:       minY = Math.min(minY, pos.y - size);
284:       maxY = Math.max(maxY, pos.y + size);
285:     }
286: 
287:     const padding = size;
288:     return {
289:       minX: minX - padding,
290:       minY: minY - padding,
291:       width: maxX - minX + padding * 2,
292:       height: maxY - minY + padding * 2,
293:     };
294:   });
295: 
296:   /**
297:    * Convert axial coordinates to cube coordinates.
298:    */
299:   function axialToCube(q: number, r: number): { x: number; y: number; z: number } {
300:     const x = q;
301:     const z = r;
302:     const y = -x - z;
303:     return { x, y, z };
304:   }
305: 
306:   /**
307:    * Convert cube coordinates to axial coordinates.
308:    */
309:   function cubeToAxial(x: number, _y: number, z: number): { q: number; r: number } {
310:     return { q: x, r: z };
311:   }
312: 
313:   /**
314:    * Calculate hex distance between two cells (number of hex steps).
315:    */
316:   function hexDistance(q1: number, r1: number, q2: number, r2: number): number {
317:     const a = axialToCube(q1, r1);
318:     const b = axialToCube(q2, r2);
319:     return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z));
320:   }
321: 
322:   /**
323:    * Get the six neighboring hex coordinates.
324:    */
325:   function getNeighbors(q: number, r: number): Array<{ q: number; r: number }> {
326:     const neighbors = orientation.value === 'pointy' ? POINTY_NEIGHBORS : FLAT_NEIGHBORS;
327:     return neighbors.map((offset) => ({
328:       q: q + offset.q,
329:       r: r + offset.r,
330:     }));
331:   }
332: 
333:   function* iterateCells(): IterableIterator<[string, TCell]> {
334:     yield* cellMap.value.entries();
335:   }
336: 
337:   function findCells(predicate: (cell: TCell, q: number, r: number) => boolean): TCell[] {
338:     const results: TCell[] = [];
339:     for (const [key, cell] of cellMap.value) {
340:       const [qStr, rStr] = key.split(',');
341:       const q = parseInt(qStr, 10);
342:       const r = parseInt(rStr, 10);
343:       if (predicate(cell, q, r)) {
344:         results.push(cell);
345:       }
346:     }
347:     return results;
348:   }
349: 
350:   return {
351:     board,
352:     cells,
353:     hexSize,
354:     orientation,
355:     cellMap,
356:     getKey,
357:     getCellAt,
358:     getChildAt,
359:     getChildrenAt,
360:     getHexPosition,
361:     getHexPoints,
362:     hexGridBounds,
363:     axialToCube,
364:     cubeToAxial,
365:     hexDistance,
366:     getNeighbors,
367:     iterateCells,
368:     findCells,
369:   };
370: }
371: 
372: /**
373:  * Standalone hex position calculation (for use without the full composable).
374:  */
375: export function hexToPixel(
376:   q: number,
377:   r: number,
378:   hexSize: number,
379:   orientation: HexOrientation = 'pointy'
380: ): HexPosition {
381:   if (orientation === 'pointy') {
382:     return {
383:       x: hexSize * (Math.sqrt(3) * q + (Math.sqrt(3) / 2) * r),
384:       y: hexSize * ((3 / 2) * r),
385:     };
386:   } else {
387:     return {
388:       x: hexSize * ((3 / 2) * q),
389:       y: hexSize * ((Math.sqrt(3) / 2) * q + Math.sqrt(3) * r),
390:     };
391:   }
392: }
393: 
394: /**
395:  * Standalone hex polygon points generation.
396:  */
397: export function getHexPolygonPoints(
398:   hexSize: number,
399:   orientation: HexOrientation = 'pointy',
400:   scale: number = 1
401: ): string {
402:   const size = hexSize * scale;
403:   const points: string[] = [];
404: 
405:   for (let i = 0; i < 6; i++) {
406:     const angleDeg = orientation === 'pointy' ? 60 * i - 30 : 60 * i;
407:     const angleRad = (Math.PI / 180) * angleDeg;
408:     const x = size * Math.cos(angleRad);
409:     const y = size * Math.sin(angleRad);
410:     points.push(`${x},${y}`);
411:   }
412: 
413:   return points.join(' ');
414: }
415: 
416: /**
417:  * Calculate hex distance between two axial coordinates.
418:  */
419: export function calculateHexDistance(q1: number, r1: number, q2: number, r2: number): number {
420:   // Convert to cube coordinates and use cube distance
421:   const x1 = q1, z1 = r1, y1 = -x1 - z1;
422:   const x2 = q2, z2 = r2, y2 = -x2 - z2;
423:   return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
424: }
````

## File: packages/worker/package.json
````json
 1: {
 2:   "name": "@boardsmith/worker",
 3:   "version": "0.1.0",
 4:   "description": "Cloudflare Worker runtime for BoardSmith - handles game hosting via Durable Objects, WebSocket connections, and KV-based matchmaking (internal package)",
 5:   "type": "module",
 6:   "main": "./dist/index.js",
 7:   "types": "./dist/index.d.ts",
 8:   "exports": {
 9:     ".": {
10:       "types": "./dist/index.d.ts",
11:       "import": "./dist/index.js"
12:     }
13:   },
14:   "scripts": {
15:     "build": "tsc"
16:   },
17:   "dependencies": {
18:     "@boardsmith/ai": "workspace:*",
19:     "@boardsmith/engine": "workspace:*",
20:     "@boardsmith/server": "workspace:*",
21:     "@boardsmith/session": "workspace:*",
22:     "@boardsmith/runtime": "workspace:*"
23:   },
24:   "devDependencies": {
25:     "@cloudflare/workers-types": "^4.20241127.0",
26:     "typescript": "^5.7.0"
27:   }
28: }
````

## File: package.json
````json
 1: {
 2:   "name": "boardsmith",
 3:   "version": "0.0.1",
 4:   "private": true,
 5:   "type": "module",
 6:   "workspaces": [
 7:     "packages/*",
 8:     "packages/games/*"
 9:   ],
10:   "scripts": {
11:     "build": "npm run build --workspaces --if-present",
12:     "test": "vitest",
13:     "test:watch": "vitest --watch",
14:     "cli": "npm run cli --workspace=@boardsmith/cli"
15:   },
16:   "devDependencies": {
17:     "@playwright/test": "^1.57.0",
18:     "@types/node": "^22.0.0",
19:     "playwright": "^1.57.0",
20:     "puppeteer": "^24.32.1",
21:     "typescript": "^5.7.0",
22:     "vitest": "^2.1.0"
23:   },
24:   "engines": {
25:     "node": ">=20"
26:   }
27: }
````

## File: packages/engine/src/action/index.ts
````typescript
 1: export { Action, ActionExecutor } from './action.js';
 2: export type {
 3:   SelectionType,
 4:   Selection,
 5:   BaseSelection,
 6:   ChoiceSelection,
 7:   PlayerSelection,
 8:   ElementSelection,
 9:   TextSelection,
10:   NumberSelection,
11:   ActionContext,
12:   ActionDefinition,
13:   ActionResult,
14:   SerializedAction,
15:   ValidationResult,
16:   BoardElementRef,
17:   ChoiceBoardRefs,
18:   DependentFilter,
19: } from './types.js';
````

## File: packages/engine/src/element/index.ts
````typescript
 1: export { GameElement } from './game-element.js';
 2: export { Space } from './space.js';
 3: export { Piece } from './piece.js';
 4: export { Card } from './card.js';
 5: export { Hand } from './hand.js';
 6: export { Deck } from './deck.js';
 7: export { Grid, GridCell } from './grid.js';
 8: export { HexGrid, HexCell } from './hex-grid.js';
 9: export { Game } from './game.js';
10: export { ElementCollection } from './element-collection.js';
11: 
12: export type {
13:   ElementClass,
14:   ElementContext,
15:   ElementTree,
16:   ElementJSON,
17:   ElementFinder,
18:   ElementAttributes,
19:   Sorter,
20: } from './types.js';
21: 
22: export type { GameOptions, GamePhase, PlayerViewFunction } from './game.js';
23: export type { ElementLayout } from './grid.js';
24: export type { HexOrientation, HexCoordSystem } from './hex-grid.js';
25: export type { LayoutDirection, LayoutAlignment } from './space.js';
````

## File: packages/games/checkers/rules/src/game.ts
````typescript
  1: import { Game, type GameOptions } from '@boardsmith/engine';
  2: import { Board, Square, CheckerPiece, CheckersPlayer, type CheckersMove } from './elements.js';
  3: import { createMoveAction, createEndTurnAction } from './actions.js';
  4: import { createCheckersFlow } from './flow.js';
  5: 
  6: /**
  7:  * Checkers game options
  8:  */
  9: export interface CheckersOptions extends GameOptions {
 10:   /** Random seed for deterministic gameplay */
 11:   seed?: string;
 12: }
 13: 
 14: /**
 15:  * American Checkers (English Draughts) implementation
 16:  *
 17:  * Rules:
 18:  * - 8x8 board, pieces on dark squares only
 19:  * - Each player starts with 12 pieces
 20:  * - Dark pieces move first
 21:  * - Regular pieces move diagonally forward only
 22:  * - Kings (crowned when reaching opposite end) move diagonally in any direction
 23:  * - Captures are mandatory - must jump if able
 24:  * - Multiple captures in one turn if available
 25:  * - Can choose which capture to make if multiple options
 26:  * - Win by capturing all opponent pieces or blocking all their moves
 27:  */
 28: export class CheckersGame extends Game<CheckersGame, CheckersPlayer> {
 29:   /** The game board */
 30:   board!: Board;
 31: 
 32:   /** Track which player must continue capturing (for multi-jump turns) */
 33:   continuingPlayer: CheckersPlayer | null = null;
 34:   continuingPiece: CheckerPiece | null = null;
 35: 
 36:   /** Track if the current player has made a move this turn (for undo/endTurn) */
 37:   hasMovedThisTurn: boolean = false;
 38: 
 39:   constructor(options: CheckersOptions) {
 40:     super(options);
 41: 
 42:     // Register element classes
 43:     this.registerElements([Board, Square, CheckerPiece]);
 44: 
 45:     // Create the board
 46:     this.board = this.create(Board, 'board');
 47:     this.board.contentsVisible();
 48: 
 49:     // Create all 64 squares
 50:     this.createSquares();
 51: 
 52:     // Place initial pieces
 53:     this.placePieces();
 54: 
 55:     // Register actions
 56:     this.registerAction(createMoveAction(this));
 57:     this.registerAction(createEndTurnAction(this));
 58: 
 59:     // Set up game flow
 60:     this.setFlow(createCheckersFlow(this));
 61:   }
 62: 
 63:   /**
 64:    * Override to create CheckersPlayer instances
 65:    */
 66:   protected override createPlayer(position: number, name: string): CheckersPlayer {
 67:     return new CheckersPlayer(position, name);
 68:   }
 69: 
 70:   /**
 71:    * Create all 64 squares on the board
 72:    */
 73:   private createSquares(): void {
 74:     for (let row = 0; row < 8; row++) {
 75:       for (let col = 0; col < 8; col++) {
 76:         // Dark squares are where (row + col) is odd
 77:         const isDark = (row + col) % 2 === 1;
 78:         // Use algebraic notation for square names (a1-h8)
 79:         const colLetter = String.fromCharCode(97 + col); // a-h
 80:         const rowNumber = 8 - row; // 1-8 (row 0 = 8, row 7 = 1)
 81:         const notation = `${colLetter}${rowNumber}`;
 82:         const square = this.board.create(Square, notation, { row, col, isDark });
 83:         square.contentsVisible();
 84:       }
 85:     }
 86:   }
 87: 
 88:   /**
 89:    * Place initial pieces on the board
 90:    * Player 0 (dark pieces) on rows 0-2
 91:    * Player 1 (light pieces) on rows 5-7
 92:    */
 93:   private placePieces(): void {
 94:     for (let row = 0; row < 8; row++) {
 95:       for (let col = 0; col < 8; col++) {
 96:         const square = this.board.getSquare(row, col);
 97:         if (!square || !square.isDark) continue;
 98: 
 99:         // Player 0 pieces on top 3 rows
100:         if (row < 3) {
101:           const piece = square.create(CheckerPiece, `p0-${row}-${col}`);
102:           piece.player = this.players[0];
103:         }
104:         // Player 1 pieces on bottom 3 rows
105:         else if (row > 4) {
106:           const piece = square.create(CheckerPiece, `p1-${row}-${col}`);
107:           piece.player = this.players[1];
108:         }
109:       }
110:     }
111:   }
112: 
113:   /**
114:    * Get all pieces belonging to a player
115:    */
116:   getPlayerPieces(player: CheckersPlayer): CheckerPiece[] {
117:     const pieces: CheckerPiece[] = [];
118:     for (const square of this.board.getDarkSquares()) {
119:       const piece = square.getPiece();
120:       if (piece && piece.player === player) {
121:         pieces.push(piece);
122:       }
123:     }
124:     return pieces;
125:   }
126: 
127:   /**
128:    * Get the square a piece is on
129:    */
130:   getPieceSquare(piece: CheckerPiece): Square | undefined {
131:     return piece.parent as Square | undefined;
132:   }
133: 
134:   /**
135:    * Check if a move is a valid simple move (non-capture)
136:    */
137:   isValidSimpleMove(piece: CheckerPiece, to: Square): boolean {
138:     const from = this.getPieceSquare(piece);
139:     if (!from || !to.isEmpty()) return false;
140: 
141:     const rowDiff = to.row - from.row;
142:     const colDiff = Math.abs(to.col - from.col);
143: 
144:     // Must move exactly 1 square diagonally
145:     if (colDiff !== 1 || Math.abs(rowDiff) !== 1) return false;
146: 
147:     // Check direction
148:     if (!piece.isKing) {
149:       // Regular pieces can only move forward
150:       if (piece.forwardDirection === 1 && rowDiff !== 1) return false;
151:       if (piece.forwardDirection === -1 && rowDiff !== -1) return false;
152:     }
153: 
154:     return true;
155:   }
156: 
157:   /**
158:    * Get all valid capture moves for a piece
159:    * Returns array of { to: Square, captured: Square }
160:    */
161:   getCaptureMoves(piece: CheckerPiece): Array<{ to: Square; captured: Square }> {
162:     const from = this.getPieceSquare(piece);
163:     if (!from) return [];
164: 
165:     const player = piece.player;
166:     if (!player) return [];
167: 
168:     const captures: Array<{ to: Square; captured: Square }> = [];
169:     const directions = piece.isKing
170:       ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
171:       : piece.forwardDirection === 1
172:         ? [[1, -1], [1, 1]]
173:         : [[-1, -1], [-1, 1]];
174: 
175:     for (const [dRow, dCol] of directions) {
176:       const midRow = from.row + dRow;
177:       const midCol = from.col + dCol;
178:       const endRow = from.row + 2 * dRow;
179:       const endCol = from.col + 2 * dCol;
180: 
181:       // Check bounds
182:       if (endRow < 0 || endRow > 7 || endCol < 0 || endCol > 7) continue;
183: 
184:       const midSquare = this.board.getSquare(midRow, midCol);
185:       const endSquare = this.board.getSquare(endRow, endCol);
186: 
187:       if (!midSquare || !endSquare) continue;
188: 
189:       // Middle square must have opponent's piece
190:       if (!midSquare.hasOpponentPiece(player)) continue;
191: 
192:       // End square must be empty
193:       if (!endSquare.isEmpty()) continue;
194: 
195:       captures.push({ to: endSquare, captured: midSquare });
196:     }
197: 
198:     return captures;
199:   }
200: 
201:   /**
202:    * Check if a player has any capture moves available
203:    */
204:   playerHasCaptures(player: CheckersPlayer): boolean {
205:     for (const piece of this.getPlayerPieces(player)) {
206:       if (this.getCaptureMoves(piece).length > 0) {
207:         return true;
208:       }
209:     }
210:     return false;
211:   }
212: 
213:   /**
214:    * Check if a player has ANY valid move (early exit optimization)
215:    * Much faster than getValidMoves().length > 0 for checking game state
216:    */
217:   hasAnyValidMove(player: CheckersPlayer): boolean {
218:     const pieces = this.getPlayerPieces(player);
219:     if (pieces.length === 0) return false;
220: 
221:     // First check for captures (mandatory) - early exit on first found
222:     for (const piece of pieces) {
223:       if (this.getCaptureMoves(piece).length > 0) {
224:         return true;
225:       }
226:     }
227: 
228:     // No captures, check for simple moves - early exit on first found
229:     for (const piece of pieces) {
230:       const from = this.getPieceSquare(piece);
231:       if (!from) continue;
232: 
233:       for (const dRow of piece.isKing ? [-1, 1] : [piece.forwardDirection]) {
234:         for (const dCol of [-1, 1]) {
235:           const toRow = from.row + dRow;
236:           const toCol = from.col + dCol;
237: 
238:           if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) continue;
239: 
240:           const to = this.board.getSquare(toRow, toCol);
241:           if (to && to.isEmpty()) {
242:             return true; // Found at least one valid move
243:           }
244:         }
245:       }
246:     }
247: 
248:     return false;
249:   }
250: 
251:   /**
252:    * Check if a specific piece has capture moves available
253:    */
254:   pieceHasCaptures(piece: CheckerPiece): boolean {
255:     return this.getCaptureMoves(piece).length > 0;
256:   }
257: 
258:   /**
259:    * Get all valid moves for a player
260:    * If captures are available, only capture moves are returned (mandatory capture rule)
261:    */
262:   getValidMoves(player: CheckersPlayer): CheckersMove[] {
263:     const moves: CheckersMove[] = [];
264:     const pieces = this.getPlayerPieces(player);
265: 
266:     // First check for captures (mandatory)
267:     let hasCaptures = false;
268:     for (const piece of pieces) {
269:       const captureMoves = this.getCaptureMoves(piece);
270:       if (captureMoves.length > 0) {
271:         hasCaptures = true;
272:         const from = this.getPieceSquare(piece)!;
273:         for (const { to, captured } of captureMoves) {
274:           const becomesKing = !piece.isKing && this.isKingRow(to.row, player);
275:           moves.push({
276:             piece,
277:             from,
278:             to,
279:             captures: [captured],
280:             becomesKing,
281:           });
282:         }
283:       }
284:     }
285: 
286:     // If captures available, must capture (return only capture moves)
287:     if (hasCaptures) return moves;
288: 
289:     // No captures, return simple moves
290:     for (const piece of pieces) {
291:       const from = this.getPieceSquare(piece);
292:       if (!from) continue;
293: 
294:       // Check all diagonally adjacent squares
295:       for (const dRow of piece.isKing ? [-1, 1] : [piece.forwardDirection]) {
296:         for (const dCol of [-1, 1]) {
297:           const toRow = from.row + dRow;
298:           const toCol = from.col + dCol;
299: 
300:           if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) continue;
301: 
302:           const to = this.board.getSquare(toRow, toCol);
303:           if (!to || !to.isEmpty()) continue;
304: 
305:           const becomesKing = !piece.isKing && this.isKingRow(to.row, player);
306:           moves.push({
307:             piece,
308:             from,
309:             to,
310:             captures: [],
311:             becomesKing,
312:           });
313:         }
314:       }
315:     }
316: 
317:     return moves;
318:   }
319: 
320:   /**
321:    * Get valid moves for a specific piece (for multi-jump continuation)
322:    */
323:   getValidMovesForPiece(piece: CheckerPiece): CheckersMove[] {
324:     const player = piece.player;
325:     if (!player) return [];
326: 
327:     const moves: CheckersMove[] = [];
328:     const captureMoves = this.getCaptureMoves(piece);
329: 
330:     if (captureMoves.length > 0) {
331:       const from = this.getPieceSquare(piece)!;
332:       for (const { to, captured } of captureMoves) {
333:         const becomesKing = !piece.isKing && this.isKingRow(to.row, player);
334:         moves.push({
335:           piece,
336:           from,
337:           to,
338:           captures: [captured],
339:           becomesKing,
340:         });
341:       }
342:     }
343: 
344:     return moves;
345:   }
346: 
347:   /**
348:    * Check if a row is the king row for a player
349:    */
350:   isKingRow(row: number, player: CheckersPlayer): boolean {
351:     // Player 0 kings at row 7, Player 1 kings at row 0
352:     return player.position === 0 ? row === 7 : row === 0;
353:   }
354: 
355:   /**
356:    * Execute a move
357:    */
358:   executeMove(move: CheckersMove): void {
359:     const { piece, from, to, captures, becomesKing } = move;
360: 
361:     // Remove captured pieces
362:     for (const capturedSquare of captures) {
363:       const capturedPiece = capturedSquare.getPiece();
364:       if (capturedPiece) {
365:         capturedPiece.remove();
366:         if (piece.player) {
367:           piece.player.capturedCount++;
368:         }
369:         this.message(`${piece.player?.name} captured a piece!`);
370:       }
371:     }
372: 
373:     // Move the piece
374:     piece.putInto(to);
375: 
376:     // Crown if reaching king row (and turn ends)
377:     if (becomesKing) {
378:       piece.crown();
379:       this.message(`${piece.player?.name}'s piece was crowned!`);
380:     }
381:   }
382: 
383:   /**
384:    * Check if the game is over
385:    * Optimized to use hasAnyValidMove() for early exit
386:    */
387:   override isFinished(): boolean {
388:     // Game is over if either player has no pieces or no valid moves
389:     for (const player of this.players) {
390:       if (!this.hasAnyValidMove(player)) return true;
391:     }
392:     return false;
393:   }
394: 
395:   /**
396:    * Get the winner(s)
397:    * Optimized to use hasAnyValidMove() instead of getValidMoves()
398:    */
399:   override getWinners(): CheckersPlayer[] {
400:     if (!this.isFinished()) return [];
401: 
402:     // Check each player - whoever has no moves loses
403:     for (const player of this.players) {
404:       if (!this.hasAnyValidMove(player)) {
405:         const opponent = this.players.find(p => p !== player);
406:         return opponent ? [opponent] : [];
407:       }
408:     }
409: 
410:     return [];
411:   }
412: 
413:   /**
414:    * Check if current player can make any move
415:    * Optimized to use hasAnyValidMove() for early exit
416:    */
417:   canCurrentPlayerMove(player: CheckersPlayer): boolean {
418:     return this.hasAnyValidMove(player);
419:   }
420: }
````

## File: packages/ui/src/composables/useBoardInteraction.ts
````typescript
  1: /**
  2:  * Board Interaction State
  3:  *
  4:  * Shared state between ActionPanel and game boards for bidirectional
  5:  * interaction. When you hover a choice in ActionPanel, the board highlights.
  6:  * When you click an element on the board, ActionPanel filters choices.
  7:  *
  8:  * Note: Board refs (sourceRefs, targetRefs) are now provided explicitly by
  9:  * the ActionPanel from the action metadata, rather than being parsed from
 10:  * choice values using regex. This makes the system work with any notation
 11:  * format, not just chess-style notation.
 12:  */
 13: import { reactive, provide, inject, type InjectionKey } from 'vue';
 14: 
 15: /**
 16:  * Reference to a board element (can match by various properties)
 17:  */
 18: export interface ElementRef {
 19:   id?: number;
 20:   name?: string;
 21:   notation?: string;
 22: }
 23: 
 24: /**
 25:  * A choice that can be highlighted on the board
 26:  */
 27: export interface HighlightableChoice {
 28:   value: unknown;
 29:   display: string;
 30:   /** Elements to highlight as source when this choice is hovered */
 31:   sourceRefs?: ElementRef[];
 32:   /** Elements to highlight as target when this choice is hovered */
 33:   targetRefs?: ElementRef[];
 34: }
 35: 
 36: /**
 37:  * Valid element for the current action selection
 38:  */
 39: export interface ValidElement {
 40:   id: number;
 41:   ref: ElementRef;
 42: }
 43: 
 44: /**
 45:  * Board interaction state
 46:  */
 47: export interface BoardInteractionState {
 48:   /** Currently hovered choice in ActionPanel */
 49:   hoveredChoice: HighlightableChoice | null;
 50: 
 51:   /** Currently selected element on the board */
 52:   selectedElement: ElementRef | null;
 53: 
 54:   /** Valid elements that can be clicked to complete the current selection */
 55:   validElements: ValidElement[];
 56: 
 57:   /** Callback to invoke when a valid element is clicked */
 58:   onElementSelect: ((elementId: number) => void) | null;
 59: 
 60:   /** Currently dragged element (for drag-and-drop actions) */
 61:   draggedElement: ElementRef | null;
 62: 
 63:   /** Valid drop targets for the dragged element */
 64:   dropTargets: ValidElement[];
 65: 
 66:   /** Whether drag mode is active */
 67:   isDragging: boolean;
 68: 
 69:   /** Element that is selected and can be dragged (for skipIfOnlyOne scenarios) */
 70:   draggableSelectedElement: ElementRef | null;
 71: }
 72: 
 73: /**
 74:  * Board interaction actions
 75:  */
 76: export interface BoardInteractionActions {
 77:   /** Set the hovered choice (called by ActionPanel) */
 78:   setHoveredChoice: (choice: HighlightableChoice | null) => void;
 79: 
 80:   /** Set the selected element (called by board) */
 81:   selectElement: (ref: ElementRef | null) => void;
 82: 
 83:   /** Set valid elements for current selection (called by ActionPanel) */
 84:   setValidElements: (elements: ValidElement[], onSelect: (elementId: number) => void) => void;
 85: 
 86:   /** Clear all interaction state */
 87:   clear: () => void;
 88: 
 89:   /** Check if an element should be highlighted (source or target) */
 90:   isHighlighted: (element: { id?: number; name?: string; notation?: string }) => boolean;
 91: 
 92:   /** Check if an element is the selected source */
 93:   isSelected: (element: { id?: number; name?: string; notation?: string }) => boolean;
 94: 
 95:   /** Check if an element is a valid target */
 96:   isValidTarget: (element: { id?: number; name?: string; notation?: string }) => boolean;
 97: 
 98:   /** Check if an element is selectable for the current action */
 99:   isSelectableElement: (element: { id?: number; name?: string; notation?: string }) => boolean;
100: 
101:   /** Trigger element selection (called by board when clicking a valid element) */
102:   triggerElementSelect: (element: { id?: number; name?: string; notation?: string }) => void;
103: 
104:   /** Start dragging an element (called by board when drag starts) */
105:   startDrag: (element: ElementRef) => void;
106: 
107:   /** End drag operation (called when drag ends or is cancelled) */
108:   endDrag: () => void;
109: 
110:   /** Set valid drop targets for current drag operation */
111:   setDropTargets: (targets: ValidElement[], onDrop: (elementId: number) => void) => void;
112: 
113:   /** Check if an element is a valid drop target */
114:   isDropTarget: (element: { id?: number; name?: string; notation?: string }) => boolean;
115: 
116:   /** Check if an element is the currently dragged element */
117:   isDraggedElement: (element: { id?: number; name?: string; notation?: string }) => boolean;
118: 
119:   /** Trigger drop on target (called by board when element is dropped) */
120:   triggerDrop: (target: { id?: number; name?: string; notation?: string }) => void;
121: 
122:   /** Set the element that is selected and can be dragged (for skipIfOnlyOne) */
123:   setDraggableSelectedElement: (element: ElementRef | null) => void;
124: 
125:   /** Check if an element is the draggable selected element */
126:   isDraggableSelectedElement: (element: { id?: number; name?: string; notation?: string }) => boolean;
127: }
128: 
129: export type BoardInteraction = BoardInteractionState & BoardInteractionActions;
130: 
131: const BOARD_INTERACTION_KEY: InjectionKey<BoardInteraction> = Symbol('boardInteraction');
132: 
133: /**
134:  * Create board interaction state (call in GameShell)
135:  */
136: export function createBoardInteraction(): BoardInteraction {
137:   const state = reactive<BoardInteractionState>({
138:     hoveredChoice: null,
139:     selectedElement: null,
140:     validElements: [],
141:     onElementSelect: null,
142:     draggedElement: null,
143:     dropTargets: [],
144:     isDragging: false,
145:     draggableSelectedElement: null,
146:   });
147: 
148:   // Callback for when element is dropped on valid target
149:   let onDropCallback: ((elementId: number) => void) | null = null;
150: 
151:   function matchesRef(element: { id?: number; name?: string; notation?: string }, ref: ElementRef): boolean {
152:     if (ref.id !== undefined && element.id === ref.id) return true;
153:     if (ref.name && element.name === ref.name) return true;
154:     if (ref.notation && element.notation === ref.notation) return true;
155:     return false;
156:   }
157: 
158:   function matchesAnyRef(element: { id?: number; name?: string; notation?: string }, refs: ElementRef[]): boolean {
159:     return refs.some(ref => matchesRef(element, ref));
160:   }
161: 
162:   const actions: BoardInteractionActions = {
163:     setHoveredChoice(choice) {
164:       state.hoveredChoice = choice;
165:     },
166: 
167:     selectElement(ref) {
168:       // Clear any previous hover state when selecting
169:       state.hoveredChoice = null;
170:       state.selectedElement = ref;
171:     },
172: 
173:     setValidElements(elements, onSelect) {
174:       state.validElements = elements;
175:       state.onElementSelect = onSelect;
176:     },
177: 
178:     clear() {
179:       state.hoveredChoice = null;
180:       state.selectedElement = null;
181:       state.validElements = [];
182:       state.onElementSelect = null;
183:       state.draggedElement = null;
184:       state.dropTargets = [];
185:       state.isDragging = false;
186:       state.draggableSelectedElement = null;
187:       onDropCallback = null;
188:     },
189: 
190:     isHighlighted(element) {
191:       if (!state.hoveredChoice) return false;
192:       const { sourceRefs = [], targetRefs = [] } = state.hoveredChoice;
193:       return matchesAnyRef(element, [...sourceRefs, ...targetRefs]);
194:     },
195: 
196:     isSelected(element) {
197:       if (!state.selectedElement) return false;
198:       return matchesRef(element, state.selectedElement);
199:     },
200: 
201:     isValidTarget(element) {
202:       // Check if this element is a target in the hovered choice
203:       if (!state.hoveredChoice?.targetRefs) return false;
204:       return matchesAnyRef(element, state.hoveredChoice.targetRefs);
205:     },
206: 
207:     isSelectableElement(element) {
208:       // Check if this element is in the valid elements list
209:       return state.validElements.some(ve => matchesRef(element, ve.ref));
210:     },
211: 
212:     triggerElementSelect(element) {
213:       // Find the matching valid element and trigger the callback
214:       const validElem = state.validElements.find(ve => matchesRef(element, ve.ref));
215:       if (validElem && state.onElementSelect) {
216:         state.onElementSelect(validElem.id);
217:       }
218:     },
219: 
220:     startDrag(element) {
221:       state.draggedElement = element;
222:       state.isDragging = true;
223:       // Clear hover state when starting drag
224:       state.hoveredChoice = null;
225:     },
226: 
227:     endDrag() {
228:       state.draggedElement = null;
229:       state.isDragging = false;
230:       state.dropTargets = [];
231:       onDropCallback = null;
232:     },
233: 
234:     setDropTargets(targets, onDrop) {
235:       state.dropTargets = targets;
236:       onDropCallback = onDrop;
237:     },
238: 
239:     isDropTarget(element) {
240:       if (!state.isDragging) return false;
241:       return state.dropTargets.some(dt => matchesRef(element, dt.ref));
242:     },
243: 
244:     isDraggedElement(element) {
245:       if (!state.draggedElement) return false;
246:       return matchesRef(element, state.draggedElement);
247:     },
248: 
249:     triggerDrop(target) {
250:       // Find the matching drop target and trigger the callback
251:       const dropTarget = state.dropTargets.find(dt => matchesRef(target, dt.ref));
252:       if (dropTarget && onDropCallback) {
253:         onDropCallback(dropTarget.id);
254:         // End drag after successful drop
255:         this.endDrag();
256:       }
257:     },
258: 
259:     setDraggableSelectedElement(element) {
260:       state.draggableSelectedElement = element;
261:     },
262: 
263:     isDraggableSelectedElement(element) {
264:       if (!state.draggableSelectedElement) return false;
265:       return matchesRef(element, state.draggableSelectedElement);
266:     },
267:   };
268: 
269:   // Merge actions into the state object to maintain reactivity
270:   // (spreading would copy values, breaking reactive updates)
271:   return Object.assign(state, actions) as unknown as BoardInteraction;
272: }
273: 
274: /**
275:  * Provide board interaction (call in GameShell setup)
276:  */
277: export function provideBoardInteraction(interaction: BoardInteraction): void {
278:   provide(BOARD_INTERACTION_KEY, interaction);
279: }
280: 
281: /**
282:  * Use board interaction (call in ActionPanel or game board)
283:  */
284: export function useBoardInteraction(): BoardInteraction | undefined {
285:   return inject(BOARD_INTERACTION_KEY);
286: }
````

## File: packages/ui/src/composables/useElementChangeTracker.ts
````typescript
  1: /**
  2:  * useElementChangeTracker - Track changes to game elements over time
  3:  *
  4:  * Provides utilities for tracking when elements are added/removed from the game,
  5:  * capturing DOM positions before changes, and detecting deltas between states.
  6:  *
  7:  * This is useful for:
  8:  * - Flying cards from source to destination when cards are dealt
  9:  * - Detecting when cards leave a hand (e.g., for book formation animations)
 10:  * - Animating captured pieces in checkers/chess
 11:  * - Tracking counts (e.g., opponent card count, deck count)
 12:  *
 13:  * ## Basic Usage (Cards)
 14:  *
 15:  * ```typescript
 16:  * import { useElementChangeTracker } from '@boardsmith/ui';
 17:  *
 18:  * const handRef = ref<HTMLElement | null>(null);
 19:  *
 20:  * const {
 21:  *   prevIds,
 22:  *   positions,
 23:  *   capturePositions,
 24:  *   getAddedIds,
 25:  *   getRemovedIds,
 26:  *   updateIds,
 27:  * } = useElementChangeTracker({
 28:  *   containerRef: handRef,
 29:  *   selector: '[data-card-id]',
 30:  *   getElementId: (el) => parseInt(el.getAttribute('data-card-id') || '0', 10),
 31:  * });
 32:  * ```
 33:  *
 34:  * ## With Element Metadata (Checkers Example)
 35:  *
 36:  * Track piece ownership so you can animate captured pieces correctly:
 37:  *
 38:  * ```typescript
 39:  * const { positions, capturePositions } = useElementChangeTracker({
 40:  *   containerRef: boardRef,
 41:  *   selector: '[data-piece-id]',
 42:  *   getElementId: (el) => parseInt(el.getAttribute('data-piece-id') || '0', 10),
 43:  *   getElementData: (el) => ({
 44:  *     // Track which player owns this piece (dark = 0, light = 1)
 45:  *     playerPosition: el.classList.contains('dark') ? 0 : 1,
 46:  *     isKing: el.classList.contains('king'),
 47:  *   }),
 48:  * });
 49:  *
 50:  * // Later, when detecting captures:
 51:  * const pieceData = positions.value.get(capturedId);
 52:  * // pieceData.rect - position for animation
 53:  * // pieceData.playerPosition - owner for correct styling
 54:  * ```
 55:  */
 56: 
 57: import { ref, type Ref } from 'vue';
 58: 
 59: export interface ElementPositionData {
 60:   /** Bounding rectangle of the element */
 61:   rect: DOMRect;
 62:   /** Any additional data captured from the element */
 63:   [key: string]: DOMRect | string | number | boolean | undefined;
 64: }
 65: 
 66: 
 67: export interface ElementChangeTrackerOptions<T = number> {
 68:   /** Ref to the container element to query for elements */
 69:   containerRef: Ref<HTMLElement | null>;
 70:   /** CSS selector to find elements (default: '[data-card-id]') */
 71:   selector?: string;
 72:   /** Function to extract ID from an element */
 73:   getElementId: (el: Element) => T;
 74:   /** Optional function to extract additional data from an element (e.g., ownership, type) */
 75:   getElementData?: (el: Element) => Omit<ElementPositionData, 'rect'>;
 76: }
 77: 
 78: export interface ElementChangeTrackerReturn<T = number> {
 79:   /** Previous set of element IDs (before state change) */
 80:   prevIds: Ref<Set<T>>;
 81:   /** Map of captured positions keyed by element ID */
 82:   positions: Ref<Map<T, ElementPositionData>>;
 83:   /** Capture current positions from DOM */
 84:   capturePositions: () => void;
 85:   /** Get IDs that were added (in current but not in previous) */
 86:   getAddedIds: (prevSnapshot: Set<T>, current: Set<T>) => Set<T>;
 87:   /** Get IDs that were removed (in previous but not in current) */
 88:   getRemovedIds: (prevSnapshot: Set<T>, current: Set<T>) => Set<T>;
 89:   /** Update the prevIds ref with new values */
 90:   updateIds: (ids: Set<T>) => void;
 91:   /** Clear all tracking state */
 92:   reset: () => void;
 93:   /** Check if tracking has been initialized */
 94:   isInitialized: Ref<boolean>;
 95:   /** Mark tracking as initialized */
 96:   initialize: (initialIds: Set<T>) => void;
 97: }
 98: 
 99: /**
100:  * Create a tracker for element changes.
101:  *
102:  * @param options - Configuration options
103:  * @returns Tracking utilities
104:  */
105: export function useElementChangeTracker<T = number>(
106:   options: ElementChangeTrackerOptions<T>
107: ): ElementChangeTrackerReturn<T> {
108:   const {
109:     containerRef,
110:     selector = '[data-card-id]',
111:     getElementId,
112:     getElementData,
113:   } = options;
114: 
115:   const prevIds = ref<Set<T>>(new Set()) as Ref<Set<T>>;
116:   const positions = ref<Map<T, ElementPositionData>>(new Map()) as Ref<Map<T, ElementPositionData>>;
117:   const isInitialized = ref(false);
118: 
119:   /**
120:    * Capture current positions of all elements from the DOM.
121:    * Call this BEFORE Vue updates the DOM (in a sync watcher).
122:    */
123:   function capturePositions(): void {
124:     positions.value.clear();
125: 
126:     if (!containerRef.value) return;
127: 
128:     const elements = containerRef.value.querySelectorAll(selector);
129:     elements.forEach((el) => {
130:       const id = getElementId(el);
131:       if (id !== null && id !== undefined) {
132:         const rect = el.getBoundingClientRect();
133:         const extraData = getElementData ? getElementData(el) : {};
134:         positions.value.set(id, { rect, ...extraData });
135:       }
136:     });
137:   }
138: 
139:   /**
140:    * Get IDs that are in the current set but weren't in the previous set.
141:    */
142:   function getAddedIds(prevSnapshot: Set<T>, current: Set<T>): Set<T> {
143:     const added = new Set<T>();
144:     for (const id of current) {
145:       if (!prevSnapshot.has(id)) {
146:         added.add(id);
147:       }
148:     }
149:     return added;
150:   }
151: 
152:   /**
153:    * Get IDs that were in the previous set but aren't in the current set.
154:    */
155:   function getRemovedIds(prevSnapshot: Set<T>, current: Set<T>): Set<T> {
156:     const removed = new Set<T>();
157:     for (const id of prevSnapshot) {
158:       if (!current.has(id)) {
159:         removed.add(id);
160:       }
161:     }
162:     return removed;
163:   }
164: 
165:   /**
166:    * Update the prevIds ref with new values.
167:    */
168:   function updateIds(ids: Set<T>): void {
169:     prevIds.value = ids;
170:   }
171: 
172:   /**
173:    * Clear all tracking state.
174:    */
175:   function reset(): void {
176:     prevIds.value = new Set();
177:     positions.value.clear();
178:     isInitialized.value = false;
179:   }
180: 
181:   /**
182:    * Initialize tracking with initial IDs (call once on first load).
183:    */
184:   function initialize(initialIds: Set<T>): void {
185:     if (isInitialized.value) return;
186:     prevIds.value = initialIds;
187:     isInitialized.value = true;
188:   }
189: 
190:   return {
191:     prevIds,
192:     positions,
193:     capturePositions,
194:     getAddedIds,
195:     getRemovedIds,
196:     updateIds,
197:     reset,
198:     isInitialized,
199:     initialize,
200:   };
201: }
202: 
203: /**
204:  * Simple counter tracker for tracking counts (e.g., opponent card count, deck count).
205:  * Useful when you don't have access to individual element IDs.
206:  */
207: export interface CountTrackerReturn {
208:   /** Previous count value */
209:   prevCount: Ref<number>;
210:   /** Update the count and return the delta (positive = increase, negative = decrease) */
211:   updateCount: (newCount: number) => number;
212:   /** Reset the counter */
213:   reset: () => void;
214:   /** Initialize with a value */
215:   initialize: (count: number) => void;
216:   /** Check if initialized */
217:   isInitialized: Ref<boolean>;
218: }
219: 
220: /**
221:  * Create a simple counter tracker.
222:  */
223: export function useCountTracker(): CountTrackerReturn {
224:   const prevCount = ref(0);
225:   const isInitialized = ref(false);
226: 
227:   function updateCount(newCount: number): number {
228:     const delta = newCount - prevCount.value;
229:     prevCount.value = newCount;
230:     return delta;
231:   }
232: 
233:   function reset(): void {
234:     prevCount.value = 0;
235:     isInitialized.value = false;
236:   }
237: 
238:   function initialize(count: number): void {
239:     if (isInitialized.value) return;
240:     prevCount.value = count;
241:     isInitialized.value = true;
242:   }
243: 
244:   return {
245:     prevCount,
246:     updateCount,
247:     reset,
248:     initialize,
249:     isInitialized,
250:   };
251: }
````

## File: packages/ui/src/composables/useGameViewHelpers.ts
````typescript
  1: /**
  2:  * useGameViewHelpers - Utilities for working with game view data in custom UIs
  3:  *
  4:  * Provides helper functions for finding elements in the game view tree,
  5:  * handling the className mangling issue that can occur with bundlers.
  6:  *
  7:  * Usage:
  8:  * ```typescript
  9:  * const { findElement, findPlayerHand, getElementCount } = useGameViewHelpers();
 10:  *
 11:  * const deck = findElement(gameView, { type: 'deck' });
 12:  * const myHand = findPlayerHand(gameView, playerPosition);
 13:  * const cardCount = getElementCount(deck);
 14:  * ```
 15:  */
 16: 
 17: import type { GameElement, ElementMatchOptions, BaseElementAttributes } from '../types.js';
 18: 
 19: // Re-export for backwards compatibility
 20: export type { GameElement };
 21: export type { ElementMatchOptions as FindElementOptions };
 22: 
 23: /** Helper to get typed attributes from an element */
 24: function getAttrs(element: GameElement): BaseElementAttributes & Record<string, unknown> {
 25:   return (element.attributes ?? {}) as BaseElementAttributes & Record<string, unknown>;
 26: }
 27: 
 28: /**
 29:  * Find an element in the game view by type, name, or className.
 30:  * Prefers $type and name over className since className can be mangled by bundlers.
 31:  */
 32: export function findElement(
 33:   gameView: GameElement | null | undefined,
 34:   options: ElementMatchOptions
 35: ): GameElement | undefined {
 36:   if (!gameView?.children) return undefined;
 37: 
 38:   const { type, name, className } = options;
 39: 
 40:   return gameView.children.find((c) => {
 41:     if (type && getAttrs(c).$type === type) return true;
 42:     if (name && c.name === name) return true;
 43:     if (className && c.className === className) return true;
 44:     return false;
 45:   });
 46: }
 47: 
 48: /**
 49:  * Find multiple elements in the game view matching the criteria.
 50:  */
 51: export function findElements(
 52:   gameView: GameElement | null | undefined,
 53:   options: ElementMatchOptions
 54: ): GameElement[] {
 55:   if (!gameView?.children) return [];
 56: 
 57:   const { type, name, className } = options;
 58: 
 59:   return gameView.children.filter((c) => {
 60:     if (type && getAttrs(c).$type === type) return true;
 61:     if (name && c.name === name) return true;
 62:     if (className && c.className === className) return true;
 63:     return false;
 64:   });
 65: }
 66: 
 67: /**
 68:  * Find a player's hand element by position.
 69:  */
 70: export function findPlayerHand(
 71:   gameView: GameElement | null | undefined,
 72:   playerPosition: number
 73: ): GameElement | undefined {
 74:   if (!gameView?.children) return undefined;
 75: 
 76:   return gameView.children.find((c) => {
 77:     const attrs = getAttrs(c);
 78:     return attrs.$type === 'hand' && attrs.player?.position === playerPosition;
 79:   });
 80: }
 81: 
 82: /**
 83:  * Find all hand elements in the game view.
 84:  */
 85: export function findAllHands(
 86:   gameView: GameElement | null | undefined
 87: ): GameElement[] {
 88:   if (!gameView?.children) return [];
 89: 
 90:   return gameView.children.filter((c) => getAttrs(c).$type === 'hand');
 91: }
 92: 
 93: /**
 94:  * Get the count of children in an element, handling hidden contents.
 95:  * For elements with hidden contents (like decks), this returns childCount.
 96:  */
 97: export function getElementCount(element: GameElement | null | undefined): number {
 98:   if (!element) return 0;
 99: 
100:   // If there are visible children, count them
101:   if (element.children && element.children.length > 0) {
102:     return element.children.length;
103:   }
104: 
105:   // Otherwise use childCount for hidden contents
106:   return element.childCount || 0;
107: }
108: 
109: /**
110:  * Get cards from an element (filters to elements with rank attribute).
111:  */
112: export function getCards(element: GameElement | null | undefined): GameElement[] {
113:   if (!element?.children) return [];
114: 
115:   return element.children.filter((c) => getAttrs(c).rank !== undefined);
116: }
117: 
118: /**
119:  * Get the first card from an element.
120:  */
121: export function getFirstCard(element: GameElement | null | undefined): GameElement | undefined {
122:   return getCards(element)[0];
123: }
124: 
125: /**
126:  * Extract card data (rank, suit) from a game element.
127:  * Returns undefined if the element has no rank attribute.
128:  */
129: export function getCardData(element: GameElement | null | undefined): { rank: string; suit: string } | undefined {
130:   if (!element) return undefined;
131: 
132:   const attrs = getAttrs(element);
133:   if (attrs.rank === undefined) return undefined;
134: 
135:   return {
136:     rank: attrs.rank,
137:     suit: attrs.suit ?? '',
138:   };
139: }
140: 
141: /**
142:  * Get the player position that owns an element.
143:  * Returns undefined if the element has no player owner.
144:  */
145: export function getElementOwner(element: GameElement | null | undefined): number | undefined {
146:   if (!element) return undefined;
147:   return getAttrs(element).player?.position;
148: }
149: 
150: /**
151:  * Check if an element belongs to a specific player.
152:  */
153: export function isOwnedByPlayer(
154:   element: GameElement | null | undefined,
155:   playerPosition: number
156: ): boolean {
157:   return getElementOwner(element) === playerPosition;
158: }
159: 
160: /**
161:  * Check if an element belongs to the specified player (convenience for "my" checks).
162:  */
163: export function isMyElement(
164:   element: GameElement | null | undefined,
165:   myPlayerPosition: number
166: ): boolean {
167:   return isOwnedByPlayer(element, myPlayerPosition);
168: }
169: 
170: /**
171:  * Check if an element belongs to an opponent (any player that isn't the specified player).
172:  */
173: export function isOpponentElement(
174:   element: GameElement | null | undefined,
175:   myPlayerPosition: number
176: ): boolean {
177:   const owner = getElementOwner(element);
178:   return owner !== undefined && owner !== myPlayerPosition;
179: }
180: 
181: /**
182:  * Composable that returns all helper functions.
183:  * Can be used in Vue components for convenience.
184:  */
185: export function useGameViewHelpers() {
186:   return {
187:     findElement,
188:     findElements,
189:     findPlayerHand,
190:     findAllHands,
191:     getElementCount,
192:     getCards,
193:     getFirstCard,
194:     getCardData,
195:     getElementOwner,
196:     isOwnedByPlayer,
197:     isMyElement,
198:     isOpponentElement,
199:   };
200: }
````

## File: packages/engine/src/action/action.ts
````typescript
  1: import type { GameElement } from '../element/game-element.js';
  2: import type { Player } from '../player/player.js';
  3: import type { Game } from '../element/game.js';
  4: import type {
  5:   ActionDefinition,
  6:   ActionContext,
  7:   ActionResult,
  8:   Selection,
  9:   ChoiceSelection,
 10:   PlayerSelection,
 11:   ElementSelection,
 12:   TextSelection,
 13:   NumberSelection,
 14:   ValidationResult,
 15:   ChoiceBoardRefs,
 16:   DependentFilter,
 17:   BoardElementRef,
 18: } from './types.js';
 19: import type { ElementClass } from '../element/types.js';
 20: 
 21: /**
 22:  * Builder class for creating game actions with a fluent API.
 23:  *
 24:  * Actions represent high-level player operations (game-specific, user-facing).
 25:  * They generate low-level Commands internally to modify game state.
 26:  *
 27:  * @see {@link ../../ARCHITECTURE.md} for the Actions vs Commands architecture explanation
 28:  *
 29:  * @example
 30:  * ```typescript
 31:  * const askAction = Action.create('ask')
 32:  *   .prompt('Ask another player for a card')
 33:  *   .choosePlayer('target', {
 34:  *     prompt: 'Choose a player to ask',
 35:  *     filter: (p, ctx) => p !== ctx.player
 36:  *   })
 37:  *   .chooseFrom('rank', {
 38:  *     prompt: 'Choose a rank',
 39:  *     choices: (ctx) => getPlayerRanks(ctx.player)
 40:  *   })
 41:  *   .condition((ctx) => ctx.player.hand.count() > 0)
 42:  *   .execute((args, ctx) => {
 43:  *     // Handle the ask action
 44:  *   });
 45:  * ```
 46:  */
 47: export class Action {
 48:   private definition: ActionDefinition;
 49: 
 50:   private constructor(name: string) {
 51:     this.definition = {
 52:       name,
 53:       selections: [],
 54:       execute: () => {},
 55:     };
 56:   }
 57: 
 58:   /**
 59:    * Create a new action builder
 60:    */
 61:   static create(name: string): Action {
 62:     return new Action(name);
 63:   }
 64: 
 65:   /**
 66:    * Set the user-facing prompt for this action
 67:    */
 68:   prompt(prompt: string): this {
 69:     this.definition.prompt = prompt;
 70:     return this;
 71:   }
 72: 
 73:   /**
 74:    * Add a condition for when this action is available
 75:    */
 76:   condition(fn: (context: ActionContext) => boolean): this {
 77:     this.definition.condition = fn;
 78:     return this;
 79:   }
 80: 
 81:   /**
 82:    * Mark this action as non-undoable.
 83:    * Use for actions that reveal hidden info, involve randomness, or shouldn't be undone.
 84:    * When executed, undo is disabled for the rest of the turn.
 85:    */
 86:   notUndoable(): this {
 87:     this.definition.undoable = false;
 88:     return this;
 89:   }
 90: 
 91:   /**
 92:    * Add a choice selection
 93:    */
 94:   chooseFrom<T>(
 95:     name: string,
 96:     options: {
 97:       prompt?: string;
 98:       choices: T[] | ((context: ActionContext) => T[]);
 99:       display?: (choice: T) => string;
100:       skipIfOnlyOne?: boolean;
101:       optional?: boolean;
102:       validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;
103:       /** Get board element references for highlighting (source/target) */
104:       boardRefs?: (choice: T, context: ActionContext) => ChoiceBoardRefs;
105:       /** Filter choices based on a previous selection value */
106:       filterBy?: DependentFilter;
107:     }
108:   ): this {
109:     const selection: ChoiceSelection<T> = {
110:       type: 'choice',
111:       name,
112:       prompt: options.prompt,
113:       choices: options.choices,
114:       display: options.display,
115:       skipIfOnlyOne: options.skipIfOnlyOne,
116:       optional: options.optional,
117:       validate: options.validate,
118:       boardRefs: options.boardRefs,
119:       filterBy: options.filterBy,
120:     };
121:     this.definition.selections.push(selection as Selection);
122:     return this;
123:   }
124: 
125:   /**
126:    * Add a player selection
127:    */
128:   choosePlayer(
129:     name: string,
130:     options: {
131:       prompt?: string;
132:       filter?: (player: Player, context: ActionContext) => boolean;
133:       skipIfOnlyOne?: boolean;
134:       optional?: boolean;
135:       validate?: (value: Player, args: Record<string, unknown>, context: ActionContext) => boolean | string;
136:       boardRefs?: (player: Player, context: ActionContext) => ChoiceBoardRefs;
137:     } = {}
138:   ): this {
139:     const selection: PlayerSelection = {
140:       type: 'player',
141:       name,
142:       prompt: options.prompt,
143:       filter: options.filter,
144:       skipIfOnlyOne: options.skipIfOnlyOne,
145:       optional: options.optional,
146:       validate: options.validate,
147:       boardRefs: options.boardRefs,
148:     };
149:     this.definition.selections.push(selection);
150:     return this;
151:   }
152: 
153:   /**
154:    * Add an element selection (choose from board)
155:    */
156:   chooseElement<T extends GameElement>(
157:     name: string,
158:     options: {
159:       prompt?: string;
160:       elementClass?: ElementClass<T>;
161:       from?: GameElement | ((context: ActionContext) => GameElement);
162:       filter?: (element: GameElement, context: ActionContext) => boolean;
163:       skipIfOnlyOne?: boolean;
164:       optional?: boolean;
165:       validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;
166:       /** Display function for elements (for UI buttons) */
167:       display?: (element: T, context: ActionContext) => string;
168:       /** Get board element reference for highlighting */
169:       boardRef?: (element: T, context: ActionContext) => BoardElementRef;
170:     } = {}
171:   ): this {
172:     const selection: ElementSelection<T> = {
173:       type: 'element',
174:       name,
175:       prompt: options.prompt,
176:       elementClass: options.elementClass,
177:       from: options.from,
178:       filter: options.filter,
179:       skipIfOnlyOne: options.skipIfOnlyOne,
180:       optional: options.optional,
181:       validate: options.validate,
182:       display: options.display as ElementSelection<T>['display'],
183:       boardRef: options.boardRef as ElementSelection<T>['boardRef'],
184:     };
185:     this.definition.selections.push(selection as Selection);
186:     return this;
187:   }
188: 
189:   /**
190:    * Add a text input selection
191:    */
192:   enterText(
193:     name: string,
194:     options: {
195:       prompt?: string;
196:       pattern?: RegExp;
197:       minLength?: number;
198:       maxLength?: number;
199:       optional?: boolean;
200:       validate?: (value: string, args: Record<string, unknown>, context: ActionContext) => boolean | string;
201:     } = {}
202:   ): this {
203:     const selection: TextSelection = {
204:       type: 'text',
205:       name,
206:       prompt: options.prompt,
207:       pattern: options.pattern,
208:       minLength: options.minLength,
209:       maxLength: options.maxLength,
210:       optional: options.optional,
211:       validate: options.validate,
212:     };
213:     this.definition.selections.push(selection);
214:     return this;
215:   }
216: 
217:   /**
218:    * Add a number input selection
219:    */
220:   enterNumber(
221:     name: string,
222:     options: {
223:       prompt?: string;
224:       min?: number;
225:       max?: number;
226:       integer?: boolean;
227:       optional?: boolean;
228:       validate?: (value: number, args: Record<string, unknown>, context: ActionContext) => boolean | string;
229:     } = {}
230:   ): this {
231:     const selection: NumberSelection = {
232:       type: 'number',
233:       name,
234:       prompt: options.prompt,
235:       min: options.min,
236:       max: options.max,
237:       integer: options.integer,
238:       optional: options.optional,
239:       validate: options.validate,
240:     };
241:     this.definition.selections.push(selection);
242:     return this;
243:   }
244: 
245:   /**
246:    * Set the execution handler for this action
247:    */
248:   execute(
249:     fn: (args: Record<string, unknown>, context: ActionContext) => ActionResult | void
250:   ): ActionDefinition {
251:     this.definition.execute = fn;
252:     return this.definition;
253:   }
254: 
255:   /**
256:    * Get the built definition (without execute, for inspection)
257:    */
258:   build(): ActionDefinition {
259:     return this.definition;
260:   }
261: }
262: 
263: /**
264:  * Action executor handles resolving selections and executing actions
265:  */
266: export class ActionExecutor {
267:   private game: Game;
268: 
269:   constructor(game: Game) {
270:     this.game = game;
271:   }
272: 
273:   /**
274:    * Resolve serialized args (player indices, element IDs) to actual objects.
275:    * This is needed because network-serialized args use indices/IDs instead of objects.
276:    */
277:   resolveArgs(
278:     action: ActionDefinition,
279:     args: Record<string, unknown>
280:   ): Record<string, unknown> {
281:     const resolved = { ...args };
282: 
283:     for (const selection of action.selections) {
284:       const value = args[selection.name];
285:       if (value === undefined) continue;
286: 
287:       switch (selection.type) {
288:         case 'player': {
289:           // If value is a number, resolve to actual Player object
290:           if (typeof value === 'number') {
291:             const player = this.game.players[value];
292:             if (player) {
293:               resolved[selection.name] = player;
294:             }
295:           }
296:           break;
297:         }
298: 
299:         case 'element': {
300:           // If value is a number, resolve to actual GameElement by ID
301:           if (typeof value === 'number') {
302:             const element = this.game.getElementById(value);
303:             if (element) {
304:               resolved[selection.name] = element;
305:             }
306:           }
307:           break;
308:         }
309:       }
310:     }
311: 
312:     return resolved;
313:   }
314: 
315:   /**
316:    * Get available choices for a selection given current args
317:    */
318:   getChoices(
319:     selection: Selection,
320:     player: Player,
321:     args: Record<string, unknown>
322:   ): unknown[] {
323:     const context: ActionContext = {
324:       game: this.game,
325:       player,
326:       args,
327:     };
328: 
329:     switch (selection.type) {
330:       case 'choice': {
331:         const choiceSel = selection as ChoiceSelection;
332:         let choices = typeof choiceSel.choices === 'function'
333:           ? choiceSel.choices(context)
334:           : [...choiceSel.choices];
335: 
336:         // Apply filterBy if present and the dependent selection has a value
337:         if (choiceSel.filterBy) {
338:           const { key, selectionName } = choiceSel.filterBy;
339:           const previousValue = args[selectionName];
340: 
341:           if (previousValue !== undefined) {
342:             // Extract the filter value from the previous selection
343:             // For elements, use .id as fallback if the key doesn't exist
344:             let filterValue: unknown;
345:             if (typeof previousValue === 'object' && previousValue !== null) {
346:               const prevObj = previousValue as Record<string, unknown>;
347:               // Try the key first, then fall back to 'id' (for element selections)
348:               filterValue = prevObj[key] !== undefined ? prevObj[key] : prevObj['id'];
349:             } else {
350:               filterValue = previousValue;
351:             }
352: 
353:             // Filter choices where choice[key] matches the filter value
354:             choices = choices.filter((choice) => {
355:               if (typeof choice === 'object' && choice !== null) {
356:                 return (choice as Record<string, unknown>)[key] === filterValue;
357:               }
358:               return choice === filterValue;
359:             });
360:           }
361:         }
362: 
363:         return choices;
364:       }
365: 
366:       case 'player': {
367:         const playerSel = selection as PlayerSelection;
368:         let players = [...this.game.players];
369:         if (playerSel.filter) {
370:           players = players.filter((p) => playerSel.filter!(p, context));
371:         }
372:         return players;
373:       }
374: 
375:       case 'element': {
376:         const elementSel = selection as ElementSelection;
377:         const from =
378:           typeof elementSel.from === 'function'
379:             ? elementSel.from(context)
380:             : elementSel.from ?? this.game;
381: 
382:         let elements: GameElement[];
383:         if (elementSel.elementClass) {
384:           elements = [...from.all(elementSel.elementClass)];
385:         } else {
386:           elements = [...from.all()];
387:         }
388: 
389:         if (elementSel.filter) {
390:           elements = elements.filter((e) => elementSel.filter!(e, context));
391:         }
392: 
393:         return elements;
394:       }
395: 
396:       case 'text':
397:       case 'number':
398:         // These don't have predefined choices
399:         return [];
400: 
401:       default:
402:         return [];
403:     }
404:   }
405: 
406:   /**
407:    * Check if a selection should be skipped (only one valid choice)
408:    */
409:   shouldSkip(
410:     selection: Selection,
411:     player: Player,
412:     args: Record<string, unknown>
413:   ): { skip: boolean; value?: unknown } {
414:     if (!selection.skipIfOnlyOne) {
415:       return { skip: false };
416:     }
417: 
418:     const choices = this.getChoices(selection, player, args);
419:     if (choices.length === 1) {
420:       return { skip: true, value: choices[0] };
421:     }
422: 
423:     return { skip: false };
424:   }
425: 
426:   /**
427:    * Check if two values are equal (handles objects by comparing JSON)
428:    */
429:   private valuesEqual(a: unknown, b: unknown): boolean {
430:     if (a === b) return true;
431:     if (typeof a !== typeof b) return false;
432:     if (typeof a === 'object' && a !== null && b !== null) {
433:       // For objects, compare by JSON serialization
434:       return JSON.stringify(a) === JSON.stringify(b);
435:     }
436:     return false;
437:   }
438: 
439:   /**
440:    * Check if a value exists in a choices array (handles object comparison)
441:    */
442:   private choicesContain(choices: unknown[], value: unknown): boolean {
443:     return choices.some(choice => this.valuesEqual(choice, value));
444:   }
445: 
446:   /**
447:    * Validate a single selection value
448:    */
449:   validateSelection(
450:     selection: Selection,
451:     value: unknown,
452:     player: Player,
453:     args: Record<string, unknown>
454:   ): ValidationResult {
455:     const errors: string[] = [];
456:     const context: ActionContext = {
457:       game: this.game,
458:       player,
459:       args,
460:     };
461: 
462:     // Check if value is in valid choices (for choice/player/element)
463:     if (selection.type === 'choice' || selection.type === 'player' || selection.type === 'element') {
464:       const choices = this.getChoices(selection, player, args);
465:       if (!this.choicesContain(choices, value)) {
466:         errors.push(`Invalid selection for ${selection.name}`);
467:       }
468:     }
469: 
470:     // Type-specific validation
471:     switch (selection.type) {
472:       case 'text': {
473:         const textSel = selection as TextSelection;
474:         const str = value as string;
475:         if (typeof str !== 'string') {
476:           errors.push(`${selection.name} must be a string`);
477:         } else {
478:           if (textSel.minLength !== undefined && str.length < textSel.minLength) {
479:             errors.push(`${selection.name} must be at least ${textSel.minLength} characters`);
480:           }
481:           if (textSel.maxLength !== undefined && str.length > textSel.maxLength) {
482:             errors.push(`${selection.name} must be at most ${textSel.maxLength} characters`);
483:           }
484:           if (textSel.pattern && !textSel.pattern.test(str)) {
485:             errors.push(`${selection.name} does not match required pattern`);
486:           }
487:         }
488:         break;
489:       }
490: 
491:       case 'number': {
492:         const numSel = selection as NumberSelection;
493:         const num = value as number;
494:         if (typeof num !== 'number' || isNaN(num)) {
495:           errors.push(`${selection.name} must be a number`);
496:         } else {
497:           if (numSel.min !== undefined && num < numSel.min) {
498:             errors.push(`${selection.name} must be at least ${numSel.min}`);
499:           }
500:           if (numSel.max !== undefined && num > numSel.max) {
501:             errors.push(`${selection.name} must be at most ${numSel.max}`);
502:           }
503:           if (numSel.integer && !Number.isInteger(num)) {
504:             errors.push(`${selection.name} must be an integer`);
505:           }
506:         }
507:         break;
508:       }
509:     }
510: 
511:     // Custom validation
512:     if (selection.validate && errors.length === 0) {
513:       // Cast value since we've already validated the type above
514:       const result = (selection.validate as (v: unknown, a: Record<string, unknown>, c: ActionContext) => boolean | string)(value, args, context);
515:       if (result !== true) {
516:         errors.push(typeof result === 'string' ? result : `Invalid ${selection.name}`);
517:       }
518:     }
519: 
520:     return {
521:       valid: errors.length === 0,
522:       errors,
523:     };
524:   }
525: 
526:   /**
527:    * Validate all arguments for an action
528:    */
529:   validateAction(
530:     action: ActionDefinition,
531:     player: Player,
532:     args: Record<string, unknown>
533:   ): ValidationResult {
534:     const allErrors: string[] = [];
535:     const context: ActionContext = {
536:       game: this.game,
537:       player,
538:       args,
539:     };
540: 
541:     // Check condition
542:     if (action.condition && !action.condition(context)) {
543:       return {
544:         valid: false,
545:         errors: ['Action is not available'],
546:       };
547:     }
548: 
549:     // Validate each selection
550:     for (const selection of action.selections) {
551:       const value = args[selection.name];
552: 
553:       // Handle optional selections
554:       if (value === undefined) {
555:         if (!selection.optional) {
556:           allErrors.push(`Missing required selection: ${selection.name}`);
557:         }
558:         continue;
559:       }
560: 
561:       const result = this.validateSelection(selection, value, player, args);
562:       allErrors.push(...result.errors);
563:     }
564: 
565:     return {
566:       valid: allErrors.length === 0,
567:       errors: allErrors,
568:     };
569:   }
570: 
571:   /**
572:    * Execute an action with the given arguments
573:    */
574:   executeAction(
575:     action: ActionDefinition,
576:     player: Player,
577:     args: Record<string, unknown>
578:   ): ActionResult {
579:     // Resolve serialized args (player indices, element IDs) to actual objects
580:     const resolvedArgs = this.resolveArgs(action, args);
581: 
582:     // Validate with resolved args
583:     const validation = this.validateAction(action, player, resolvedArgs);
584:     if (!validation.valid) {
585:       return {
586:         success: false,
587:         error: validation.errors.join('; '),
588:       };
589:     }
590: 
591:     const context: ActionContext = {
592:       game: this.game,
593:       player,
594:       args: resolvedArgs,
595:     };
596: 
597:     try {
598:       const result = action.execute(resolvedArgs, context);
599:       return result ?? { success: true };
600:     } catch (error) {
601:       return {
602:         success: false,
603:         error: error instanceof Error ? error.message : String(error),
604:       };
605:     }
606:   }
607: 
608:   /**
609:    * Check if an action is available for a player.
610:    * For actions with dependent selections (filterBy), this checks if at least
611:    * one valid path through all selections exists.
612:    */
613:   isActionAvailable(action: ActionDefinition, player: Player): boolean {
614:     const context: ActionContext = {
615:       game: this.game,
616:       player,
617:       args: {},
618:     };
619: 
620:     if (action.condition && !action.condition(context)) {
621:       return false;
622:     }
623: 
624:     // Check if there's at least one valid path through all selections
625:     return this.hasValidSelectionPath(action.selections, player, {}, 0);
626:   }
627: 
628:   /**
629:    * Extract the value used for matching from a choice (for filterBy)
630:    */
631:   private getChoiceFilterValue(choice: unknown, key: string): unknown {
632:     if (typeof choice === 'object' && choice !== null) {
633:       return (choice as Record<string, unknown>)[key];
634:     }
635:     return choice;
636:   }
637: 
638:   /**
639:    * Check if any selection after the given index depends on a selection by name
640:    */
641:   private hasDependentSelection(
642:     selections: Selection[],
643:     afterIndex: number,
644:     selectionName: string
645:   ): boolean {
646:     for (let i = afterIndex; i < selections.length; i++) {
647:       const sel = selections[i];
648:       if (sel.type === 'choice') {
649:         const choiceSel = sel as ChoiceSelection;
650:         if (choiceSel.filterBy?.selectionName === selectionName) {
651:           return true;
652:         }
653:       }
654:     }
655:     return false;
656:   }
657: 
658:   /**
659:    * Recursively check if there's a valid path through all selections.
660:    * For dependent selections, we need to verify at least one choice
661:    * leads to valid subsequent selections.
662:    *
663:    * OPTIMIZATION: We only do full path validation for choice selections
664:    * with static choices and filterBy. For element/player selections,
665:    * or choice selections with dynamic choices functions, the cost of
666:    * repeatedly computing choices is too high.
667:    */
668:   private hasValidSelectionPath(
669:     selections: Selection[],
670:     player: Player,
671:     args: Record<string, unknown>,
672:     index: number
673:   ): boolean {
674:     // Base case: all selections processed
675:     if (index >= selections.length) {
676:       return true;
677:     }
678: 
679:     const selection = selections[index];
680: 
681:     // Skip optional selections - they don't block availability
682:     if (selection.optional) {
683:       return this.hasValidSelectionPath(selections, player, args, index + 1);
684:     }
685: 
686:     // Text/number inputs are always available
687:     if (selection.type === 'text' || selection.type === 'number') {
688:       return this.hasValidSelectionPath(selections, player, args, index + 1);
689:     }
690: 
691:     // For element and player selections, just check they have choices
692:     // (don't do expensive path validation - trust their filter functions)
693:     if (selection.type === 'element' || selection.type === 'player') {
694:       const choices = this.getChoices(selection, player, args);
695:       if (choices.length === 0) {
696:         return false;
697:       }
698:       return this.hasValidSelectionPath(selections, player, args, index + 1);
699:     }
700: 
701:     // For choice selections with dynamic choices functions, also skip path validation
702:     // (computing dynamic choices repeatedly is too expensive)
703:     if (selection.type === 'choice') {
704:       const choiceSel = selection as ChoiceSelection;
705:       if (typeof choiceSel.choices === 'function') {
706:         const choices = this.getChoices(selection, player, args);
707:         if (choices.length === 0) {
708:           return false;
709:         }
710:         return this.hasValidSelectionPath(selections, player, args, index + 1);
711:       }
712:     }
713: 
714:     // Get choices for this selection (static choices only at this point)
715:     const choices = this.getChoices(selection, player, args);
716:     if (choices.length === 0) {
717:       return false;
718:     }
719: 
720:     // Check if any later selection depends on this one
721:     const hasDependent = this.hasDependentSelection(selections, index + 1, selection.name);
722: 
723:     if (!hasDependent) {
724:       // No dependent selections, just check if subsequent selections are valid
725:       return this.hasValidSelectionPath(selections, player, args, index + 1);
726:     }
727: 
728:     // Has dependent selections - need to check if at least one choice
729:     // leads to a valid path through subsequent selections
730:     for (const choice of choices) {
731:       // Build new args with this choice
732:       const newArgs = { ...args, [selection.name]: choice };
733: 
734:       // Check if this choice leads to a valid path
735:       if (this.hasValidSelectionPath(selections, player, newArgs, index + 1)) {
736:         return true; // Found at least one valid path
737:       }
738:     }
739: 
740:     // No choice led to a valid path
741:     return false;
742:   }
743: }
````

## File: packages/engine/src/action/types.ts
````typescript
  1: import type { GameElement } from '../element/game-element.js';
  2: import type { Player } from '../player/player.js';
  3: import type { Game } from '../element/game.js';
  4: import type { ElementClass } from '../element/types.js';
  5: 
  6: /**
  7:  * Selection types for action arguments
  8:  */
  9: export type SelectionType = 'element' | 'player' | 'choice' | 'text' | 'number';
 10: 
 11: /**
 12:  * Base selection configuration
 13:  */
 14: export interface BaseSelection<T = unknown> {
 15:   /** Selection name (becomes key in args) */
 16:   name: string;
 17:   /** User-facing prompt */
 18:   prompt?: string;
 19:   /** Skip if only one valid choice */
 20:   skipIfOnlyOne?: boolean;
 21:   /** Make this selection optional */
 22:   optional?: boolean;
 23:   /** Validation function */
 24:   validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;
 25: }
 26: 
 27: /**
 28:  * Reference to a board element for UI highlighting
 29:  */
 30: export interface BoardElementRef {
 31:   id?: number;
 32:   name?: string;
 33:   notation?: string;
 34: }
 35: 
 36: /**
 37:  * Board references for a choice (source and target elements)
 38:  */
 39: export interface ChoiceBoardRefs {
 40:   sourceRef?: BoardElementRef;
 41:   targetRef?: BoardElementRef;
 42: }
 43: 
 44: /**
 45:  * Filter configuration for dependent selections
 46:  */
 47: export interface DependentFilter {
 48:   /** Key in the choice value object to filter by */
 49:   key: string;
 50:   /** Name of the previous selection to match against */
 51:   selectionName: string;
 52: }
 53: 
 54: /**
 55:  * Select from a list of choices
 56:  */
 57: export interface ChoiceSelection<T = unknown> extends BaseSelection<T> {
 58:   type: 'choice';
 59:   /** Choices - can be static array or function */
 60:   choices: T[] | ((context: ActionContext) => T[]);
 61:   /** Display function for choices */
 62:   display?: (choice: T) => string;
 63:   /** Get board element references for highlighting (source/target) */
 64:   boardRefs?: (choice: T, context: ActionContext) => ChoiceBoardRefs;
 65:   /** Filter choices based on a previous selection value */
 66:   filterBy?: DependentFilter;
 67: }
 68: 
 69: /**
 70:  * Select a player
 71:  */
 72: export interface PlayerSelection extends BaseSelection<Player> {
 73:   type: 'player';
 74:   /** Filter which players can be selected */
 75:   filter?: (player: Player, context: ActionContext) => boolean;
 76:   /** Get board element references for highlighting (e.g., player's hand or avatar) */
 77:   boardRefs?: (player: Player, context: ActionContext) => ChoiceBoardRefs;
 78: }
 79: 
 80: /**
 81:  * Select an element from the board
 82:  */
 83: export interface ElementSelection<T extends GameElement = GameElement> extends BaseSelection<T> {
 84:   type: 'element';
 85:   /** Filter which elements can be selected */
 86:   filter?: (element: GameElement, context: ActionContext) => boolean;
 87:   /** Limit selection to elements of this class */
 88:   elementClass?: ElementClass<T>;
 89:   /** Starting point for the search (defaults to game) */
 90:   from?: GameElement | ((context: ActionContext) => GameElement);
 91:   /** Display function for elements (for UI buttons) */
 92:   display?: (element: T, context: ActionContext) => string;
 93:   /** Get board element reference for highlighting */
 94:   boardRef?: (element: T, context: ActionContext) => BoardElementRef;
 95: }
 96: 
 97: /**
 98:  * Enter text
 99:  */
100: export interface TextSelection extends BaseSelection<string> {
101:   type: 'text';
102:   /** Pattern to validate against */
103:   pattern?: RegExp;
104:   /** Min length */
105:   minLength?: number;
106:   /** Max length */
107:   maxLength?: number;
108: }
109: 
110: /**
111:  * Enter a number
112:  */
113: export interface NumberSelection extends BaseSelection<number> {
114:   type: 'number';
115:   /** Minimum value */
116:   min?: number;
117:   /** Maximum value */
118:   max?: number;
119:   /** Must be integer */
120:   integer?: boolean;
121: }
122: 
123: /**
124:  * Union of all selection types
125:  */
126: export type Selection =
127:   | ChoiceSelection
128:   | PlayerSelection
129:   | ElementSelection
130:   | TextSelection
131:   | NumberSelection;
132: 
133: /**
134:  * Context passed to selection functions and validators
135:  */
136: export interface ActionContext {
137:   /** The game instance */
138:   game: Game;
139:   /** The player taking the action */
140:   player: Player;
141:   /** Arguments collected so far */
142:   args: Record<string, unknown>;
143: }
144: 
145: /**
146:  * Definition of an action
147:  */
148: export interface ActionDefinition {
149:   /** Unique action name */
150:   name: string;
151:   /** User-facing prompt */
152:   prompt?: string;
153:   /** Selections required for this action */
154:   selections: Selection[];
155:   /** Condition for when this action is available */
156:   condition?: (context: ActionContext) => boolean;
157:   /** The effect to execute */
158:   execute: (args: Record<string, unknown>, context: ActionContext) => ActionResult | void;
159:   /**
160:    * Whether this action can be undone (default: true).
161:    * Set to false for actions that reveal hidden information (e.g., drawing cards),
162:    * involve randomness (e.g., dice rolls), or shouldn't be undoable for game reasons.
163:    * When a non-undoable action is executed, undo is disabled for the rest of the turn.
164:    */
165:   undoable?: boolean;
166: }
167: 
168: /**
169:  * Result of action execution
170:  */
171: export interface ActionResult {
172:   /** Whether the action succeeded */
173:   success: boolean;
174:   /** Error message if failed */
175:   error?: string;
176:   /** Additional data to return */
177:   data?: Record<string, unknown>;
178:   /** Message to log */
179:   message?: string;
180: }
181: 
182: /**
183:  * Serialized action for transmission
184:  */
185: export interface SerializedAction {
186:   /** Action name */
187:   name: string;
188:   /** Player position */
189:   player: number;
190:   /** Serialized arguments */
191:   args: Record<string, unknown>;
192:   /** Timestamp */
193:   timestamp?: number;
194:   /** Whether this action was undoable (false if action.undoable was false) */
195:   undoable?: boolean;
196: }
197: 
198: /**
199:  * Validation result
200:  */
201: export interface ValidationResult {
202:   valid: boolean;
203:   errors: string[];
204: }
````

## File: packages/engine/src/flow/engine.ts
````typescript
  1: import type { Game } from '../element/game.js';
  2: import type { Player } from '../player/player.js';
  3: import type { ActionResult } from '../action/types.js';
  4: import type {
  5:   FlowNode,
  6:   FlowContext,
  7:   FlowPosition,
  8:   FlowState,
  9:   FlowStepResult,
 10:   FlowDefinition,
 11:   SequenceConfig,
 12:   LoopConfig,
 13:   EachPlayerConfig,
 14:   ForEachConfig,
 15:   ActionStepConfig,
 16:   SimultaneousActionStepConfig,
 17:   SwitchConfig,
 18:   IfConfig,
 19:   ExecuteConfig,
 20:   PhaseConfig,
 21:   PlayerAwaitingState,
 22: } from './types.js';
 23: 
 24: /**
 25:  * Maximum iterations for safety (prevent infinite loops)
 26:  */
 27: const DEFAULT_MAX_ITERATIONS = 10000;
 28: 
 29: /**
 30:  * Creates a flow context for execution
 31:  */
 32: function createContext<G extends Game>(
 33:   game: G,
 34:   player?: Player,
 35:   variables: Record<string, unknown> = {}
 36: ): FlowContext<G> {
 37:   return {
 38:     game,
 39:     player,
 40:     variables,
 41:     set: (name: string, value: unknown) => {
 42:       variables[name] = value;
 43:     },
 44:     get: <T = unknown>(name: string): T | undefined => {
 45:       return variables[name] as T | undefined;
 46:     },
 47:   };
 48: }
 49: 
 50: /**
 51:  * Internal execution state for tracking position in nested flows
 52:  */
 53: interface ExecutionFrame {
 54:   node: FlowNode;
 55:   index: number; // Current step index for sequences, iteration for loops
 56:   completed: boolean;
 57:   data?: Record<string, unknown>; // Node-specific data
 58: }
 59: 
 60: /**
 61:  * FlowEngine executes flow definitions and manages game state progression.
 62:  * It handles pausing for player input and resuming from serialized positions.
 63:  */
 64: export class FlowEngine<G extends Game = Game> {
 65:   private game: G;
 66:   private definition: FlowDefinition;
 67:   private stack: ExecutionFrame[] = [];
 68:   private variables: Record<string, unknown> = {};
 69:   private currentPlayer?: Player;
 70:   private awaitingInput = false;
 71:   private availableActions: string[] = [];
 72:   private prompt?: string;
 73:   private complete = false;
 74:   private lastActionResult?: ActionResult;
 75:   /** For simultaneous action steps - tracks which players can act */
 76:   private awaitingPlayers: PlayerAwaitingState[] = [];
 77:   /** Current named phase (for UI display) */
 78:   private currentPhase?: string;
 79:   /** Move count for current action step with move limits */
 80:   private moveCount = 0;
 81:   /** Current action step config (for move limit tracking) */
 82:   private currentActionConfig?: ActionStepConfig;
 83: 
 84:   constructor(game: G, definition: FlowDefinition) {
 85:     this.game = game;
 86:     this.definition = definition;
 87:   }
 88: 
 89:   /**
 90:    * Start the flow from the beginning
 91:    */
 92:   start(): FlowState {
 93:     // Run setup if defined
 94:     const context = this.createContext();
 95:     if (this.definition.setup) {
 96:       this.definition.setup(context);
 97:     }
 98: 
 99:     // Initialize stack with root node
100:     this.stack = [{ node: this.definition.root, index: 0, completed: false }];
101:     this.variables = { ...context.variables };
102:     this.currentPlayer = this.game.players.current;
103:     this.awaitingInput = false;
104:     this.complete = false;
105: 
106:     // Execute until we need input or complete
107:     return this.run();
108:   }
109: 
110:   /**
111:    * Resume flow after player action
112:    * @param actionName The action to perform
113:    * @param args The action arguments
114:    * @param playerIndex Optional player index for simultaneous actions (if not provided, uses current player)
115:    */
116:   resume(actionName: string, args: Record<string, unknown>, playerIndex?: number): FlowState {
117:     if (!this.awaitingInput) {
118:       throw new Error('Flow is not awaiting input');
119:     }
120: 
121:     const currentFrame = this.stack[this.stack.length - 1];
122: 
123:     // Handle simultaneous action step
124:     if (currentFrame?.node.type === 'simultaneous-action-step') {
125:       return this.resumeSimultaneousAction(actionName, args, playerIndex, currentFrame);
126:     }
127: 
128:     // Execute the action (regular action step)
129:     const result = this.game.performAction(actionName, this.currentPlayer!, args);
130:     this.lastActionResult = result;
131: 
132:     if (!result.success) {
133:       // Action failed, stay in same state
134:       return this.getState();
135:     }
136: 
137:     // Clear awaiting state
138:     this.awaitingInput = false;
139: 
140:     // Handle action step completion logic
141:     if (currentFrame?.node.type === 'action-step') {
142:       const config = currentFrame.node.config as ActionStepConfig;
143: 
144:       // Increment move count
145:       const currentMoveCount = (currentFrame.data?.moveCount as number) ?? 0;
146:       const newMoveCount = currentMoveCount + 1;
147:       currentFrame.data = { ...currentFrame.data, moveCount: newMoveCount };
148: 
149:       // Check if maxMoves reached - auto-complete
150:       if (config.maxMoves && newMoveCount >= config.maxMoves) {
151:         currentFrame.completed = true;
152:         this.currentActionConfig = undefined;
153:         this.moveCount = 0;
154:       }
155:       // Check repeatUntil - only complete if minMoves is met
156:       else if (config.repeatUntil) {
157:         const minMovesMet = !config.minMoves || newMoveCount >= config.minMoves;
158:         if (config.repeatUntil(this.createContext()) && minMovesMet) {
159:           currentFrame.completed = true;
160:           this.currentActionConfig = undefined;
161:           this.moveCount = 0;
162:         }
163:       }
164:       // No repeatUntil and no maxMoves - complete after single action (unless minMoves/maxMoves configured)
165:       else if (!config.minMoves && !config.maxMoves) {
166:         currentFrame.completed = true;
167:         this.currentActionConfig = undefined;
168:         this.moveCount = 0;
169:       }
170:       // Has minMoves but no maxMoves and no repeatUntil - keep going
171:       // The executeActionStep will check minMoves when re-entered
172:     }
173: 
174:     return this.run();
175:   }
176: 
177:   /**
178:    * Resume a simultaneous action step after a player's action
179:    */
180:   private resumeSimultaneousAction(
181:     actionName: string,
182:     args: Record<string, unknown>,
183:     playerIndex: number | undefined,
184:     frame: ExecutionFrame
185:   ): FlowState {
186:     const config = frame.node.config as SimultaneousActionStepConfig;
187: 
188:     // Determine which player is acting
189:     let actingPlayerIndex = playerIndex;
190:     if (actingPlayerIndex === undefined) {
191:       // If not provided, use the first awaiting player
192:       const firstAwaiting = this.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
193:       if (firstAwaiting) {
194:         actingPlayerIndex = firstAwaiting.playerIndex;
195:       }
196:     }
197: 
198:     if (actingPlayerIndex === undefined) {
199:       throw new Error('No player specified and no awaiting players found');
200:     }
201: 
202:     // Validate player can act
203:     const playerState = this.awaitingPlayers.find(p => p.playerIndex === actingPlayerIndex);
204:     if (!playerState) {
205:       throw new Error(`Player ${actingPlayerIndex} is not awaiting action`);
206:     }
207:     if (playerState.completed) {
208:       throw new Error(`Player ${actingPlayerIndex} has already completed their action`);
209:     }
210:     if (!playerState.availableActions.includes(actionName)) {
211:       throw new Error(`Action ${actionName} is not available for player ${actingPlayerIndex}`);
212:     }
213: 
214:     // Execute the action
215:     const player = this.game.players[actingPlayerIndex];
216:     const result = this.game.performAction(actionName, player as any, args);
217:     this.lastActionResult = result;
218: 
219:     if (!result.success) {
220:       // Action failed, stay in same state
221:       return this.getState();
222:     }
223: 
224:     // Check if this player is done (re-evaluate after action)
225:     const context = this.createContext();
226:     if (config.playerDone) {
227:       playerState.completed = config.playerDone(context, player);
228:     }
229: 
230:     // Re-evaluate available actions for this player
231:     if (!playerState.completed) {
232:       const actions = typeof config.actions === 'function'
233:         ? config.actions(context, player)
234:         : config.actions;
235:       playerState.availableActions = actions.filter((actionName) => {
236:         const action = this.game.getAction(actionName);
237:         if (!action) return false;
238:         return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
239:       });
240:       // If no available actions left, mark as completed
241:       if (playerState.availableActions.length === 0) {
242:         playerState.completed = true;
243:       }
244:     }
245: 
246:     // Check if all players are done
247:     const allDone = config.allDone
248:       ? config.allDone(context)
249:       : this.awaitingPlayers.every(p => p.completed);
250: 
251:     if (allDone) {
252:       // Clear awaiting state and complete the step
253:       this.awaitingInput = false;
254:       this.awaitingPlayers = [];
255:       frame.completed = true;
256:       return this.run();
257:     }
258: 
259:     // Still awaiting other players
260:     return this.getState();
261:   }
262: 
263:   /**
264:    * Get the current flow state
265:    */
266:   getState(): FlowState {
267:     const state: FlowState = {
268:       position: this.getPosition(),
269:       complete: this.complete,
270:       awaitingInput: this.awaitingInput,
271:       currentPlayer: this.currentPlayer?.position,
272:       availableActions: this.awaitingInput ? this.availableActions : undefined,
273:       prompt: this.prompt,
274:       awaitingPlayers: this.awaitingPlayers.length > 0 ? this.awaitingPlayers : undefined,
275:       currentPhase: this.currentPhase,
276:     };
277: 
278:     // Add move count info if in an action step with limits
279:     if (this.currentActionConfig && (this.currentActionConfig.minMoves || this.currentActionConfig.maxMoves)) {
280:       state.moveCount = this.moveCount;
281:       if (this.currentActionConfig.maxMoves) {
282:         state.movesRemaining = this.currentActionConfig.maxMoves - this.moveCount;
283:       }
284:       if (this.currentActionConfig.minMoves) {
285:         state.movesRequired = Math.max(0, this.currentActionConfig.minMoves - this.moveCount);
286:       }
287:     }
288: 
289:     return state;
290:   }
291: 
292:   /**
293:    * Restore flow from a serialized position
294:    */
295:   restore(position: FlowPosition): void {
296:     this.variables = { ...position.variables };
297:     this.stack = [];
298: 
299:     // Rebuild stack from path
300:     let currentNode = this.definition.root;
301:     for (let i = 0; i < position.path.length; i++) {
302:       const index = position.path[i];
303:       const iterationKey = `__iter_${i}`;
304:       const iteration = position.iterations[iterationKey] ?? 0;
305: 
306:       this.stack.push({
307:         node: currentNode,
308:         index,
309:         completed: false,
310:         data: { iteration },
311:       });
312: 
313:       // Navigate to child node for next level
314:       currentNode = this.getChildNode(currentNode, index);
315:     }
316: 
317:     // Set player from position
318:     if (position.playerIndex !== undefined) {
319:       this.currentPlayer = this.game.players[position.playerIndex];
320:     }
321:   }
322: 
323:   /**
324:    * Check if the game is complete
325:    */
326:   isComplete(): boolean {
327:     return this.complete;
328:   }
329: 
330:   /**
331:    * Get the winners (if game is complete)
332:    */
333:   getWinners(): Player[] {
334:     if (!this.complete) return [];
335:     if (this.definition.getWinners) {
336:       return this.definition.getWinners(this.createContext());
337:     }
338:     return [];
339:   }
340: 
341:   // ============================================
342:   // Private Methods
343:   // ============================================
344: 
345:   private createContext(): FlowContext<G> {
346:     const context = createContext(this.game, this.currentPlayer, this.variables);
347:     context.lastActionResult = this.lastActionResult;
348:     return context;
349:   }
350: 
351:   private getPosition(): FlowPosition {
352:     const path: number[] = [];
353:     const iterations: Record<string, number> = {};
354: 
355:     for (let i = 0; i < this.stack.length; i++) {
356:       const frame = this.stack[i];
357:       path.push(frame.index);
358:       if (frame.data?.iteration !== undefined) {
359:         iterations[`__iter_${i}`] = frame.data.iteration as number;
360:       }
361:     }
362: 
363:     return {
364:       path,
365:       iterations,
366:       playerIndex: this.currentPlayer?.position,
367:       variables: { ...this.variables },
368:     };
369:   }
370: 
371:   private getChildNode(node: FlowNode, index: number): FlowNode {
372:     switch (node.type) {
373:       case 'sequence':
374:         return node.config.steps[index];
375:       case 'loop':
376:       case 'each-player':
377:       case 'for-each':
378:       case 'phase':
379:         return node.config.do;
380:       case 'if':
381:         return index === 0 ? node.config.then : (node.config.else ?? node.config.then);
382:       case 'switch': {
383:         const cases = Object.values(node.config.cases);
384:         return cases[index] ?? node.config.default ?? cases[0];
385:       }
386:       default:
387:         return node;
388:     }
389:   }
390: 
391:   /**
392:    * Main execution loop - runs until awaiting input or complete
393:    */
394:   private run(): FlowState {
395:     let iterations = 0;
396: 
397:     while (this.stack.length > 0 && !this.awaitingInput && !this.complete) {
398:       iterations++;
399:       if (iterations > DEFAULT_MAX_ITERATIONS) {
400:         throw new Error('Flow exceeded maximum iterations - possible infinite loop');
401:       }
402: 
403:       const frame = this.stack[this.stack.length - 1];
404: 
405:       // If frame is already completed (e.g., from resume), pop it and continue
406:       if (frame.completed) {
407:         this.stack.pop();
408:         continue;
409:       }
410: 
411:       const result = this.executeNode(frame);
412: 
413:       if (result.awaitingInput) {
414:         this.awaitingInput = true;
415:         break;
416:       }
417: 
418:       if (frame.completed) {
419:         this.stack.pop();
420:       }
421: 
422:       // Check game completion after each node execution
423:       if (this.definition.isComplete?.(this.createContext())) {
424:         this.complete = true;
425:         break;
426:       }
427:     }
428: 
429:     // Check completion after stack empty
430:     if (this.stack.length === 0 || this.definition.isComplete?.(this.createContext())) {
431:       this.complete = true;
432:     }
433: 
434:     return this.getState();
435:   }
436: 
437:   /**
438:    * Execute a single flow node
439:    */
440:   private executeNode(frame: ExecutionFrame): FlowStepResult {
441:     const context = this.createContext();
442: 
443:     switch (frame.node.type) {
444:       case 'sequence':
445:         return this.executeSequence(frame, frame.node.config, context);
446:       case 'loop':
447:         return this.executeLoop(frame, frame.node.config, context);
448:       case 'each-player':
449:         return this.executeEachPlayer(frame, frame.node.config, context);
450:       case 'for-each':
451:         return this.executeForEach(frame, frame.node.config, context);
452:       case 'action-step':
453:         return this.executeActionStep(frame, frame.node.config, context);
454:       case 'simultaneous-action-step':
455:         return this.executeSimultaneousActionStep(frame, frame.node.config, context);
456:       case 'switch':
457:         return this.executeSwitch(frame, frame.node.config, context);
458:       case 'if':
459:         return this.executeIf(frame, frame.node.config, context);
460:       case 'execute':
461:         return this.executeExecute(frame, frame.node.config, context);
462:       case 'phase':
463:         return this.executePhase(frame, frame.node.config, context);
464:       default:
465:         frame.completed = true;
466:         return { continue: true, awaitingInput: false };
467:     }
468:   }
469: 
470:   private executeSequence(
471:     frame: ExecutionFrame,
472:     config: SequenceConfig,
473:     context: FlowContext
474:   ): FlowStepResult {
475:     if (frame.index >= config.steps.length) {
476:       frame.completed = true;
477:       return { continue: true, awaitingInput: false };
478:     }
479: 
480:     // Push next step onto stack
481:     const nextStep = config.steps[frame.index];
482:     this.stack.push({ node: nextStep, index: 0, completed: false });
483:     frame.index++;
484: 
485:     return { continue: true, awaitingInput: false };
486:   }
487: 
488:   private executeLoop(
489:     frame: ExecutionFrame,
490:     config: LoopConfig,
491:     context: FlowContext
492:   ): FlowStepResult {
493:     const iteration = (frame.data?.iteration as number) ?? 0;
494:     const maxIterations = config.maxIterations ?? DEFAULT_MAX_ITERATIONS;
495: 
496:     // Check termination conditions
497:     if (iteration >= maxIterations) {
498:       frame.completed = true;
499:       return { continue: true, awaitingInput: false };
500:     }
501: 
502:     if (config.while && !config.while(context)) {
503:       frame.completed = true;
504:       return { continue: true, awaitingInput: false };
505:     }
506: 
507:     // Push loop body and increment iteration
508:     this.stack.push({ node: config.do, index: 0, completed: false });
509:     frame.data = { ...frame.data, iteration: iteration + 1 };
510:     frame.index++;
511: 
512:     return { continue: true, awaitingInput: false };
513:   }
514: 
515:   private executeEachPlayer(
516:     frame: ExecutionFrame,
517:     config: EachPlayerConfig,
518:     context: FlowContext
519:   ): FlowStepResult {
520:     // Get players to iterate over
521:     let players = [...this.game.players];
522: 
523:     if (config.filter) {
524:       players = players.filter((p) => config.filter!(p, context));
525:     }
526: 
527:     if (config.direction === 'backward') {
528:       players.reverse();
529:     }
530: 
531:     // Determine starting index
532:     if (frame.data?.playerIndex === undefined) {
533:       let startIndex = 0;
534:       if (config.startingPlayer) {
535:         const startPlayer = config.startingPlayer(context);
536:         startIndex = players.findIndex((p) => p === startPlayer);
537:         if (startIndex === -1) startIndex = 0;
538:       }
539:       frame.data = { ...frame.data, playerIndex: startIndex, players };
540:     }
541: 
542:     const playerIndex = frame.data.playerIndex as number;
543:     const playerList = (frame.data.players as Player[]) ?? players;
544: 
545:     if (playerIndex >= playerList.length) {
546:       frame.completed = true;
547:       return { continue: true, awaitingInput: false };
548:     }
549: 
550:     // Set current player and execute body
551:     this.currentPlayer = playerList[playerIndex];
552:     this.variables[config.name ?? 'currentPlayer'] = this.currentPlayer;
553: 
554:     this.stack.push({ node: config.do, index: 0, completed: false });
555:     frame.data = { ...frame.data, playerIndex: playerIndex + 1 };
556:     frame.index++;
557: 
558:     return { continue: true, awaitingInput: false };
559:   }
560: 
561:   private executeForEach(
562:     frame: ExecutionFrame,
563:     config: ForEachConfig,
564:     context: FlowContext
565:   ): FlowStepResult {
566:     // Get items to iterate
567:     const items = typeof config.collection === 'function'
568:       ? config.collection(context)
569:       : config.collection;
570: 
571:     const itemIndex = (frame.data?.itemIndex as number) ?? 0;
572: 
573:     if (itemIndex >= items.length) {
574:       frame.completed = true;
575:       return { continue: true, awaitingInput: false };
576:     }
577: 
578:     // Set current item variable
579:     this.variables[config.as] = items[itemIndex];
580: 
581:     this.stack.push({ node: config.do, index: 0, completed: false });
582:     frame.data = { ...frame.data, itemIndex: itemIndex + 1 };
583:     frame.index++;
584: 
585:     return { continue: true, awaitingInput: false };
586:   }
587: 
588:   private executeActionStep(
589:     frame: ExecutionFrame,
590:     config: ActionStepConfig,
591:     context: FlowContext
592:   ): FlowStepResult {
593:     // Check skip condition
594:     if (config.skipIf?.(context)) {
595:       this.currentActionConfig = undefined;
596:       this.moveCount = 0;
597:       frame.completed = true;
598:       return { continue: true, awaitingInput: false };
599:     }
600: 
601:     // Initialize move count on first entry
602:     if (frame.data?.moveCount === undefined) {
603:       frame.data = { ...frame.data, moveCount: 0 };
604:     }
605:     const moveCount = frame.data.moveCount as number;
606: 
607:     // Check if maxMoves reached
608:     if (config.maxMoves && moveCount >= config.maxMoves) {
609:       this.currentActionConfig = undefined;
610:       this.moveCount = 0;
611:       frame.completed = true;
612:       return { continue: true, awaitingInput: false };
613:     }
614: 
615:     // Check repeat-until (if we have a last action result and minMoves is met)
616:     const minMovesMet = !config.minMoves || moveCount >= config.minMoves;
617:     if (this.lastActionResult && config.repeatUntil?.(context) && minMovesMet) {
618:       this.currentActionConfig = undefined;
619:       this.moveCount = 0;
620:       frame.completed = true;
621:       this.lastActionResult = undefined;
622:       return { continue: true, awaitingInput: false };
623:     }
624: 
625:     // Determine player
626:     const player = config.player ? config.player(context) : context.player;
627:     if (!player) {
628:       throw new Error('ActionStep requires a player');
629:     }
630: 
631:     // Get available actions
632:     const actions = typeof config.actions === 'function'
633:       ? config.actions(context)
634:       : config.actions;
635: 
636:     // Filter to only available actions
637:     const available = actions.filter((actionName) => {
638:       const action = this.game.getAction(actionName);
639:       if (!action) return false;
640:       return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
641:     });
642: 
643:     // If no available actions and minMoves met, complete
644:     if (available.length === 0 && minMovesMet) {
645:       this.currentActionConfig = undefined;
646:       this.moveCount = 0;
647:       frame.completed = true;
648:       return { continue: true, awaitingInput: false };
649:     }
650: 
651:     // If no available actions but minMoves not met, this is an error state
652:     if (available.length === 0 && !minMovesMet) {
653:       throw new Error(`ActionStep requires ${config.minMoves} moves but only ${moveCount} were possible`);
654:     }
655: 
656:     // Store config for getState() move count tracking
657:     this.currentActionConfig = config;
658:     this.moveCount = moveCount;
659: 
660:     // Prompt for input
661:     this.currentPlayer = player;
662:     this.availableActions = available;
663:     this.prompt = typeof config.prompt === 'function' ? config.prompt(context) : config.prompt;
664: 
665:     // Don't mark completed yet - we'll continue after input
666:     return {
667:       continue: false,
668:       awaitingInput: true,
669:       availableActions: available,
670:       currentPlayer: player,
671:     };
672:   }
673: 
674:   private executeSimultaneousActionStep(
675:     frame: ExecutionFrame,
676:     config: SimultaneousActionStepConfig,
677:     context: FlowContext
678:   ): FlowStepResult {
679:     // Get players who should participate
680:     const players = config.players
681:       ? config.players(context)
682:       : [...this.game.players];
683: 
684:     // Build awaiting state for each player
685:     this.awaitingPlayers = [];
686: 
687:     for (const player of players) {
688:       // Check if player should be skipped
689:       if (config.skipPlayer?.(context, player)) {
690:         continue;
691:       }
692: 
693:       // Check if player is already done
694:       if (config.playerDone?.(context, player)) {
695:         continue;
696:       }
697: 
698:       // Get available actions for this player
699:       const actions = typeof config.actions === 'function'
700:         ? config.actions(context, player)
701:         : config.actions;
702: 
703:       const available = actions.filter((actionName) => {
704:         const action = this.game.getAction(actionName);
705:         if (!action) return false;
706:         return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
707:       });
708: 
709:       // Only add player if they have available actions
710:       if (available.length > 0) {
711:         this.awaitingPlayers.push({
712:           playerIndex: player.position,
713:           availableActions: available,
714:           completed: false,
715:         });
716:       }
717:     }
718: 
719:     // If no players need to act, complete immediately
720:     if (this.awaitingPlayers.length === 0) {
721:       frame.completed = true;
722:       return { continue: true, awaitingInput: false };
723:     }
724: 
725:     // Check if allDone already returns true
726:     if (config.allDone?.(context)) {
727:       this.awaitingPlayers = [];
728:       frame.completed = true;
729:       return { continue: true, awaitingInput: false };
730:     }
731: 
732:     // Set prompt
733:     this.prompt = typeof config.prompt === 'function' ? config.prompt(context) : config.prompt;
734: 
735:     // Don't mark completed - waiting for all players
736:     return {
737:       continue: false,
738:       awaitingInput: true,
739:     };
740:   }
741: 
742:   private executeSwitch(
743:     frame: ExecutionFrame,
744:     config: SwitchConfig,
745:     context: FlowContext
746:   ): FlowStepResult {
747:     // If we've already pushed a branch, we're done (child has completed)
748:     if (frame.data?.branchPushed) {
749:       frame.completed = true;
750:       return { continue: true, awaitingInput: false };
751:     }
752: 
753:     const value = config.on(context);
754:     const stringValue = String(value);
755: 
756:     const branch = config.cases[stringValue] ?? config.default;
757:     if (!branch) {
758:       frame.completed = true;
759:       return { continue: true, awaitingInput: false };
760:     }
761: 
762:     this.stack.push({ node: branch, index: 0, completed: false });
763:     frame.data = { branchPushed: true };
764: 
765:     return { continue: true, awaitingInput: false };
766:   }
767: 
768:   private executeIf(
769:     frame: ExecutionFrame,
770:     config: IfConfig,
771:     context: FlowContext
772:   ): FlowStepResult {
773:     // If we've already pushed a branch, we're done (child has completed)
774:     if (frame.data?.branchPushed) {
775:       frame.completed = true;
776:       return { continue: true, awaitingInput: false };
777:     }
778: 
779:     const condition = config.condition(context);
780: 
781:     if (condition) {
782:       this.stack.push({ node: config.then, index: 0, completed: false });
783:       frame.data = { branchPushed: true };
784:     } else if (config.else) {
785:       this.stack.push({ node: config.else, index: 0, completed: false });
786:       frame.data = { branchPushed: true };
787:     } else {
788:       // No branch to execute, complete immediately
789:       frame.completed = true;
790:     }
791: 
792:     return { continue: true, awaitingInput: false };
793:   }
794: 
795:   private executeExecute(
796:     frame: ExecutionFrame,
797:     config: ExecuteConfig,
798:     context: FlowContext
799:   ): FlowStepResult {
800:     // Run the side effect function
801:     config.fn(context);
802:     // Update variables in engine from context
803:     this.variables = { ...context.variables };
804:     frame.completed = true;
805:     return { continue: true, awaitingInput: false };
806:   }
807: 
808:   private executePhase(
809:     frame: ExecutionFrame,
810:     config: PhaseConfig,
811:     context: FlowContext
812:   ): FlowStepResult {
813:     // If we haven't entered this phase yet
814:     if (!frame.data?.entered) {
815:       // Set current phase
816:       const previousPhase = this.currentPhase;
817:       this.currentPhase = config.name;
818: 
819:       // Call onEnterPhase hook
820:       if (this.definition.onEnterPhase) {
821:         this.definition.onEnterPhase(config.name, context);
822:       }
823: 
824:       // Push the phase body and mark as entered
825:       this.stack.push({ node: config.do, index: 0, completed: false });
826:       frame.data = { entered: true, previousPhase };
827: 
828:       return { continue: true, awaitingInput: false };
829:     }
830: 
831:     // Phase body has completed - call onExitPhase hook
832:     if (this.definition.onExitPhase) {
833:       this.definition.onExitPhase(config.name, context);
834:     }
835: 
836:     // Restore previous phase (for nested phases)
837:     this.currentPhase = frame.data.previousPhase as string | undefined;
838:     frame.completed = true;
839: 
840:     return { continue: true, awaitingInput: false };
841:   }
842: }
````

## File: packages/engine/src/flow/index.ts
````typescript
 1: // Flow engine
 2: export { FlowEngine } from './engine.js';
 3: 
 4: // Builder functions
 5: export {
 6:   sequence,
 7:   namedSequence,
 8:   phase,
 9:   loop,
10:   repeat,
11:   eachPlayer,
12:   forEach,
13:   actionStep,
14:   simultaneousActionStep,
15:   playerActions,
16:   switchOn,
17:   ifThen,
18:   defineFlow,
19:   noop,
20:   execute,
21:   setVar,
22: } from './builders.js';
23: 
24: // Turn order presets
25: export { TurnOrder } from './turn-order.js';
26: export type { TurnOrderConfig } from './turn-order.js';
27: 
28: // Types
29: export type {
30:   FlowNodeType,
31:   FlowStepResult,
32:   FlowPosition,
33:   FlowContext,
34:   FlowNode,
35:   FlowState,
36:   FlowDefinition,
37:   BaseFlowConfig,
38:   SequenceConfig,
39:   LoopConfig,
40:   EachPlayerConfig,
41:   ForEachConfig,
42:   ActionStepConfig,
43:   SimultaneousActionStepConfig,
44:   SwitchConfig,
45:   IfConfig,
46:   ExecuteConfig,
47:   PhaseConfig,
48:   PlayerAwaitingState,
49: } from './types.js';
````

## File: packages/engine/src/flow/types.ts
````typescript
  1: import type { Game } from '../element/game.js';
  2: import type { Player } from '../player/player.js';
  3: import type { ActionDefinition, ActionResult } from '../action/types.js';
  4: 
  5: /**
  6:  * Flow node types
  7:  */
  8: export type FlowNodeType =
  9:   | 'sequence'
 10:   | 'loop'
 11:   | 'each-player'
 12:   | 'for-each'
 13:   | 'action-step'
 14:   | 'simultaneous-action-step'
 15:   | 'switch'
 16:   | 'if'
 17:   | 'execute'
 18:   | 'phase';
 19: 
 20: /**
 21:  * Result of a flow step execution
 22:  */
 23: export interface FlowStepResult {
 24:   /** Whether the flow should continue */
 25:   continue: boolean;
 26:   /** Whether the flow needs player input */
 27:   awaitingInput: boolean;
 28:   /** Available actions if awaiting input */
 29:   availableActions?: string[];
 30:   /** Current player if awaiting input */
 31:   currentPlayer?: Player;
 32:   /** Message to display */
 33:   message?: string;
 34:   /** Additional data */
 35:   data?: Record<string, unknown>;
 36: }
 37: 
 38: /**
 39:  * Serialized flow position for pause/resume
 40:  */
 41: export interface FlowPosition {
 42:   /** Stack of node indices (path through nested flows) */
 43:   path: number[];
 44:   /** Current iteration counts for loops */
 45:   iterations: Record<string, number>;
 46:   /** Current player index for eachPlayer */
 47:   playerIndex?: number;
 48:   /** Current item index for forEach */
 49:   itemIndex?: number;
 50:   /** Variables stored in flow context */
 51:   variables: Record<string, unknown>;
 52: }
 53: 
 54: /**
 55:  * Context passed to flow nodes during execution
 56:  */
 57: export interface FlowContext<G extends Game = Game> {
 58:   /** The game instance */
 59:   game: G;
 60:   /** Current player (if in a player-scoped flow) */
 61:   player?: Player;
 62:   /** Variables stored during flow execution */
 63:   variables: Record<string, unknown>;
 64:   /** Set a variable */
 65:   set: (name: string, value: unknown) => void;
 66:   /** Get a variable */
 67:   get: <T = unknown>(name: string) => T | undefined;
 68:   /** Result of the last action */
 69:   lastActionResult?: ActionResult;
 70: }
 71: 
 72: /**
 73:  * Base configuration for all flow nodes
 74:  */
 75: export interface BaseFlowConfig {
 76:   /** Optional name for this flow node (for serialization) */
 77:   name?: string;
 78: }
 79: 
 80: /**
 81:  * Configuration for sequence flow
 82:  */
 83: export interface SequenceConfig extends BaseFlowConfig {
 84:   /** Steps to execute in order */
 85:   steps: FlowNode[];
 86: }
 87: 
 88: /**
 89:  * Configuration for loop flow
 90:  */
 91: export interface LoopConfig extends BaseFlowConfig {
 92:   /** Condition to continue looping (evaluated before each iteration) */
 93:   while?: (context: FlowContext) => boolean;
 94:   /** Maximum iterations (safety limit) */
 95:   maxIterations?: number;
 96:   /** Body of the loop */
 97:   do: FlowNode;
 98: }
 99: 
100: /**
101:  * Configuration for each-player flow
102:  */
103: export interface EachPlayerConfig extends BaseFlowConfig {
104:   /** Filter which players to include */
105:   filter?: (player: Player, context: FlowContext) => boolean;
106:   /** Direction of rotation */
107:   direction?: 'forward' | 'backward';
108:   /** Starting player (defaults to current player) */
109:   startingPlayer?: (context: FlowContext) => Player;
110:   /** Body to execute for each player */
111:   do: FlowNode;
112: }
113: 
114: /**
115:  * Configuration for for-each flow
116:  */
117: export interface ForEachConfig<T = unknown> extends BaseFlowConfig {
118:   /** Items to iterate over */
119:   collection: T[] | ((context: FlowContext) => T[]);
120:   /** Variable name to store current item */
121:   as: string;
122:   /** Body to execute for each item */
123:   do: FlowNode;
124: }
125: 
126: /**
127:  * Configuration for action step
128:  */
129: export interface ActionStepConfig extends BaseFlowConfig {
130:   /** Player who should act (defaults to context.player) */
131:   player?: (context: FlowContext) => Player;
132:   /** Actions available to the player */
133:   actions: string[] | ((context: FlowContext) => string[]);
134:   /** Prompt to display */
135:   prompt?: string | ((context: FlowContext) => string);
136:   /** Continue until this returns true */
137:   repeatUntil?: (context: FlowContext) => boolean;
138:   /** Skip if this returns true */
139:   skipIf?: (context: FlowContext) => boolean;
140:   /** Optional timeout in milliseconds */
141:   timeout?: number;
142:   /** Minimum number of moves required before step can complete */
143:   minMoves?: number;
144:   /** Maximum number of moves allowed (auto-completes after this many) */
145:   maxMoves?: number;
146: }
147: 
148: /**
149:  * Configuration for simultaneous action step (multiple players act at once)
150:  */
151: export interface SimultaneousActionStepConfig extends BaseFlowConfig {
152:   /** Players who can act (defaults to all players) */
153:   players?: (context: FlowContext) => Player[];
154:   /** Actions available to each player */
155:   actions: string[] | ((context: FlowContext, player: Player) => string[]);
156:   /** Prompt to display */
157:   prompt?: string | ((context: FlowContext) => string);
158:   /** Condition to check if a player is done (per-player) */
159:   playerDone?: (context: FlowContext, player: Player) => boolean;
160:   /** Condition to check if the entire step is complete */
161:   allDone?: (context: FlowContext) => boolean;
162:   /** Skip this player if returns true */
163:   skipPlayer?: (context: FlowContext, player: Player) => boolean;
164:   /** Optional timeout in milliseconds */
165:   timeout?: number;
166: }
167: 
168: /**
169:  * Configuration for switch flow (branch based on condition)
170:  */
171: export interface SwitchConfig extends BaseFlowConfig {
172:   /** Value to switch on */
173:   on: (context: FlowContext) => unknown;
174:   /** Cases to match */
175:   cases: Record<string, FlowNode>;
176:   /** Default case if no match */
177:   default?: FlowNode;
178: }
179: 
180: /**
181:  * Configuration for if flow (conditional execution)
182:  */
183: export interface IfConfig extends BaseFlowConfig {
184:   /** Condition to check */
185:   condition: (context: FlowContext) => boolean;
186:   /** Execute if true */
187:   then: FlowNode;
188:   /** Execute if false */
189:   else?: FlowNode;
190: }
191: 
192: /**
193:  * Configuration for execute flow (run side effect)
194:  */
195: export interface ExecuteConfig extends BaseFlowConfig {
196:   /** Function to execute */
197:   fn: (context: FlowContext) => void;
198: }
199: 
200: /**
201:  * Configuration for phase flow (named game phase)
202:  */
203: export interface PhaseConfig extends BaseFlowConfig {
204:   /** Phase name (required, displayed in UI) */
205:   name: string;
206:   /** Body to execute during this phase */
207:   do: FlowNode;
208: }
209: 
210: /**
211:  * Union of all flow node types
212:  */
213: export type FlowNode =
214:   | { type: 'sequence'; config: SequenceConfig }
215:   | { type: 'loop'; config: LoopConfig }
216:   | { type: 'each-player'; config: EachPlayerConfig }
217:   | { type: 'for-each'; config: ForEachConfig }
218:   | { type: 'action-step'; config: ActionStepConfig }
219:   | { type: 'simultaneous-action-step'; config: SimultaneousActionStepConfig }
220:   | { type: 'switch'; config: SwitchConfig }
221:   | { type: 'if'; config: IfConfig }
222:   | { type: 'execute'; config: ExecuteConfig }
223:   | { type: 'phase'; config: PhaseConfig };
224: 
225: /**
226:  * Per-player awaiting state for simultaneous actions
227:  */
228: export interface PlayerAwaitingState {
229:   /** Player position */
230:   playerIndex: number;
231:   /** Actions available to this player */
232:   availableActions: string[];
233:   /** Whether this player has completed their action */
234:   completed: boolean;
235: }
236: 
237: /**
238:  * Flow execution state
239:  */
240: export interface FlowState {
241:   /** Current position in the flow */
242:   position: FlowPosition;
243:   /** Whether the flow is complete */
244:   complete: boolean;
245:   /** Whether awaiting player input */
246:   awaitingInput: boolean;
247:   /** Current player if awaiting input (for single-player action steps) */
248:   currentPlayer?: number;
249:   /** Available actions if awaiting input (for single-player action steps) */
250:   availableActions?: string[];
251:   /** Prompt to display */
252:   prompt?: string;
253:   /** Multiple players awaiting input (for simultaneous action steps) */
254:   awaitingPlayers?: PlayerAwaitingState[];
255:   /** Current named phase (for UI display) */
256:   currentPhase?: string;
257:   /** Move count for current action step (if minMoves/maxMoves configured) */
258:   moveCount?: number;
259:   /** Moves remaining until maxMoves (if configured) */
260:   movesRemaining?: number;
261:   /** Moves required until minMoves met (if configured) */
262:   movesRequired?: number;
263: }
264: 
265: /**
266:  * Flow definition for a game
267:  */
268: export interface FlowDefinition {
269:   /** The root flow node */
270:   root: FlowNode;
271:   /** Setup function called before flow starts */
272:   setup?: (context: FlowContext) => void;
273:   /** Check if game is complete */
274:   isComplete?: (context: FlowContext) => boolean;
275:   /** Determine winners when complete */
276:   getWinners?: (context: FlowContext) => Player[];
277:   /** Called when entering a named phase */
278:   onEnterPhase?: (phaseName: string, context: FlowContext) => void;
279:   /** Called when exiting a named phase */
280:   onExitPhase?: (phaseName: string, context: FlowContext) => void;
281: }
````

## File: packages/session/src/game-session.ts
````typescript
  1: /**
  2:  * Core GameSession class for managing game state and lifecycle
  3:  */
  4: 
  5: import type { FlowState, SerializedAction, Game } from '@boardsmith/engine';
  6: import { GameRunner } from '@boardsmith/runtime';
  7: import type {
  8:   GameClass,
  9:   StoredGameState,
 10:   PlayerGameState,
 11:   SessionInfo,
 12:   StateUpdate,
 13:   StorageAdapter,
 14:   BroadcastAdapter,
 15:   AIConfig,
 16: } from './types.js';
 17: import { buildPlayerState, computeUndoInfo } from './utils.js';
 18: import { AIController } from './ai-controller.js';
 19: 
 20: // ============================================
 21: // Types
 22: // ============================================
 23: 
 24: /**
 25:  * Options for creating a new game session
 26:  */
 27: export interface GameSessionOptions<G extends Game = Game> {
 28:   gameType: string;
 29:   GameClass: GameClass<G>;
 30:   playerCount: number;
 31:   playerNames: string[];
 32:   playerIds?: string[];
 33:   seed?: string;
 34:   storage?: StorageAdapter;
 35:   aiConfig?: AIConfig;
 36: }
 37: 
 38: /**
 39:  * Result of performing an action
 40:  */
 41: export interface ActionResult {
 42:   success: boolean;
 43:   error?: string;
 44:   flowState?: FlowState;
 45:   state?: PlayerGameState;
 46:   serializedAction?: SerializedAction;
 47: }
 48: 
 49: /**
 50:  * Result of undoing actions
 51:  */
 52: export interface UndoResult {
 53:   success: boolean;
 54:   error?: string;
 55:   flowState?: FlowState;
 56:   state?: PlayerGameState;
 57:   /** Number of actions that were undone */
 58:   actionsUndone?: number;
 59: }
 60: 
 61: /**
 62:  * Element-level diff between two game states
 63:  */
 64: export interface ElementDiff {
 65:   /** Element IDs that were added */
 66:   added: number[];
 67:   /** Element IDs that were removed */
 68:   removed: number[];
 69:   /** Element IDs that changed (attributes, children, etc.) */
 70:   changed: number[];
 71:   /** The from action index */
 72:   fromIndex: number;
 73:   /** The to action index */
 74:   toIndex: number;
 75: }
 76: 
 77: // ============================================
 78: // GameSession Class
 79: // ============================================
 80: 
 81: /**
 82:  * Core game session that manages game state, actions, and real-time updates.
 83:  *
 84:  * This class is platform-agnostic and uses adapters for storage and broadcasting.
 85:  * It handles:
 86:  * - Game lifecycle (create, restore)
 87:  * - Action processing
 88:  * - State management
 89:  * - Broadcasting to connected clients
 90:  * - AI player integration (optional)
 91:  *
 92:  * @example
 93:  * ```typescript
 94:  * // Create a new game
 95:  * const session = GameSession.create({
 96:  *   gameType: 'checkers',
 97:  *   GameClass: CheckersGame,
 98:  *   playerCount: 2,
 99:  *   playerNames: ['Alice', 'Bob'],
100:  *   aiConfig: { players: [1], level: 'medium' },
101:  * });
102:  *
103:  * // Set up broadcasting
104:  * session.setBroadcaster(myBroadcastAdapter);
105:  *
106:  * // Perform actions
107:  * const result = await session.performAction('move', 0, { from: 'a3', to: 'b4' });
108:  * ```
109:  */
110: export class GameSession<G extends Game = Game, TSession extends SessionInfo = SessionInfo> {
111:   #runner: GameRunner<G>;
112:   readonly #storedState: StoredGameState;
113:   readonly #GameClass: GameClass<G>;
114:   readonly #storage?: StorageAdapter;
115:   readonly #aiController?: AIController<G>;
116:   #broadcaster?: BroadcastAdapter<TSession>;
117: 
118:   private constructor(
119:     runner: GameRunner<G>,
120:     storedState: StoredGameState,
121:     GameClass: GameClass<G>,
122:     storage?: StorageAdapter,
123:     aiController?: AIController<G>
124:   ) {
125:     this.#runner = runner;
126:     this.#storedState = storedState;
127:     this.#GameClass = GameClass;
128:     this.#storage = storage;
129:     this.#aiController = aiController;
130:   }
131: 
132:   // ============================================
133:   // Factory Methods
134:   // ============================================
135: 
136:   /**
137:    * Create a new game session
138:    */
139:   static create<G extends Game = Game>(options: GameSessionOptions<G>): GameSession<G> {
140:     const {
141:       gameType,
142:       GameClass,
143:       playerCount,
144:       playerNames,
145:       playerIds,
146:       seed,
147:       storage,
148:       aiConfig,
149:     } = options;
150: 
151:     const gameSeed = seed ?? Math.random().toString(36).substring(2) + Date.now().toString(36);
152: 
153:     const runner = new GameRunner<G>({
154:       GameClass,
155:       gameType,
156:       gameOptions: { playerCount, playerNames, seed: gameSeed },
157:     });
158: 
159:     const storedState: StoredGameState = {
160:       gameType,
161:       playerCount,
162:       playerNames,
163:       playerIds,
164:       seed: gameSeed,
165:       actionHistory: [],
166:       createdAt: Date.now(),
167:       aiConfig,
168:     };
169: 
170:     runner.start();
171: 
172:     const aiController = aiConfig
173:       ? new AIController(GameClass, gameType, playerCount, aiConfig)
174:       : undefined;
175: 
176:     const session = new GameSession(runner, storedState, GameClass, storage, aiController);
177: 
178:     // Trigger AI if it should move first
179:     if (aiController?.hasAIPlayers()) {
180:       session.#scheduleAICheck();
181:     }
182: 
183:     return session;
184:   }
185: 
186:   /**
187:    * Restore a game session from stored state
188:    */
189:   static restore<G extends Game = Game>(
190:     storedState: StoredGameState,
191:     GameClass: GameClass<G>,
192:     storage?: StorageAdapter
193:   ): GameSession<G> {
194:     const runner = GameRunner.replay<G>(
195:       {
196:         GameClass,
197:         gameType: storedState.gameType,
198:         gameOptions: {
199:           playerCount: storedState.playerCount,
200:           playerNames: storedState.playerNames,
201:           seed: storedState.seed,
202:         },
203:       },
204:       storedState.actionHistory
205:     );
206: 
207:     const aiController = storedState.aiConfig
208:       ? new AIController(GameClass, storedState.gameType, storedState.playerCount, storedState.aiConfig)
209:       : undefined;
210: 
211:     return new GameSession(runner, storedState, GameClass, storage, aiController);
212:   }
213: 
214:   // ============================================
215:   // Accessors
216:   // ============================================
217: 
218:   /**
219:    * Set the broadcast adapter for real-time updates
220:    */
221:   setBroadcaster(broadcaster: BroadcastAdapter<TSession>): void {
222:     this.#broadcaster = broadcaster;
223:   }
224: 
225:   /**
226:    * Get the current game runner (for advanced use cases)
227:    */
228:   get runner(): GameRunner<G> {
229:     return this.#runner;
230:   }
231: 
232:   /**
233:    * Get the stored state
234:    */
235:   get storedState(): StoredGameState {
236:     return this.#storedState;
237:   }
238: 
239:   /**
240:    * Get the game type
241:    */
242:   get gameType(): string {
243:     return this.#storedState.gameType;
244:   }
245: 
246:   /**
247:    * Get the player count
248:    */
249:   get playerCount(): number {
250:     return this.#storedState.playerCount;
251:   }
252: 
253:   /**
254:    * Get the player names
255:    */
256:   get playerNames(): string[] {
257:     return this.#storedState.playerNames;
258:   }
259: 
260:   // ============================================
261:   // State Methods
262:   // ============================================
263: 
264:   /**
265:    * Get the flow state
266:    */
267:   getFlowState(): FlowState | undefined {
268:     return this.#runner.getFlowState();
269:   }
270: 
271:   /**
272:    * Get the game state for a specific player
273:    * @param playerPosition Player's position
274:    * @param options.includeActionMetadata Include action metadata for auto-UI (default: true)
275:    */
276:   getState(
277:     playerPosition: number,
278:     options?: { includeActionMetadata?: boolean }
279:   ): { success: boolean; flowState?: FlowState; state?: PlayerGameState } {
280:     const flowState = this.#runner.getFlowState();
281:     const state = buildPlayerState(
282:       this.#runner,
283:       this.#storedState.playerNames,
284:       playerPosition,
285:       { includeActionMetadata: options?.includeActionMetadata ?? true }
286:     );
287:     return { success: true, flowState, state };
288:   }
289: 
290:   /**
291:    * Build player state for a specific position
292:    */
293:   buildPlayerState(playerPosition: number, options?: { includeActionMetadata?: boolean }): PlayerGameState {
294:     return buildPlayerState(
295:       this.#runner,
296:       this.#storedState.playerNames,
297:       playerPosition,
298:       { includeActionMetadata: options?.includeActionMetadata ?? true }
299:     );
300:   }
301: 
302:   /**
303:    * Get action history
304:    */
305:   getHistory(): { actionHistory: SerializedAction[]; createdAt: number } {
306:     return {
307:       actionHistory: this.#storedState.actionHistory,
308:       createdAt: this.#storedState.createdAt,
309:     };
310:   }
311: 
312:   /**
313:    * Get state at a specific action index (for time travel debugging)
314:    * Creates a temporary game and replays actions up to the specified index.
315:    */
316:   getStateAtAction(actionIndex: number, playerPosition: number): { success: boolean; state?: PlayerGameState; error?: string } {
317:     const history = this.#storedState.actionHistory;
318: 
319:     // Validate index
320:     if (actionIndex < 0 || actionIndex > history.length) {
321:       return { success: false, error: `Invalid action index: ${actionIndex}. History has ${history.length} actions.` };
322:     }
323: 
324:     try {
325:       // Get subset of actions to replay
326:       const actionsToReplay = history.slice(0, actionIndex);
327: 
328:       // Create a temporary runner and replay
329:       const tempRunner = GameRunner.replay<G>(
330:         {
331:           GameClass: this.#GameClass,
332:           gameType: this.#storedState.gameType,
333:           gameOptions: {
334:             playerCount: this.#storedState.playerCount,
335:             playerNames: this.#storedState.playerNames,
336:             seed: this.#storedState.seed,
337:           },
338:         },
339:         actionsToReplay
340:       );
341: 
342:       // Build state for the requested player
343:       const state = buildPlayerState(
344:         tempRunner,
345:         this.#storedState.playerNames,
346:         playerPosition,
347:         { includeActionMetadata: false }
348:       );
349: 
350:       return { success: true, state };
351:     } catch (error) {
352:       return {
353:         success: false,
354:         error: error instanceof Error ? error.message : 'Failed to replay game state',
355:       };
356:     }
357:   }
358: 
359:   /**
360:    * Compute diff between two action points (for state diff highlighting)
361:    * Returns lists of element IDs that were added, removed, or changed
362:    */
363:   getStateDiff(
364:     fromIndex: number,
365:     toIndex: number,
366:     playerPosition: number
367:   ): { success: boolean; diff?: ElementDiff; error?: string } {
368:     const history = this.#storedState.actionHistory;
369: 
370:     // Validate indices
371:     if (fromIndex < 0 || fromIndex > history.length) {
372:       return { success: false, error: `Invalid fromIndex: ${fromIndex}` };
373:     }
374:     if (toIndex < 0 || toIndex > history.length) {
375:       return { success: false, error: `Invalid toIndex: ${toIndex}` };
376:     }
377: 
378:     try {
379:       // Get states at both points
380:       const fromResult = this.getStateAtAction(fromIndex, playerPosition);
381:       const toResult = this.getStateAtAction(toIndex, playerPosition);
382: 
383:       if (!fromResult.success || !fromResult.state) {
384:         return { success: false, error: fromResult.error || 'Failed to get from state' };
385:       }
386:       if (!toResult.success || !toResult.state) {
387:         return { success: false, error: toResult.error || 'Failed to get to state' };
388:       }
389: 
390:       // Extract element IDs from view trees, tracking parent relationships
391:       // Map: element id -> { parentId, attributes (without children/player metadata) }
392:       const fromElements = new Map<number, { parentId: number | null; attrs: string }>();
393:       const toElements = new Map<number, { parentId: number | null; attrs: string }>();
394: 
395:       function getComparableAttrs(obj: Record<string, unknown>): string {
396:         // Only compare attributes that represent actual game state, not metadata
397:         const attrs = obj.attributes as Record<string, unknown> | undefined;
398:         if (!attrs) return '';
399:         // Filter out player object (has _isCurrent that changes), keep game-relevant attrs
400:         const filtered: Record<string, unknown> = {};
401:         for (const [key, value] of Object.entries(attrs)) {
402:           // Skip player objects and internal metadata
403:           if (key === 'player' || key === 'game' || key.startsWith('_')) continue;
404:           filtered[key] = value;
405:         }
406:         return JSON.stringify(filtered);
407:       }
408: 
409:       function collectElements(node: unknown, map: Map<number, { parentId: number | null; attrs: string }>, parentId: number | null = null) {
410:         if (!node || typeof node !== 'object') return;
411:         const obj = node as Record<string, unknown>;
412:         if (typeof obj.id === 'number') {
413:           map.set(obj.id, {
414:             parentId,
415:             attrs: getComparableAttrs(obj),
416:           });
417:           // Recurse into children with this node as parent
418:           if (Array.isArray(obj.children)) {
419:             for (const child of obj.children) {
420:               collectElements(child, map, obj.id);
421:             }
422:           }
423:         } else if (Array.isArray(obj.children)) {
424:           // Node without id, just recurse
425:           for (const child of obj.children) {
426:             collectElements(child, map, parentId);
427:           }
428:         }
429:       }
430: 
431:       collectElements(fromResult.state.view, fromElements);
432:       collectElements(toResult.state.view, toElements);
433: 
434:       // Compute diff - focus on elements that moved (parent changed) or whose attributes changed
435:       const added: number[] = [];
436:       const removed: number[] = [];
437:       const changed: number[] = [];
438: 
439:       for (const [id, toData] of toElements.entries()) {
440:         const fromData = fromElements.get(id);
441:         if (!fromData) {
442:           added.push(id);
443:         } else if (fromData.parentId !== toData.parentId || fromData.attrs !== toData.attrs) {
444:           // Element moved to different parent OR its attributes changed
445:           changed.push(id);
446:         }
447:       }
448: 
449:       for (const id of fromElements.keys()) {
450:         if (!toElements.has(id)) {
451:           removed.push(id);
452:         }
453:       }
454: 
455:       return {
456:         success: true,
457:         diff: { added, removed, changed, fromIndex, toIndex },
458:       };
459:     } catch (error) {
460:       return {
461:         success: false,
462:         error: error instanceof Error ? error.message : 'Failed to compute diff',
463:       };
464:     }
465:   }
466: 
467:   // ============================================
468:   // Action Methods
469:   // ============================================
470: 
471:   /**
472:    * Perform an action
473:    */
474:   async performAction(
475:     action: string,
476:     player: number,
477:     args: Record<string, unknown>
478:   ): Promise<ActionResult> {
479:     if (player < 0 || player >= this.#storedState.playerCount) {
480:       return { success: false, error: `Invalid player: ${player}` };
481:     }
482: 
483:     const result = this.#runner.performAction(action, player, args);
484: 
485:     if (!result.success) {
486:       return { success: false, error: result.error };
487:     }
488: 
489:     // Update stored action history
490:     this.#storedState.actionHistory = this.#runner.actionHistory;
491: 
492:     // Persist if storage adapter is provided
493:     if (this.#storage) {
494:       await this.#storage.save(this.#storedState);
495:     }
496: 
497:     // Broadcast to all connected clients
498:     this.broadcast();
499: 
500:     // Check if AI should respond
501:     this.#scheduleAICheck();
502: 
503:     return {
504:       success: true,
505:       flowState: result.flowState,
506:       state: buildPlayerState(this.#runner, this.#storedState.playerNames, player, { includeActionMetadata: true }),
507:       serializedAction: result.serializedAction,
508:     };
509:   }
510: 
511:   /**
512:    * Undo actions back to the start of the current player's turn.
513:    * Only works if it's the player's turn and they've made at least one action.
514:    */
515:   async undoToTurnStart(playerPosition: number): Promise<UndoResult> {
516:     // Validate player position
517:     if (playerPosition < 0 || playerPosition >= this.#storedState.playerCount) {
518:       return { success: false, error: `Invalid player: ${playerPosition}` };
519:     }
520: 
521:     // Check if it's this player's turn
522:     const flowState = this.#runner.getFlowState();
523:     if (flowState?.currentPlayer !== playerPosition) {
524:       return { success: false, error: "It's not your turn" };
525:     }
526: 
527:     // Compute where the turn started
528:     const { turnStartActionIndex, actionsThisTurn } = computeUndoInfo(
529:       this.#storedState.actionHistory,
530:       flowState.currentPlayer
531:     );
532: 
533:     // Check if there's anything to undo
534:     if (actionsThisTurn === 0) {
535:       return { success: false, error: 'No actions to undo' };
536:     }
537: 
538:     // Replay game to the turn start point
539:     const actionsToReplay = this.#storedState.actionHistory.slice(0, turnStartActionIndex);
540: 
541:     try {
542:       // Create a new runner replayed to the turn start
543:       const newRunner = GameRunner.replay<G>(
544:         {
545:           GameClass: this.#GameClass,
546:           gameType: this.#storedState.gameType,
547:           gameOptions: {
548:             playerCount: this.#storedState.playerCount,
549:             playerNames: this.#storedState.playerNames,
550:             seed: this.#storedState.seed,
551:           },
552:         },
553:         actionsToReplay
554:       );
555: 
556:       // Replace the current runner
557:       this.#runner = newRunner;
558: 
559:       // Update stored action history
560:       this.#storedState.actionHistory = actionsToReplay;
561: 
562:       // Persist if storage adapter is provided
563:       if (this.#storage) {
564:         await this.#storage.save(this.#storedState);
565:       }
566: 
567:       // Broadcast to all connected clients
568:       this.broadcast();
569: 
570:       const newFlowState = this.#runner.getFlowState();
571: 
572:       return {
573:         success: true,
574:         flowState: newFlowState,
575:         state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true }),
576:         actionsUndone: actionsThisTurn,
577:       };
578:     } catch (error) {
579:       return {
580:         success: false,
581:         error: error instanceof Error ? error.message : 'Failed to undo',
582:       };
583:     }
584:   }
585: 
586:   // ============================================
587:   // Broadcasting
588:   // ============================================
589: 
590:   /**
591:    * Broadcast current state to all connected sessions
592:    */
593:   broadcast(): void {
594:     if (!this.#broadcaster) return;
595: 
596:     const flowState = this.#runner.getFlowState();
597:     const sessions = this.#broadcaster.getSessions();
598: 
599:     for (const session of sessions) {
600:       const effectivePosition = session.isSpectator ? 0 : session.playerPosition;
601:       const state = buildPlayerState(this.#runner, this.#storedState.playerNames, effectivePosition, { includeActionMetadata: true });
602: 
603:       const update: StateUpdate = {
604:         type: 'state',
605:         flowState,
606:         state,
607:         playerPosition: session.playerPosition,
608:         isSpectator: session.isSpectator,
609:       };
610: 
611:       try {
612:         this.#broadcaster.send(session, update);
613:       } catch (error) {
614:         console.error('Broadcast error:', error);
615:       }
616:     }
617:   }
618: 
619:   // ============================================
620:   // AI Integration
621:   // ============================================
622: 
623:   /**
624:    * Schedule an AI check (non-blocking)
625:    */
626:   #scheduleAICheck(): void {
627:     if (!this.#aiController?.hasAIPlayers()) return;
628: 
629:     // Use setImmediate/setTimeout to avoid blocking
630:     const schedule = typeof setImmediate !== 'undefined'
631:       ? setImmediate
632:       : (fn: () => void) => setTimeout(fn, 0);
633: 
634:     schedule(() => this.#checkAITurn());
635:   }
636: 
637:   /**
638:    * Check if AI should play and execute move
639:    */
640:   async #checkAITurn(): Promise<void> {
641:     if (!this.#aiController) return;
642: 
643:     const move = await this.#aiController.checkAndPlay(
644:       this.#runner,
645:       this.#storedState.actionHistory,
646:       async (action, player, args) => {
647:         const result = this.#runner.performAction(action, player, args);
648:         if (result.success) {
649:           this.#storedState.actionHistory = this.#runner.actionHistory;
650:           if (this.#storage) {
651:             await this.#storage.save(this.#storedState);
652:           }
653:           this.broadcast();
654:           return true;
655:         }
656:         return false;
657:       }
658:     );
659: 
660:     // If AI made a move, check again (might be multi-step or next AI player)
661:     if (move) {
662:       this.#scheduleAICheck();
663:     }
664:   }
665: }
````

## File: packages/engine/src/element/game.ts
````typescript
  1: import { Space } from './space.js';
  2: import { GameElement } from './game-element.js';
  3: import type { ElementContext, ElementClass, ElementJSON } from './types.js';
  4: import { Player, PlayerCollection } from '../player/player.js';
  5: import type { GameCommand, CommandResult } from '../command/types.js';
  6: import { executeCommand } from '../command/executor.js';
  7: import type { ActionDefinition, ActionResult, SerializedAction } from '../action/types.js';
  8: import { ActionExecutor } from '../action/action.js';
  9: import type { FlowDefinition, FlowState, FlowPosition } from '../flow/types.js';
 10: import { FlowEngine } from '../flow/engine.js';
 11: 
 12: /**
 13:  * Options for creating a new game
 14:  */
 15: export type GameOptions = {
 16:   /** Number of players */
 17:   playerCount: number;
 18:   /** Player names (optional) */
 19:   playerNames?: string[];
 20:   /** Random seed for deterministic gameplay */
 21:   seed?: string;
 22: };
 23: 
 24: /**
 25:  * Game phase
 26:  */
 27: export type GamePhase = 'setup' | 'started' | 'finished';
 28: 
 29: /**
 30:  * Function to transform game state for a specific player's view.
 31:  * Runs AFTER zone-based visibility filtering.
 32:  * Use for attribute-level filtering that zone visibility can't handle.
 33:  *
 34:  * @param state - The zone-filtered state
 35:  * @param playerPosition - The player position (null for spectators)
 36:  * @param game - The game instance
 37:  * @returns The transformed state
 38:  */
 39: export type PlayerViewFunction<G extends Game = Game> = (
 40:   state: ElementJSON,
 41:   playerPosition: number | null,
 42:   game: G
 43: ) => ElementJSON;
 44: 
 45: /**
 46:  * Seeded random number generator
 47:  */
 48: function createSeededRandom(seed: string): () => number {
 49:   // Simple mulberry32 PRNG
 50:   let h = 0;
 51:   for (let i = 0; i < seed.length; i++) {
 52:     h = Math.imul(31, h) + seed.charCodeAt(i) | 0;
 53:   }
 54: 
 55:   return function () {
 56:     h |= 0;
 57:     h = h + 0x6D2B79F5 | 0;
 58:     let t = Math.imul(h ^ h >>> 15, 1 | h);
 59:     t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
 60:     return ((t ^ t >>> 14) >>> 0) / 4294967296;
 61:   };
 62: }
 63: 
 64: /**
 65:  * Base Game class. The root of the element tree and container for all game state.
 66:  * Extend this class to create your game.
 67:  */
 68: export class Game<
 69:   G extends Game = any,
 70:   P extends Player = any
 71: > extends Space<G, P> {
 72:   /**
 73:    * Optional function to transform state for each player's view.
 74:    * Override in subclass for custom attribute-level filtering.
 75:    */
 76:   static playerView?: PlayerViewFunction;
 77: 
 78:   /** Container for removed elements */
 79:   pile!: GameElement;
 80: 
 81:   /** All players in the game */
 82:   players: PlayerCollection<P> = new PlayerCollection<P>();
 83: 
 84:   /** Current game phase */
 85:   phase: GamePhase = 'setup';
 86: 
 87:   /** Seeded random number generator */
 88:   random: () => number;
 89: 
 90:   /** Message log */
 91:   messages: Array<{ text: string; data?: Record<string, unknown> }> = [];
 92: 
 93:   /** Game settings */
 94:   settings: Record<string, unknown> = {};
 95: 
 96:   /** Command history for event sourcing */
 97:   commandHistory: GameCommand[] = [];
 98: 
 99:   /** Registered actions */
100:   private _actions: Map<string, ActionDefinition> = new Map();
101: 
102:   /** Action executor for validation and execution */
103:   private _actionExecutor!: ActionExecutor;
104: 
105:   /** Flow definition for this game */
106:   private _flowDefinition?: FlowDefinition;
107: 
108:   /** Flow engine instance */
109:   private _flowEngine?: FlowEngine;
110: 
111:   static override unserializableAttributes = [
112:     ...Space.unserializableAttributes,
113:     'pile',
114:     'players',
115:     'random',
116:     'commandHistory',
117:     '_actions',
118:     '_actionExecutor',
119:     '_flowDefinition',
120:     '_flowEngine',
121:   ];
122: 
123:   constructor(options: GameOptions) {
124:     // Create seed for random
125:     const seed = options.seed ?? Math.random().toString(36).substring(2);
126:     const random = createSeededRandom(seed);
127: 
128:     // Initialize context with Map for class registry
129:     const ctx: Partial<ElementContext> = {
130:       sequence: 0,
131:       classRegistry: new Map(),
132:       random,
133:     };
134: 
135:     super(ctx);
136: 
137:     this.random = random;
138:     this.game = this as unknown as G;
139:     this._ctx.game = this;
140: 
141:     // Register base classes
142:     this._ctx.classRegistry.set('Space', Space as unknown as ElementClass);
143:     this._ctx.classRegistry.set('GameElement', GameElement as unknown as ElementClass);
144: 
145:     // Create removed elements pile
146:     this.pile = this.createElement(Space, '__pile__');
147:     this.pile._t.parent = undefined; // Remove from main tree
148: 
149:     // Create players
150:     for (let i = 0; i < options.playerCount; i++) {
151:       const name = options.playerNames?.[i] ?? `Player ${i + 1}`;
152:       const player = this.createPlayer(i, name);
153:       player.game = this as unknown as Game;
154:       this.players.push(player as P);
155:     }
156: 
157:     // Set first player as current
158:     if (this.players.length > 0) {
159:       this.players.setCurrent(0);
160:     }
161: 
162:     // Initialize action executor
163:     this._actionExecutor = new ActionExecutor(this);
164:   }
165: 
166:   /**
167:    * Factory method to create players - override to use custom Player class
168:    */
169:   protected createPlayer(position: number, name: string): P {
170:     return new Player(position, name) as P;
171:   }
172: 
173:   /**
174:    * Register element classes for serialization/deserialization.
175:    * Call this in your game constructor before creating elements.
176:    *
177:    * @example
178:    * ```typescript
179:    * constructor(options: MyGameOptions) {
180:    *   super(options);
181:    *   this.registerElements([Card, Hand, Deck, DiscardPile]);
182:    *   // ... create elements
183:    * }
184:    * ```
185:    */
186:   protected registerElements(
187:     classes: (new (...args: any[]) => GameElement)[]
188:   ): void {
189:     for (const cls of classes) {
190:       const className = cls.name;
191:       if (!this._ctx.classRegistry.has(className)) {
192:         this._ctx.classRegistry.set(className, cls as ElementClass);
193:       }
194:     }
195:   }
196: 
197:   /**
198:    * Create an element without adding it to the tree (internal use)
199:    */
200:   protected createElement<T extends GameElement>(
201:     elementClass: ElementClass<T>,
202:     name: string
203:   ): T {
204:     const element = new elementClass(this._ctx);
205:     element.name = name;
206:     element.game = this as unknown as Game;
207: 
208:     const className = elementClass.name;
209:     if (!this._ctx.classRegistry.has(className)) {
210:       this._ctx.classRegistry.set(className, elementClass);
211:     }
212: 
213:     return element;
214:   }
215: 
216:   // ============================================
217:   // Element Lookup
218:   // ============================================
219: 
220:   /**
221:    * Find an element by its ID anywhere in the game tree
222:    */
223:   getElementById(id: number): GameElement | undefined {
224:     // Check main tree
225:     const found = this.atId(id);
226:     if (found) return found;
227: 
228:     // Check pile
229:     return this.pile.atId(id);
230:   }
231: 
232:   /**
233:    * Get an element class by name (for command execution)
234:    */
235:   getElementClass(className: string): ElementClass | undefined {
236:     return this._ctx.classRegistry.get(className);
237:   }
238: 
239:   // ============================================
240:   // Command Execution
241:   // ============================================
242: 
243:   /**
244:    * Execute a command and record it in history
245:    */
246:   execute(command: GameCommand): CommandResult {
247:     const result = executeCommand(this, command);
248:     if (result.success) {
249:       this.commandHistory.push(command);
250:     }
251:     return result;
252:   }
253: 
254:   /**
255:    * Replay commands to rebuild state
256:    */
257:   replayCommands(commands: GameCommand[]): void {
258:     for (const command of commands) {
259:       const result = executeCommand(this, command);
260:       if (!result.success) {
261:         throw new Error(`Failed to replay command: ${result.error}`);
262:       }
263:       this.commandHistory.push(command);
264:     }
265:   }
266: 
267:   // ============================================
268:   // Action System
269:   // ============================================
270: 
271:   /**
272:    * Register an action definition
273:    */
274:   registerAction(action: ActionDefinition): void {
275:     this._actions.set(action.name, action);
276:   }
277: 
278:   /**
279:    * Register multiple actions
280:    */
281:   registerActions(...actions: ActionDefinition[]): void {
282:     for (const action of actions) {
283:       this.registerAction(action);
284:     }
285:   }
286: 
287:   /**
288:    * Get an action definition by name
289:    */
290:   getAction(name: string): ActionDefinition | undefined {
291:     return this._actions.get(name);
292:   }
293: 
294:   /**
295:    * Get all registered action names
296:    */
297:   getActionNames(): string[] {
298:     return [...this._actions.keys()];
299:   }
300: 
301:   /**
302:    * Get available actions for a player
303:    */
304:   getAvailableActions(player: P): ActionDefinition[] {
305:     const available: ActionDefinition[] = [];
306:     for (const action of this._actions.values()) {
307:       if (this._actionExecutor.isActionAvailable(action, player)) {
308:         available.push(action);
309:       }
310:     }
311:     return available;
312:   }
313: 
314:   /**
315:    * Get the action executor (for advanced usage like building action metadata)
316:    */
317:   getActionExecutor(): ActionExecutor {
318:     return this._actionExecutor;
319:   }
320: 
321:   /**
322:    * Get the choices for a selection (for UI)
323:    */
324:   getSelectionChoices(
325:     actionName: string,
326:     selectionName: string,
327:     player: P,
328:     args: Record<string, unknown> = {}
329:   ): unknown[] {
330:     const action = this._actions.get(actionName);
331:     if (!action) return [];
332: 
333:     const selection = action.selections.find(s => s.name === selectionName);
334:     if (!selection) return [];
335: 
336:     return this._actionExecutor.getChoices(selection, player, args);
337:   }
338: 
339:   /**
340:    * Perform an action with the given arguments
341:    */
342:   performAction(
343:     actionName: string,
344:     player: P,
345:     args: Record<string, unknown>
346:   ): ActionResult {
347:     const action = this._actions.get(actionName);
348:     if (!action) {
349:       return { success: false, error: `Unknown action: ${actionName}` };
350:     }
351: 
352:     return this._actionExecutor.executeAction(action, player, args);
353:   }
354: 
355:   /**
356:    * Perform an action from serialized form (for network play)
357:    */
358:   performSerializedAction(serialized: SerializedAction): ActionResult {
359:     const player = this.players[serialized.player];
360:     if (!player) {
361:       return { success: false, error: `Invalid player: ${serialized.player}` };
362:     }
363: 
364:     return this.performAction(serialized.name, player as P, serialized.args);
365:   }
366: 
367:   // ============================================
368:   // Flow System
369:   // ============================================
370: 
371:   /**
372:    * Set the flow definition for this game
373:    */
374:   setFlow(definition: FlowDefinition): void {
375:     this._flowDefinition = definition;
376:   }
377: 
378:   /**
379:    * Get the flow definition
380:    */
381:   getFlow(): FlowDefinition | undefined {
382:     return this._flowDefinition;
383:   }
384: 
385:   /**
386:    * Start the game flow
387:    */
388:   startFlow(): FlowState {
389:     if (!this._flowDefinition) {
390:       throw new Error('No flow definition set');
391:     }
392: 
393:     this._flowEngine = new FlowEngine(this, this._flowDefinition);
394:     const state = this._flowEngine.start();
395: 
396:     // Update game phase based on flow state
397:     if (this.phase === 'setup') {
398:       this.phase = 'started';
399:     }
400:     if (state.complete) {
401:       this.phase = 'finished';
402:     }
403: 
404:     return state;
405:   }
406: 
407:   /**
408:    * Resume flow after player action
409:    * @param actionName Action name to perform
410:    * @param args Action arguments
411:    * @param playerIndex Optional player index for simultaneous actions
412:    */
413:   continueFlow(actionName: string, args: Record<string, unknown>, playerIndex?: number): FlowState {
414:     if (!this._flowEngine) {
415:       throw new Error('Flow not started');
416:     }
417: 
418:     const state = this._flowEngine.resume(actionName, args, playerIndex);
419: 
420:     if (state.complete) {
421:       this.phase = 'finished';
422:       const winners = this._flowEngine.getWinners();
423:       if (winners.length > 0) {
424:         this.settings.winners = winners.map(p => p.position);
425:       }
426:     }
427: 
428:     return state;
429:   }
430: 
431:   /**
432:    * Get current flow state
433:    */
434:   getFlowState(): FlowState | undefined {
435:     return this._flowEngine?.getState();
436:   }
437: 
438:   /**
439:    * Restore flow from serialized position
440:    */
441:   restoreFlow(position: FlowPosition): void {
442:     if (!this._flowDefinition) {
443:       throw new Error('No flow definition set');
444:     }
445: 
446:     this._flowEngine = new FlowEngine(this, this._flowDefinition);
447:     this._flowEngine.restore(position);
448:   }
449: 
450:   /**
451:    * Check if flow is awaiting player input
452:    */
453:   isAwaitingInput(): boolean {
454:     return this._flowEngine?.getState().awaitingInput ?? false;
455:   }
456: 
457:   /**
458:    * Get current player from flow (if awaiting input)
459:    */
460:   getCurrentFlowPlayer(): P | undefined {
461:     const state = this._flowEngine?.getState();
462:     if (state?.currentPlayer !== undefined) {
463:       return this.players[state.currentPlayer];
464:     }
465:     return undefined;
466:   }
467: 
468:   /**
469:    * Get available actions from flow (if awaiting input)
470:    */
471:   getFlowAvailableActions(): string[] {
472:     return this._flowEngine?.getState().availableActions ?? [];
473:   }
474: 
475:   /**
476:    * Get awaiting players for simultaneous actions
477:    * Returns undefined if not in a simultaneous action step
478:    */
479:   getAwaitingPlayers(): { playerIndex: number; availableActions: string[]; completed: boolean }[] | undefined {
480:     const state = this._flowEngine?.getState();
481:     return state?.awaitingPlayers;
482:   }
483: 
484:   /**
485:    * Check if a player can act (either as current player or in simultaneous action)
486:    */
487:   canPlayerAct(playerIndex: number): boolean {
488:     const state = this._flowEngine?.getState();
489:     if (!state?.awaitingInput) return false;
490: 
491:     // Check for simultaneous action step
492:     if (state.awaitingPlayers && state.awaitingPlayers.length > 0) {
493:       const playerState = state.awaitingPlayers.find(p => p.playerIndex === playerIndex);
494:       return playerState ? !playerState.completed && playerState.availableActions.length > 0 : false;
495:     }
496: 
497:     // Check for regular single-player action step
498:     return state.currentPlayer === playerIndex;
499:   }
500: 
501:   // ============================================
502:   // Game Lifecycle
503:   // ============================================
504: 
505:   /**
506:    * Start the game (called after setup)
507:    */
508:   start(): void {
509:     if (this.phase !== 'setup') {
510:       throw new Error('Game has already started');
511:     }
512:     this.phase = 'started';
513:   }
514: 
515:   /**
516:    * End the game
517:    */
518:   finish(winners?: P[]): void {
519:     this.phase = 'finished';
520:     if (winners) {
521:       this.settings.winners = winners.map(p => p.position);
522:     }
523:   }
524: 
525:   /**
526:    * Check if the game is finished
527:    */
528:   isFinished(): boolean {
529:     return this.phase === 'finished';
530:   }
531: 
532:   /**
533:    * Get the winners (if game is finished)
534:    */
535:   getWinners(): P[] {
536:     const positions = this.settings.winners as number[] | undefined;
537:     if (!positions) return [];
538:     return positions.map(pos => this.players[pos]);
539:   }
540: 
541:   // ============================================
542:   // Player Context
543:   // ============================================
544: 
545:   /**
546:    * Set the current player context for "mine" queries
547:    */
548:   setPlayerContext(player: P | number | undefined): void {
549:     if (player === undefined) {
550:       this._ctx.player = undefined;
551:     } else if (typeof player === 'number') {
552:       this._ctx.player = this.players[player];
553:     } else {
554:       this._ctx.player = player;
555:     }
556:   }
557: 
558:   /**
559:    * Get the current player context
560:    */
561:   getPlayerContext(): P | undefined {
562:     return this._ctx.player as P | undefined;
563:   }
564: 
565:   // ============================================
566:   // Messaging
567:   // ============================================
568: 
569:   /**
570:    * Add a message to the game log
571:    */
572:   message(text: string, data?: Record<string, unknown>): void {
573:     this.addMessageInternal(text, data);
574:   }
575: 
576:   /**
577:    * Internal method to add a message (called by command executor)
578:    */
579:   addMessageInternal(text: string, data?: Record<string, unknown>): void {
580:     this.messages.push({ text, data });
581:   }
582: 
583:   /**
584:    * Get formatted messages (with template substitution)
585:    */
586:   getFormattedMessages(): string[] {
587:     return this.messages.map(({ text, data }) => {
588:       if (!data) return text;
589:       let processed = text;
590:       for (const [key, value] of Object.entries(data)) {
591:         const replacement = value instanceof GameElement
592:           ? value.toString()
593:           : value instanceof Player
594:             ? value.name
595:             : String(value);
596:         processed = processed.replace(new RegExp(`{{${key}}}`, 'g'), replacement);
597:       }
598:       return processed;
599:     });
600:   }
601: 
602:   // ============================================
603:   // Serialization
604:   // ============================================
605: 
606:   /**
607:    * Serialize the complete game state
608:    */
609:   override toJSON(): ElementJSON & {
610:     players: Record<string, unknown>[];
611:     phase: GamePhase;
612:     messages: Array<{ text: string; data?: Record<string, unknown> }>;
613:     settings: Record<string, unknown>;
614:   } {
615:     return {
616:       ...super.toJSON(),
617:       players: this.players.toJSON(),
618:       phase: this.phase,
619:       messages: this.messages,
620:       settings: this.settings,
621:     };
622:   }
623: 
624:   /**
625:    * Get the game state from the perspective of a specific player
626:    * (hides elements that player shouldn't see based on zone visibility)
627:    * @param player - Player, player position, or null for spectator view
628:    */
629:   toJSONForPlayer(player: P | number | null): ElementJSON {
630:     const position = player === null ? null : (typeof player === 'number' ? player : player.position);
631:     // For visibility checks, spectators use -1 (no special access)
632:     const visibilityPosition = position ?? -1;
633: 
634:     const filterElement = (json: ElementJSON, element: GameElement): ElementJSON | null => {
635:       const visibility = element.getEffectiveVisibility();
636: 
637:       // Handle count-only mode: show count but not contents
638:       // Preserve element name and $-prefixed system attributes (like $type) for AutoUI rendering
639:       if (visibility.mode === 'count-only' && !element.isVisibleTo(visibilityPosition)) {
640:         const systemAttrs: Record<string, unknown> = {};
641:         for (const [key, value] of Object.entries(json.attributes ?? {})) {
642:           if (key.startsWith('$')) {
643:             systemAttrs[key] = value;
644:           }
645:         }
646:         return {
647:           className: json.className,
648:           id: json.id,
649:           name: json.name,
650:           attributes: systemAttrs,
651:           childCount: element._t.children.length,
652:         };
653:       }
654: 
655:       // Check if element is visible to this player
656:       if (!element.isVisibleTo(visibilityPosition)) {
657:         // Return a hidden placeholder
658:         return {
659:           className: json.className,
660:           id: json.id,
661:           attributes: { __hidden: true },
662:         };
663:       }
664: 
665:       // Check zone visibility for children (if this is a Space)
666:       const zoneVisibility = (element as any).getZoneVisibility?.();
667: 
668:       // If zone has hidden or count-only visibility, handle children specially
669:       if (zoneVisibility) {
670:         if (zoneVisibility.mode === 'hidden') {
671:           // Don't show children at all
672:           return {
673:             ...json,
674:             children: undefined,
675:             childCount: element._t.children.length,
676:           };
677:         } else if (zoneVisibility.mode === 'count-only') {
678:           // Show count but not actual children
679:           return {
680:             ...json,
681:             children: undefined,
682:             childCount: element._t.children.length,
683:           };
684:         } else if (zoneVisibility.mode === 'owner' && element.player?.position !== visibilityPosition) {
685:           // Owner-only zone and this player doesn't own it - show hidden placeholders
686:           // Preserve $-prefixed system attributes (like $type) for proper AutoUI rendering
687:           const hiddenChildren: ElementJSON[] = [];
688:           if (json.children) {
689:             for (const childJson of json.children) {
690:               const systemAttrs: Record<string, unknown> = { __hidden: true };
691:               for (const [key, value] of Object.entries(childJson.attributes ?? {})) {
692:                 if (key.startsWith('$')) {
693:                   systemAttrs[key] = value;
694:                 }
695:               }
696:               hiddenChildren.push({
697:                 className: childJson.className,
698:                 id: childJson.id,
699:                 attributes: systemAttrs,
700:               });
701:             }
702:           }
703:           return {
704:             ...json,
705:             children: hiddenChildren.length > 0 ? hiddenChildren : undefined,
706:           };
707:         }
708:       }
709: 
710:       // Filter children normally
711:       const filteredChildren: ElementJSON[] = [];
712:       if (json.children) {
713:         for (let i = 0; i < json.children.length; i++) {
714:           const childJson = json.children[i];
715:           const childElement = element._t.children[i];
716:           const filtered = filterElement(childJson, childElement);
717:           if (filtered) {
718:             filteredChildren.push(filtered);
719:           }
720:         }
721:       }
722: 
723:       return {
724:         ...json,
725:         children: filteredChildren.length > 0 ? filteredChildren : undefined,
726:       };
727:     };
728: 
729:     const fullJson = this.toJSON();
730:     let filteredState = filterElement(fullJson, this) ?? fullJson;
731: 
732:     // Apply playerView transformation if defined
733:     const GameClass = this.constructor as typeof Game;
734:     if (GameClass.playerView) {
735:       filteredState = GameClass.playerView(filteredState, position, this);
736:     }
737: 
738:     return filteredState;
739:   }
740: 
741:   /**
742:    * Create a game from serialized JSON
743:    */
744:   static restoreGame<G extends Game>(
745:     json: ReturnType<G['toJSON']>,
746:     GameClass: new (options: GameOptions) => G,
747:     classRegistry: Map<string, ElementClass>
748:   ): G {
749:     const game = new GameClass({
750:       playerCount: json.players.length,
751:       playerNames: json.players.map(p => p.name as string),
752:     });
753: 
754:     // Merge class registry
755:     for (const [name, cls] of classRegistry) {
756:       game._ctx.classRegistry.set(name, cls);
757:     }
758: 
759:     // Restore state from JSON
760:     game.phase = json.phase;
761:     game.messages = json.messages;
762:     game.settings = json.settings;
763: 
764:     // Clear auto-created children and restore from JSON
765:     game._t.children = [];
766:     if (json.children) {
767:       for (const childJson of json.children) {
768:         const child = GameElement.fromJSON(childJson, game._ctx, game._ctx.classRegistry);
769:         child._t.parent = game;
770:         (child as GameElement).game = game;
771:         game._t.children.push(child);
772:       }
773:     }
774: 
775:     return game;
776:   }
777: }
````

## File: packages/engine/src/index.ts
````typescript
  1: // Element system
  2: export {
  3:   GameElement,
  4:   Space,
  5:   Piece,
  6:   Card,
  7:   Hand,
  8:   Deck,
  9:   Grid,
 10:   GridCell,
 11:   HexGrid,
 12:   HexCell,
 13:   Game,
 14:   ElementCollection,
 15: } from './element/index.js';
 16: 
 17: export type {
 18:   ElementClass,
 19:   ElementContext,
 20:   ElementTree,
 21:   ElementJSON,
 22:   ElementFinder,
 23:   ElementAttributes,
 24:   Sorter,
 25:   GameOptions,
 26:   GamePhase,
 27:   PlayerViewFunction,
 28:   ElementLayout,
 29:   HexOrientation,
 30:   HexCoordSystem,
 31:   LayoutDirection,
 32:   LayoutAlignment,
 33: } from './element/index.js';
 34: 
 35: // Player system
 36: export { Player, PlayerCollection } from './player/index.js';
 37: 
 38: // Command system (event sourcing)
 39: export {
 40:   executeCommand,
 41:   canPlayerSee,
 42:   visibilityFromMode,
 43:   resolveVisibility,
 44:   DEFAULT_VISIBILITY,
 45: } from './command/index.js';
 46: 
 47: export type {
 48:   GameCommand,
 49:   CommandResult,
 50:   BaseCommand,
 51:   CreateElementCommand,
 52:   CreateManyCommand,
 53:   MoveCommand,
 54:   RemoveCommand,
 55:   ShuffleCommand,
 56:   SetAttributeCommand,
 57:   SetVisibilityCommand,
 58:   AddVisibleToCommand,
 59:   SetCurrentPlayerCommand,
 60:   MessageCommand,
 61:   StartGameCommand,
 62:   EndGameCommand,
 63:   SetOrderCommand,
 64:   VisibilityConfig,
 65:   VisibilityMode,
 66:   VisibilityState,
 67: } from './command/index.js';
 68: 
 69: // Action system
 70: export { Action, ActionExecutor } from './action/index.js';
 71: 
 72: export type {
 73:   SelectionType,
 74:   Selection,
 75:   BaseSelection,
 76:   ChoiceSelection,
 77:   PlayerSelection,
 78:   ElementSelection,
 79:   TextSelection,
 80:   NumberSelection,
 81:   ActionContext,
 82:   ActionDefinition,
 83:   ActionResult,
 84:   SerializedAction,
 85:   ValidationResult,
 86:   BoardElementRef,
 87:   ChoiceBoardRefs,
 88:   DependentFilter,
 89: } from './action/index.js';
 90: 
 91: // Flow system
 92: export {
 93:   FlowEngine,
 94:   sequence,
 95:   namedSequence,
 96:   phase,
 97:   loop,
 98:   repeat,
 99:   eachPlayer,
100:   forEach,
101:   actionStep,
102:   simultaneousActionStep,
103:   playerActions,
104:   switchOn,
105:   ifThen,
106:   defineFlow,
107:   noop,
108:   execute,
109:   setVar,
110:   TurnOrder,
111: } from './flow/index.js';
112: 
113: export type {
114:   FlowNodeType,
115:   FlowStepResult,
116:   FlowPosition,
117:   FlowContext,
118:   FlowNode,
119:   FlowState,
120:   FlowDefinition,
121:   BaseFlowConfig,
122:   SequenceConfig,
123:   LoopConfig,
124:   EachPlayerConfig,
125:   ForEachConfig,
126:   ActionStepConfig,
127:   SimultaneousActionStepConfig,
128:   SwitchConfig,
129:   IfConfig,
130:   ExecuteConfig,
131:   PhaseConfig,
132:   PlayerAwaitingState,
133:   TurnOrderConfig,
134: } from './flow/index.js';
135: 
136: // Utilities (serialization, snapshots, replays)
137: export {
138:   serializeValue,
139:   deserializeValue,
140:   serializeAction,
141:   deserializeAction,
142:   isSerializedReference,
143:   createSnapshot,
144:   createPlayerView,
145:   createAllPlayerViews,
146:   computeDiff,
147:   createReplayFile,
148:   validateReplayFile,
149:   parseReplayFile,
150: } from './utils/index.js';
151: 
152: export type {
153:   SerializedReference,
154:   SerializeOptions,
155:   GameStateSnapshot,
156:   PlayerStateView,
157:   StateDiff,
158:   ReplayFile,
159: } from './utils/index.js';
160: 
161: // Sandbox (execution limits and security)
162: export {
163:   ExecutionContext,
164:   ExecutionLimitError,
165:   withLimits,
166:   withLimitsAsync,
167:   guard,
168:   validateCode,
169:   DEFAULT_LIMITS,
170: } from './sandbox/index.js';
171: 
172: export type {
173:   ExecutionLimits,
174: } from './sandbox/index.js';
````

## File: packages/cli/src/local-server.ts
````typescript
  1: /**
  2:  * Local development server for BoardSmith games
  3:  * Uses the shared @boardsmith/server core with Node.js HTTP and WebSocket adapters
  4:  */
  5: 
  6: import { createServer, IncomingMessage, ServerResponse } from 'node:http';
  7: import { WebSocketServer, WebSocket } from 'ws';
  8: import type { Server } from 'node:http';
  9: import {
 10:   GameServerCore,
 11:   InMemoryGameStore,
 12:   InMemoryMatchmakingStore,
 13:   SimpleGameRegistry,
 14:   type ServerRequest,
 15:   type ServerResponse as CoreResponse,
 16:   type GameDefinition,
 17:   type AIConfig,
 18:   type SessionInfo,
 19:   type BroadcastAdapter,
 20: } from '@boardsmith/server';
 21: 
 22: // ============================================
 23: // WebSocket Broadcast Adapter for Node.js
 24: // ============================================
 25: 
 26: interface WsSession extends SessionInfo {
 27:   ws: WebSocket;
 28: }
 29: 
 30: class WsBroadcastAdapter implements BroadcastAdapter<WsSession> {
 31:   readonly #sessions = new Map<WebSocket, WsSession>();
 32: 
 33:   addSession(ws: WebSocket, info: SessionInfo): void {
 34:     this.#sessions.set(ws, { ...info, ws });
 35:   }
 36: 
 37:   removeSession(ws: WebSocket): void {
 38:     this.#sessions.delete(ws);
 39:   }
 40: 
 41:   getSessions(): WsSession[] {
 42:     return [...this.#sessions.values()];
 43:   }
 44: 
 45:   send(session: WsSession, message: unknown): void {
 46:     if (session.ws.readyState === WebSocket.OPEN) {
 47:       session.ws.send(JSON.stringify(message));
 48:     }
 49:   }
 50: 
 51:   /** Broadcast a message to all connected sessions */
 52:   broadcast(message: unknown): void {
 53:     const json = JSON.stringify(message);
 54:     for (const session of this.#sessions.values()) {
 55:       if (session.ws.readyState === WebSocket.OPEN) {
 56:         session.ws.send(json);
 57:       }
 58:     }
 59:   }
 60: }
 61: 
 62: // ============================================
 63: // Local Server
 64: // ============================================
 65: 
 66: export interface LocalServerOptions {
 67:   port: number;
 68:   definitions: GameDefinition[];
 69:   onReady?: (port: number) => void;
 70:   aiConfig?: AIConfig;
 71: }
 72: 
 73: export class LocalServer {
 74:   readonly #server: Server;
 75:   readonly #wss: WebSocketServer;
 76:   readonly #port: number;
 77:   readonly #core: GameServerCore;
 78:   readonly #store: InMemoryGameStore<WsSession>;
 79:   readonly #registry: SimpleGameRegistry;
 80:   readonly #readyPromise: Promise<void>;
 81: 
 82:   /** Promise that resolves when the server is ready to accept connections */
 83:   get ready(): Promise<void> {
 84:     return this.#readyPromise;
 85:   }
 86: 
 87:   constructor(options: LocalServerOptions) {
 88:     this.#port = options.port;
 89: 
 90:     // Build registry from definitions
 91:     this.#registry = new SimpleGameRegistry(options.definitions);
 92: 
 93:     // Create in-memory game store with broadcaster factory
 94:     this.#store = new InMemoryGameStore<WsSession>(
 95:       this.#registry,
 96:       () => new WsBroadcastAdapter()
 97:     );
 98: 
 99:     // Create in-memory matchmaking store
100:     const matchmaking = new InMemoryMatchmakingStore();
101: 
102:     // Create the server core
103:     this.#core = new GameServerCore({
104:       store: this.#store,
105:       registry: this.#registry,
106:       matchmaking,
107:       aiConfig: options.aiConfig,
108:       environment: 'development',
109:     });
110: 
111:     // Create HTTP server with proper async error handling
112:     this.#server = createServer((req, res) => {
113:       this.#handleRequest(req, res).catch((error) => {
114:         console.error('Unhandled request error:', error);
115:         if (!res.headersSent) {
116:           res.writeHead(500, { 'Content-Type': 'application/json' });
117:           res.end(JSON.stringify({ success: false, error: 'Internal server error' }));
118:         }
119:       });
120:     });
121: 
122:     // Create WebSocket server
123:     this.#wss = new WebSocketServer({ server: this.#server });
124:     this.#wss.on('connection', (ws, req) => this.#handleWebSocket(ws, req));
125: 
126:     // Start listening and create ready promise
127:     this.#readyPromise = new Promise<void>((resolve) => {
128:       this.#server.listen(this.#port, () => {
129:         options.onReady?.(this.#port);
130:         resolve();
131:       });
132:     });
133:   }
134: 
135:   updateDefinition(definition: GameDefinition): void {
136:     this.#registry.set(definition);
137:     this.#store.updateRegistry?.(definition);
138:   }
139: 
140:   close(): Promise<void> {
141:     return new Promise((resolve, reject) => {
142:       // Close all WebSocket connections
143:       for (const client of this.#wss.clients) {
144:         client.close();
145:       }
146: 
147:       this.#wss.close(() => {
148:         this.#server.close((err) => {
149:           if (err) reject(err);
150:           else resolve();
151:         });
152:       });
153:     });
154:   }
155: 
156:   async #handleRequest(req: IncomingMessage, res: ServerResponse): Promise<void> {
157:     res.setHeader('Access-Control-Allow-Origin', '*');
158:     res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
159:     res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
160: 
161:     if (req.method === 'OPTIONS') {
162:       res.writeHead(204);
163:       res.end();
164:       return;
165:     }
166: 
167:     try {
168:       // Convert Node request to platform-agnostic request
169:       const serverRequest = await this.#nodeToServerRequest(req);
170: 
171:       // Handle request through core
172:       const response = await this.#core.handleRequest(serverRequest);
173: 
174:       // Send response
175:       this.#sendResponse(res, response);
176:     } catch (error) {
177:       console.error('Server error:', error);
178:       this.#sendResponse(res, {
179:         status: 500,
180:         body: { success: false, error: error instanceof Error ? error.message : 'Internal error' },
181:       });
182:     }
183:   }
184: 
185:   async #nodeToServerRequest(req: IncomingMessage): Promise<ServerRequest> {
186:     const url = new URL(req.url || '/', `http://localhost:${this.#port}`);
187: 
188:     // Parse query params
189:     const query: Record<string, string> = {};
190:     for (const [key, value] of url.searchParams) {
191:       query[key] = value;
192:     }
193: 
194:     // Read body for POST requests
195:     let body: unknown = {};
196:     if (req.method === 'POST') {
197:       body = await this.#readBody(req);
198:     }
199: 
200:     return {
201:       method: req.method || 'GET',
202:       path: url.pathname,
203:       query,
204:       body,
205:     };
206:   }
207: 
208:   #readBody<T>(req: IncomingMessage): Promise<T> {
209:     return new Promise((resolve, reject) => {
210:       let data = '';
211:       req.on('data', (chunk) => { data += chunk; });
212:       req.on('end', () => {
213:         try {
214:           resolve(data ? JSON.parse(data) : {});
215:         } catch (e) {
216:           reject(new Error('Invalid JSON'));
217:         }
218:       });
219:       req.on('error', reject);
220:     });
221:   }
222: 
223:   #sendResponse(res: ServerResponse, response: CoreResponse): void {
224:     res.writeHead(response.status, { 'Content-Type': 'application/json' });
225:     res.end(JSON.stringify(response.body));
226:   }
227: 
228:   async #handleWebSocket(ws: WebSocket, req: IncomingMessage): Promise<void> {
229:     const url = new URL(req.url || '/', `http://localhost:${this.#port}`);
230: 
231:     const match = url.pathname.match(/^\/games\/([^/]+)$/);
232:     if (!match) {
233:       ws.close(4000, 'Invalid WebSocket path');
234:       return;
235:     }
236: 
237:     const gameId = match[1];
238:     const playerParam = url.searchParams.get('player');
239:     const playerPosition = playerParam ? parseInt(playerParam, 10) : 0;
240:     const isSpectator = url.searchParams.get('spectator') === 'true';
241: 
242:     // Get the game's broadcaster
243:     const broadcaster = this.#store.getBroadcaster(gameId);
244:     if (!broadcaster) {
245:       ws.close(4004, 'Game not found');
246:       return;
247:     }
248: 
249:     const effectivePosition = isSpectator ? 0 : playerPosition;
250: 
251:     // Add session to broadcaster
252:     (broadcaster as WsBroadcastAdapter).addSession(ws, {
253:       playerPosition,
254:       isSpectator,
255:     });
256: 
257:     // Send initial state
258:     const initialState = await this.#core.getWebSocketInitialState(gameId, playerPosition, isSpectator);
259:     if (initialState) {
260:       ws.send(JSON.stringify(initialState));
261:     }
262: 
263:     ws.on('message', async (data) => {
264:       try {
265:         const message = JSON.parse(data.toString());
266: 
267:         // Create a WebSocket adapter for the core
268:         const wsAdapter = {
269:           send: (msg: unknown) => {
270:             if (ws.readyState === WebSocket.OPEN) {
271:               ws.send(JSON.stringify(msg));
272:             }
273:           },
274:           close: (code?: number, reason?: string) => {
275:             ws.close(code, reason);
276:           },
277:         };
278: 
279:         await this.#core.handleWebSocketMessage(
280:           {
281:             ws: wsAdapter,
282:             playerPosition,
283:             isSpectator,
284:           },
285:           gameId,
286:           message
287:         );
288:       } catch (error) {
289:         console.error('WebSocket message error:', error);
290:         ws.send(JSON.stringify({ type: 'error', error: 'Invalid message' }));
291:       }
292:     });
293: 
294:     ws.on('close', () => {
295:       (broadcaster as WsBroadcastAdapter).removeSession(ws);
296:     });
297:   }
298: }
299: 
300: export function createLocalServer(options: LocalServerOptions): LocalServer {
301:   return new LocalServer(options);
302: }
303: 
304: // Re-export types from server for convenience
305: export type { GameDefinition, AIConfig };
````

## File: packages/ui/src/index.ts
````typescript
  1: // Core components
  2: export { default as GameShell } from './components/GameShell.vue';
  3: export { default as DebugPanel } from './components/DebugPanel.vue';
  4: export { default as GameHeader } from './components/GameHeader.vue';
  5: export { default as GameHistory } from './components/GameHistory.vue';
  6: export { default as GameLobby } from './components/GameLobby.vue';
  7: export { default as HamburgerMenu } from './components/HamburgerMenu.vue';
  8: export { default as PlayersPanel } from './components/PlayersPanel.vue';
  9: export { default as WaitingRoom } from './components/WaitingRoom.vue';
 10: 
 11: // Helper components
 12: export {
 13:   Draggable,
 14:   DiceRoller,
 15:   CardFan,
 16:   DeckPile,
 17:   FlyingCardsOverlay,
 18: } from './components/helpers/index.js';
 19: 
 20: // Auto-UI components (automatic game UI generation)
 21: export {
 22:   AutoUI,
 23:   AutoGameBoard,
 24:   AutoElement,
 25:   ActionPanel,
 26:   type GameElement,
 27:   type Selection,
 28:   type ActionMetadata,
 29:   type Player,
 30: } from './components/auto-ui/index.js';
 31: 
 32: // Composables
 33: export {
 34:   useBoardInteraction,
 35:   createBoardInteraction,
 36:   provideBoardInteraction,
 37:   type BoardInteraction,
 38:   type BoardInteractionState,
 39:   type BoardInteractionActions,
 40:   type ElementRef,
 41:   type HighlightableChoice,
 42: } from './composables/useBoardInteraction.js';
 43: 
 44: // Animation composables
 45: export {
 46:   useElementAnimation,
 47:   prefersReducedMotion,
 48:   type AnimationOptions,
 49: } from './composables/useElementAnimation.js';
 50: 
 51: export {
 52:   useCardFlip,
 53:   useCardReveal,
 54:   type CardFlipOptions,
 55:   type CardFlipReturn,
 56: } from './composables/useCardFlip.js';
 57: 
 58: export {
 59:   useFlyingCards,
 60:   type FlyingCard,
 61:   type FlyingCardData,
 62:   type FlyCardOptions,
 63:   type FlyingCardsReturn,
 64: } from './composables/useFlyingCards.js';
 65: 
 66: export {
 67:   useFlyOnAppear,
 68:   type FlyOnAppearOptions,
 69:   type FlyOnAppearReturn,
 70: } from './composables/useFlyOnAppear.js';
 71: 
 72: // Player stat animation utilities
 73: export {
 74:   usePlayerStatAnimation,
 75:   getPlayerStatElement,
 76:   flyToPlayerStat,
 77:   type CardForAnimation,
 78:   type FlyToStatOptions,
 79: } from './composables/usePlayerStatAnimation.js';
 80: 
 81: // Game view helpers (for custom UIs)
 82: export {
 83:   useGameViewHelpers,
 84:   findElement,
 85:   findElements,
 86:   findPlayerHand,
 87:   findAllHands,
 88:   getElementCount,
 89:   getCards,
 90:   getFirstCard,
 91:   getCardData,
 92:   getElementOwner,
 93:   isOwnedByPlayer,
 94:   isMyElement,
 95:   isOpponentElement,
 96:   type GameElement as GameViewElement,
 97:   type FindElementOptions,
 98: } from './composables/useGameViewHelpers.js';
 99: 
100: // Grid/board game utilities
101: export {
102:   useGameGrid,
103:   toAlgebraicNotation,
104:   fromAlgebraicNotation,
105:   type GameGridOptions,
106:   type GameGridReturn,
107: } from './composables/useGameGrid.js';
108: 
109: // Hex grid utilities
110: export {
111:   useHexGrid,
112:   hexToPixel,
113:   getHexPolygonPoints,
114:   calculateHexDistance,
115:   type HexOrientation,
116:   type HexGridOptions,
117:   type HexPosition,
118:   type HexBounds,
119:   type HexGridReturn,
120: } from './composables/useHexGrid.js';
121: 
122: // Card display utilities
123: export {
124:   useCardDisplay,
125:   getSuitSymbol,
126:   getSuitColor,
127:   getRankName,
128:   getCardPointValue,
129:   isRedSuit,
130:   isBlackSuit,
131:   type SuitAbbreviation,
132:   type RankAbbreviation,
133: } from './composables/useCardDisplay.js';
134: 
135: // Element change tracking utilities
136: export {
137:   useElementChangeTracker,
138:   useCountTracker,
139:   type ElementPositionData,
140:   type ElementChangeTrackerOptions,
141:   type ElementChangeTrackerReturn,
142:   type CountTrackerReturn,
143: } from './composables/useElementChangeTracker.js';
144: 
145: // FLIP animation utilities
146: export {
147:   useFLIPAnimation,
148:   createFLIPSnapshot,
149:   type FLIPAnimationOptions,
150:   type FLIPAnimationReturn,
151: } from './composables/useFLIPAnimation.js';
152: 
153: // Theming
154: export {
155:   applyTheme,
156:   getTheme,
157:   themeCSS,
158:   type ThemeConfig,
159: } from './theme.js';
160: 
161: // Shared types
162: export type {
163:   BaseElementAttributes,
164:   ElementMatchOptions,
165:   PlayerRef,
166: } from './types.js';
````
