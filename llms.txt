This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/**/*.md, packages/*/README.md, packages/engine/ARCHITECTURE.md, packages/engine/src/**/*.ts, packages/runtime/src/**/*.ts, packages/session/src/**/*.ts, packages/testing/src/**/*.ts, packages/ai/src/**/*.ts
- Files matching these patterns are excluded: node_modules/**, dist/**, **/dist/**, **/*.d.ts, **/*.test.ts, **/*.spec.ts, **/*.bundle.js, pnpm-lock.yaml, .git/**, coverage/**, *.log, packages/games/**, packages/cli/**, packages/server/**, packages/ui/**, packages/worker/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)

# User Provided Header
# BoardSmith - Turn-Based Game Framework

BoardSmith is a TypeScript framework for building multiplayer turn-based board and card games.

## Package Structure

- `@boardsmith/engine` - Core game elements, actions, commands, flow control
- `@boardsmith/runtime` - Game runner, state machine, serialization
- `@boardsmith/session` - Game session management, multiplayer coordination
- `@boardsmith/testing` - Test utilities, debug tools, assertions
- `@boardsmith/ai` - AI player integration

## Quick Reference

- `docs/llm-overview.md` - comprehensive framework summary
- `docs/core-concepts.md` - element tree, actions, commands
- `docs/common-patterns.md` - reusable code patterns
- `docs/common-pitfalls.md` - common mistakes and fixes
- Package README files contain API documentation

# Directory Structure
```
docs/
  actions-and-flow.md
  ai-system.md
  common-patterns.md
  common-pitfalls.md
  core-concepts.md
  dice-and-scoring.md
  game-examples.md
  getting-started.md
  llm-overview.md
  README.md
  ui-components.md
packages/
  ai/
    src/
      index.ts
      mcts-bot.ts
      types.ts
      utils.ts
  engine/
    src/
      action/
        action.ts
        helpers.ts
        index.ts
        types.ts
      command/
        executor.ts
        index.ts
        types.ts
        visibility.ts
      element/
        card.ts
        deck.ts
        dice-pool.ts
        die.ts
        element-collection.ts
        game-element.ts
        game.ts
        grid.ts
        hand.ts
        hex-grid.ts
        index.ts
        piece.ts
        space.ts
        types.ts
      flow/
        builders.ts
        engine.ts
        index.ts
        turn-order.ts
        types.ts
      player/
        abilities.ts
        index.ts
        player.ts
      sandbox/
        index.ts
      scoring/
        index.ts
        track.ts
      utils/
        index.ts
        replay.ts
        serializer.ts
        snapshot.ts
      index.ts
    ARCHITECTURE.md
    README.md
  runtime/
    src/
      index.ts
      runner.ts
  session/
    src/
      ai-controller.ts
      colors.ts
      game-session.ts
      index.ts
      types.ts
      utils.ts
    README.md
  testing/
    src/
      assertions.ts
      debug.ts
      fixtures.ts
      index.ts
      random-simulation.ts
      simulate-action.ts
      test-game.ts
    README.md
```

# Files

## File: docs/ai-system.md
````markdown
# AI System

BoardSmith includes a game-agnostic AI system using Monte-Carlo Tree Search (MCTS). The AI works with any game without game-specific tuning.

## Overview

The `@boardsmith/ai` package provides:
- **MCTSBot**: MCTS-based AI player
- **Difficulty presets**: easy, medium, hard
- **Custom objectives**: Guide AI behavior for specific games

## How MCTS Works

Monte-Carlo Tree Search builds a game tree by repeatedly:

1. **SELECT**: Walk down the tree using UCT (Upper Confidence Bound for Trees) to balance exploration vs exploitation
2. **EXPAND**: Try one unexplored action from a leaf node
3. **PLAYOUT**: Random moves until game ends (or depth limit)
4. **BACKPROPAGATE**: Update win counts back up the tree

After many iterations, the bot chooses the most-visited child of the root (robust choice).

## Basic Usage

### Using the CLI

The easiest way to add AI players is via the CLI:

```bash
# Player 1 is AI (medium difficulty)
boardsmith dev --ai 1

# Players 0 and 2 are AI
boardsmith dev --ai 0 2

# Set difficulty level
boardsmith dev --ai 1 --ai-level hard

# Custom iteration count
boardsmith dev --ai 1 --ai-level 50
```

### Difficulty Levels

| Level | Iterations | Playout Depth | Timeout |
|-------|-----------|---------------|---------|
| easy | 3 | 3 | 1000ms |
| medium | 5 | 4 | 1500ms |
| hard | 8 | 5 | 2000ms |

Note: Iterations are kept low because game operations can be slow (~18ms per move). The timeout ensures responsive behavior.

### Programmatic Usage

```typescript
import { createBot, parseAILevel } from '@boardsmith/ai';
import { MyGame } from './game.js';

// Create a bot for player 1
const bot = createBot(
  game,                    // Game instance
  MyGame,                  // Game class constructor
  'my-game',               // Game type identifier
  1,                       // Player index (0-based)
  actionHistory,           // History of actions taken so far
  'hard'                   // Difficulty level or iteration count
);

// Get the bot's move
const move = await bot.play();
console.log(`Bot plays: ${move.action}`, move.args);

// Execute the move
game.continueFlow(move.action, move.args, 1);
```

## Custom Objectives

For games where win/loss isn't sufficient guidance, you can define objectives that give the AI partial credit during playouts.

### Defining Objectives

```typescript
import type { AIConfig, Game } from '@boardsmith/ai';

const aiConfig: AIConfig = {
  objectives: (game: Game, playerIndex: number) => ({
    // Positive weight = good for the player
    controlCenter: {
      checker: (g, p) => {
        const center = g.board.cells.filter(c => c.isCentral);
        const playerPieces = center.filter(c => c.piece?.player?.position === p);
        return playerPieces.length >= 2;
      },
      weight: 0.3,
    },

    // Negative weight = bad for the player
    exposedKing: {
      checker: (g, p) => {
        const king = g.players[p].king;
        return king.isExposed();
      },
      weight: -0.5,
    },

    // Material advantage
    materialAdvantage: {
      checker: (g, p) => {
        const myPieces = g.pieces.filter(pc => pc.player?.position === p);
        const oppPieces = g.pieces.filter(pc => pc.player?.position !== p);
        return myPieces.length > oppPieces.length;
      },
      weight: 0.4,
    },
  }),
};

// Use with createBot
const bot = createBot(game, MyGame, 'my-game', 1, [], 'medium', aiConfig);
```

### Objective Evaluation

During playouts that don't reach a terminal state:
- If total objective score > 0: returns 0.6 (slightly favorable)
- If total objective score < 0: returns 0.4 (slightly unfavorable)
- If total objective score = 0: returns 0.5 (neutral)

Terminal states always use actual win/loss (1.0/0.0).

## Example: Checkers AI

From `packages/games/checkers/rules/src/ai.ts`:

```typescript
import type { AIConfig, Game } from '@boardsmith/ai';

export const checkersAIConfig: AIConfig = {
  objectives: (game: Game, playerIndex: number) => ({
    // Having more pieces is good
    morePieces: {
      checker: (g, p) => {
        const myPieces = countPieces(g, p);
        const oppPieces = countPieces(g, 1 - p);
        return myPieces > oppPieces;
      },
      weight: 0.5,
    },

    // Having kings is good
    hasKings: {
      checker: (g, p) => {
        const myKings = countKings(g, p);
        return myKings > 0;
      },
      weight: 0.3,
    },

    // Controlling the center is good
    centerControl: {
      checker: (g, p) => {
        const centerCells = getCenterCells(g);
        const myPiecesInCenter = centerCells.filter(
          c => c.piece?.player?.position === p
        );
        return myPiecesInCenter.length >= 2;
      },
      weight: 0.2,
    },
  }),
};
```

## Integration with GameSession

The `@boardsmith/session` package integrates AI automatically:

```typescript
import { GameSession } from '@boardsmith/session';
import { MyGame } from './game.js';
import { myGameAIConfig } from './ai.js';

const session = new GameSession({
  gameClass: MyGame,
  gameType: 'my-game',
  playerCount: 2,
  aiPlayers: [1],           // Player 1 is AI
  aiLevel: 'hard',
  aiConfig: myGameAIConfig,  // Optional custom objectives
});

// AI will automatically play when it's player 1's turn
session.start();
```

## BotConfig Options

```typescript
interface BotConfig {
  /** Number of MCTS iterations (higher = stronger but slower). Default: 100 */
  iterations: number;

  /** Maximum playout depth before evaluating position. Default: 5 */
  playoutDepth: number;

  /** Random seed for reproducible behavior */
  seed?: string;

  /** Run async to yield to event loop (prevents UI freezing). Default: true */
  async?: boolean;

  /** Maximum time in milliseconds before returning best move found. Default: 2000 */
  timeout?: number;
}
```

## Performance Considerations

1. **Iteration count**: More iterations = better play, but slower. The default presets are tuned for responsiveness.

2. **Playout depth**: Deeper playouts give more accurate evaluations but take longer. 3-5 is usually sufficient.

3. **Timeout**: The timeout ensures the bot always returns within a reasonable time, even if iterations haven't completed.

4. **Branching factor**: Games with many possible moves per turn will have fewer iterations explored per move. The bot samples up to 20 choices per selection to limit combinatorial explosion.

5. **Game complexity**: Simple games (Hex, Checkers) work well. Complex games (Cribbage with many scoring possibilities) may need custom objectives.

## Limitations

- **No learning**: The AI doesn't learn from past games. Each game starts fresh.
- **Text/number inputs**: The AI can't handle actions that require text or number input (it can only choose from discrete options).
- **Determinism**: With a seed, the bot is deterministic. Without a seed, it uses `Math.random()`.

## API Reference

### createBot()

```typescript
function createBot<G extends Game>(
  game: G,
  GameClass: new (options: GameOptions) => G,
  gameType: string,
  playerIndex: number,
  actionHistory?: SerializedAction[],
  difficulty?: DifficultyLevel | number,
  aiConfig?: AIConfig
): MCTSBot<G>
```

### MCTSBot.play()

```typescript
async play(): Promise<BotMove>
```

Returns the best move found after running MCTS iterations.

### parseAILevel()

```typescript
function parseAILevel(level: string): DifficultyLevel | number
```

Parse an AI level string (e.g., from CLI arguments).

## Related Documentation

- [Core Concepts](./core-concepts.md) - Understanding game state
- [Actions & Flow](./actions-and-flow.md) - How actions work
- [Game Examples](./game-examples.md) - Games with AI implementations
````

## File: docs/common-patterns.md
````markdown
# Common Game Patterns

This guide shows reusable patterns that appear across many board games. Use these as starting points for your implementation.

---

## 1. Dealer Rotation

Many card games rotate who deals each round.

### Pattern

```typescript
class MyGame extends Game<MyGame, MyPlayer> {
  dealerPosition: number = 0;

  /**
   * Get the current dealer
   */
  get dealer(): MyPlayer {
    return this.players[this.dealerPosition] as MyPlayer;
  }

  /**
   * Get the player to the dealer's left (usually plays first)
   */
  get playerAfterDealer(): MyPlayer {
    const nextPosition = (this.dealerPosition + 1) % this.players.length;
    return this.players[nextPosition] as MyPlayer;
  }

  /**
   * Rotate dealer to the next player
   */
  rotateDealer(): void {
    this.dealerPosition = (this.dealerPosition + 1) % this.players.length;
  }
}
```

### In Flow

```typescript
export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      while: () => !game.isFinished(),
      do: sequence(
        // Deal from current dealer
        execute({ do: () => game.deal() }),

        // Play round starting from player after dealer
        eachPlayer({
          startingPlayer: () => game.playerAfterDealer,
          do: actionStep({ actions: ['play'] }),
        }),

        // Rotate dealer for next round
        execute({ do: () => game.rotateDealer() }),
      ),
    }),
    // ...
  };
}
```

---

## 2. Simultaneous Actions

All players act at the same time (e.g., revealing cards, placing bids).

### Pattern

```typescript
// In flow
simultaneousActionStep({
  name: 'discard-phase',
  actions: ['discard'],
  prompt: 'Discard 2 cards to the crib',

  // Optional: custom completion check per player
  playerDone: (ctx, player) => {
    const p = player as MyPlayer;
    return p.discarded.count(Card) >= 2;
  },

  // Optional: when all players are done
  allDone: (ctx) => {
    return ctx.game.players.every(p => p.discarded.count(Card) >= 2);
  },
})
```

### Manual Tracking Alternative

For more control, track completion manually:

```typescript
class MyGame extends Game<MyGame, MyPlayer> {
  private completedPlayers: Set<number> = new Set();

  playerCompletedAction(player: MyPlayer): void {
    this.completedPlayers.add(player.position);
  }

  allPlayersCompleted(): boolean {
    return this.completedPlayers.size === this.players.length;
  }

  resetCompletedPlayers(): void {
    this.completedPlayers.clear();
  }
}
```

---

## 3. Multi-Turn Same Player (Go Again)

Player continues their turn under certain conditions.

### Pattern: Using Flow Variable

```typescript
export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: loop({
          name: 'player-turn',
          while: (ctx) => ctx.get<boolean>('goAgain') !== false,
          do: sequence(
            // Reset go-again flag
            setVar({ name: 'goAgain', value: false }),

            // Player takes action
            actionStep({ actions: ['play'] }),

            // Action can set goAgain = true to continue
          ),
        }),
      }),
    }),
  };
}

// In action execute:
.execute((args, ctx) => {
  // ... action logic ...

  if (shouldGoAgain) {
    ctx.game.flow.set('goAgain', true);
  }

  return { success: true };
});
```

### Pattern: Using Game State

```typescript
class MyGame extends Game<MyGame, MyPlayer> {
  private playerGoesAgain: boolean = false;

  setPlayerGoesAgain(value: boolean): void {
    this.playerGoesAgain = value;
  }

  shouldPlayerGoAgain(): boolean {
    return this.playerGoesAgain;
  }

  resetPlayerGoesAgain(): void {
    this.playerGoesAgain = false;
  }
}

// In flow
loop({
  while: (ctx) => !ctx.game.shouldPlayerGoAgain(),
  do: sequence(
    execute({ do: (ctx) => ctx.game.resetPlayerGoesAgain() }),
    actionStep({ actions: ['play'] }),
  ),
})
```

---

## 4. Multi-Step Move (e.g., Checkers Captures)

A single turn consists of multiple moves.

### Pattern

```typescript
// In flow - allow multiple captures in one turn
loop({
  name: 'capture-chain',
  while: (ctx) => {
    const piece = ctx.get<Piece>('movingPiece');
    return piece && game.canCapture(piece);
  },
  do: actionStep({
    name: 'continue-capture',
    actions: ['capture'],
  }),
})

// Track the moving piece
.execute((args, ctx) => {
  const piece = args.piece as Piece;

  // First move or continuing?
  if (!ctx.get('movingPiece')) {
    ctx.set('movingPiece', piece);
  }

  // Perform capture
  game.performCapture(piece, args.target);

  // If piece can't capture anymore, clear tracking
  if (!game.canCapture(piece)) {
    ctx.set('movingPiece', null);
  }

  return { success: true };
});
```

---

## 5. Hidden Information

Managing what each player can see.

### Hand Cards (Visible to Owner Only)

```typescript
class MyPlayer extends Player {
  hand!: Hand;
}

class MyGame extends Game<MyGame, MyPlayer> {
  constructor(options: GameOptions) {
    super(options);

    for (const player of this.players) {
      player.hand = player.create(Hand, 'hand');
      player.hand.contentsVisibleOnlyToOwner();
    }
  }
}
```

### Deck (Hidden Until Drawn)

```typescript
this.deck = this.create(Deck, 'deck');
this.deck.contentsHidden();  // No one sees cards in deck
```

### Revealing Cards

```typescript
// Reveal a single card to all players
card.setVisibleToAll();

// Reveal to specific player
card.setVisibleTo([player]);

// Hide again (e.g., after showing)
card.setHidden();
```

---

## 6. Piece Promotion

Pieces that change type (e.g., pawns to queens, checkers to kings).

### Pattern: State Property

```typescript
class CheckerPiece extends Piece {
  isKing: boolean = false;

  /**
   * Promote this piece to a king
   */
  promote(): void {
    this.isKing = true;
    // Optionally update visual
    this.$image = this.player?.color === 'black'
      ? '/pieces/black-king.svg'
      : '/pieces/white-king.svg';
  }

  /**
   * Check if this piece can move backward
   */
  canMoveBackward(): boolean {
    return this.isKing;
  }

  /**
   * Get valid move directions
   */
  getMoveDirections(): Array<{ row: number; col: number }> {
    const forward = this.player?.position === 0 ? -1 : 1;

    if (this.isKing) {
      return [
        { row: forward, col: -1 },
        { row: forward, col: 1 },
        { row: -forward, col: -1 },
        { row: -forward, col: 1 },
      ];
    }

    return [
      { row: forward, col: -1 },
      { row: forward, col: 1 },
    ];
  }
}
```

### Check for Promotion in Move Action

```typescript
.execute((args, ctx) => {
  const piece = args.piece as CheckerPiece;
  const destination = args.destination as Cell;

  // Move the piece
  piece.putInto(destination);

  // Check for promotion
  const promotionRow = piece.player?.position === 0 ? 0 : 7;
  if (destination.row === promotionRow && !piece.isKing) {
    piece.promote();
    game.message(`${piece} was crowned king!`);
  }

  return { success: true };
});
```

---

## 7. Turn-Based Combat

Resolving combat between game pieces.

### Pattern

```typescript
interface CombatResult {
  attacker: Piece;
  defender: Piece;
  attackerDamage: number;
  defenderDamage: number;
  attackerDestroyed: boolean;
  defenderDestroyed: boolean;
}

class MyGame extends Game<MyGame, MyPlayer> {
  /**
   * Resolve combat between two pieces
   */
  resolveCombat(attacker: Piece, defender: Piece): CombatResult {
    // Roll dice or use stats
    const attackRoll = this.random.d6();
    const defendRoll = this.random.d6();

    const attackerPower = (attacker.attack ?? 0) + attackRoll;
    const defenderPower = (defender.defense ?? 0) + defendRoll;

    const result: CombatResult = {
      attacker,
      defender,
      attackerDamage: 0,
      defenderDamage: 0,
      attackerDestroyed: false,
      defenderDestroyed: false,
    };

    if (attackerPower > defenderPower) {
      // Attacker wins
      result.defenderDamage = attackerPower - defenderPower;
      defender.health -= result.defenderDamage;
      result.defenderDestroyed = defender.health <= 0;
    } else if (defenderPower > attackerPower) {
      // Defender wins
      result.attackerDamage = defenderPower - attackerPower;
      attacker.health -= result.attackerDamage;
      result.attackerDestroyed = attacker.health <= 0;
    }
    // Tie: no damage

    // Remove destroyed pieces
    if (result.attackerDestroyed) attacker.remove();
    if (result.defenderDestroyed) defender.remove();

    return result;
  }
}
```

---

## 8. Resource/Economy System

Managing player resources.

### Pattern

```typescript
class MyPlayer extends Player {
  gold: number = 0;
  wood: number = 0;
  food: number = 0;

  /**
   * Check if player can afford a cost
   */
  canAfford(cost: { gold?: number; wood?: number; food?: number }): boolean {
    if (cost.gold && this.gold < cost.gold) return false;
    if (cost.wood && this.wood < cost.wood) return false;
    if (cost.food && this.food < cost.food) return false;
    return true;
  }

  /**
   * Pay a cost (throws if can't afford)
   */
  pay(cost: { gold?: number; wood?: number; food?: number }): void {
    if (!this.canAfford(cost)) {
      throw new Error('Cannot afford this cost');
    }
    this.gold -= cost.gold ?? 0;
    this.wood -= cost.wood ?? 0;
    this.food -= cost.food ?? 0;
  }

  /**
   * Gain resources
   */
  gain(resources: { gold?: number; wood?: number; food?: number }): void {
    this.gold += resources.gold ?? 0;
    this.wood += resources.wood ?? 0;
    this.food += resources.food ?? 0;
  }
}
```

### In Actions

```typescript
Action.create('build')
  .condition((ctx) => {
    const player = ctx.player as MyPlayer;
    return player.canAfford({ wood: 5, gold: 2 });
  })
  .execute((args, ctx) => {
    const player = ctx.player as MyPlayer;
    player.pay({ wood: 5, gold: 2 });

    // Create building...

    return { success: true };
  });
```

---

## 9. Area Control / Majority

Determining who controls a zone based on unit count.

### Pattern

```typescript
class Zone extends Space {
  /**
   * Get the player(s) with the most units in this zone
   */
  getControllers(): Player[] {
    const counts = new Map<Player, number>();

    for (const unit of this.all(Unit)) {
      if (unit.player) {
        counts.set(unit.player, (counts.get(unit.player) ?? 0) + 1);
      }
    }

    if (counts.size === 0) return [];

    const maxCount = Math.max(...counts.values());
    const controllers: Player[] = [];

    for (const [player, count] of counts) {
      if (count === maxCount) {
        controllers.push(player);
      }
    }

    return controllers;
  }

  /**
   * Get the single controller, or null if contested/empty
   */
  getController(): Player | null {
    const controllers = this.getControllers();
    return controllers.length === 1 ? controllers[0] : null;
  }

  /**
   * Check if a player controls this zone
   */
  isControlledBy(player: Player): boolean {
    const controller = this.getController();
    return controller?.position === player.position;
  }
}
```

---

## 10. Victory Point Scoring

Tracking and calculating victory points.

### Pattern

```typescript
interface ScoreBreakdown {
  cards: number;
  territories: number;
  bonuses: number;
  total: number;
}

class MyPlayer extends Player {
  /**
   * Calculate this player's score
   */
  calculateScore(game: MyGame): ScoreBreakdown {
    const cardPoints = this.hand.sum((card) => card.pointValue);

    const territoryPoints = game.zones
      .filter(z => z.isControlledBy(this))
      .reduce((sum, z) => sum + z.pointValue, 0);

    const bonusPoints = this.calculateBonuses(game);

    return {
      cards: cardPoints,
      territories: territoryPoints,
      bonuses: bonusPoints,
      total: cardPoints + territoryPoints + bonusPoints,
    };
  }

  private calculateBonuses(game: MyGame): number {
    let bonus = 0;

    // Longest road bonus
    if (game.hasLongestRoad(this)) {
      bonus += 5;
    }

    // Most cards bonus
    if (game.hasMostCards(this)) {
      bonus += 3;
    }

    return bonus;
  }
}

class MyGame extends Game<MyGame, MyPlayer> {
  override getWinners(): MyPlayer[] {
    const scores = this.players.map(p => ({
      player: p,
      score: p.calculateScore(this),
    }));

    const maxScore = Math.max(...scores.map(s => s.score.total));

    return scores
      .filter(s => s.score.total === maxScore)
      .map(s => s.player);
  }
}
```

---

## See Also

- [Common Pitfalls](./common-pitfalls.md) - Mistakes to avoid
- [Actions & Flow](./actions-and-flow.md) - Action and flow details
- [Game Examples](./game-examples.md) - Complete game implementations
````

## File: docs/common-pitfalls.md
````markdown
# Common Pitfalls in BoardSmith

This guide documents common mistakes that cause hard-to-debug issues. Read this before starting your game implementation.

---

## 1. Object Reference Comparison (CRITICAL)

### The Problem

BoardSmith's `chooseElement` and element queries return **new object instances** each time. This means JavaScript's default equality checks will fail:

```typescript
// WRONG - This will ALWAYS be false!
const myCards = player.hand.all(Card);
const selectedCard = args.card as Card;
if (myCards.includes(selectedCard)) {
  // This code will NEVER run
}

// WRONG - Same problem
if (myCards.indexOf(selectedCard) !== -1) { ... }

// WRONG - Direct comparison fails too
if (card1 === card2) { ... }
```

### The Solution

Always compare elements by their `id` property:

```typescript
// CORRECT - Compare by ID
const myCards = player.hand.all(Card);
const selectedCard = args.card as Card;
if (myCards.some(c => c.id === selectedCard.id)) {
  // This works!
}

// CORRECT - Use the equals() helper
if (card1.equals(card2)) { ... }

// CORRECT - Use contains() on collections
if (myCards.contains(selectedCard)) { ... }

// CORRECT - Find by ID
const found = myCards.find(c => c.id === selectedCard.id);
```

### Why This Happens

BoardSmith serializes and deserializes game state for:
- Network synchronization between players
- Action replay and undo
- AI decision making
- State snapshots

Each deserialization creates new object instances with the same data but different memory addresses.

---

## 2. Multi-Step Selection Filters

### The Problem

When an action has multiple selections, BoardSmith evaluates **all filters during the availability check**, even for selections the player hasn't made yet. The previous selection will be `undefined`:

```typescript
// WRONG - crashes when squad is undefined during availability check
Action.create('move')
  .chooseElement<Squad>('squad', { ... })
  .chooseElement<Sector>('destination', {
    filter: (sector, ctx) => {
      const squad = ctx.args.squad as Squad;  // undefined during availability!
      return isAdjacent(squad.sectorId, sector.id);  // CRASH: Cannot read 'sectorId' of undefined
    }
  })
```

### The Solution

Always handle the `undefined` case. During availability check, return `true` if the element would be valid for **any** possible previous selection:

```typescript
// CORRECT - Handle both availability check and actual selection
Action.create('move')
  .chooseElement<Squad>('squad', { ... })
  .chooseElement<Sector>('destination', {
    filter: (sector, ctx) => {
      const selectedSquad = ctx.args?.squad as Squad | undefined;

      if (!selectedSquad) {
        // Availability check - squad not yet selected
        // Return true if this sector would be valid for ANY movable squad
        return movableSquads.some(squad =>
          isAdjacent(squad.sectorId, sector.id)
        );
      }

      // Actual selection - filter based on selected squad
      return isAdjacent(selectedSquad.sectorId, sector.id);
    }
  })
```

### When This Matters

This pattern is needed whenever:
- Selection B depends on Selection A's value
- The filter uses properties of a previous selection
- You're building multi-step actions (select piece, then select destination)

---

## 3. Dead/Removed Elements in Collections

### The Problem

Element queries like `all()`, `first()`, etc. return **all matching elements**, including those that are logically "dead" or removed from play:

```typescript
// WRONG - includes dead pieces
const pieces = player.board.all(Piece);
const canMove = pieces.every(p => p.canMove);  // False if any dead piece exists

// WRONG - dead element with 0 actions breaks the check
const mercs = squad.all(Merc);
const allHaveActions = mercs.every(m => m.actionsRemaining >= 1);  // Always false!
```

### The Solution

Filter out dead/inactive elements explicitly:

```typescript
// CORRECT - filter to living pieces
const livingPieces = player.board.all(Piece).filter(p => !p.isDead);
const canMove = livingPieces.every(p => p.canMove);

// CORRECT - create a helper method
class Squad extends Space {
  getLivingMercs(): MercCard[] {
    return this.all(MercCard).filter(m => !m.isDead);
  }
}

// Then use it consistently
const mercs = squad.getLivingMercs();
const allHaveActions = mercs.every(m => m.actionsRemaining >= 1);
```

### Best Practice

Create helper methods for common filtered queries in your element classes:
- `getLivingPieces()`
- `getActiveCards()`
- `getAvailableSlots()`

This prevents the filter from being forgotten in different parts of your code.

---

## 4. Action Cost Placement

### The Problem

If you place action cost logic inside a `repeat.onEach` callback, the cost is charged **per item selected**, not once per action:

```typescript
// WRONG - charges 1 action for EACH equipment piece selected
Action.create('equip')
  .chooseElement<Equipment>('equipment', {
    repeat: { max: 3 },
    onEach: (equipment, ctx) => {
      merc.useAction(1);  // Called 3 times if player selects 3 items!
    }
  })
  .execute((args) => { ... });
```

### The Solution

Place action costs in the `execute` block, which runs once:

```typescript
// CORRECT - charges once in execute
Action.create('equip')
  .chooseElement<Equipment>('equipment', {
    repeat: { max: 3 }
  })
  .execute((args, ctx) => {
    // Charge action cost once
    merc.useAction(1);

    // Process all selected equipment
    const items = args.equipment as Equipment[];
    for (const item of items) {
      merc.equip(item);
    }
  });
```

---

## 5. Player Data Serialization

### The Problem

Custom data on Player objects may not serialize correctly, especially complex objects or element references:

```typescript
// PROBLEMATIC - element references on player
class MyPlayer extends Player {
  selectedCard?: Card;  // May not survive serialization
  squadRefs: Squad[] = [];  // Array of element refs is tricky
}
```

### The Solution

Store element references by ID or use game-level storage:

```typescript
// CORRECT - store IDs instead of references
class MyPlayer extends Player {
  selectedCardId?: number;
  squadIds: number[] = [];

  getSelectedCard(): Card | undefined {
    if (!this.selectedCardId) return undefined;
    return this.game.getElementById(this.selectedCardId) as Card;
  }
}

// ALTERNATIVE - use game-level maps
class MyGame extends Game {
  playerSelections: Map<number, number> = new Map();  // playerId -> cardId
}
```

---

## 6. Flow Loop Conditions

### The Problem

Flow loops with stale condition checks can cause infinite loops:

```typescript
// WRONG - condition may never become true
loop({
  while: () => !game.isFinished(),  // If isFinished() never returns true...
  do: actionStep({ actions: ['play'] })
})
```

### The Solution

Ensure your loop conditions will eventually become false:

```typescript
// CORRECT - use maxIterations as safety net
loop({
  while: () => !game.isFinished(),
  maxIterations: 1000,  // Prevents infinite loop
  do: actionStep({ actions: ['play'] })
})

// CORRECT - condition references mutable state
loop({
  while: (ctx) => {
    const player = ctx.player;
    return player.actionsRemaining > 0;  // Will decrease each iteration
  },
  do: actionStep({ actions: ['play'] })
})
```

---

## 7. Element Class Registration

### The Problem

Forgetting to register custom element classes causes deserialization failures:

```typescript
// WRONG - MyCard not registered
class MyGame extends Game {
  constructor() {
    this.deck = this.create(Deck, 'deck');
    this.deck.create(MyCard, 'card', { value: 1 });  // Works initially...
    // But fails on reload/restore!
  }
}
```

### The Solution

Always register custom element classes in your Game constructor:

```typescript
// CORRECT - register all custom classes
class MyGame extends Game {
  constructor() {
    super(options);

    // Register ALL custom element classes
    this.registerElements([MyCard, MyDeck, MyPiece, MyBoard]);

    // Now create elements
    this.deck = this.create(Deck, 'deck');
    // ...
  }
}
```

---

## Quick Reference

| Pitfall | Wrong | Right |
|---------|-------|-------|
| Element comparison | `array.includes(element)` | `array.some(e => e.id === element.id)` |
| Element equality | `el1 === el2` | `el1.equals(el2)` |
| Multi-step filter | `args.previous.prop` | `args?.previous?.prop` with fallback |
| Dead elements | `squad.all(Merc)` | `squad.getLivingMercs()` |
| Action costs | In `onEach` callback | In `execute` block |
| Element refs on Player | `selectedCard: Card` | `selectedCardId: number` |
| Loop safety | No `maxIterations` | Always set `maxIterations` |
| Class registration | Forget to register | `registerElements([...])` |

---

## See Also

- [Core Concepts](./core-concepts.md) - Element tree structure
- [Actions & Flow](./actions-and-flow.md) - Action and flow patterns
- [Common Patterns](./common-patterns.md) - Reusable game patterns
````

## File: packages/ai/src/index.ts
````typescript
import type { Game, GameOptions, SerializedAction } from '@boardsmith/engine';
import { MCTSBot } from './mcts-bot.js';
import type { BotConfig, AIConfig, DifficultyLevel } from './types.js';
import { DIFFICULTY_PRESETS } from './types.js';


export { MCTSBot } from './mcts-bot.js';
export type {
  BotConfig,
  BotMove,
  AIConfig,
  Objective,
  DifficultyLevel,
} from './types.js';
export { DIFFICULTY_PRESETS, DEFAULT_CONFIG } from './types.js';


type GameClass<G extends Game = Game> = new (options: GameOptions) => G;

























export function createBot<G extends Game>(
  game: G,
  GameClass: GameClass<G>,
  gameType: string,
  playerIndex: number,
  actionHistory: SerializedAction[] = [],
  difficulty: DifficultyLevel | number = 'medium',
  aiConfig?: AIConfig
): MCTSBot<G> {
  const config: Partial<BotConfig> = typeof difficulty === 'number'
    ? { iterations: difficulty }
    : DIFFICULTY_PRESETS[difficulty];

  return new MCTSBot(
    game,
    GameClass,
    gameType,
    playerIndex,
    actionHistory,
    config,
    aiConfig
  );
}




export function parseAILevel(level: string): DifficultyLevel | number {

  if (level in DIFFICULTY_PRESETS) {
    return level as DifficultyLevel;
  }


  const num = parseInt(level, 10);
  if (!isNaN(num) && num > 0) {
    return num;
  }


  return 'medium';
}
````

## File: packages/ai/src/types.ts
````typescript
import type { Game, Player, FlowState, GameStateSnapshot } from '@boardsmith/engine';




export interface BotConfig {

  iterations: number;

  playoutDepth: number;

  seed?: string;

  async?: boolean;

  timeout?: number;
}




export interface BotMove {

  action: string;

  args: Record<string, unknown>;
}




export interface MCTSNode {

  snapshot: GameStateSnapshot;

  flowState: FlowState;

  parent: MCTSNode | null;

  parentMove: BotMove | null;

  children: MCTSNode[];

  untriedMoves: BotMove[];

  visits: number;

  value: number;

  currentPlayer: number;
}




export interface Objective {

  checker: (game: Game, playerIndex: number) => boolean;

  weight: number;
}




export interface AIConfig {




  objectives?: (game: Game, playerIndex: number) => Record<string, Objective>;
}




export const DEFAULT_CONFIG: BotConfig = {
  iterations: 100,
  playoutDepth: 5,
  async: true,
  timeout: 2000,
};






export const DIFFICULTY_PRESETS: Record<string, Partial<BotConfig>> = {
  easy: { iterations: 3, playoutDepth: 3, timeout: 1000 },
  medium: { iterations: 5, playoutDepth: 4, timeout: 1500 },
  hard: { iterations: 8, playoutDepth: 5, timeout: 2000 },
};




export type DifficultyLevel = keyof typeof DIFFICULTY_PRESETS;
````

## File: packages/ai/src/utils.ts
````typescript
export function createSeededRandom(seed?: string): () => number {

  let h = 0;
  const seedStr = seed ?? Math.random().toString(36).substring(2);
  for (let i = 0; i < seedStr.length; i++) {
    h = Math.imul(31, h) + seedStr.charCodeAt(i) | 0;
  }


  return function () {
    h |= 0;
    h = h + 0x6D2B79F5 | 0;
    let t = Math.imul(h ^ h >>> 15, 1 | h);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}




export function randomChoice<T>(array: T[], rng: () => number): T {
  return array[Math.floor(rng() * array.length)];
}




export function shuffle<T>(array: T[], rng: () => number): T[] {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
````

## File: packages/engine/src/action/helpers.ts
````typescript
import type { GameElement } from '../element/game-element.js';
import type { ActionContext } from './types.js';




export interface DependentFilterOptions<T, TPrev> {




  dependsOn: string;










  whenUndefined: (element: T, ctx: ActionContext) => boolean;










  whenSelected: (element: T, previousValue: TPrev, ctx: ActionContext) => boolean;
}


























export function dependentFilter<T, TPrev>(
  options: DependentFilterOptions<T, TPrev>
): (element: T, ctx: ActionContext) => boolean {
  return (element: T, ctx: ActionContext) => {
    const previousValue = ctx.args?.[options.dependsOn] as TPrev | undefined;

    if (previousValue === undefined) {

      return options.whenUndefined(element, ctx);
    }


    return options.whenSelected(element, previousValue, ctx);
  };
}

















export function adjacentToSelection<TDest, TSrc>(options: {

  dependsOn: string;

  getPosition: (source: TSrc) => GameElement | undefined;

  isAdjacent: (destination: TDest, sourcePosition: GameElement) => boolean;

  getAllSources: (ctx: ActionContext) => TSrc[];
}): (element: TDest, ctx: ActionContext) => boolean {
  return dependentFilter<TDest, TSrc>({
    dependsOn: options.dependsOn,
    whenUndefined: (dest, ctx) => {

      const sources = options.getAllSources(ctx);
      return sources.some(src => {
        const pos = options.getPosition(src);
        return pos && options.isAdjacent(dest, pos);
      });
    },
    whenSelected: (dest, src, ctx) => {
      const pos = options.getPosition(src);
      return pos ? options.isAdjacent(dest, pos) : false;
    },
  });
}













export function excludeAlreadySelected<T extends GameElement>(
  selectionName: string
): (element: T, ctx: ActionContext) => boolean {
  return (element: T, ctx: ActionContext) => {
    const selected = ctx.args?.[selectionName] as T[] | undefined;
    if (!selected || selected.length === 0) {
      return true;
    }

    return !selected.some(s => s.id === element.id);
  };
}














export function allOf<T>(
  ...filters: Array<(element: T, ctx: ActionContext) => boolean>
): (element: T, ctx: ActionContext) => boolean {
  return (element: T, ctx: ActionContext) => {
    return filters.every(f => f(element, ctx));
  };
}













export function anyOf<T>(
  ...filters: Array<(element: T, ctx: ActionContext) => boolean>
): (element: T, ctx: ActionContext) => boolean {
  return (element: T, ctx: ActionContext) => {
    return filters.some(f => f(element, ctx));
  };
}









export function not<T>(
  filter: (element: T, ctx: ActionContext) => boolean
): (element: T, ctx: ActionContext) => boolean {
  return (element: T, ctx: ActionContext) => !filter(element, ctx);
}
````

## File: packages/engine/src/command/index.ts
````typescript
export type {
  GameCommand,
  CommandResult,
  BaseCommand,
  CreateElementCommand,
  CreateManyCommand,
  MoveCommand,
  RemoveCommand,
  ShuffleCommand,
  SetAttributeCommand,
  SetVisibilityCommand,
  AddVisibleToCommand,
  SetCurrentPlayerCommand,
  MessageCommand,
  StartGameCommand,
  EndGameCommand,
  SetOrderCommand,
  VisibilityConfig,
} from './types.js';

export {
  type VisibilityMode,
  type VisibilityState,
  canPlayerSee,
  visibilityFromMode,
  resolveVisibility,
  DEFAULT_VISIBILITY,
} from './visibility.js';

export { executeCommand } from './executor.js';
````

## File: packages/engine/src/command/visibility.ts
````typescript
export type VisibilityMode = 'all' | 'owner' | 'hidden' | 'count-only' | 'unordered';




export interface VisibilityState {

  mode: VisibilityMode;

  addPlayers?: number[];

  exceptPlayers?: number[];

  explicit: boolean;
}




export function canPlayerSee(
  visibility: VisibilityState,
  playerPosition: number,
  ownerPosition: number | undefined
): boolean {

  if (visibility.exceptPlayers?.includes(playerPosition)) {
    return false;
  }


  if (visibility.addPlayers?.includes(playerPosition)) {
    return true;
  }


  switch (visibility.mode) {
    case 'all':
      return true;
    case 'owner':
      return ownerPosition !== undefined && playerPosition === ownerPosition;
    case 'hidden':
    case 'count-only':
    case 'unordered':
      return false;
    default:
      return true;
  }
}




export const DEFAULT_VISIBILITY: VisibilityState = {
  mode: 'all',
  explicit: false,
};




export function visibilityFromMode(mode: VisibilityMode): VisibilityState {
  return {
    mode,
    explicit: true,
  };
}




export function resolveVisibility(
  childVisibility: VisibilityState | undefined,
  parentVisibility: VisibilityState | undefined
): VisibilityState {

  if (childVisibility?.explicit) {
    return childVisibility;
  }


  if (parentVisibility) {
    return {
      ...parentVisibility,
      explicit: false,
    };
  }


  return DEFAULT_VISIBILITY;
}
````

## File: packages/engine/src/element/card.ts
````typescript
import { Piece } from './piece.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';



















export class Card<G extends Game = any, P extends Player = any> extends Piece<G, P> {




  $type!: 'card';


  faceUp: boolean = true;

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'card';
  }




  flip(): void {
    this.faceUp = !this.faceUp;
  }




  showFace(): void {
    this.faceUp = true;
  }




  hideFace(): void {
    this.faceUp = false;
  }
}
````

## File: packages/engine/src/element/grid.ts
````typescript
import { Space } from './space.js';
import type { Game } from './game.js';
import type { Player } from '../player/player.js';





export type ElementLayout =
  | 'grid'
  | 'hex-grid'
  | 'list'
  | 'stack'
  | 'hand'
  | 'free-form';














export class Grid<G extends Game = any, P extends Player = any> extends Space<G, P> {





  readonly $layout: ElementLayout = 'grid';






  $rowLabels?: string[];






  $columnLabels?: string[];






  $rowCoord?: string;






  $colCoord?: string;

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}






















export class GridCell<G extends Game = any, P extends Player = any> extends Space<G, P> {





  readonly $layout: ElementLayout = 'list';

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}
````

## File: packages/engine/src/element/hex-grid.ts
````typescript
import { Space } from './space.js';
import type { Game } from './game.js';
import type { Player } from '../player/player.js';
import type { ElementLayout } from './grid.js';




export type HexOrientation = 'flat' | 'pointy';







export type HexCoordSystem = 'offset' | 'axial' | 'cube';













export class HexGrid<G extends Game = any, P extends Player = any> extends Space<G, P> {





  readonly $layout: ElementLayout = 'hex-grid';







  $hexOrientation: HexOrientation = 'pointy';





  $coordSystem: HexCoordSystem = 'axial';





  $qCoord?: string;





  $rCoord?: string;





  $sCoord?: string;





  $hexSize?: number;

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}

















export class HexCell<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'hex-cell';

  constructor(ctx: Partial<import('./types.js').ElementContext>) {
    super(ctx);
    this.$type = 'hex-cell';
  }

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}
````

## File: packages/engine/src/element/piece.ts
````typescript
import { GameElement } from './game-element.js';
import { Space } from './space.js';
import type { ElementClass, ElementAttributes, ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';
import type { VisibilityMode } from '../command/visibility.js';
import { visibilityFromMode } from '../command/visibility.js';










export class Piece<G extends Game = any, P extends Player = any> extends GameElement<G, P> {
  constructor(ctx: Partial<ElementContext>) {
    super(ctx);
  }








  putInto(destination: GameElement, options?: { position?: 'first' | 'last' }): void {
    this.moveToInternal(destination, options?.position);
  }




  moveToInternal(destination: GameElement, position?: 'first' | 'last'): void {
    const oldParent = this._t.parent;


    if (oldParent) {
      const index = oldParent._t.children.indexOf(this);
      if (index !== -1) {
        oldParent._t.children.splice(index, 1);
      }


      if (oldParent instanceof Space) {
        oldParent.triggerEvent('exit', this);
      }
    }


    this._t.parent = destination;

    const pos = position ?? (destination._t.order === 'stacking' ? 'first' : 'last');
    if (pos === 'first') {
      destination._t.children.unshift(this);
    } else {
      destination._t.children.push(this);
    }


    if (destination instanceof Space) {
      destination.triggerEvent('enter', this);
    }
  }




  remove(): void {
    if (this.game.pile) {
      this.putInto(this.game.pile);
    }
  }








  setVisibility(mode: VisibilityMode): void {
    this._visibility = visibilityFromMode(mode);
  }




  showToAll(): void {
    this.setVisibility('all');
  }




  showToOwner(): void {
    this.setVisibility('owner');
  }




  hideFromAll(): void {
    this.setVisibility('hidden');
  }




  addVisibleTo(...players: (Player | number)[]): void {
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    this.addVisibleToInternal(positions);
  }




  showOnlyTo(player: Player | number): void {
    const position = typeof player === 'number' ? player : player.position;
    this._visibility = {
      mode: 'hidden',
      addPlayers: [position],
      explicit: true,
    };
  }




  hideFrom(...players: (Player | number)[]): void {
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    this._visibility = {
      mode: 'all',
      exceptPlayers: positions,
      explicit: true,
    };
  }




  clearVisibility(): void {
    this._visibility = undefined;
  }








  override create<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T>
  ): T {
    if (elementClass === Space as unknown as ElementClass<T> ||
        Object.prototype.isPrototypeOf.call(Space, elementClass)) {
      throw new Error(`Cannot create Space "${name}" inside Piece "${this.name}"`);
    }
    return super.create(elementClass, name, attributes);
  }








  isPiece(): boolean {
    return true;
  }
}
````

## File: packages/engine/src/sandbox/index.ts
````typescript
export interface ExecutionLimits {

  actionTimeout: number;

  maxOperations: number;

  maxRecursionDepth: number;
}




export const DEFAULT_LIMITS: ExecutionLimits = {
  actionTimeout: 100,
  maxOperations: 100000,
  maxRecursionDepth: 100,
};




export class ExecutionLimitError extends Error {
  constructor(
    public readonly limitType: 'timeout' | 'operations' | 'recursion',
    message: string
  ) {
    super(message);
    this.name = 'ExecutionLimitError';
  }
}




export class ExecutionContext {
  private operationCount = 0;
  private recursionDepth = 0;
  private startTime: number | null = null;
  private limits: ExecutionLimits;

  constructor(limits: Partial<ExecutionLimits> = {}) {
    this.limits = { ...DEFAULT_LIMITS, ...limits };
  }




  start(): void {
    this.operationCount = 0;
    this.recursionDepth = 0;
    this.startTime = Date.now();
  }




  stop(): void {
    this.startTime = null;
    this.operationCount = 0;
    this.recursionDepth = 0;
  }





  tick(): void {
    this.operationCount++;


    if (this.operationCount > this.limits.maxOperations) {
      throw new ExecutionLimitError(
        'operations',
        `Maximum operation count (${this.limits.maxOperations}) exceeded. ` +
        'This may indicate an infinite loop in your game logic.'
      );
    }


    if (this.startTime !== null) {
      const elapsed = Date.now() - this.startTime;
      if (elapsed > this.limits.actionTimeout) {
        throw new ExecutionLimitError(
          'timeout',
          `Action timeout (${this.limits.actionTimeout}ms) exceeded. ` +
          'Game actions must complete quickly.'
        );
      }
    }
  }





  enterFunction(): void {
    this.recursionDepth++;
    if (this.recursionDepth > this.limits.maxRecursionDepth) {
      throw new ExecutionLimitError(
        'recursion',
        `Maximum recursion depth (${this.limits.maxRecursionDepth}) exceeded. ` +
        'This may indicate infinite recursion in your game logic.'
      );
    }
  }




  exitFunction(): void {
    this.recursionDepth = Math.max(0, this.recursionDepth - 1);
  }




  getStats(): {
    operations: number;
    recursionDepth: number;
    elapsedMs: number | null;
  } {
    return {
      operations: this.operationCount,
      recursionDepth: this.recursionDepth,
      elapsedMs: this.startTime ? Date.now() - this.startTime : null,
    };
  }
}








export function withLimits<T>(
  fn: (ctx: ExecutionContext) => T,
  limits?: Partial<ExecutionLimits>
): T {
  const ctx = new ExecutionContext(limits);
  ctx.start();
  try {
    return fn(ctx);
  } finally {
    ctx.stop();
  }
}




export async function withLimitsAsync<T>(
  fn: (ctx: ExecutionContext) => Promise<T>,
  limits?: Partial<ExecutionLimits>
): Promise<T> {
  const ctx = new ExecutionContext(limits);
  ctx.start();
  try {
    return await fn(ctx);
  } finally {
    ctx.stop();
  }
}




export function guard<T extends (...args: unknown[]) => unknown>(
  fn: T,
  ctx: ExecutionContext
): T {
  return ((...args: Parameters<T>) => {
    ctx.tick();
    ctx.enterFunction();
    try {
      return fn(...args);
    } finally {
      ctx.exitFunction();
    }
  }) as T;
}





export function validateCode(code: string): { valid: boolean; issues: string[] } {
  const issues: string[] = [];

  const forbiddenPatterns = [
    { pattern: /\bfetch\s*\(/, message: 'Network access (fetch) is forbidden' },
    { pattern: /\bXMLHttpRequest\b/, message: 'Network access (XMLHttpRequest) is forbidden' },
    { pattern: /\beval\s*\(/, message: 'Code evaluation (eval) is forbidden' },
    { pattern: /\bnew\s+Function\s*\(/, message: 'Code evaluation (Function) is forbidden' },
    { pattern: /\bsetTimeout\s*\(/, message: 'Timers (setTimeout) are forbidden' },
    { pattern: /\bsetInterval\s*\(/, message: 'Timers (setInterval) are forbidden' },
    { pattern: /\bMath\.random\s*\(/, message: 'Math.random() is forbidden - use game.random instead' },
    { pattern: /\bDate\.now\s*\(/, message: 'Date.now() is forbidden' },
    { pattern: /\brequire\s*\(\s*['"]fs/, message: 'Filesystem access is forbidden' },
    { pattern: /\bimport\s*\(\s*['"]fs/, message: 'Filesystem access is forbidden' },
  ];

  for (const { pattern, message } of forbiddenPatterns) {
    if (pattern.test(code)) {
      issues.push(message);
    }
  }

  return {
    valid: issues.length === 0,
    issues,
  };
}
````

## File: packages/engine/src/scoring/index.ts
````typescript
export {
  Track,
  MonotonicTrack,
  UniqueTrack,
  CounterTrack,
} from './track.js';

export type {
  TrackEntry,
  TrackConfig,
  MonotonicTrackConfig,
  UniqueTrackConfig,
  CounterTrackConfig,
} from './track.js';
````

## File: packages/engine/src/scoring/track.ts
````typescript
export interface TrackEntry {

  value: number;

  points: number;

  isSpecial?: boolean;
}




export interface TrackConfig {

  id: string;

  name?: string;

  maxEntries: number;

  pointsPerEntry?: number[];

  completionBonus?: number;

  allowSpecialEntries?: boolean;
}




export abstract class Track {
  readonly id: string;
  readonly name: string;
  readonly maxEntries: number;
  readonly pointsPerEntry: number[];
  readonly completionBonus: number;
  readonly allowSpecialEntries: boolean;

  protected entries: TrackEntry[] = [];

  constructor(config: TrackConfig) {
    this.id = config.id;
    this.name = config.name ?? config.id;
    this.maxEntries = config.maxEntries;
    this.pointsPerEntry = config.pointsPerEntry ?? new Array(config.maxEntries).fill(0);
    this.completionBonus = config.completionBonus ?? 0;
    this.allowSpecialEntries = config.allowSpecialEntries ?? false;
  }






  abstract canAdd(value: number, isSpecial?: boolean): boolean;





  add(value: number, isSpecial: boolean = false): number {
    if (!this.canAdd(value, isSpecial)) {
      throw new Error(`Cannot add value ${value} to track ${this.id}`);
    }

    const position = this.entries.length;
    const points = this.pointsPerEntry[position] ?? 0;

    this.entries.push({ value, points, isSpecial });
    return points;
  }




  getEntries(): readonly TrackEntry[] {
    return this.entries;
  }




  getLastEntry(): TrackEntry | undefined {
    return this.entries[this.entries.length - 1];
  }




  get length(): number {
    return this.entries.length;
  }




  isComplete(): boolean {
    return this.entries.length >= this.maxEntries;
  }




  isEmpty(): boolean {
    return this.entries.length === 0;
  }




  calculatePoints(): number {
    let total = 0;
    for (const entry of this.entries) {
      total += entry.points;
    }
    if (this.isComplete()) {
      total += this.completionBonus;
    }
    return total;
  }




  getPointsBreakdown(): { entries: number; bonus: number; total: number } {
    const entries = this.entries.reduce((sum, e) => sum + e.points, 0);
    const bonus = this.isComplete() ? this.completionBonus : 0;
    return { entries, bonus, total: entries + bonus };
  }




  clear(): void {
    this.entries = [];
  }




  toJSON(): { id: string; entries: TrackEntry[] } {
    return {
      id: this.id,
      entries: [...this.entries],
    };
  }




  fromJSON(data: { entries: TrackEntry[] }): void {
    this.entries = [...data.entries];
  }
}




export interface MonotonicTrackConfig extends TrackConfig {

  direction: 'increasing' | 'decreasing';

  allowEqual?: boolean;
}






















export class MonotonicTrack extends Track {
  readonly direction: 'increasing' | 'decreasing';
  readonly allowEqual: boolean;

  constructor(config: MonotonicTrackConfig) {
    super(config);
    this.direction = config.direction;
    this.allowEqual = config.allowEqual ?? false;
  }

  canAdd(value: number, isSpecial: boolean = false): boolean {

    if (this.entries.length >= this.maxEntries) {
      return false;
    }


    if (this.entries.length === 0) {
      return true;
    }

    const lastValue = this.entries[this.entries.length - 1].value;


    const allowEqualForThis = this.allowEqual || (isSpecial && this.allowSpecialEntries);

    if (this.direction === 'increasing') {
      return allowEqualForThis ? value >= lastValue : value > lastValue;
    } else {
      return allowEqualForThis ? value <= lastValue : value < lastValue;
    }
  }
}




export interface UniqueTrackConfig extends TrackConfig {

  validRange?: { min: number; max: number };
}














export class UniqueTrack extends Track {
  readonly validRange?: { min: number; max: number };

  constructor(config: UniqueTrackConfig) {
    super(config);
    this.validRange = config.validRange;
  }

  canAdd(value: number, isSpecial: boolean = false): boolean {

    if (this.entries.length >= this.maxEntries) {
      return false;
    }


    if (this.validRange) {
      if (value < this.validRange.min || value > this.validRange.max) {
        return false;
      }
    }


    if (!isSpecial || !this.allowSpecialEntries) {
      if (this.entries.some(e => e.value === value)) {
        return false;
      }
    }

    return true;
  }




  hasValue(value: number): boolean {
    return this.entries.some(e => e.value === value);
  }




  getValues(): Set<number> {
    return new Set(this.entries.map(e => e.value));
  }
}




export interface CounterTrackConfig extends TrackConfig {

  pointsPerCount?: number;
}














export class CounterTrack extends Track {
  readonly pointsPerCount: number;

  constructor(config: CounterTrackConfig) {

    const pointsPerCount = config.pointsPerCount ?? 0;
    super({
      ...config,
      pointsPerEntry: new Array(config.maxEntries).fill(pointsPerCount),
    });
    this.pointsPerCount = pointsPerCount;
  }




  canAdd(_value: number, _isSpecial?: boolean): boolean {
    return this.entries.length < this.maxEntries;
  }




  increment(): number {
    return this.add(this.entries.length + 1);
  }




  get count(): number {
    return this.entries.length;
  }
}
````

## File: packages/engine/ARCHITECTURE.md
````markdown
# BoardSmith Engine Architecture

## Core Concepts

### Actions vs Commands

BoardSmith uses a two-layer architecture for handling player operations:

#### **Actions** (High-Level, Game-Specific)

**Location:** `src/action/`

Actions represent what **players do** in the game from a game design perspective. They are:

- **High-level operations**: "move piece", "draw card", "ask for rank"
- **Game-specific**: Defined by game designers for their particular game
- **Declarative**: Describe *what* players want to do, not *how* to do it
- **User-facing**: Have prompts, selections, and validation for the UI

**Example:**
```typescript
const moveAction = Action.create('move')
  .prompt('Move a piece')
  .chooseElement('from', { prompt: 'Select piece to move' })
  .chooseFrom('to', { prompt: 'Select destination', choices: getValidMoves })
  .execute((args, ctx) => {
    // This execute function generates Commands
    const piece = args.from as Piece;
    const destination = args.to as Space;
    piece.putInto(destination); //  Generates MoveCommand internally
  });
```

#### **Commands** (Low-Level, Event-Sourced)

**Location:** `src/command/`

Commands represent **low-level state mutations** that modify the game tree. They are:

- **Low-level operations**: `CreateElementCommand`, `MoveCommand`, `SetAttributeCommand`
- **Generic**: Same commands work for any game
- **Imperative**: Direct instructions to modify state
- **Event-sourced**: Tracked, serializable, and replayable
- **Internal**: Not exposed to game designers directly

**Example:**
```typescript
// When piece.putInto(destination) is called, it generates:
{
  type: 'move',
  elementId: piece.id,
  targetId: destination.id,
  position: 'last'
}
```

### Why This Separation?

#### 1. **Separation of Concerns**
- **Actions** handle game logic and player intent
- **Commands** handle state management and persistence

#### 2. **Event Sourcing**
- Commands form an event log that can be:
  - Replayed for debugging
  - Stored for game history
  - Used for undo/redo
  - Validated and sanitized

#### 3. **Flexibility**
- Game designers work with intuitive Actions
- Engine manages state changes via Commands
- UI can be auto-generated from Action metadata

#### 4. **Security**
- Commands are validated before execution
- Players can't directly manipulate state
- All mutations go through the command system

### Flow Diagram

```

 Player selects action in UI                        

                  
                  

 Action System (High-Level)                          
 - Validates selections                              
 - Executes game logic                               
 - Calls element methods (putInto, create, etc.)    

                  
                  

 Command System (Low-Level)                          
 - Generates MoveCommand, CreateElementCommand, etc.
 - Validates against current state                   
 - Executes state mutations                          
 - Logs for event sourcing                           

                  
                  

 Game State Updated                                  

```

### Comparison to Other Patterns

#### Redux/Vuex (Frontend State Management)
- **Actions** = Actions (user intent)
- **Commands** = Mutations (state changes)
- Similar pattern, different domain

#### Event Sourcing (Backend Architecture)
- **Actions** = Commands (user intent)
- **Commands** = Events (things that happened)
- BoardSmith uses imperative commands, not past-tense events

#### CQRS (Command Query Responsibility Segregation)
- **Actions** = Application commands
- **Commands** = Domain events
- Similar layering concept

## When to Use Which?

### Game Designers Use: **Actions**

```typescript
// Define what players can do
const askAction = Action.create('ask')
  .chooseFrom('target', { choices: (ctx) => game.playerChoices({ excludeSelf: true, currentPlayer: ctx.player }) })
  .chooseFrom('rank', { choices: ['A', '2', '3', ...] })
  .execute((args, ctx) => {
    // Game logic here
  });
```

### Engine Developers Use: **Commands**

```typescript
// Internal state mutations
executeCommand({
  type: 'move',
  elementId: 42,
  targetId: 17,
});
```

### Element Methods Generate: **Commands**

```typescript
// Game designers call this
piece.putInto(destination);

// Which internally generates this command
{
  type: 'move',
  elementId: piece.id,
  targetId: destination.id,
}
```

## Best Practices

###  Do

- Use Actions for game-specific player operations
- Use element methods (`putInto`, `create`) which generate Commands
- Let the command system handle state mutations
- Keep Action execute functions focused on game logic

###  Don't

- Don't manually create Commands in game code
- Don't bypass the Action system for player operations
- Don't directly mutate element properties (use `setAttribute` if needed)
- Don't mix UI concerns into Action execute functions

## Related Documentation

- **[Action API](src/action/README.md)** - Creating player actions
- **[Command Types](src/command/types.ts)** - Available command types
- **[Element System](src/element/README.md)** - Game element tree structure
- **[Flow System](src/flow/README.md)** - Game flow control

---

**Summary:** Actions are what players *do*. Commands are how the engine *does it*.
````

## File: packages/engine/README.md
````markdown
# @boardsmith/engine

Core game engine for BoardSmith. Provides the element system, actions, flow control, and command execution.

## Installation

```bash
npm install @boardsmith/engine
```

## Core Concepts

### Element System

Build your game state as a tree of elements:

```typescript
import { Game, Card, Deck, Hand, Space, Piece } from '@boardsmith/engine';

class MyGame extends Game {
  deck: Deck<PlayingCard>;
  players: PlayerCollection<MyPlayer>;

  constructor(options: GameOptions) {
    super(options);

    // Register custom element classes for serialization
    this.registerElements([PlayingCard, MyPlayer]);

    // Create element tree
    this.deck = this.create(Deck, 'deck');
    this.deck.createMany(52, PlayingCard, 'card', (i) => ({
      suit: ['hearts', 'diamonds', 'clubs', 'spades'][Math.floor(i / 13)],
      rank: (i % 13) + 1,
    }));
  }
}
```

### Element Types

| Type | Description |
|------|-------------|
| `Game` | Root element, contains all game state |
| `Space` | Container for other elements (board regions, zones) |
| `Piece` | Movable game pieces |
| `Card` | Card elements with flip states |
| `Deck` | Ordered stack of cards with shuffle/draw |
| `Hand` | Player's hand of cards |
| `Die` | Rollable die with configurable sides |
| `DicePool` | Collection of dice |
| `Grid` | 2D grid of cells |
| `HexGrid` | Hexagonal grid |

### Element Comparison

**Important**: Always compare elements by ID, not reference:

```typescript
// WRONG - may fail due to serialization
if (myCards.includes(selectedCard)) { ... }

// CORRECT - compare by ID
if (myCards.some(c => c.id === selectedCard.id)) { ... }

// CORRECT - use built-in helpers
if (selectedCard.equals(otherCard)) { ... }
if (myCards.contains(selectedCard)) { ... }
```

## Actions

Define player actions with the Action builder:

```typescript
import { Action } from '@boardsmith/engine';

const playCard = Action.create<MyGame>('playCard')
  .chooseElement<PlayingCard>('card', {
    prompt: 'Choose a card to play',
    from: (ctx) => ctx.player.hand.all(PlayingCard),
    filter: (card, ctx) => card.isPlayable(),
  })
  .execute((args, ctx) => {
    const card = args.card as PlayingCard;
    card.moveTo(ctx.game.discardPile);
    ctx.player.score += card.value;
  });
```

### Selection Types

- `chooseElement<T>()` - Select a game element
- `chooseFrom()` - Select from a list of choices
- `chooseNumber()` - Select a number in a range
- `chooseText()` - Free text input

### Multi-Step Selections

When filters depend on previous selections, handle the undefined case:

```typescript
Action.create('move')
  .chooseElement<Piece>('piece', { ... })
  .chooseElement<Cell>('destination', {
    filter: (cell, ctx) => {
      const piece = ctx.args?.piece as Piece | undefined;
      if (!piece) {
        // Availability check - return true if ANY piece can reach this cell
        return getAllPieces(ctx).some(p => p.canMoveTo(cell));
      }
      // Actual selection - filter based on selected piece
      return piece.canMoveTo(cell);
    }
  })
```

Or use the `dependentFilter` helper:

```typescript
import { dependentFilter } from '@boardsmith/engine';

.chooseElement<Cell>('destination', {
  filter: dependentFilter({
    dependsOn: 'piece',
    whenUndefined: (cell, ctx) => getAllPieces(ctx).some(p => p.canMoveTo(cell)),
    whenSelected: (cell, piece, ctx) => piece.canMoveTo(cell),
  })
})
```

## Flow Control

Define game structure with flow nodes:

```typescript
import {
  defineFlow, sequence, phase, loop, eachPlayer,
  actionStep, execute, TurnOrder
} from '@boardsmith/engine';

export const flow = defineFlow(
  sequence(
    phase('setup', {
      do: execute((ctx) => {
        ctx.game.deck.shuffle();
        for (const player of ctx.game.players) {
          ctx.game.deck.deal(player.hand, 5);
        }
      }),
    }),

    phase('play', {
      do: loop({
        while: (ctx) => !ctx.game.isGameOver(),
        maxIterations: 1000,
        do: eachPlayer({
          ...TurnOrder.DEFAULT,
          do: actionStep({ actions: ['playCard', 'draw', 'pass'] }),
        }),
      }),
    }),

    execute((ctx) => ctx.game.declareWinner()),
  )
);
```

### Flow Nodes

| Node | Description |
|------|-------------|
| `sequence()` | Execute nodes in order |
| `phase()` | Named game phase |
| `loop()` | Repeat while condition is true |
| `repeat()` | Repeat a fixed number of times |
| `turnLoop()` | Simplified action loop with auto game.isFinished() check |
| `eachPlayer()` | Iterate through players |
| `forEach()` | Iterate through elements |
| `actionStep()` | Wait for player action |
| `simultaneousActionStep()` | All players act at once |
| `switchOn()` | Branch based on value |
| `ifThen()` | Conditional execution |
| `execute()` | Run code immediately |

### turnLoop

A simplified loop for turn-based action sequences. Automatically checks `game.isFinished()` and reduces boilerplate for common turn loop patterns:

```typescript
// Instead of this verbose pattern:
loop({
  while: (ctx) => {
    if (ctx.game.isFinished()) return false;
    const player = ctx.player as MyPlayer;
    return player.actionsRemaining > 0;
  },
  maxIterations: 30,
  do: actionStep({ actions: ['move', 'attack', 'endTurn'] }),
})

// Use turnLoop:
turnLoop({
  actions: ['move', 'attack', 'endTurn'],
  while: (ctx) => (ctx.player as MyPlayer).actionsRemaining > 0,
  maxIterations: 30,
})
```

### Turn Order

Use `TurnOrder` presets for common patterns:

```typescript
eachPlayer({
  ...TurnOrder.LEFT_OF_DEALER(ctx => ctx.game.dealerPosition),
  ...TurnOrder.SKIP_IF(player => player.hasFolded),
  do: actionStep({ actions: ['bet', 'fold'] }),
})
```

## Commands

The engine uses event sourcing. All state changes go through commands:

```typescript
// In action execute:
ctx.game.deck.shuffle();  // Generates ShuffleCommand
card.moveTo(player.hand); // Generates MoveCommand
card.flip();              // Generates SetAttributeCommand
```

Commands are automatically generated and can be replayed for undo/redo.

## Visibility

Control what players can see:

```typescript
// Card is visible only to its owner
card.showOnlyTo(player);

// Card is visible to everyone
card.showToAll();

// Card is hidden from everyone
card.hide();
```

## API Reference

### Game

```typescript
class Game extends GameElement {
  players: PlayerCollection;
  phase?: string;
  finished: boolean;

  registerElements(classes: ElementClass[]): void;
  getElementById(id: number): GameElement | undefined;
  atBranch(path: string): GameElement | undefined;
  finish(winners?: Player[]): void;
}
```

### GameElement

```typescript
class GameElement {
  id: number;            // Unique identifier
  name: string;          // Element name
  game: Game;            // Root game reference
  parent?: GameElement;  // Parent in tree

  create<T>(Class, name, attrs?): T;
  createMany<T>(count, Class, name, attrs?): ElementCollection<T>;
  all<T>(Class?): ElementCollection<T>;
  first<T>(Class?): T | undefined;
  count(Class?): number;

  moveTo(destination: GameElement): void;
  remove(): void;

  equals(other: GameElement): boolean;
  hasId(id: number): boolean;
}
```

### ElementCollection

```typescript
class ElementCollection<T> extends Array<T> {
  first(): T | undefined;
  last(): T | undefined;
  random(): T | undefined;
  shuffle(): this;

  contains(element: GameElement): boolean;
  findById(id: number): T | undefined;
  hasId(id: number): boolean;
  indexOfElement(element: GameElement): number;
}
```

## See Also

- [Getting Started Guide](../../docs/getting-started.md)
- [Common Pitfalls](../../docs/common-pitfalls.md)
- [Common Patterns](../../docs/common-patterns.md)
- [Actions & Flow](../../docs/actions-and-flow.md)
````

## File: packages/session/src/colors.ts
````typescript
export interface ColorChoice {
  value: string;
  label: string;
}




export const STANDARD_PLAYER_COLORS: readonly ColorChoice[] = [
  { value: '#e74c3c', label: 'Red' },
  { value: '#3498db', label: 'Blue' },
  { value: '#27ae60', label: 'Green' },
  { value: '#e67e22', label: 'Orange' },
  { value: '#9b59b6', label: 'Purple' },
  { value: '#f1c40f', label: 'Yellow' },
  { value: '#95a5a6', label: 'Black' },
  { value: '#ecf0f1', label: 'White' },
] as const;




export const DEFAULT_PLAYER_COLORS = ['#e74c3c', '#3498db'] as const;




export interface ColorOptionDefinition {
  type: 'color';
  label: string;
  choices: ColorChoice[];
}

























export function createColorOption(
  colors?: readonly ColorChoice[],
  label = 'Color'
): ColorOptionDefinition {
  return {
    type: 'color' as const,
    label,
    choices: [...(colors ?? STANDARD_PLAYER_COLORS)],
  };
}
````

## File: packages/session/README.md
````markdown
# @boardsmith/session

Game session management for BoardSmith. Handles game lifecycle, state synchronization, action processing, and AI players.

## Installation

```bash
npm install @boardsmith/session
```

## Overview

The session package provides a unified API for managing game sessions across different platforms (local development, Cloudflare Workers, etc.) while keeping game designers isolated from implementation details.

## Quick Start

```typescript
import { GameSession, generateGameId } from '@boardsmith/session';
import { CheckersGame, gameDefinition } from './my-game';

// Create a new game session
const session = await GameSession.create({
  gameType: 'checkers',
  GameClass: CheckersGame,
  playerCount: 2,
  playerNames: ['Alice', 'Bob'],
  seed: 12345,  // Optional: for reproducible games
});

// Get state for a specific player
const playerState = session.getState(0);  // Alice's view

// Perform an action
const result = await session.performAction('move', 0, {
  piece: pieceId,
  destination: cellId,
});

if (result.success) {
  console.log('Move successful!');
} else {
  console.log(`Error: ${result.error}`);
}
```

## GameSession

The main class for managing a game instance.

### Creation

```typescript
// Create a new game
const session = await GameSession.create({
  gameType: 'my-game',
  GameClass: MyGame,
  playerCount: 4,
  playerNames: ['Alice', 'Bob', 'Carol', 'Dave'],
  gameOptions: { variant: 'advanced' },
  seed: Date.now(),  // Optional random seed
  storage: myStorageAdapter,  // Optional persistence
});

// Restore from saved state
const session = await GameSession.restore(
  gameDefinition,
  storedState,
  { storage: myStorageAdapter }
);
```

### Getting State

```typescript
// Get state for a specific player (with hidden info filtered)
const playerState = session.getState(playerPosition);

interface PlayerGameState {
  game: any;              // Serialized game state (player's view)
  flowState: FlowState;   // Current flow state
  playerNames: string[];  // All player names
  playerPosition: number; // This player's position
  finished: boolean;      // Is game over
  winners?: number[];     // Winning player positions
}
```

### Performing Actions

```typescript
const result = await session.performAction(
  'playCard',      // Action name
  0,               // Player position
  { card: cardId } // Action arguments
);

interface ActionResult {
  success: boolean;
  error?: string;
  state?: PlayerGameState;
  pendingAction?: PendingActionInfo;
}
```

### Undo

```typescript
// Undo to turn start
const result = await session.undoToTurnStart(playerPosition);

// Undo last action (with limits)
const result = await session.undo(playerPosition);

interface UndoResult {
  success: boolean;
  error?: string;
  actionsUndone?: number;
}
```

### History and Replay

```typescript
// Get state at a specific action index (for time travel)
const historicalState = session.getStateAtAction(actionIndex);

// Rewind game to an action and continue from there
const result = await session.rewindToAction(actionIndex);

// Get action history
const history = session.getActionHistory();
```

## Storage Adapters

Persist game state with storage adapters:

```typescript
interface StorageAdapter {
  save(state: StoredGameState): Promise<void>;
  load(): Promise<StoredGameState | null>;
}

// Example: SQLite adapter
class SqliteStorage implements StorageAdapter {
  constructor(private db: Database, private gameId: string) {}

  async save(state: StoredGameState): Promise<void> {
    this.db.run(
      'INSERT OR REPLACE INTO games (id, state) VALUES (?, ?)',
      [this.gameId, JSON.stringify(state)]
    );
  }

  async load(): Promise<StoredGameState | null> {
    const row = this.db.get('SELECT state FROM games WHERE id = ?', [this.gameId]);
    return row ? JSON.parse(row.state) : null;
  }
}
```

## Broadcast Adapters

Notify connected clients of state changes:

```typescript
interface BroadcastAdapter<TSession extends SessionInfo> {
  addSession(session: TSession): void;
  removeSession(session: TSession): void;
  getSessions(): TSession[];
  send(session: TSession, message: unknown): void;
  broadcast(message: unknown): void;
}

interface SessionInfo {
  playerPosition: number;
  isSpectator: boolean;
  playerId?: string;
}
```

## AI Controller

Built-in AI player support using Monte Carlo Tree Search:

```typescript
import { AIController } from '@boardsmith/session';

const ai = new AIController({
  level: 'medium',  // 'easy' | 'medium' | 'hard' | 'expert' or iteration count
  players: [1, 3],  // AI-controlled player positions
});

// Check if current player is AI
if (ai.isAIPlayer(currentPlayerPosition)) {
  const move = await ai.getMove(session);
  await session.performAction(move.action, move.player, move.args);
}
```

### AI Levels

| Level | Iterations | Description |
|-------|------------|-------------|
| easy | 100 | Quick, makes mistakes |
| medium | 500 | Balanced play |
| hard | 1500 | Strong play |
| expert | 5000 | Very strong, slower |

## Lobby System

Manage pre-game player setup:

```typescript
// Lobby is integrated into GameSession
const lobby = session.lobby;

// Claim a position
await session.claimPosition(playerId, playerPosition);

// Update player name
await session.updatePlayerName(playerId, 'New Name');

// Check if ready to start
if (lobby.canStart()) {
  await session.startGame();
}

interface LobbyState {
  slots: LobbySlot[];
  minPlayers: number;
  maxPlayers: number;
  isStarted: boolean;
}

interface LobbySlot {
  position: number;
  status: 'open' | 'claimed' | 'ai' | 'locked';
  playerId?: string;
  playerName?: string;
  isConnected: boolean;
}
```

## Player Options

Configure per-player settings:

```typescript
interface PlayerOptionDefinition {
  id: string;
  type: 'standard' | 'exclusive';
  choices: { id: string; label: string }[];
  defaultValue: string;
}

// Standard option: each player picks independently
const colorOption: StandardPlayerOption = {
  id: 'color',
  type: 'standard',
  choices: [
    { id: 'red', label: 'Red' },
    { id: 'blue', label: 'Blue' },
    { id: 'green', label: 'Green' },
  ],
  defaultValue: 'red',
};

// Exclusive option: first-come-first-served
const factionOption: ExclusivePlayerOption = {
  id: 'faction',
  type: 'exclusive',
  choices: [
    { id: 'empire', label: 'Empire' },
    { id: 'rebels', label: 'Rebels' },
  ],
  defaultValue: 'empire',
};
```

### Color Options

Built-in color picker:

```typescript
import { createColorOption, STANDARD_PLAYER_COLORS } from '@boardsmith/session';

const colorOption = createColorOption({
  defaultColors: ['red', 'blue', 'green', 'yellow'],
});

// Available colors
console.log(STANDARD_PLAYER_COLORS);
// ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'cyan', ...]
```

## Utility Functions

### generateGameId

Create unique game identifiers:

```typescript
import { generateGameId } from '@boardsmith/session';

const gameId = generateGameId();  // e.g., 'abc123xyz'
```

### buildPlayerState

Create player-specific state view:

```typescript
import { buildPlayerState } from '@boardsmith/session';

const playerView = buildPlayerState(
  gameRunner,
  playerNames,
  playerPosition,
  { includeActionMetadata: true }
);
```

### isPlayersTurn

Check if it's a player's turn:

```typescript
import { isPlayersTurn } from '@boardsmith/session';

const canAct = isPlayersTurn(flowState, playerPosition);
```

## Type Definitions

### GameDefinition

```typescript
interface GameDefinition {
  gameType: string;
  displayName?: string;
  gameClass: GameClass;
  flow: FlowNode;
  actions: Record<string, Action>;
  minPlayers: number;
  maxPlayers: number;
  playerOptions?: PlayerOptionDefinition[];
  gameOptions?: GameOptionDefinition[];
  presets?: GamePreset[];
}
```

### StoredGameState

```typescript
interface StoredGameState {
  gameType: string;
  playerCount: number;
  playerNames: string[];
  seed: number;
  gameOptions?: Record<string, unknown>;
  playerConfigs?: PlayerConfig[];
  actionHistory: SerializedAction[];
  version: number;
}
```

### WebSocketMessage

```typescript
type WebSocketMessage =
  | { type: 'action'; action: string; args: unknown }
  | { type: 'undo' }
  | { type: 'undoToTurnStart' }
  | { type: 'ping' };
```

## Error Handling

```typescript
const result = await session.performAction('move', 0, args);

if (!result.success) {
  switch (result.error) {
    case 'Not your turn':
      // Handle wrong player
      break;
    case 'Action not available':
      // Handle invalid action
      break;
    case 'Invalid selection':
      // Handle invalid arguments
      break;
    default:
      console.error('Unknown error:', result.error);
  }
}
```

## Best Practices

1. **Use storage adapters** for game persistence
2. **Implement broadcast adapters** for multiplayer
3. **Set random seeds** for reproducible games
4. **Check isPlayersTurn** before allowing actions
5. **Handle pending actions** for multi-step selections
6. **Use lobby system** for proper game setup

## See Also

- [Getting Started](../../docs/getting-started.md)
- [@boardsmith/engine](../engine/README.md) - Core game engine
- [@boardsmith/server](../server/README.md) - HTTP/WebSocket server
````

## File: packages/testing/src/assertions.ts
````typescript
import type { Game, GameElement, Player } from '@boardsmith/engine';
import type { TestGame } from './test-game.js';




export interface ExpectedFlowState {

  currentPlayer?: number;

  actions?: string[];

  complete?: boolean;

  awaitingInput?: boolean;

  phase?: string;
}




export interface FlowStateAssertionResult {
  passed: boolean;
  message: string;
  expected: ExpectedFlowState;
  actual: {
    currentPlayer?: number;
    actions?: string[];
    complete: boolean;
    awaitingInput: boolean;
    phase?: string;
  };
}













export function assertFlowState(
  testGame: TestGame,
  expected: ExpectedFlowState
): FlowStateAssertionResult {
  const flowState = testGame.getFlowState();
  const errors: string[] = [];

  const actual = {
    currentPlayer: flowState?.currentPlayer,
    actions: flowState?.availableActions,
    complete: testGame.isComplete(),
    awaitingInput: testGame.isAwaitingInput(),
    phase: flowState?.currentPhase,
  };

  if (expected.currentPlayer !== undefined && actual.currentPlayer !== expected.currentPlayer) {
    errors.push(`Expected current player ${expected.currentPlayer}, got ${actual.currentPlayer}`);
  }

  if (expected.complete !== undefined && actual.complete !== expected.complete) {
    errors.push(`Expected complete=${expected.complete}, got ${actual.complete}`);
  }

  if (expected.awaitingInput !== undefined && actual.awaitingInput !== expected.awaitingInput) {
    errors.push(`Expected awaitingInput=${expected.awaitingInput}, got ${actual.awaitingInput}`);
  }

  if (expected.phase !== undefined && actual.phase !== expected.phase) {
    errors.push(`Expected phase="${expected.phase}", got "${actual.phase}"`);
  }

  if (expected.actions !== undefined) {
    const missingActions = expected.actions.filter(a => !actual.actions?.includes(a));
    if (missingActions.length > 0) {
      errors.push(`Missing expected actions: ${missingActions.join(', ')}`);
    }
  }

  const passed = errors.length === 0;
  const message = passed ? 'Flow state matches expected' : errors.join('; ');

  if (!passed) {
    throw new Error(`Flow state assertion failed: ${message}`);
  }

  return { passed, message, expected, actual };
}










export function assertPlayerHas<E extends GameElement>(
  testGame: TestGame,
  playerIndex: number,
  zoneName: string,
  elementClass: new (...args: any[]) => E,
  countOrOptions: number | { min?: number; max?: number; exact?: number }
): void {
  const player = testGame.getPlayer(playerIndex) as any;
  const zone = player[zoneName];

  if (!zone) {
    throw new Error(`Player ${playerIndex} has no zone named "${zoneName}"`);
  }

  const count = zone.count(elementClass);
  const options = typeof countOrOptions === 'number' ? { exact: countOrOptions } : countOrOptions;

  if (options.exact !== undefined && count !== options.exact) {
    throw new Error(
      `Expected player ${playerIndex} to have exactly ${options.exact} ${elementClass.name}(s) in ${zoneName}, got ${count}`
    );
  }

  if (options.min !== undefined && count < options.min) {
    throw new Error(
      `Expected player ${playerIndex} to have at least ${options.min} ${elementClass.name}(s) in ${zoneName}, got ${count}`
    );
  }

  if (options.max !== undefined && count > options.max) {
    throw new Error(
      `Expected player ${playerIndex} to have at most ${options.max} ${elementClass.name}(s) in ${zoneName}, got ${count}`
    );
  }
}










export function assertElementCount<E extends GameElement>(
  testGame: TestGame,
  elementClass: new (...args: any[]) => E,
  countOrOptions: number | { min?: number; max?: number; exact?: number }
): void {

  const count = testGame.game.all(elementClass as any).length;
  const options = typeof countOrOptions === 'number' ? { exact: countOrOptions } : countOrOptions;

  if (options.exact !== undefined && count !== options.exact) {
    throw new Error(
      `Expected exactly ${options.exact} ${elementClass.name}(s) in game, got ${count}`
    );
  }

  if (options.min !== undefined && count < options.min) {
    throw new Error(
      `Expected at least ${options.min} ${elementClass.name}(s) in game, got ${count}`
    );
  }

  if (options.max !== undefined && count > options.max) {
    throw new Error(
      `Expected at most ${options.max} ${elementClass.name}(s) in game, got ${count}`
    );
  }
}











export function assertGameFinished(
  testGame: TestGame,
  options?: { winner?: number; winners?: number[] }
): void {
  if (!testGame.isComplete()) {
    throw new Error('Expected game to be finished, but it is not complete');
  }

  if (options?.winner !== undefined) {
    const winners = testGame.getWinners();
    if (winners.length !== 1 || winners[0].position !== options.winner) {
      const actualWinners = winners.map(w => w.position).join(', ');
      throw new Error(`Expected player ${options.winner} to win, but winners are: [${actualWinners}]`);
    }
  }

  if (options?.winners !== undefined) {
    const winners = testGame.getWinners();
    const actualPositions = winners.map(w => w.position).sort();
    const expectedPositions = [...options.winners].sort();

    if (actualPositions.length !== expectedPositions.length ||
        !actualPositions.every((p, i) => p === expectedPositions[i])) {
      throw new Error(
        `Expected winners [${expectedPositions.join(', ')}], but got [${actualPositions.join(', ')}]`
      );
    }
  }
}










export function assertActionAvailable(
  testGame: TestGame,
  playerIndex: number,
  actionName: string,
  options?: { withChoices?: boolean }
): void {
  const flowState = testGame.getFlowState();

  if (flowState?.currentPlayer !== playerIndex) {
    throw new Error(
      `Cannot check action availability for player ${playerIndex} - current player is ${flowState?.currentPlayer}`
    );
  }

  const availableActions = flowState?.availableActions ?? [];
  if (!availableActions.includes(actionName)) {
    throw new Error(
      `Action "${actionName}" is not available for player ${playerIndex}. Available actions: [${availableActions.join(', ')}]`
    );
  }


}









export function assertActionNotAvailable(
  testGame: TestGame,
  playerIndex: number,
  actionName: string
): void {
  const flowState = testGame.getFlowState();


  if (flowState?.currentPlayer !== playerIndex) {
    return;
  }

  const availableActions = flowState?.availableActions ?? [];
  if (availableActions.includes(actionName)) {
    throw new Error(
      `Action "${actionName}" should NOT be available for player ${playerIndex}, but it is`
    );
  }
}
````

## File: packages/testing/src/fixtures.ts
````typescript
import type { Game, GameElement, GameOptions, Player } from '@boardsmith/engine';
import { TestGame, type TestGameOptions } from './test-game.js';














export class ScenarioBuilder<G extends Game = Game> {
  private GameClass: new (options: GameOptions) => G;
  private options: TestGameOptions;
  private setupFunctions: Array<(testGame: TestGame<G>) => void> = [];

  constructor(GameClass: new (options: GameOptions) => G) {
    this.GameClass = GameClass;
    this.options = { playerCount: 2 };
  }




  withPlayers(count: number, names?: string[]): this {
    this.options.playerCount = count;
    if (names) {
      this.options.playerNames = names;
    }
    return this;
  }




  withSeed(seed: string): this {
    this.options.seed = seed;
    return this;
  }




  setup(fn: (testGame: TestGame<G>) => void): this {
    this.setupFunctions.push(fn);
    return this;
  }




  build(): TestGame<G> {
    const testGame = TestGame.create(this.GameClass, {
      ...this.options,
      autoStart: false,
    });


    for (const setupFn of this.setupFunctions) {
      setupFn(testGame);
    }


    testGame.start();

    return testGame;
  }




  buildWithoutStart(): TestGame<G> {
    const testGame = TestGame.create(this.GameClass, {
      ...this.options,
      autoStart: false,
    });


    for (const setupFn of this.setupFunctions) {
      setupFn(testGame);
    }

    return testGame;
  }
}















export function scenario<G extends Game>(
  GameClass: new (options: GameOptions) => G
): ScenarioBuilder<G> {
  return new ScenarioBuilder(GameClass);
}










export function quickGame<G extends Game>(
  GameClass: new (options: GameOptions) => G,
  playerCount: number,
  seed?: string
): TestGame<G> {
  return TestGame.create(GameClass, {
    playerCount,
    seed,
  });
}














export function playSequence<G extends Game>(
  GameClass: new (options: GameOptions) => G,
  options: TestGameOptions,
  actions: Array<{ player: number; action: string; args?: Record<string, unknown> }>
): TestGame<G> {
  const testGame = TestGame.create(GameClass, options);

  for (const { player, action, args } of actions) {
    const result = testGame.doAction(player, action, args ?? {});
    if (!result.success) {
      throw new Error(
        `Action "${action}" by player ${player} failed: ${result.error ?? 'unknown error'}`
      );
    }
  }

  return testGame;
}











export function playUntil<G extends Game>(
  testGame: TestGame<G>,
  condition: (testGame: TestGame<G>) => boolean,
  maxMoves: number = 1000
): TestGame<G> {
  let moves = 0;

  while (!condition(testGame) && moves < maxMoves && !testGame.isComplete()) {
    const flowState = testGame.getFlowState();
    if (!flowState?.availableActions?.length || flowState.currentPlayer === undefined) {
      break;
    }


    const actionName = flowState.availableActions[
      Math.floor(Math.random() * flowState.availableActions.length)
    ];



    try {
      testGame.doAction(flowState.currentPlayer, actionName, {});
    } catch {

    }

    moves++;
  }

  return testGame;
}


















export function createMultiple<G extends Game>(
  GameClass: new (options: GameOptions) => G,
  configurations: TestGameOptions[]
): TestGame<G>[] {
  return configurations.map(config => TestGame.create(GameClass, config));
}
````

## File: packages/testing/src/random-simulation.ts
````typescript
import type { Game, GameOptions, FlowState } from '@boardsmith/engine';
import { createTestGame, type TestGame, type TestGameOptions } from './test-game.js';




export interface SimulateRandomGamesOptions {

  count: number;

  playerCounts: number[];

  timeout?: number;

  maxActions?: number;

  onGameComplete?: (result: SingleGameResult, progress: { completed: number; total: number }) => void;
}




export interface SingleGameResult {

  completed: boolean;

  crashed: boolean;

  timedOut: boolean;

  exceededMaxActions: boolean;

  error?: string;

  actionCount: number;

  duration: number;

  playerCount: number;

  seed: string;

  winners?: number[];
}




export interface SimulationResults {

  completed: number;

  crashed: number;

  timedOut: number;

  exceededMaxActions: number;

  total: number;

  games: SingleGameResult[];

  averageActions: number;

  averageDuration: number;

  errors: string[];
}




class SeededRandom {
  private seed: number;

  constructor(seed: string) {

    this.seed = 0;
    for (let i = 0; i < seed.length; i++) {
      this.seed = ((this.seed << 5) - this.seed + seed.charCodeAt(i)) | 0;
    }
  }

  next(): number {
    this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
    return this.seed / 0x7fffffff;
  }

  nextInt(max: number): number {
    return Math.floor(this.next() * max);
  }

  pick<T>(array: T[]): T {
    return array[this.nextInt(array.length)];
  }

  shuffle<T>(array: T[]): T[] {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = this.nextInt(i + 1);
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }
}




async function simulateSingleGame<G extends Game>(
  GameClass: new (options: GameOptions) => G,
  playerCount: number,
  seed: string,
  timeout: number,
  maxActions: number
): Promise<SingleGameResult> {
  const startTime = Date.now();
  const rng = new SeededRandom(seed);

  let testGame: TestGame<G>;
  let actionCount = 0;
  let timedOut = false;
  let exceededMaxActions = false;

  try {
    testGame = createTestGame(GameClass, {
      playerCount,
      seed,
      autoStart: true,
    });


    while (!testGame.isComplete()) {

      if (Date.now() - startTime > timeout) {
        timedOut = true;
        break;
      }


      if (actionCount >= maxActions) {
        exceededMaxActions = true;
        break;
      }


      if (!testGame.isAwaitingInput()) {

        break;
      }


      const flowState = testGame.getFlowState();
      if (!flowState) break;


      const currentPlayer = flowState.currentPlayer;
      if (currentPlayer === undefined) break;



      const player = testGame.getPlayer(currentPlayer);




      const possibleActions = getAvailableActions(testGame, currentPlayer);

      if (possibleActions.length === 0) {

        break;
      }

      const action = rng.pick(possibleActions);
      const result = testGame.doAction(currentPlayer, action.name, action.args);

      if (result.success) {
        actionCount++;
      } else {


      }
    }

    const duration = Date.now() - startTime;

    return {
      completed: testGame.isComplete(),
      crashed: false,
      timedOut,
      exceededMaxActions,
      actionCount,
      duration,
      playerCount,
      seed,
      winners: testGame.isComplete()
        ? testGame.getWinners().map(p => p.position)
        : undefined,
    };

  } catch (error) {
    return {
      completed: false,
      crashed: true,
      timedOut: false,
      exceededMaxActions: false,
      error: error instanceof Error ? error.message : String(error),
      actionCount,
      duration: Date.now() - startTime,
      playerCount,
      seed,
    };
  }
}





function getAvailableActions<G extends Game>(
  testGame: TestGame<G>,
  playerIndex: number
): Array<{ name: string; args: Record<string, unknown> }> {
  const flowState = testGame.getFlowState();
  if (!flowState) return [];


  const awaitingPlayers = flowState.awaitingPlayers;
  if (awaitingPlayers) {
    const playerState = awaitingPlayers[playerIndex];
    if (playerState?.availableActions) {

      return playerState.availableActions.map((name: string) => ({ name, args: {} }));
    }
  }

  return [];
}
















export async function simulateRandomGames<G extends Game>(
  GameClass: new (options: GameOptions) => G,
  options: SimulateRandomGamesOptions
): Promise<SimulationResults> {
  const {
    count,
    playerCounts,
    timeout = 5000,
    maxActions = 10000,
    onGameComplete,
  } = options;

  const games: SingleGameResult[] = [];
  const errors = new Set<string>();
  let total = 0;


  const gamesPerPlayerCount = Math.ceil(count / playerCounts.length);

  for (const playerCount of playerCounts) {
    for (let i = 0; i < gamesPerPlayerCount && total < count; i++) {
      const seed = `sim-${playerCount}-${i}-${Date.now()}`;

      const result = await simulateSingleGame(
        GameClass,
        playerCount,
        seed,
        timeout,
        maxActions
      );

      games.push(result);
      total++;

      if (result.error) {
        errors.add(result.error);
      }

      if (onGameComplete) {
        onGameComplete(result, { completed: total, total: count });
      }
    }
  }


  const completed = games.filter(g => g.completed).length;
  const crashed = games.filter(g => g.crashed).length;
  const timedOut = games.filter(g => g.timedOut).length;
  const exceededMaxActions = games.filter(g => g.exceededMaxActions).length;

  const completedGames = games.filter(g => g.completed);
  const averageActions = completedGames.length > 0
    ? completedGames.reduce((sum, g) => sum + g.actionCount, 0) / completedGames.length
    : 0;
  const averageDuration = completedGames.length > 0
    ? completedGames.reduce((sum, g) => sum + g.duration, 0) / completedGames.length
    : 0;

  return {
    completed,
    crashed,
    timedOut,
    exceededMaxActions,
    total,
    games,
    averageActions,
    averageDuration,
    errors: [...errors],
  };
}
````

## File: packages/testing/src/simulate-action.ts
````typescript
import type { Game } from '@boardsmith/engine';
import type { TestGame } from './test-game.js';
import type { ActionExecutionResult } from '@boardsmith/runtime';




export interface SimulateActionResult extends ActionExecutionResult {

  action: string;

  playerIndex: number;

  args: Record<string, unknown>;
}














export function simulateAction<G extends Game>(
  testGame: TestGame<G>,
  playerIndex: number,
  actionName: string,
  args: Record<string, unknown> = {}
): SimulateActionResult {
  const result = testGame.doAction(playerIndex, actionName, args);

  return {
    ...result,
    action: actionName,
    playerIndex,
    args,
  };
}














export function simulateActions<G extends Game>(
  testGame: TestGame<G>,
  actions: Array<[playerIndex: number, actionName: string, args?: Record<string, unknown>]>
): SimulateActionResult[] {
  return actions.map(([playerIndex, actionName, args]) =>
    simulateAction(testGame, playerIndex, actionName, args ?? {})
  );
}





export function assertActionSucceeds<G extends Game>(
  testGame: TestGame<G>,
  playerIndex: number,
  actionName: string,
  args: Record<string, unknown> = {}
): SimulateActionResult {
  const result = simulateAction(testGame, playerIndex, actionName, args);

  if (!result.success) {
    throw new Error(
      `Expected action '${actionName}' by player ${playerIndex} to succeed, but it failed: ${result.error}`
    );
  }

  return result;
}





export function assertActionFails<G extends Game>(
  testGame: TestGame<G>,
  playerIndex: number,
  actionName: string,
  args: Record<string, unknown> = {},
  expectedError?: string | RegExp
): SimulateActionResult {
  const result = simulateAction(testGame, playerIndex, actionName, args);

  if (result.success) {
    throw new Error(
      `Expected action '${actionName}' by player ${playerIndex} to fail, but it succeeded`
    );
  }

  if (expectedError) {
    const errorMatches = typeof expectedError === 'string'
      ? result.error?.includes(expectedError)
      : expectedError.test(result.error ?? '');

    if (!errorMatches) {
      throw new Error(
        `Expected error to match ${expectedError}, but got: ${result.error}`
      );
    }
  }

  return result;
}
````

## File: packages/testing/src/test-game.ts
````typescript
import {
  Game,
  type GameOptions,
  type FlowState,
  type Player,
} from '@boardsmith/engine';
import { GameRunner, type ActionExecutionResult } from '@boardsmith/runtime';




export interface TestGameOptions {

  playerCount: number;

  playerNames?: string[];

  seed?: string;

  autoStart?: boolean;
}




export class TestGame<G extends Game = Game> {
  readonly runner: GameRunner<G>;
  readonly game: G;

  private constructor(runner: GameRunner<G>) {
    this.runner = runner;
    this.game = runner.game;
  }




  static create<G extends Game>(
    GameClass: new (options: GameOptions) => G,
    options: TestGameOptions
  ): TestGame<G> {
    const seed = options.seed ?? `test-${Date.now()}`;
    const playerNames = options.playerNames ??
      Array.from({ length: options.playerCount }, (_, i) => `Player ${i + 1}`);

    const runner = new GameRunner({
      GameClass,
      gameType: GameClass.name.toLowerCase(),
      gameOptions: {
        playerCount: options.playerCount,
        playerNames,
        seed,
      },
    });

    const testGame = new TestGame(runner);

    if (options.autoStart !== false) {
      testGame.start();
    }

    return testGame;
  }




  start(): FlowState {
    return this.runner.start();
  }




  getFlowState(): FlowState | undefined {
    return this.runner.getFlowState();
  }




  isComplete(): boolean {
    return this.runner.isComplete();
  }




  isAwaitingInput(): boolean {
    return this.game.isAwaitingInput();
  }




  getCurrentPlayer(): Player | undefined {
    const flowState = this.getFlowState();
    if (flowState?.currentPlayer !== undefined) {
      return this.game.players[flowState.currentPlayer];
    }
    return undefined;
  }




  getPlayers(): Player[] {
    return [...this.game.players];
  }




  getPlayer(index: number): Player {
    const player = this.game.players[index];
    if (!player) {
      throw new Error(`Player ${index} not found`);
    }
    return player;
  }




  doAction(
    playerIndex: number,
    actionName: string,
    args: Record<string, unknown> = {}
  ): ActionExecutionResult {
    return this.runner.performAction(actionName, playerIndex, args);
  }




  getWinners(): Player[] {
    return this.runner.getWinners();
  }




  getActionHistory() {
    return [...this.runner.actionHistory];
  }




  getSnapshot() {
    return this.runner.getSnapshot();
  }




  getPlayerView(playerIndex: number) {
    return this.runner.getPlayerView(playerIndex);
  }
}





export function createTestGame<G extends Game>(
  GameClass: new (options: GameOptions) => G,
  options: TestGameOptions
): TestGame<G> {
  return TestGame.create(GameClass, options);
}
````

## File: docs/dice-and-scoring.md
````markdown
# Dice & Scoring Systems

BoardSmith provides comprehensive support for dice games and roll-and-write style scoring. This document covers the engine's dice elements, 3D dice rendering, ability management, and scoring track systems.

## Dice Elements

### Die

The base `Die` class extends `Piece` with dice-specific properties:

```typescript
import { Die } from '@boardsmith/engine';

class MyDie extends Die<MyGame, MyPlayer> {
  // Inherited properties:
  // sides: number - Number of faces (4, 6, 8, 10, 12, 20)
  // value: number - Current face value

  // Add custom properties
  color?: 'red' | 'blue' | 'green';
}
```

#### Die Sides

The engine supports standard polyhedral dice:

| Type | Geometry | Values |
|------|----------|--------|
| D4 | Tetrahedron | 1-4 |
| D6 | Cube | 1-6 |
| D8 | Octahedron | 1-8 |
| D10 | Trapezohedron | 0-9 or 1-10 |
| D12 | Dodecahedron | 1-12 |
| D20 | Icosahedron | 1-20 |

### DicePool

A `DicePool` is a `Space` designed to hold multiple dice:

```typescript
import { DicePool, Die } from '@boardsmith/engine';

class MyGame extends Game<MyGame, MyPlayer> {
  shelf!: DicePool;

  constructor(options: GameOptions) {
    super(options);

    this.registerElements([DicePool, MyDie]);

    // Create the dice pool
    this.shelf = this.create(DicePool, 'shelf');

    // Create dice inside the pool
    this.shelf.create(MyDie, 'd6-1', { sides: 6 });
    this.shelf.create(MyDie, 'd6-2', { sides: 6 });
    this.shelf.create(MyDie, 'd8-1', { sides: 8 });
  }
}
```

### Rolling Dice

Dice are rolled by setting their values randomly:

```typescript
const rollAction = Action.create('roll')
  .prompt('Roll all dice')
  .execute((args, ctx) => {
    const dice = ctx.game.shelf.all(MyDie);
    for (const die of dice) {
      die.value = Math.floor(Math.random() * die.sides) + 1;
    }
  });
```

For D10s that can show 0:
```typescript
// D10 can be 0-9 or 1-10 depending on game rules
die.value = Math.floor(Math.random() * 10);  // 0-9
die.value = Math.floor(Math.random() * 10) + 1;  // 1-10
```

## 3D Dice UI

The `@boardsmith/ui` package includes a WebGL-based 3D dice renderer that displays accurate polyhedral geometry with smooth roll animations.

### Die3D Component

```vue
<script setup lang="ts">
import { Die3D } from '@boardsmith/ui';

const props = defineProps<{
  die: {
    id: string;
    sides: number;
    value: number;
  };
}>();
</script>

<template>
  <Die3D
    :die-id="die.id"
    :sides="die.sides"
    :value="die.value"
    :size="80"
    style="--die-color: #2196F3"
  />
</template>
```

#### Props

| Prop | Type | Description |
|------|------|-------------|
| `dieId` | `string` | Unique identifier for the die |
| `sides` | `4 \| 6 \| 8 \| 10 \| 12 \| 20` | Number of faces |
| `value` | `number` | Current face value to display |
| `size` | `number` | Size in pixels (default: 60) |

#### CSS Custom Properties

Style dice using CSS variables:

```css
.my-die {
  --die-color: #FF5722;           /* Face color */
  --die-pip-color: #FFFFFF;       /* Number/pip color */
  --die-edge-color: #333333;      /* Edge color */
}
```

### Roll Animations

The Die3D component automatically animates when the value changes:

```typescript
// In your game board component
watch(() => props.gameView.dice, (newDice) => {
  // Die3D components will automatically animate to new values
}, { deep: true });
```

### Zoom Preview

Enable Alt+hover zoom by adding `data-die-preview` attribute:

```vue
<template>
  <div
    class="die-slot"
    :data-die-preview="JSON.stringify({ sides: die.sides, value: die.value })"
  >
    <Die3D :die-id="die.id" :sides="die.sides" :value="die.value" />
  </div>
</template>
```

The zoom preview provides a larger, centered view of the die for accessibility.

## Ability System

The `AbilityManager` provides a reusable system for games where players earn and use special abilities/powers. Common in dice games with unlockable abilities.

### Basic Usage

```typescript
import { AbilityManager, Player } from '@boardsmith/engine';

// Define your ability types
type MyAbility = 'reroll' | 'flip' | 'bonus' | 'skip';

class MyPlayer extends Player<MyGame, MyPlayer> {
  abilities = new AbilityManager<MyAbility>();

  constructor(position: number, name: string) {
    super(position, name);
    // Give each player a starting ability
    this.abilities.add('reroll', 'starting');
  }

  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      abilities: this.abilities.toJSON(),
    };
  }
}
```

### AbilityManager API

```typescript
const abilities = new AbilityManager<MyAbility>();

// Adding abilities
abilities.add('reroll');                    // Add an ability
abilities.add('reroll', 'from-track');      // With source description

// Checking abilities
abilities.hasUnused('reroll');              // Has unused ability?
abilities.has('reroll');                    // Has any (used or unused)?
abilities.countUnused('reroll');            // Count unused of type
abilities.countAllUnused();                 // Total unused count

// Using abilities
if (abilities.hasUnused('reroll')) {
  abilities.use('reroll');                  // Marks one as used
}

// Querying
abilities.getAll();                         // All abilities
abilities.getUnused();                      // Only unused
abilities.getUsed();                        // Only used
abilities.getTypes();                       // Unique types ['reroll', 'flip']
abilities.getGrouped();                     // [{ type, total, unused }]

// Management
abilities.resetAll();                       // Reset all to unused
abilities.clear();                          // Remove all

// Serialization
const data = abilities.toJSON();
abilities.fromJSON(data);
AbilityManager.fromJSON(data);              // Static factory
```

## Scoring Tracks

BoardSmith provides abstract track classes for dice/roll-and-write games where players record values on scoring sheets.

### Track Types

| Class | Use Case | Example |
|-------|----------|---------|
| `Track` | Base class | - |
| `MonotonicTrack` | Increasing or decreasing sequences | Distillation, Fulminate |
| `UniqueTrack` | No duplicate values allowed | Yahtzee upper section |
| `CounterTrack` | Simple count/tally | Poison skulls, bonus boxes |

### MonotonicTrack

For tracks where values must increase or decrease:

```typescript
import { MonotonicTrack } from '@boardsmith/engine';

// Increasing track (values must go up)
const fulminateTrack = new MonotonicTrack({
  id: 'fulminate',
  name: 'Fulminate',
  direction: 'increasing',
  maxEntries: 10,
  pointsPerEntry: [0, 1, 3, 6, 11, 16, 23, 30, 40, 50],
  completionBonus: 65,
});

// Decreasing track (values must go down)
const distillTrack = new MonotonicTrack({
  id: 'distill-1',
  name: 'Distillation Column 1',
  direction: 'decreasing',
  maxEntries: 5,
  pointsPerEntry: [0, -10, -5, -2, 10],
  completionBonus: 25,
  allowSpecialEntries: true,  // Special entries can equal previous
});
```

#### API

```typescript
// Check if a value can be added
track.canAdd(15);                    // Returns true/false
track.canAdd(15, isSpecial);         // With special entry flag

// Add a value (returns points earned)
const points = track.add(15);

// Query state
track.getEntries();                  // [{ value, points, special }]
track.isEmpty();
track.isComplete();
track.calculatePoints();             // Total including completion bonus

// Serialization
const data = track.toJSON();
track.fromJSON(data);
```

### UniqueTrack

For tracks where each value can only appear once:

```typescript
import { UniqueTrack } from '@boardsmith/engine';

const upperSection = new UniqueTrack({
  id: 'ones',
  name: 'Ones',
  maxEntries: 1,
  pointsPerEntry: (value) => value,  // Function-based points
});

// Will reject if value already used
upperSection.canAdd(3);  // true (first time)
upperSection.add(3);
upperSection.canAdd(3);  // false (already used)
```

### CounterTrack

For simple counting/tallying:

```typescript
import { CounterTrack } from '@boardsmith/engine';

const poisonTrack = new CounterTrack({
  id: 'poison',
  name: 'Poison',
  maxEntries: 6,
  pointsPerCount: 2,       // 2 points per mark
  completionBonus: 10,     // Bonus for filling all 6
});

// Increment the counter
poisonTrack.increment();
poisonTrack.increment();

// Query
poisonTrack.count;         // 2
poisonTrack.isComplete();  // false
poisonTrack.calculatePoints();  // 4 (2 * 2)
```

## Example: Dice Game Player

Here's a complete example combining dice, abilities, and tracks:

```typescript
import {
  Player,
  AbilityManager,
  MonotonicTrack,
  CounterTrack
} from '@boardsmith/engine';

type PowerUp = 'reroll-2' | 'flip' | 'refresh' | 'adjust';

class DiceGamePlayer extends Player<DiceGame, DiceGamePlayer> {
  abilities: AbilityManager<PowerUp>;
  scoreTrack: MonotonicTrack;
  bonusTrack: CounterTrack;

  constructor(position: number, name: string) {
    super(position, name);

    // Initialize ability manager
    this.abilities = new AbilityManager<PowerUp>();
    this.abilities.add('reroll-2', 'starting');

    // Initialize scoring tracks
    this.scoreTrack = new MonotonicTrack({
      id: 'score',
      name: 'Score',
      direction: 'increasing',
      maxEntries: 10,
      pointsPerEntry: [1, 2, 3, 5, 8, 13, 21, 34, 55, 89],
    });

    this.bonusTrack = new CounterTrack({
      id: 'bonus',
      name: 'Bonus Stars',
      maxEntries: 5,
      pointsPerCount: 10,
    });
  }

  get totalScore(): number {
    return this.scoreTrack.calculatePoints() + this.bonusTrack.calculatePoints();
  }

  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      totalScore: this.totalScore,
      abilities: this.abilities.toJSON(),
      scoreTrack: this.scoreTrack.toJSON(),
      bonusTrack: this.bonusTrack.toJSON(),
    };
  }
}
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Element tree and game structure
- [UI Components](./ui-components.md) - Vue components and composables
- [Actions & Flow](./actions-and-flow.md) - Building game actions
- [Game Examples](./game-examples.md) - Complete game implementations
````

## File: docs/game-examples.md
````markdown
# Game Examples & Patterns

This document analyzes the example games in `packages/games/` to demonstrate common patterns and best practices.

## Example Games Overview

| Game | Location | Complexity | Key Patterns |
|------|----------|-----------|--------------|
| Hex | `packages/games/hex/` | Simple | Hex grid, path-finding, simple flow |
| Go Fish | `packages/games/go-fish/` | Medium | Cards, hidden info, conditional turns |
| Checkers | `packages/games/checkers/` | Medium | Square grid, multi-step actions, piece promotion |
| Cribbage | `packages/games/cribbage/` | Complex | Multi-phase, simultaneous actions, complex scoring |

---

## Hex - Simplest Example

**Location**: `packages/games/hex/`

Hex is the simplest example, demonstrating core patterns with minimal complexity.

### Key Features
- Hex grid board
- Simple alternating turns
- Path-finding win condition
- Single action type

### Game Structure

```typescript
// game.ts
export class HexGame extends Game<HexGame, HexPlayer> {
  board!: Board;
  winner?: HexPlayer;

  constructor(options: HexOptions) {
    super(options);

    // Register elements
    this.registerElements([Board, Cell, Stone]);

    // Create hex board
    this.board = this.create(Board, 'board', { boardSize: 7 });
    for (let r = 0; r < 7; r++) {
      for (let q = 0; q < 7; q++) {
        this.board.create(Cell, `cell-${q}-${r}`, { q, r });
      }
    }

    // Single action
    this.registerAction(createPlaceStoneAction(this));
    this.setFlow(createHexFlow(this));
  }
}
```

### Simple Flow

```typescript
// flow.ts
export function createHexFlow(game: HexGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: actionStep({
          actions: ['placeStone'],
          skipIf: () => game.isFinished(),
        }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.winner ? [game.winner] : [],
  };
}
```

### Element with Board Reference

```typescript
// actions.ts
Action.create('placeStone')
  .chooseElement<Cell>('cell', {
    filter: (cell) => cell.isEmpty(),
    boardRef: (cell) => ({
      id: cell.id,
      notation: cell.notation,
    }),
  })
  .execute((args, ctx) => {
    const cell = args.cell as Cell;
    cell.create(Stone, `stone-${player.position}`, { player });

    // Check win condition
    if (game.board.checkWin(player)) {
      game.setWinner(player);
    }
  });
```

### Pattern: Custom Element Classes

```typescript
// elements.ts
export class Cell extends HexCell {
  q!: number;
  r!: number;

  get notation(): string {
    return `${String.fromCharCode(97 + this.q)}${this.r + 1}`;
  }

  isEmpty(): boolean {
    return this.count(Stone) === 0;
  }
}
```

---

## Go Fish - Card Game Patterns

**Location**: `packages/games/go-fish/`

Go Fish demonstrates card game patterns including hidden information and conditional turns.

### Key Features
- Standard deck creation
- Private hands with visibility
- Player interaction (asking)
- Conditional turns (go again if match)
- Book collection

### Hidden Information

```typescript
// game.ts
constructor(options) {
  // Create player hands - hidden from other players
  for (const player of this.players) {
    const hand = this.create(Hand, `hand-${player.position}`);
    hand.player = player;
    hand.contentsVisibleToOwner();  // Only owner sees their cards
  }

  // The pond (draw pile) - hidden
  this.pond = this.create(Pond, 'pond');
  this.pond.contentsHidden();
}
```

### Conditional Turns (Extra Turn Logic)

```typescript
// flow.ts - Turn loop with extra turns
const playerTurn = sequence(
  setVar('extraTurn', false),
  setVar('turnEnded', false),

  loop({
    name: 'turn-loop',
    while: (ctx) => {
      if (ctx.get('turnEnded')) return false;
      // ... other conditions
      return true;
    },
    do: sequence(
      actionStep({ actions: ['ask'] }),
      execute((ctx) => {
        const extraTurn = ctx.lastActionResult?.data?.extraTurn;
        if (!extraTurn) {
          ctx.set('turnEnded', true);
        }
      }),
    ),
  }),
);
```

### Action with Extra Turn Signal

```typescript
// actions.ts
.execute((args, ctx) => {
  const matchingCards = target.hand.all(Card).filter(c => c.rank === rank);

  if (matchingCards.length > 0) {
    for (const card of matchingCards) {
      card.putInto(player.hand);
    }
    // Signal extra turn
    return { success: true, data: { extraTurn: true } };
  } else {
    game.drawFromPond(player);
    return { success: true, data: { extraTurn: false } };
  }
});
```

### Pattern: Book/Set Collection

```typescript
// game.ts
checkForBooks(player: GoFishPlayer): void {
  const hand = this.getPlayerHand(player);
  const cards = hand.all(Card);

  // Count cards by rank
  const rankCounts = new Map<string, Card[]>();
  for (const card of cards) {
    const existing = rankCounts.get(card.rank) || [];
    existing.push(card);
    rankCounts.set(card.rank, existing);
  }

  // Create books for complete sets
  for (const [rank, rankCards] of rankCounts) {
    if (rankCards.length === 4) {
      const book = this.books.create(Book, `book-${rank}`, { rank, player });
      for (const card of rankCards) {
        card.putInto(book);
      }
      player.score++;
    }
  }
}
```

---

## Checkers - Grid & Multi-Step Actions

**Location**: `packages/games/checkers/`

Checkers demonstrates square grids, forced moves, and multi-step actions.

### Key Features
- 8x8 square grid
- Jump chains (multi-step moves)
- Forced jump rule
- Piece promotion (kings)

### Grid Setup

```typescript
// game.ts
constructor(options) {
  this.board = this.create(Board, 'board');
  this.board.contentsVisible();

  // Create 8x8 grid
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const cell = this.board.create(Cell, `cell-${col}-${row}`, {
        col, row,
        isPlayable: (row + col) % 2 === 1,  // Dark squares only
      });
    }
  }

  // Place initial pieces
  this.setupInitialPieces();
}
```

### Multi-Step Action (Jump Chain)

```typescript
// actions.ts - Handling jump chains
Action.create('move')
  .chooseElement<Piece>('piece', {
    filter: (piece, ctx) => {
      const game = ctx.game as CheckersGame;
      // If there's a pending jump, only that piece can continue
      if (game.pendingJumpPiece) {
        return piece === game.pendingJumpPiece;
      }
      return piece.player === ctx.player && game.hasValidMoves(piece);
    },
  })
  .chooseElement<Cell>('destination', {
    filter: (cell, ctx) => {
      const piece = ctx.args.piece as Piece;
      return game.isValidMove(piece, cell);
    },
  })
  .execute((args, ctx) => {
    const piece = args.piece as Piece;
    const dest = args.destination as Cell;

    const isJump = game.isJumpMove(piece, dest);
    piece.putInto(dest);

    if (isJump) {
      game.captureJumpedPiece(piece, dest);

      // Check for additional jumps
      if (game.canContinueJumping(piece)) {
        game.pendingJumpPiece = piece;
        game.setPlayerGoesAgain(true);
      } else {
        game.pendingJumpPiece = null;
      }
    }

    // Check for promotion
    if (game.shouldPromote(piece)) {
      piece.isKing = true;
    }
  });
```

### Forced Move Logic

```typescript
// game.ts
getValidMoves(player: CheckersPlayer): Move[] {
  const pieces = this.board.all(Piece).filter(p => p.player === player);

  // Check for forced jumps
  const jumpMoves = [];
  for (const piece of pieces) {
    jumpMoves.push(...this.getJumpMoves(piece));
  }

  // If jumps available, must take one
  if (jumpMoves.length > 0) {
    return jumpMoves;
  }

  // Otherwise, regular moves
  return pieces.flatMap(p => this.getRegularMoves(p));
}
```

---

## Cribbage - Complex Multi-Phase Game

**Location**: `packages/games/cribbage/`

Cribbage is the most complex example, demonstrating multi-phase flow, simultaneous actions, and complex scoring.

### Key Features
- Multi-phase rounds (deal, discard, play, show)
- Simultaneous actions (both players discard at once)
- Complex scoring logic
- Running count during play
- "Go" mechanics

### Multi-Phase Flow

```typescript
// flow.ts
const playRound = sequence(
  // Initialize round
  execute((ctx) => game.startNewRound()),

  // Discard phase - simultaneous
  phase('discarding', {
    do: simultaneousActionStep({
      actions: ['discard'],
      prompt: 'Discard 2 cards to the crib',
      playerDone: (ctx, player) => {
        const hand = game.getPlayerHand(player);
        return hand.count(Card) <= 4;  // Done when 4 cards left
      },
      allDone: (ctx) => game.allPlayersDiscarded(),
    }),
  }),

  // Store hands before play
  execute(() => game.storeOriginalHands()),

  // Cut starter
  execute(() => game.cutStarterCard()),

  // Play phase - alternating turns
  phase('play', { do: playPhaseSequence }),

  // Scoring phase
  phase('scoring', {
    do: sequence(
      execute(() => game.scoreRoundAndBuildSummary()),
      simultaneousActionStep({
        actions: ['acknowledgeScore'],
        allDone: () => !game.roundSummary.active,
      }),
    ),
  }),

  // Rotate dealer
  execute(() => game.rotateDealer()),
);
```

### Simultaneous Actions

```typescript
// Both players discard at the same time
simultaneousActionStep({
  name: 'simultaneous-discard',
  actions: ['discard'],
  prompt: 'Discard 2 cards to the crib',
  playerDone: (ctx, player) => {
    const hand = game.getPlayerHand(player as CribbagePlayer);
    return hand.count(Card) <= 4;
  },
  allDone: (ctx) => {
    return game.allPlayersDiscarded() || game.isFinished();
  },
});
```

### Phase Lifecycle Hooks

```typescript
// flow.ts
return {
  root: /* ... */,
  isComplete: /* ... */,
  getWinners: /* ... */,

  // Phase lifecycle hooks
  onEnterPhase: (phaseName, ctx) => {
    const game = ctx.game as CribbageGame;
    game.cribbagePhase = phaseName;

    const phaseNames = {
      discarding: 'DISCARD PHASE',
      play: 'PLAY PHASE',
      scoring: 'SCORING PHASE',
    };
    game.message(`=== ${phaseNames[phaseName]} ===`);
  },
};
```

### Complex Play Phase with Go

```typescript
// Play phase loop with "Go" mechanics
loop({
  name: 'play-loop',
  while: () => !game.allCardsPlayed() && !game.isFinished(),
  do: sequence(
    // Check if count needs reset
    execute(() => {
      const currentStuck = currentSaidGo || !currentCanPlay;
      const otherStuck = otherSaidGo || !otherCanPlay;

      if (currentStuck && otherStuck && (hasCards)) {
        // Award "Go" point
        if (game.runningTotal < 31) {
          game.addPoints(lastPlayer, 1, 'Go');
        }
        game.resetCount();
      }
    }),

    // Player plays or says Go
    actionStep({
      player: () => game.getCurrentPlayPlayer(),
      actions: ['playCard', 'sayGo'],
      skipIf: () => playerAlreadySaidGo || !hasCards,
    }),

    // Switch turns
    execute(() => {
      if (!otherSaidGo && otherHasCards) {
        game.switchPlayTurn();
      }
    }),
  ),
});
```

### Scoring System

```typescript
// scoring.ts - Complex scoring calculation
export function scoreHand(cards: Card[], starter: Card, isCrib: boolean): ScoreBreakdown {
  const allFive = [...cards, starter];
  const breakdown: ScoreBreakdown = { fifteens: 0, pairs: 0, runs: 0, flush: 0, nobs: 0 };

  // Score 15s (combinations summing to 15)
  breakdown.fifteens = scoreFifteens(allFive);

  // Score pairs
  breakdown.pairs = scorePairs(allFive);

  // Score runs (sequences)
  breakdown.runs = scoreRuns(allFive);

  // Score flush (requires 4 in hand, or 5 total for crib)
  breakdown.flush = scoreFlush(cards, starter, isCrib);

  // Score nobs (Jack of starter suit)
  breakdown.nobs = scoreNobs(cards, starter);

  return breakdown;
}
```

---

## Common Patterns Summary

### 1. Game Initialization

```typescript
constructor(options) {
  super(options);
  this.registerElements([...]);  // Always register elements
  // Create board/deck
  // Register actions
  this.setFlow(createGameFlow(this));
}
```

### 2. Custom Player Classes

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  hand!: Hand;
  score: number = 0;
  abilities: Record<string, number> = {};

  constructor(position: number, name: string, game: MyGame) {
    super(position, name);
    this.game = game;
    this.hand = game.create(Hand, `hand-${position}`);
    this.hand.player = this;
  }

  // Required to send custom properties to the UI
  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      score: this.score,
      abilities: this.abilities,
    };
  }
}
```

> **Note**: Always override `toJSON()` if you have custom properties that the UI needs to display (scores, abilities, etc.). See [Core Concepts - Serialization](./core-concepts.md#playercollection-serialization-warning) for details.

### 3. Win Condition Checking

```typescript
override isFinished(): boolean {
  return this.winner !== undefined || /* other condition */;
}

override getWinners(): MyPlayer[] {
  if (!this.isFinished()) return [];
  return this.winner ? [this.winner] : [];
}
```

### 4. Action Result Data

```typescript
.execute((args, ctx) => {
  // ... game logic ...
  return {
    success: true,
    message: 'Action completed',
    data: {
      extraTurn: shouldGoAgain,  // Can be read by flow
      customData: 'anything',
    },
  };
});
```

### 5. Flow Variables

```typescript
sequence(
  setVar('roundNumber', 1),
  loop({
    while: (ctx) => ctx.get('roundNumber') <= 10,
    do: sequence(
      /* round logic */,
      execute((ctx) => ctx.set('roundNumber', ctx.get('roundNumber') + 1)),
    ),
  }),
)
```

### 6. Visibility Control

```typescript
// Hidden from everyone
deck.contentsHidden();

// Visible to everyone
board.contentsVisible();

// Only owner sees
hand.contentsVisibleToOwner();
```

## Related Documentation

- [Getting Started](./getting-started.md) - Create your first game
- [Core Concepts](./core-concepts.md) - Element tree, visibility, state
- [Actions & Flow](./actions-and-flow.md) - Action and flow API details
````

## File: docs/getting-started.md
````markdown
# Getting Started with BoardSmith

BoardSmith is a TypeScript framework for building turn-based board and card games with built-in multiplayer support, AI opponents, and automatic UI generation.

## Prerequisites

- Node.js 20+
- npm, pnpm, or yarn

## Quick Start

### 1. Create a New Game Project

```bash
npx boardsmith init my-game
cd my-game
npm install
```

This creates a new game project with the following structure:

```
my-game/
 boardsmith.json          # Game configuration
 package.json             # Dependencies
 tsconfig.json            # TypeScript config
 vite.config.ts           # Vite bundler config
 index.html               # Entry HTML
 public/                  # Static assets
 src/
    main.ts              # App entry point
    rules/               # Game logic
       game.ts          # Main Game class
       elements.ts      # Custom element classes
       actions.ts       # Player action definitions
       flow.ts          # Game flow definition
       index.ts         # Exports
    ui/                  # Vue UI components
        App.vue          # Main app component
        components/      # Custom components
           GameBoard.vue
        index.ts         # UI exports
 tests/
     game.test.ts         # Game tests
```

### 2. Start Development Server

```bash
boardsmith dev
```

This starts:
- A Vite dev server on port 5173 (UI)
- A game server on port 8787 (API/WebSocket)
- Automatically opens browser tabs for each player

#### Dev Server Options

```bash
# Specify number of players
boardsmith dev --players 3

# Add AI opponents
boardsmith dev --ai 1              # Player 1 is AI
boardsmith dev --ai 0 2            # Players 0 and 2 are AI

# Set AI difficulty
boardsmith dev --ai 1 --ai-level hard    # easy, medium, hard, expert

# Custom ports
boardsmith dev --port 3000 --worker-port 9000
```

### 3. Run Tests

```bash
boardsmith test           # Run once
boardsmith test --watch   # Watch mode
```

### 4. Validate Before Publishing

```bash
boardsmith validate
```

This runs:
- TypeScript compilation checks
- Configuration validation
- Random game simulation to detect infinite loops or game-ending bugs

### 5. Build for Production

```bash
boardsmith build
```

### 6. Publish to boardsmith.io

```bash
boardsmith publish
```

## Understanding the Generated Code

### Game Configuration (boardsmith.json)

```json
{
  "$schema": "https://boardsmith.io/schemas/game.json",
  "name": "my-game",
  "displayName": "My Game",
  "description": "A fun game for 2-4 players",
  "playerCount": { "min": 2, "max": 4 },
  "estimatedDuration": "15-30 minutes",
  "complexity": 2,
  "categories": ["card-game"],
  "thumbnail": "./public/thumbnail.png",
  "scoreboard": { "stats": ["score"] }
}
```

### Game Class (src/rules/game.ts)

The Game class is the heart of your game. It:
- Extends `Game<YourGame, YourPlayer>`
- Registers element classes
- Creates the initial game state (deck, board, etc.)
- Registers actions players can take
- Defines the game flow

```typescript
export class MyGame extends Game<MyGame, MyPlayer> {
  deck!: Deck;

  constructor(options: MyGameOptions) {
    super(options);

    // Register element classes (required for serialization)
    this.registerElements([Card, Hand, Deck]);

    // Create game elements
    this.deck = this.create(Deck, 'deck');

    // Set up initial state
    this.deck.shuffle();
    for (const player of this.players) {
      // Deal cards...
    }

    // Register player actions
    this.registerAction(createDrawAction(this));
    this.registerAction(createPlayAction(this));

    // Set up game flow
    this.setFlow(createGameFlow(this));
  }

  override isFinished(): boolean {
    return this.deck.count(Card) === 0;
  }

  override getWinners(): MyPlayer[] {
    // Return winning player(s)
  }
}
```

### Element Classes (src/rules/elements.ts)

Elements are the building blocks of your game state. BoardSmith provides base classes:

- **Space** - Containers that hold other elements
  - **Deck** - Stackable card pile (can shuffle)
  - **Hand** - Player's private cards
  - **Grid** - Square grid (e.g., chess board)
  - **HexGrid** - Hexagonal grid
- **Piece** - Physical game pieces
- **Card** - Playing cards

```typescript
import { Card as BaseCard, Hand as BaseHand, Deck as BaseDeck } from '@boardsmith/engine';

export type Suit = 'H' | 'D' | 'C' | 'S';
export type Rank = 'A' | '2' | '3' | ... | 'K';

export class Card extends BaseCard {
  suit!: Suit;
  rank!: Rank;
}

export class Hand extends BaseHand {}
export class Deck extends BaseDeck {}
```

### Actions (src/rules/actions.ts)

Actions define what players can do. Use the fluent builder API:

```typescript
import { Action, type ActionDefinition } from '@boardsmith/engine';

export function createPlayAction(game: MyGame): ActionDefinition {
  return Action.create('play')
    .prompt('Play a card from your hand')
    .chooseFrom<Card>('card', {
      prompt: 'Select a card to play',
      choices: (ctx) => [...ctx.player.hand.all(Card)],
    })
    .execute((args, ctx) => {
      const card = args.card as Card;
      card.remove();
      ctx.player.score += 1;
      return { success: true };
    });
}
```

### Flow (src/rules/flow.ts)

The flow defines turn structure and game phases:

```typescript
import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from '@boardsmith/engine';

export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: eachPlayer({
        name: 'player-turns',
        do: sequence(
          actionStep({ actions: ['draw'] }),
          actionStep({ actions: ['play'] }),
        ),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### UI (src/ui/App.vue)

The UI uses Vue 3 and the `@boardsmith/ui` package:

```vue
<template>
  <GameShell
    game-type="my-game"
    display-name="My Game"
    :player-count="2"
  >
    <template #game-board="{ gameView, playerPosition, isMyTurn, availableActions, action }">
      <GameBoard
        :game-view="gameView"
        :player-position="playerPosition"
        :is-my-turn="isMyTurn"
        :available-actions="availableActions"
        :action="action"
      />
    </template>
  </GameShell>
</template>
```

## Important: Read Before You Start

Before diving into implementation, read [Common Pitfalls](./common-pitfalls.md) to avoid these critical issues:

1. **Object Reference Comparison** - Never use `.includes(element)` or `===` to compare elements. Always use `.some(e => e.id === element.id)` or `element.equals(other)`.

2. **Multi-Step Selection Filters** - When action B depends on selection A, handle `undefined` in your filter for availability checks.

3. **Dead Elements in Collections** - Element queries return all elements including "dead" ones. Filter explicitly with `.filter(e => !e.isDead)`.

These issues cause silent failures that are hard to debug. Five minutes reading the pitfalls guide will save hours of debugging.

## Next Steps

- **Start here**: [Common Pitfalls](./common-pitfalls.md) - Critical issues to avoid
- Read [Core Concepts](./core-concepts.md) to understand elements, actions, and commands
- Learn about [Actions & Flow](./actions-and-flow.md) for complex game logic
- Explore [UI Components](./ui-components.md) for building custom UIs
- See [Game Examples](./game-examples.md) for real implementations

## Example Games

BoardSmith includes several example games in `packages/games/`:

| Game | Complexity | Key Features |
|------|-----------|--------------|
| **Hex** | Simple | Hex grid, path-finding win condition |
| **Go Fish** | Medium | Cards, hidden information, player interaction |
| **Checkers** | Medium | Square grid, multi-step moves, piece promotion |
| **Cribbage** | Complex | Multi-phase flow, simultaneous actions, scoring |

Study these to learn common patterns and best practices.
````

## File: docs/README.md
````markdown
# BoardSmith Documentation

This folder contains documentation for the BoardSmith game framework.

## Documents

| Document | Description |
|----------|-------------|
| [Getting Started](./getting-started.md) | CLI setup, project creation, and basic development |
| [Core Concepts](./core-concepts.md) | Element tree, visibility, actions vs commands |
| [Actions & Flow](./actions-and-flow.md) | Action builder API and declarative flow system |
| [Dice & Scoring](./dice-and-scoring.md) | Dice elements, 3D rendering, abilities, and scoring tracks |
| [UI Components](./ui-components.md) | Vue components and composables |
| [AI System](./ai-system.md) | MCTS bot and AI integration |
| [Game Examples](./game-examples.md) | Analysis of example games with patterns |
| [LLM Overview](./llm-overview.md) | Quick-reference for LLMs |

## For LLMs

If you're an AI assistant reading this codebase:

1. **Start with** [`llm-overview.md`](./llm-overview.md) for a comprehensive summary
2. **Simplest example**: `packages/games/hex/` - minimal but complete game
3. **Complex example**: `packages/games/cribbage/` - multi-phase, simultaneous actions

## Generated LLM Context

The repository includes a `repomix.config.json` that generates `llms.txt` - a single file containing the entire relevant codebase optimized for LLM consumption.

To regenerate:
```bash
npx repomix
```

This produces a ~750KB file with:
- All documentation
- Core engine code
- Example game implementations
- CLI tools
- Excludes tests, type declarations, and node_modules

## Quick Links

- **CLI**: `boardsmith init`, `boardsmith dev`, `boardsmith test`
- **Key packages**: `@boardsmith/engine`, `@boardsmith/ui`, `@boardsmith/ai`
- **Example games**: `packages/games/{hex, go-fish, checkers, cribbage}`
````

## File: packages/ai/src/mcts-bot.ts
````typescript
import type {
  Game,
  GameOptions,
  Player,
  FlowState,
  SerializedAction,
  ActionDefinition,
  Selection,
  GameStateSnapshot,
} from '@boardsmith/engine';
import { createSnapshot, deserializeAction } from '@boardsmith/engine';
import type { BotConfig, BotMove, MCTSNode, AIConfig, Objective } from './types.js';
import { DEFAULT_CONFIG } from './types.js';
import { createSeededRandom, randomChoice } from './utils.js';


type GameClass<G extends Game = Game> = new (options: GameOptions) => G;










export class MCTSBot<G extends Game = Game> {
  private game: G;
  private GameClass: GameClass<G>;
  private gameType: string;
  private playerIndex: number;
  private config: BotConfig;
  private objectives?: (game: Game, playerIndex: number) => Record<string, Objective>;
  private rng: () => number;
  private actionHistory: SerializedAction[];
  private seed?: string;

  constructor(
    game: G,
    GameClass: GameClass<G>,
    gameType: string,
    playerIndex: number,
    actionHistory: SerializedAction[] = [],
    config: Partial<BotConfig> = {},
    aiConfig?: AIConfig
  ) {
    this.game = game;
    this.GameClass = GameClass;
    this.gameType = gameType;
    this.playerIndex = playerIndex;
    this.actionHistory = actionHistory;
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.objectives = aiConfig?.objectives;
    this.seed = this.config.seed;
    this.rng = createSeededRandom(this.config.seed);
  }




  async play(): Promise<BotMove> {
    const flowState = this.game.getFlowState();
    if (!flowState?.awaitingInput) {
      throw new Error('Game is not awaiting input');
    }


    if (!this.canBotAct(flowState)) {
      throw new Error(`Not bot's turn (player ${this.playerIndex})`);
    }


    const moves = this.enumerateMoves(this.game, flowState);
    if (moves.length === 0) {
      throw new Error('No available moves');
    }


    if (moves.length === 1) {
      return moves[0];
    }


    const root = this.createNode(
      this.captureSnapshot(),
      flowState,
      null,
      null,
      moves
    );


    const startTime = Date.now();
    const timeout = this.config.timeout ?? 2000;

    for (let i = 0; i < this.config.iterations; i++) {

      if (Date.now() - startTime > timeout) {
        break;
      }

      const leaf = this.select(root);
      const { child, game } = this.expand(leaf);
      const result = this.playout(child, game);
      this.backpropagate(child, result);


      if (this.config.async) {
        await new Promise(resolve => setImmediate(resolve));
      }
    }


    if (root.children.length === 0) {

      return randomChoice(moves, this.rng);
    }

    const best = root.children.reduce((a, b) =>
      a.visits > b.visits ? a : b
    );

    return best.parentMove!;
  }




  private select(node: MCTSNode): MCTSNode {
    while (node.untriedMoves.length === 0 && node.children.length > 0) {
      node = this.selectChild(node);
    }
    return node;
  }




  private selectChild(node: MCTSNode): MCTSNode {
    const C = Math.sqrt(2);
    let best = node.children[0];
    let bestUCT = -Infinity;

    for (const child of node.children) {
      const visits = child.visits + 1e-6;
      const exploitation = child.value / visits;
      const exploration = C * Math.sqrt(Math.log(node.visits + 1) / visits);
      const uct = exploitation + exploration;

      if (uct > bestUCT) {
        bestUCT = uct;
        best = child;
      }
    }
    return best;
  }





  private expand(node: MCTSNode): { child: MCTSNode; game: Game | null } {
    if (node.untriedMoves.length === 0 || node.flowState.complete) {
      return { child: node, game: null };
    }


    const idx = Math.floor(this.rng() * node.untriedMoves.length);
    const move = node.untriedMoves.splice(idx, 1)[0];


    const game = this.restoreGame(node.snapshot);
    if (!game) {

      return { child: node, game: null };
    }


    const currentPlayer = this.getCurrentPlayerFromFlowState(node.flowState);


    let flowState: FlowState;
    try {
      flowState = game.continueFlow(move.action, move.args, currentPlayer);
    } catch (error) {


      return { child: node, game: null };
    }


    const newMoves = flowState.complete ? [] : this.enumerateMovesForSimulation(game as G, flowState);


    const newActionHistory = [
      ...node.snapshot.actionHistory,
      {
        name: move.action,
        player: currentPlayer,
        args: move.args,
        timestamp: Date.now(),
      },
    ];
    const snapshot = createSnapshot(game, this.gameType, newActionHistory, node.snapshot.seed);

    const child = this.createNode(snapshot, flowState, node, move, newMoves);
    node.children.push(child);

    return { child, game };
  }





  private playout(node: MCTSNode, existingGame: Game | null): number {

    const game = existingGame ?? this.restoreGame(node.snapshot);
    if (!game) {

      return 0.5;
    }

    let flowState = node.flowState;
    let depth = 0;

    while (!flowState.complete && depth < this.config.playoutDepth) {

      const moves = this.enumerateMovesForSimulation(game as G, flowState);
      if (moves.length === 0) {
        break;
      }


      const move = randomChoice(moves, this.rng);


      const currentPlayer = this.getCurrentPlayerFromFlowState(flowState);


      try {
        flowState = game.continueFlow(move.action, move.args, currentPlayer);
      } catch (error) {

        break;
      }
      depth++;
    }


    return this.evaluateTerminalFromGame(game, flowState);
  }




  private backpropagate(node: MCTSNode | null, result: number): void {
    while (node !== null) {
      node.visits++;



      const isOurPerspective = node.parent === null ||
        node.parent.currentPlayer === this.playerIndex;
      node.value += isOurPerspective ? result : (1 - result);
      node = node.parent;
    }
  }




  private canBotAct(flowState: FlowState): boolean {

    if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
      const playerState = flowState.awaitingPlayers.find(
        p => p.playerIndex === this.playerIndex && !p.completed
      );
      return playerState !== undefined && playerState.availableActions.length > 0;
    }


    if (flowState.currentPlayer !== undefined) {
      return flowState.currentPlayer === this.playerIndex;
    }

    return false;
  }




  private getAvailableActionsForBot(flowState: FlowState): string[] {

    if (flowState.awaitingPlayers) {
      const playerState = flowState.awaitingPlayers.find(
        p => p.playerIndex === this.playerIndex && !p.completed
      );
      if (playerState && playerState.availableActions.length > 0) {
        return playerState.availableActions;
      }
    }


    if (flowState.availableActions && flowState.availableActions.length > 0 &&
        flowState.currentPlayer === this.playerIndex) {
      return flowState.availableActions;
    }


    if (flowState.availableActions && flowState.availableActions.length > 0) {
      return flowState.availableActions;
    }

    return [];
  }





  private enumerateMoves(game: G, flowState: FlowState): BotMove[] {
    const moves: BotMove[] = [];
    const actions = this.getAvailableActionsForBot(flowState);
    const player = game.players[this.playerIndex];

    for (const actionName of actions) {
      const actionDef = game.getAction(actionName);
      if (!actionDef) continue;


      const argCombos = this.enumerateSelections(game, actionDef, player);
      for (const args of argCombos) {
        moves.push({ action: actionName, args });
      }
    }

    return moves;
  }





  private enumerateMovesForSimulation(game: G, flowState: FlowState): BotMove[] {
    const moves: BotMove[] = [];


    let currentPlayerIndex = flowState.currentPlayer;
    let actions: string[] = flowState.availableActions ?? [];


    if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
      const firstAwaiting = flowState.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
      if (firstAwaiting) {
        currentPlayerIndex = firstAwaiting.playerIndex;
        actions = firstAwaiting.availableActions;
      }
    }

    if (currentPlayerIndex === undefined) {
      return moves;
    }

    const player = game.players[currentPlayerIndex];
    if (!player) {
      return moves;
    }

    for (const actionName of actions) {
      const actionDef = game.getAction(actionName);
      if (!actionDef) continue;


      const argCombos = this.enumerateSelections(game, actionDef, player);
      for (const args of argCombos) {
        moves.push({ action: actionName, args });
      }
    }

    return moves;
  }




  private getCurrentPlayerFromFlowState(flowState: FlowState): number {

    if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
      const firstAwaiting = flowState.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
      if (firstAwaiting) {
        return firstAwaiting.playerIndex;
      }
    }
    return flowState.currentPlayer ?? this.playerIndex;
  }




  private enumerateMovesFromSnapshot(snapshot: GameStateSnapshot, flowState: FlowState): BotMove[] {
    const game = this.restoreGame(snapshot);
    if (!game) return [];
    return this.enumerateMoves(game as G, flowState);
  }




  private enumerateSelections(
    game: Game,
    actionDef: ActionDefinition,
    player: Player
  ): Record<string, unknown>[] {
    if (actionDef.selections.length === 0) {
      return [{}];
    }

    return this.enumerateSelectionsRecursive(game, actionDef, player, 0, {});
  }




  private enumerateSelectionsRecursive(
    game: Game,
    actionDef: ActionDefinition,
    player: Player,
    index: number,
    currentArgs: Record<string, unknown>
  ): Record<string, unknown>[] {
    if (index >= actionDef.selections.length) {
      return [{ ...currentArgs }];
    }

    const selection = actionDef.selections[index];
    const choices = this.getChoicesForSelection(game, actionDef.name, selection, player, currentArgs);


    if (selection.type === 'text' || selection.type === 'number') {
      if (selection.optional) {
        return this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, currentArgs);
      }

      return [];
    }

    if (choices.length === 0) {
      if (selection.optional) {
        return this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, currentArgs);
      }
      return [];
    }

    const results: Record<string, unknown>[] = [];


    const maxChoices = 20;
    const sampledChoices = choices.length > maxChoices
      ? this.sampleChoices(choices, maxChoices)
      : choices;

    for (const choice of sampledChoices) {

      const serializedChoice = this.serializeChoice(choice, selection);
      const newArgs = { ...currentArgs, [selection.name]: serializedChoice };
      const subResults = this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, newArgs);
      results.push(...subResults);
    }

    return results;
  }




  private getChoicesForSelection(
    game: Game,
    actionName: string,
    selection: Selection,
    player: Player,
    currentArgs: Record<string, unknown>
  ): unknown[] {
    return game.getSelectionChoices(actionName, selection.name, player as any, currentArgs);
  }




  private serializeChoice(choice: unknown, selection: Selection): unknown {
    if (selection.type === 'player') {
      return (choice as Player).position;
    }
    if (selection.type === 'element') {
      return (choice as { _t: { id: number } })._t.id;
    }
    return choice;
  }




  private sampleChoices<T>(choices: T[], maxCount: number): T[] {
    if (choices.length <= maxCount) return choices;

    const sampled: T[] = [];
    const indices = new Set<number>();

    while (sampled.length < maxCount) {
      const idx = Math.floor(this.rng() * choices.length);
      if (!indices.has(idx)) {
        indices.add(idx);
        sampled.push(choices[idx]);
      }
    }

    return sampled;
  }




  private captureSnapshot(): GameStateSnapshot {
    return createSnapshot(this.game, this.gameType, this.actionHistory, this.seed);
  }





  private restoreGame(snapshot: GameStateSnapshot): Game | null {
    try {
      const game = new this.GameClass({
        playerCount: snapshot.state.players.length,
        playerNames: snapshot.state.players.map(p => p.name as string),
        seed: snapshot.seed,
      });


      game.replayCommands(snapshot.commandHistory);


      game.startFlow();
      for (const action of snapshot.actionHistory) {
        const { actionName, player, args } = deserializeAction(action, game);

        game.continueFlow(actionName, args, player.position);
      }

      return game;
    } catch (error) {

      return null;
    }
  }





  private applyMove(
    snapshot: GameStateSnapshot,
    move: BotMove
  ): { snapshot: GameStateSnapshot; flowState: FlowState } | null {
    const game = this.restoreGame(snapshot);
    if (!game) return null;

    const currentPlayer = game.getFlowState()?.currentPlayer ?? this.playerIndex;


    let flowState: FlowState;
    try {
      flowState = game.continueFlow(move.action, move.args, currentPlayer);
    } catch (error) {
      return null;
    }


    const newActionHistory = [
      ...snapshot.actionHistory,
      {
        name: move.action,
        player: currentPlayer,
        args: move.args,
        timestamp: Date.now(),
      },
    ];

    const newSnapshot = createSnapshot(game, this.gameType, newActionHistory, snapshot.seed);

    return { snapshot: newSnapshot, flowState };
  }




  private createNode(
    snapshot: GameStateSnapshot,
    flowState: FlowState,
    parent: MCTSNode | null,
    parentMove: BotMove | null,
    untriedMoves: BotMove[]
  ): MCTSNode {
    return {
      snapshot,
      flowState,
      parent,
      parentMove,
      children: [],
      untriedMoves: [...untriedMoves],
      visits: 0,
      value: 0,
      currentPlayer: flowState.currentPlayer ?? this.playerIndex,
    };
  }




  private evaluateObjectives(snapshot: GameStateSnapshot): number {
    if (!this.objectives) return 0;

    const game = this.restoreGame(snapshot);
    if (!game) return 0;

    const objectives = this.objectives(game, this.playerIndex);

    let totalScore = 0;
    for (const obj of Object.values(objectives)) {
      if (obj.checker(game, this.playerIndex)) {
        totalScore += obj.weight;
      }
    }

    return totalScore;
  }




  private evaluateTerminal(snapshot: GameStateSnapshot, flowState: FlowState): number {
    if (!flowState.complete) {

      if (this.objectives) {
        const score = this.evaluateObjectives(snapshot);

        return score > 0 ? 0.6 : (score < 0 ? 0.4 : 0.5);
      }
      return 0.5;
    }


    const winners = snapshot.state.settings.winners as number[] | undefined;
    if (!winners || winners.length === 0) {
      return 0.5;
    }

    if (winners.includes(this.playerIndex)) {
      return 1;
    }

    return 0;
  }




  private evaluateTerminalFromGame(game: Game, flowState: FlowState): number {
    if (!flowState.complete) {

      if (this.objectives) {
        const objectives = this.objectives(game, this.playerIndex);
        let totalScore = 0;
        for (const obj of Object.values(objectives)) {
          if (obj.checker(game, this.playerIndex)) {
            totalScore += obj.weight;
          }
        }

        return totalScore > 0 ? 0.6 : (totalScore < 0 ? 0.4 : 0.5);
      }
      return 0.5;
    }


    const winners = (game as any).settings?.winners as number[] | undefined;
    if (!winners || winners.length === 0) {
      return 0.5;
    }

    if (winners.includes(this.playerIndex)) {
      return 1;
    }

    return 0;
  }
}
````

## File: packages/engine/src/command/executor.ts
````typescript
import type {
  GameCommand,
  CommandResult,
  CreateElementCommand,
  CreateManyCommand,
  MoveCommand,
  RemoveCommand,
  ShuffleCommand,
  SetAttributeCommand,
  SetVisibilityCommand,
  AddVisibleToCommand,
  SetCurrentPlayerCommand,
  MessageCommand,
  StartGameCommand,
  EndGameCommand,
  SetOrderCommand,
  VisibilityConfig,
} from './types.js';
import type { Game } from '../element/game.js';
import type { GameElement } from '../element/game-element.js';
import type { Space } from '../element/space.js';
import type { Piece } from '../element/piece.js';
import type { ElementClass } from '../element/types.js';
import { visibilityFromMode, type VisibilityMode, type VisibilityState } from './visibility.js';




export function executeCommand(game: Game, command: GameCommand): CommandResult {
  try {
    switch (command.type) {
      case 'CREATE':
        return executeCreate(game, command);
      case 'CREATE_MANY':
        return executeCreateMany(game, command);
      case 'MOVE':
        return executeMove(game, command);
      case 'REMOVE':
        return executeRemove(game, command);
      case 'SHUFFLE':
        return executeShuffle(game, command);
      case 'SET_ATTRIBUTE':
        return executeSetAttribute(game, command);
      case 'SET_VISIBILITY':
        return executeSetVisibility(game, command);
      case 'ADD_VISIBLE_TO':
        return executeAddVisibleTo(game, command);
      case 'SET_CURRENT_PLAYER':
        return executeSetCurrentPlayer(game, command);
      case 'MESSAGE':
        return executeMessage(game, command);
      case 'START_GAME':
        return executeStartGame(game, command);
      case 'END_GAME':
        return executeEndGame(game, command);
      case 'SET_ORDER':
        return executeSetOrder(game, command);
      default:
        return { success: false, error: `Unknown command type: ${(command as any).type}` };
    }
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

function executeCreate(game: Game, command: CreateElementCommand): CommandResult {
  const parent = game.getElementById(command.parentId);
  if (!parent) {
    return { success: false, error: `Parent element not found: ${command.parentId}` };
  }

  const ElementClass = game.getElementClass(command.className);
  if (!ElementClass) {
    return { success: false, error: `Unknown element class: ${command.className}` };
  }

  parent.createInternal(ElementClass, command.name, command.attributes);
  return { success: true };
}

function executeCreateMany(game: Game, command: CreateManyCommand): CommandResult {
  const parent = game.getElementById(command.parentId);
  if (!parent) {
    return { success: false, error: `Parent element not found: ${command.parentId}` };
  }

  const ElementClass = game.getElementClass(command.className);
  if (!ElementClass) {
    return { success: false, error: `Unknown element class: ${command.className}` };
  }

  for (let i = 0; i < command.count; i++) {
    const attrs = command.attributesList?.[i] ?? {};
    parent.createInternal(ElementClass, command.name, attrs);
  }

  return { success: true };
}

function executeMove(game: Game, command: MoveCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  const destination = game.getElementById(command.destinationId);
  if (!destination) {
    return { success: false, error: `Destination not found: ${command.destinationId}` };
  }


  (element as Piece).moveToInternal(destination, command.position);
  return { success: true };
}

function executeRemove(game: Game, command: RemoveCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  (element as Piece).moveToInternal(game.pile);
  return { success: true };
}

function executeShuffle(game: Game, command: ShuffleCommand): CommandResult {
  const space = game.getElementById(command.spaceId) as Space | undefined;
  if (!space) {
    return { success: false, error: `Space not found: ${command.spaceId}` };
  }

  space.shuffleInternal();
  return { success: true };
}

function executeSetAttribute(game: Game, command: SetAttributeCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  (element as any)[command.attribute] = command.value;
  return { success: true };
}

function executeSetVisibility(game: Game, command: SetVisibilityCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  let visibility: VisibilityState;
  if (typeof command.visibility === 'string') {
    visibility = visibilityFromMode(command.visibility);
  } else {
    visibility = {
      mode: command.visibility.mode,
      addPlayers: command.visibility.addPlayers,
      exceptPlayers: command.visibility.exceptPlayers,
      explicit: true,
    };
  }

  element.setVisibilityInternal(visibility);
  return { success: true };
}

function executeAddVisibleTo(game: Game, command: AddVisibleToCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  element.addVisibleToInternal(command.players);
  return { success: true };
}

function executeSetCurrentPlayer(game: Game, command: SetCurrentPlayerCommand): CommandResult {
  game.players.setCurrent(command.playerPosition);
  return { success: true };
}

function executeMessage(game: Game, command: MessageCommand): CommandResult {
  game.addMessageInternal(command.text, command.data);
  return { success: true };
}

function executeStartGame(game: Game, command: StartGameCommand): CommandResult {
  if (game.phase !== 'setup') {
    return { success: false, error: 'Game has already started' };
  }
  game.phase = 'started';
  return { success: true };
}

function executeEndGame(game: Game, command: EndGameCommand): CommandResult {
  game.phase = 'finished';
  if (command.winners) {
    game.settings.winners = command.winners;
  }
  return { success: true };
}

function executeSetOrder(game: Game, command: SetOrderCommand): CommandResult {
  const space = game.getElementById(command.spaceId);
  if (!space) {
    return { success: false, error: `Space not found: ${command.spaceId}` };
  }

  space._t.order = command.order;
  return { success: true };
}
````

## File: packages/engine/src/command/types.ts
````typescript
import type { ElementClass, ElementAttributes } from '../element/types.js';
import type { GameElement } from '../element/game-element.js';
import type { VisibilityMode } from './visibility.js';




export interface BaseCommand {
  type: string;
}




export interface CreateElementCommand extends BaseCommand {
  type: 'CREATE';

  className: string;

  name: string;

  parentId: number;

  attributes?: Record<string, unknown>;
}




export interface CreateManyCommand extends BaseCommand {
  type: 'CREATE_MANY';

  className: string;

  name: string;

  parentId: number;

  count: number;

  attributesList?: Record<string, unknown>[];
}




export interface MoveCommand extends BaseCommand {
  type: 'MOVE';

  elementId: number;

  destinationId: number;

  position?: 'first' | 'last';
}




export interface RemoveCommand extends BaseCommand {
  type: 'REMOVE';

  elementId: number;
}




export interface ShuffleCommand extends BaseCommand {
  type: 'SHUFFLE';

  spaceId: number;
}




export interface SetAttributeCommand extends BaseCommand {
  type: 'SET_ATTRIBUTE';

  elementId: number;

  attribute: string;

  value: unknown;
}




export interface SetVisibilityCommand extends BaseCommand {
  type: 'SET_VISIBILITY';

  elementId: number;

  visibility: VisibilityMode | VisibilityConfig;
}




export interface AddVisibleToCommand extends BaseCommand {
  type: 'ADD_VISIBLE_TO';

  elementId: number;

  players: number[];
}




export interface SetCurrentPlayerCommand extends BaseCommand {
  type: 'SET_CURRENT_PLAYER';

  playerPosition: number;
}




export interface MessageCommand extends BaseCommand {
  type: 'MESSAGE';

  text: string;

  data?: Record<string, unknown>;
}




export interface StartGameCommand extends BaseCommand {
  type: 'START_GAME';
}




export interface EndGameCommand extends BaseCommand {
  type: 'END_GAME';

  winners?: number[];
}




export interface SetOrderCommand extends BaseCommand {
  type: 'SET_ORDER';

  spaceId: number;

  order: 'normal' | 'stacking';
}




export interface VisibilityConfig {

  mode: VisibilityMode;

  addPlayers?: number[];

  exceptPlayers?: number[];
}




export type GameCommand =
  | CreateElementCommand
  | CreateManyCommand
  | MoveCommand
  | RemoveCommand
  | ShuffleCommand
  | SetAttributeCommand
  | SetVisibilityCommand
  | AddVisibleToCommand
  | SetCurrentPlayerCommand
  | MessageCommand
  | StartGameCommand
  | EndGameCommand
  | SetOrderCommand;




export interface CommandResult {

  success: boolean;

  error?: string;
}
````

## File: packages/engine/src/element/dice-pool.ts
````typescript
import { Space } from './space.js';
import { Die, type DieSides } from './die.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';




















export class DicePool<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'dice-pool';

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'dice-pool';


    this.$direction = 'horizontal';
    this.$gap = '12px';
    this.$align = 'center';
  }




  getDice(): Die[] {
    return this.all(Die) as unknown as Die[];
  }




  getDiceByType(sides: DieSides): Die[] {
    return this.getDice().filter(d => d.sides === sides);
  }





  rollAll(): Array<[Die, number]> {
    const results: Array<[Die, number]> = [];
    for (const die of this.getDice()) {
      const value = die.roll();
      results.push([die, value]);
    }
    return results;
  }






  rollByName(...names: string[]): Array<[Die, number]> {
    const results: Array<[Die, number]> = [];
    for (const name of names) {
      const die = this.first(Die, { name }) as Die | undefined;
      if (die) {
        const value = die.roll();
        results.push([die, value]);
      }
    }
    return results;
  }






  rollByType(sides: DieSides): Array<[Die, number]> {
    const results: Array<[Die, number]> = [];
    for (const die of this.getDiceByType(sides)) {
      const value = die.roll();
      results.push([die, value]);
    }
    return results;
  }




  getTotal(): number {
    return this.getDice().reduce((sum, die) => sum + die.value, 0);
  }




  getValues(): number[] {
    return this.getDice().map(d => d.value);
  }




  hasValue(value: number): boolean {
    return this.getDice().some(d => d.value === value);
  }




  countValue(value: number): number {
    return this.getDice().filter(d => d.value === value).length;
  }
}
````

## File: packages/engine/src/element/die.ts
````typescript
import { Piece } from './piece.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';




export type DieSides = 4 | 6 | 8 | 10 | 12 | 20;





















export class Die<G extends Game = any, P extends Player = any> extends Piece<G, P> {




  $type!: 'die';




  sides!: DieSides;




  value: number = 0;




  color: string = '#ffffff';






  faceLabels?: string[];





  rolling: boolean = false;





  rollCount: number = 0;

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'die';
  }







  roll(): number {
    this.rollCount++;
    this.value = Math.floor(this.game.random() * this.sides) + 1;
    return this.value;
  }






  setValue(n: number): void {
    if (n < 1 || n > this.sides) {
      throw new Error(`Invalid die value ${n} for d${this.sides}`);
    }
    this.value = n;
  }






  getOpposite(): number {
    if (this.sides === 4) {

      const others = [1, 2, 3, 4].filter(n => n !== this.value);
      return others[Math.floor(this.game.random() * others.length)];
    }

    return this.sides + 1 - this.value;
  }





  flip(): void {
    this.value = this.getOpposite();
  }





  getLabel(): string {
    if (this.faceLabels && this.faceLabels.length === this.sides) {
      return this.faceLabels[this.value - 1];
    }
    return String(this.value);
  }




  isD4(): boolean { return this.sides === 4; }
  isD6(): boolean { return this.sides === 6; }
  isD8(): boolean { return this.sides === 8; }
  isD10(): boolean { return this.sides === 10; }
  isD12(): boolean { return this.sides === 12; }
  isD20(): boolean { return this.sides === 20; }
}
````

## File: packages/engine/src/element/element-collection.ts
````typescript
import type { GameElement } from './game-element.js';
import type { ElementClass, ElementFinder, Sorter } from './types.js';




type FinderOptions = {
  limit?: number;
  order?: 'asc' | 'desc';
  noRecursive?: boolean;
};





export class ElementCollection<T extends GameElement = GameElement> extends Array<T> {



  override slice(...args: Parameters<Array<T>['slice']>): ElementCollection<T> {
    return super.slice(...args) as ElementCollection<T>;
  }




  override filter(
    predicate: (value: T, index: number, array: T[]) => boolean
  ): ElementCollection<T> {
    return super.filter(predicate) as ElementCollection<T>;
  }




  all<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  all(...finders: ElementFinder<T>[]): ElementCollection<T>;
  all<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, {}, ...finders);
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, {}, ...finders) as ElementCollection<F>;
  }




  first<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  first(...finders: ElementFinder<T>[]): T | undefined;
  first<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: 1 }, ...finders)[0];
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: 1 }, ...finders)[0] as F | undefined;
  }




  firstN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  firstN(n: number, ...finders: ElementFinder<T>[]): ElementCollection<T>;
  firstN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: n }, ...finders);
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: n }, ...finders) as ElementCollection<F>;
  }




  last<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  last(...finders: ElementFinder<T>[]): T | undefined;
  last<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: 1, order: 'desc' }, ...finders)[0];
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: 1, order: 'desc' }, ...finders)[0] as F | undefined;
  }




  lastN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  lastN(n: number, ...finders: ElementFinder<T>[]): ElementCollection<T>;
  lastN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: n, order: 'desc' }, ...finders);
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: n, order: 'desc' }, ...finders) as ElementCollection<F>;
  }




  has<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): boolean;
  has(...finders: ElementFinder<T>[]): boolean;
  has<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): boolean {
    return this.first(classNameOrFinder as ElementClass<F>, ...finders) !== undefined;
  }




  sortBy<K extends Sorter<T>>(key: K, direction: 'asc' | 'desc' = 'asc'): ElementCollection<T> {
    const sorted = new ElementCollection<T>(...this);
    sorted.sort((a, b) => {
      const aVal = typeof key === 'function' ? key(a) : a[key as keyof T];
      const bVal = typeof key === 'function' ? key(b) : b[key as keyof T];
      if (aVal < bVal) return direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return direction === 'asc' ? 1 : -1;
      return 0;
    });
    return sorted;
  }




  sum(key: keyof T | ((element: T) => number)): number {
    return this.reduce((acc, el) => {
      const val = typeof key === 'function' ? key(el) : el[key as keyof T];
      return acc + (typeof val === 'number' ? val : 0);
    }, 0);
  }




  min(key: keyof T | ((element: T) => number)): T | undefined {
    if (this.length === 0) return undefined;
    return this.reduce((min, el) => {
      const minVal = typeof key === 'function' ? key(min) : min[key as keyof T];
      const elVal = typeof key === 'function' ? key(el) : el[key as keyof T];
      return elVal < minVal ? el : min;
    });
  }




  max(key: keyof T | ((element: T) => number)): T | undefined {
    if (this.length === 0) return undefined;
    return this.reduce((max, el) => {
      const maxVal = typeof key === 'function' ? key(max) : max[key as keyof T];
      const elVal = typeof key === 'function' ? key(el) : el[key as keyof T];
      return elVal > maxVal ? el : max;
    });
  }




  shuffle(random: () => number = Math.random): ElementCollection<T> {
    for (let i = this.length - 1; i > 0; i--) {
      const j = Math.floor(random() * (i + 1));
      [this[i], this[j]] = [this[j], this[i]];
    }
    return this;
  }




  unique<K extends keyof T>(key: K): T[K][] {
    const seen = new Set<T[K]>();
    for (const el of this) {
      seen.add(el[key]);
    }
    return Array.from(seen);
  }













  contains(element: GameElement | null | undefined): boolean {
    if (!element) return false;
    return this.some(e => e.id === element.id);
  }








  findById(id: number): T | undefined {
    return this.find(e => e.id === id);
  }




  hasId(id: number): boolean {
    return this.some(e => e.id === id);
  }









  indexOfElement(element: GameElement | null | undefined): number {
    if (!element) return -1;
    return this.findIndex(e => e.id === element.id);
  }




  _finder<F extends GameElement>(
    className: ElementClass<F> | undefined,
    options: FinderOptions,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const result = new ElementCollection<F>();
    if (options.limit !== undefined && options.limit <= 0) return result;


    const predicates = finders.map((finder) => this.finderToPredicate<F>(finder));

    const process = (elements: GameElement[], order: 'asc' | 'desc') => {
      const items = order === 'desc' ? [...elements].reverse() : elements;

      for (const el of items) {
        if (options.limit !== undefined && result.length >= options.limit) break;


        const matchesClass = !className || el instanceof className;
        const matchesPredicates = predicates.every((pred) => pred(el as F));

        if (matchesClass && matchesPredicates) {
          if (order === 'desc') {
            result.unshift(el as F);
          } else {
            result.push(el as F);
          }
        }


        if (!options.noRecursive && el._t.children.length > 0) {
          const childCollection = new ElementCollection(...el._t.children);
          const remaining = options.limit !== undefined
            ? options.limit - result.length
            : undefined;
          const childResults = childCollection._finder(className, {
            ...options,
            limit: remaining,
          }, ...finders);
          result.push(...childResults);
        }
      }
    };

    process(this as unknown as GameElement[], options.order ?? 'asc');
    return result;
  }




  private finderToPredicate<F extends GameElement>(finder: ElementFinder<F>): (el: F) => boolean {
    if (typeof finder === 'string') {
      return (el) => el.name === finder;
    }
    if (typeof finder === 'function') {
      return finder;
    }

    return (el) => {
      for (const [key, value] of Object.entries(finder)) {
        if (key === 'empty') {
          if (value !== el.isEmpty()) return false;
        } else if (key === 'mine') {
          if (value !== el.isMine()) return false;
        } else {
          if ((el as Record<string, unknown>)[key] !== value) return false;
        }
      }
      return true;
    };
  }




  private isElementClass<F extends GameElement>(
    value: unknown
  ): value is ElementClass<F> {
    return (
      typeof value === 'function' &&
      'isGameElement' in value &&
      (value as ElementClass<F>).isGameElement === true
    );
  }
}
````

## File: packages/engine/src/element/hand.ts
````typescript
import { Space } from './space.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';



















export class Hand<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'hand';

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'hand';


    this.$direction = 'horizontal';
    this.$fan = true;
    this.$fanAngle = 30;
    this.$overlap = 0.5;
    this.$align = 'center';
  }
}
````

## File: packages/engine/src/element/space.ts
````typescript
import { GameElement } from './game-element.js';
import type { ElementClass, ElementAttributes, ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';
import type { VisibilityMode, VisibilityState } from '../command/visibility.js';
import { visibilityFromMode } from '../command/visibility.js';




export type ElementEventHandler<T extends GameElement> = {
  callback: (element: T) => void;
  elementClass?: ElementClass;
};




export type LayoutDirection = 'horizontal' | 'vertical';




export type LayoutAlignment = 'start' | 'center' | 'end' | 'stretch';















export class Space<G extends Game = any, P extends Player = any> extends GameElement<G, P> {








  $direction?: LayoutDirection;




  $gap?: string;





  $overlap?: number;





  $fan?: boolean;





  $fanAngle?: number;





  $align?: LayoutAlignment;






  private _eventHandlers: {
    enter: ElementEventHandler<GameElement>[];
    exit: ElementEventHandler<GameElement>[];
  } = { enter: [], exit: [] };


  private _zoneVisibility?: VisibilityState;

  static override unserializableAttributes = [
    ...GameElement.unserializableAttributes,
    '_eventHandlers',
    '_zoneVisibility',
  ];

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);
  }









  setZoneVisibility(mode: VisibilityMode): void {
    this._zoneVisibility = visibilityFromMode(mode);
  }




  getZoneVisibility(): VisibilityState | undefined {
    return this._zoneVisibility;
  }




  contentsVisible(): void {
    this.setZoneVisibility('all');
  }




  contentsVisibleToOwner(): void {
    this.setZoneVisibility('owner');
  }




  contentsHidden(): void {
    this.setZoneVisibility('hidden');
  }




  contentsCountOnly(): void {
    this.setZoneVisibility('count-only');
  }




  addZoneVisibleTo(...players: (P | number)[]): void {
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    if (!this._zoneVisibility) {
      this._zoneVisibility = { mode: 'all', explicit: true };
    }
    this._zoneVisibility.addPlayers = Array.from(
      new Set([...(this._zoneVisibility.addPlayers ?? []), ...positions])
    );
  }




  hideContentsFrom(...players: (P | number)[]): void {
    if (!this._zoneVisibility) {
      this._zoneVisibility = { mode: 'all', explicit: true };
    }
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    this._zoneVisibility.exceptPlayers = Array.from(
      new Set([...(this._zoneVisibility.exceptPlayers ?? []), ...positions])
    );
  }








  onEnter<T extends GameElement>(
    callback: (element: T) => void,
    elementClass?: ElementClass<T>
  ): void {
    this._eventHandlers.enter.push({ callback: callback as (element: GameElement) => void, elementClass });
  }




  onExit<T extends GameElement>(
    callback: (element: T) => void,
    elementClass?: ElementClass<T>
  ): void {
    this._eventHandlers.exit.push({ callback: callback as (element: GameElement) => void, elementClass });
  }




  triggerEvent(type: 'enter' | 'exit', element: GameElement): void {
    for (const handler of this._eventHandlers[type]) {
      if (!handler.elementClass || element instanceof handler.elementClass) {
        handler.callback(element);
      }
    }
  }





  override create<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T>
  ): T {
    const element = super.create(elementClass, name, attributes);


    this.triggerEvent('enter', element);

    return element;
  }








  shuffle(): void {
    this.shuffleInternal();
  }




  shuffleInternal(): void {
    const random = this._ctx.random ?? Math.random;


    for (let i = this._t.children.length - 1; i > 0; i--) {
      const j = Math.floor(random() * (i + 1));
      [this._t.children[i], this._t.children[j]] = [
        this._t.children[j],
        this._t.children[i],
      ];
    }
  }








  isSpace(): boolean {
    return true;
  }
}
````

## File: packages/engine/src/element/types.ts
````typescript
import type { GameElement } from './game-element.js';
import type { Game } from './game.js';
import type { Player } from '../player/player.js';
import type { VisibilityState } from '../command/visibility.js';






export type ImageRef =
  | string
  | {

      sprite: string;

      x: number;

      y: number;

      width: number;

      height: number;
    };




export type ElementClass<T extends GameElement = GameElement> = {
  new (ctx: Partial<ElementContext>): T;
  isGameElement: boolean;
};




export type ElementContext = {

  game: Game;

  sequence: number;

  player?: Player;

  classRegistry: Map<string, ElementClass>;

  random: () => number;
};




export type ElementTree<T extends GameElement = GameElement> = {

  children: T[];

  parent?: GameElement;

  id: number;

  order: 'normal' | 'stacking';
};




export type ElementJSON = {
  className: string;
  id: number;
  name?: string;
  attributes: Record<string, unknown>;
  visibility?: VisibilityState;
  children?: ElementJSON[];

  childCount?: number;
};







export type ElementFinder<T extends GameElement = GameElement> =
  | string
  | ((element: T) => boolean)
  | Partial<Record<string, unknown> & { mine?: boolean; empty?: boolean }>;




export type Sorter<T> = keyof T | ((element: T) => number | string);




export type ElementAttributes<T extends GameElement> = Partial<
  Pick<
    T,
    {
      [K in keyof T]: K extends keyof GameElement
        ? never
        : T[K] extends (...args: unknown[]) => unknown
          ? never
          : K;
    }[keyof T]
  > & {
    name?: string;
    player?: Player;
    row?: number;
    column?: number;
  }
>;
````

## File: packages/engine/src/flow/turn-order.ts
````typescript
import type { Player } from '../player/player.js';
import type { FlowContext } from './types.js';




export interface TurnOrderConfig {
  direction?: 'forward' | 'backward';
  filter?: (player: Player, context: FlowContext) => boolean;
  startingPlayer?: (context: FlowContext) => Player;
}

















export const TurnOrder = {



  DEFAULT: {
    direction: 'forward' as const,
  } satisfies TurnOrderConfig,




  REVERSE: {
    direction: 'backward' as const,
  } satisfies TurnOrderConfig,







  CONTINUE: {
    direction: 'forward' as const,
    startingPlayer: (ctx: FlowContext) => ctx.game.players.current,
  } satisfies TurnOrderConfig,




  ACTIVE_ONLY: {
    direction: 'forward' as const,
    filter: (player: Player) => !(player as any).eliminated,
  } satisfies TurnOrderConfig,




















  START_FROM: (getPlayer: number | ((ctx: FlowContext) => Player)): TurnOrderConfig => ({
    direction: 'forward' as const,
    startingPlayer: (ctx: FlowContext) => {
      if (typeof getPlayer === 'number') {
        return ctx.game.players[getPlayer];
      }
      return getPlayer(ctx);
    },
  }),














  ONLY: (positions: number[]): TurnOrderConfig => ({
    direction: 'forward' as const,
    filter: (player: Player) => positions.includes(player.position),
  }),




















  LEFT_OF_DEALER: (getDealerPosition: (ctx: FlowContext) => number): TurnOrderConfig => ({
    direction: 'forward' as const,
    startingPlayer: (ctx: FlowContext) => {
      const dealerPos = getDealerPosition(ctx);
      const nextPos = (dealerPos + 1) % ctx.game.players.length;
      return ctx.game.players[nextPos];
    },
  }),














  SKIP_IF: (shouldSkip: (player: Player, ctx: FlowContext) => boolean): TurnOrderConfig => ({
    direction: 'forward' as const,
    filter: (player: Player, ctx: FlowContext) => !shouldSkip(player, ctx),
  }),
















  combine: (...configs: TurnOrderConfig[]): TurnOrderConfig => {
    const combined: TurnOrderConfig = { direction: 'forward' };

    for (const config of configs) {
      if (config.direction) combined.direction = config.direction;
      if (config.startingPlayer) combined.startingPlayer = config.startingPlayer;

      if (config.filter) {
        const existingFilter = combined.filter;
        if (existingFilter) {

          const newFilter = config.filter;
          combined.filter = (player, ctx) => existingFilter(player, ctx) && newFilter(player, ctx);
        } else {
          combined.filter = config.filter;
        }
      }
    }

    return combined;
  },
};
````

## File: packages/engine/src/player/abilities.ts
````typescript
export interface Ability<T extends string = string> {

  type: T;

  used: boolean;

  earnedFrom?: string;
}






















export class AbilityManager<T extends string = string> {
  private abilities: Ability<T>[] = [];






  add(type: T, earnedFrom?: string): void {
    this.abilities.push({ type, used: false, earnedFrom });
  }




  hasUnused(type: T): boolean {
    return this.abilities.some(a => a.type === type && !a.used);
  }




  has(type: T): boolean {
    return this.abilities.some(a => a.type === type);
  }




  countUnused(type: T): number {
    return this.abilities.filter(a => a.type === type && !a.used).length;
  }




  count(type: T): number {
    return this.abilities.filter(a => a.type === type).length;
  }




  countAllUnused(): number {
    return this.abilities.filter(a => !a.used).length;
  }





  use(type: T): boolean {
    const ability = this.abilities.find(a => a.type === type && !a.used);
    if (ability) {
      ability.used = true;
      return true;
    }
    return false;
  }




  getAll(): readonly Ability<T>[] {
    return this.abilities;
  }




  getUnused(): Ability<T>[] {
    return this.abilities.filter(a => !a.used);
  }




  getUsed(): Ability<T>[] {
    return this.abilities.filter(a => a.used);
  }




  getTypes(): T[] {
    return [...new Set(this.abilities.map(a => a.type))];
  }




  getGrouped(): Array<{ type: T; total: number; unused: number }> {
    const grouped = new Map<T, { total: number; unused: number }>();

    for (const ability of this.abilities) {
      const current = grouped.get(ability.type) ?? { total: 0, unused: 0 };
      current.total++;
      if (!ability.used) {
        current.unused++;
      }
      grouped.set(ability.type, current);
    }

    return Array.from(grouped.entries()).map(([type, counts]) => ({
      type,
      ...counts,
    }));
  }




  resetAll(): void {
    for (const ability of this.abilities) {
      ability.used = false;
    }
  }




  clear(): void {
    this.abilities = [];
  }




  toJSON(): Ability<T>[] {
    return this.abilities.map(a => ({ ...a }));
  }




  fromJSON(data: Ability<T>[]): void {
    this.abilities = data.map(a => ({ ...a }));
  }




  static fromJSON<T extends string>(data: Ability<T>[]): AbilityManager<T> {
    const manager = new AbilityManager<T>();
    manager.fromJSON(data);
    return manager;
  }
}
````

## File: packages/engine/src/player/player.ts
````typescript
import type { Game } from '../element/game.js';
import type { GameElement, ElementClass, ElementFinder } from '../element/index.js';
import { ElementCollection } from '../element/element-collection.js';




export class Player<G extends Game = Game> {

  readonly position: number;


  name: string;


  color?: string;


  game!: G;


  private _isCurrent: boolean = false;

  constructor(position: number, name: string) {
    this.position = position;
    this.name = name;
  }




  isCurrent(): boolean {
    return this._isCurrent;
  }




  setCurrent(isCurrent: boolean): void {
    this._isCurrent = isCurrent;
  }




  allMy<T extends GameElement>(
    className: ElementClass<T>,
    ...finders: ElementFinder<T>[]
  ): ElementCollection<T> {
    return this.game.all(className, { player: this } as ElementFinder<T>, ...finders);
  }




  my<T extends GameElement>(
    className: ElementClass<T>,
    ...finders: ElementFinder<T>[]
  ): T | undefined {
    return this.game.first(className, { player: this } as ElementFinder<T>, ...finders);
  }




  has<T extends GameElement>(
    className: ElementClass<T>,
    ...finders: ElementFinder<T>[]
  ): boolean {
    return this.my(className, ...finders) !== undefined;
  }




  toString(): string {
    return this.name;
  }




  toJSON(): Record<string, unknown> {
    return {
      position: this.position,
      name: this.name,
      color: this.color,
    };
  }
}




export class PlayerCollection<P extends Player = Player> extends Array<P> {

  private _currentIndex: number = 0;




  get current(): P | undefined {
    return this[this._currentIndex];
  }




  setCurrent(player: P | number): void {
    const index = typeof player === 'number' ? player : player.position;


    if (this[this._currentIndex]) {
      this[this._currentIndex].setCurrent(false);
    }

    this._currentIndex = index;


    if (this[this._currentIndex]) {
      this[this._currentIndex].setCurrent(true);
    }
  }




  next(from?: P): P {
    const currentPos = from?.position ?? this._currentIndex;
    const nextPos = (currentPos + 1) % this.length;
    return this[nextPos];
  }




  previous(from?: P): P {
    const currentPos = from?.position ?? this._currentIndex;
    const prevPos = (currentPos - 1 + this.length) % this.length;
    return this[prevPos];
  }




  others(excluding?: P): PlayerCollection<P> {
    const excludePos = excluding?.position ?? this._currentIndex;
    const result = new PlayerCollection<P>();
    for (const player of this) {
      if (player.position !== excludePos) {
        result.push(player);
      }
    }
    return result;
  }




  toJSON(): Record<string, unknown>[] {
    return this.map(p => {

      if (typeof p.toJSON === 'function') {
        return p.toJSON();
      }

      return {
        position: p.position,
        name: p.name,
        color: p.color,
      };
    });
  }
}
````

## File: packages/engine/src/utils/index.ts
````typescript
export {
  serializeValue,
  deserializeValue,
  serializeAction,
  deserializeAction,
  isSerializedReference,
} from './serializer.js';

export type {
  SerializedReference,
  SerializeOptions,
} from './serializer.js';


export {
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
} from './snapshot.js';

export type {
  GameStateSnapshot,
  PlayerStateView,
} from './snapshot.js';


export {
  createReplayFile,
  validateReplayFile,
  parseReplayFile,
} from './replay.js';

export type {
  ReplayFile,
} from './replay.js';
````

## File: packages/engine/src/utils/replay.ts
````typescript
import type { SerializedAction } from '../action/types.js';







export interface ReplayFile {

  version: 1;


  gameType: string;


  gameRevision: string;


  seed: string;


  playerCount: number;


  playerNames: string[];


  actions: SerializedAction[];


  outcome: 'complete' | 'aborted';


  winners?: number[];


  timestamp: string;
}




export function createReplayFile(options: {
  gameType: string;
  gameRevision: string;
  seed: string;
  playerCount: number;
  playerNames: string[];
  actions: SerializedAction[];
  outcome: 'complete' | 'aborted';
  winners?: number[];
}): ReplayFile {
  return {
    version: 1,
    gameType: options.gameType,
    gameRevision: options.gameRevision,
    seed: options.seed,
    playerCount: options.playerCount,
    playerNames: options.playerNames,
    actions: options.actions,
    outcome: options.outcome,
    winners: options.winners,
    timestamp: new Date().toISOString(),
  };
}




export function validateReplayFile(data: unknown): data is ReplayFile {
  if (typeof data !== 'object' || data === null) {
    return false;
  }

  const replay = data as Record<string, unknown>;

  return (
    replay.version === 1 &&
    typeof replay.gameType === 'string' &&
    typeof replay.gameRevision === 'string' &&
    typeof replay.seed === 'string' &&
    typeof replay.playerCount === 'number' &&
    Array.isArray(replay.playerNames) &&
    Array.isArray(replay.actions) &&
    (replay.outcome === 'complete' || replay.outcome === 'aborted') &&
    typeof replay.timestamp === 'string'
  );
}





export function parseReplayFile(json: string): ReplayFile {
  const data = JSON.parse(json);
  if (!validateReplayFile(data)) {
    throw new Error('Invalid replay file format');
  }
  return data;
}
````

## File: packages/engine/src/utils/serializer.ts
````typescript
import type { Game } from '../element/game.js';
import type { GameElement } from '../element/game-element.js';
import type { Player } from '../player/player.js';
import type { SerializedAction } from '../action/types.js';




export type SerializedReference =
  | { __elementRef: string }
  | { __elementId: number }
  | { __playerRef: number };




export interface SerializeOptions {

  useBranchPaths?: boolean;
}






export function serializeValue(
  value: unknown,
  game: Game,
  options: SerializeOptions = {}
): unknown {
  if (value === null || value === undefined) {
    return value;
  }


  if (value instanceof Object && 'branch' in value && typeof (value as GameElement).branch === 'function') {
    const element = value as GameElement;
    if (options.useBranchPaths) {
      return { __elementRef: element.branch() };
    }
    return { __elementId: element.id };
  }


  if (value instanceof Object && 'position' in value && typeof (value as Player).position === 'number') {
    const player = value as Player;
    return { __playerRef: player.position };
  }


  if (Array.isArray(value)) {
    return value.map(item => serializeValue(item, game, options));
  }


  if (typeof value === 'object' && value !== null) {
    const result: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      result[key] = serializeValue(val, game, options);
    }
    return result;
  }


  return value;
}






export function deserializeValue(
  value: unknown,
  game: Game
): unknown {
  if (value === null || value === undefined) {
    return value;
  }


  if (typeof value === 'object' && value !== null && '__elementRef' in value) {
    const ref = value as { __elementRef: string };
    return game.atBranch(ref.__elementRef);
  }


  if (typeof value === 'object' && value !== null && '__elementId' in value) {
    const ref = value as { __elementId: number };
    return game.first({ id: ref.__elementId } as Record<string, unknown>);
  }


  if (typeof value === 'object' && value !== null && '__playerRef' in value) {
    const ref = value as { __playerRef: number };
    return game.players[ref.__playerRef];
  }


  if (Array.isArray(value)) {
    return value.map(item => deserializeValue(item, game));
  }


  if (typeof value === 'object' && value !== null) {
    const result: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      result[key] = deserializeValue(val, game);
    }
    return result;
  }


  return value;
}




export function serializeAction(
  actionName: string,
  player: Player,
  args: Record<string, unknown>,
  game: Game,
  options: SerializeOptions = {},
  undoable?: boolean
): SerializedAction {
  const serialized: SerializedAction = {
    name: actionName,
    player: player.position,
    args: serializeValue(args, game, options) as Record<string, unknown>,
    timestamp: Date.now(),
  };


  if (undoable === false) {
    serialized.undoable = false;
  }

  return serialized;
}




export function deserializeAction(
  serialized: SerializedAction,
  game: Game
): { actionName: string; player: Player; args: Record<string, unknown> } {
  const player = game.players[serialized.player];
  if (!player) {
    throw new Error(`Player ${serialized.player} not found`);
  }

  return {
    actionName: serialized.name,
    player,
    args: deserializeValue(serialized.args, game) as Record<string, unknown>,
  };
}




export function isSerializedReference(value: unknown): value is SerializedReference {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  return '__elementRef' in value || '__elementId' in value || '__playerRef' in value;
}
````

## File: packages/runtime/src/index.ts
````typescript
export {
  serializeValue,
  deserializeValue,
  serializeAction,
  deserializeAction,
  isSerializedReference,
  type SerializedReference,
  type SerializeOptions,
} from '@boardsmith/engine';


export {
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
  type GameStateSnapshot,
  type PlayerStateView,
} from '@boardsmith/engine';


export {
  createReplayFile,
  validateReplayFile,
  parseReplayFile,
  type ReplayFile,
} from '@boardsmith/engine';


export {
  GameRunner,
  type GameRunnerOptions,
  type ActionExecutionResult,
} from './runner.js';
````

## File: packages/runtime/src/runner.ts
````typescript
import {
  serializeAction,
  deserializeAction,
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
  type Game,
  type GameOptions,
  type Player,
  type SerializedAction,
  type ActionResult,
  type FlowState,
  type SerializeOptions,
  type GameStateSnapshot,
  type PlayerStateView,
} from '@boardsmith/engine';




export interface GameRunnerOptions<G extends Game> {

  GameClass: new (options: GameOptions) => G;

  gameType: string;

  gameOptions: GameOptions;

  serializeOptions?: SerializeOptions;
}




export interface ActionExecutionResult {

  success: boolean;

  error?: string;

  serializedAction?: SerializedAction;

  flowState?: FlowState;

  playerViews?: PlayerStateView[];
}





export class GameRunner<G extends Game = Game> {

  readonly game: G;


  readonly gameType: string;


  readonly actionHistory: SerializedAction[] = [];


  readonly seed?: string;


  private readonly serializeOptions: SerializeOptions;

  constructor(options: GameRunnerOptions<G>) {
    this.gameType = options.gameType;
    this.seed = options.gameOptions.seed;
    this.serializeOptions = options.serializeOptions ?? { useBranchPaths: true };

    this.game = new options.GameClass(options.gameOptions);
  }




  start(): FlowState {
    return this.game.startFlow();
  }




  performAction(
    actionName: string,
    player: Player | number,
    args: Record<string, unknown>
  ): ActionExecutionResult {
    const playerObj = typeof player === 'number'
      ? this.game.players[player]
      : player;

    if (!playerObj) {
      return {
        success: false,
        error: `Player not found`,
      };
    }

    const playerIndex = playerObj.position;


    if (!this.game.isAwaitingInput()) {
      return {
        success: false,
        error: 'Game is not awaiting input',
      };
    }


    if (!this.game.canPlayerAct(playerIndex)) {
      return {
        success: false,
        error: `Not ${playerObj.name}'s turn`,
      };
    }


    const actionDef = (this.game as any)._actions?.get(actionName);
    const isUndoable = actionDef?.undoable;


    const serializedAction = serializeAction(
      actionName,
      playerObj,
      args,
      this.game,
      this.serializeOptions,
      isUndoable
    );


    let flowState: FlowState;
    try {
      flowState = this.game.continueFlow(actionName, args, playerIndex);
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }


    this.actionHistory.push(serializedAction);

    return {
      success: true,
      serializedAction,
      flowState,
      playerViews: createAllPlayerViews(this.game),
    };
  }




  getFlowState(): FlowState | undefined {
    return this.game.getFlowState() ?? undefined;
  }




  getSnapshot(): GameStateSnapshot {
    return createSnapshot(
      this.game,
      this.gameType,
      this.actionHistory,
      this.seed
    );
  }




  getPlayerView(playerPosition: number): PlayerStateView {
    return createPlayerView(this.game, playerPosition);
  }




  getAllPlayerViews(): PlayerStateView[] {
    return createAllPlayerViews(this.game);
  }




  isComplete(): boolean {
    return this.game.getFlowState()?.complete ?? false;
  }




  getWinners(): Player[] {
    return this.game.getWinners();
  }




  static replay<G extends Game>(
    options: GameRunnerOptions<G>,
    actions: SerializedAction[]
  ): GameRunner<G> {
    const runner = new GameRunner(options);
    runner.start();

    for (const action of actions) {
      const { actionName, player, args } = deserializeAction(action, runner.game);
      const result = runner.performAction(actionName, player, args);

      if (!result.success) {
        throw new Error(`Replay failed at action ${action.name}: ${result.error}`);
      }
    }

    return runner;
  }





  static fromSnapshot<G extends Game>(
    snapshot: GameStateSnapshot,
    GameClass: new (options: GameOptions) => G
  ): GameRunner<G> {
    const runner = new GameRunner({
      GameClass,
      gameType: snapshot.gameType,
      gameOptions: {
        playerCount: snapshot.state.players.length,
        playerNames: snapshot.state.players.map(p => p.name as string),
        seed: snapshot.seed,
      },
    });


    runner.game.replayCommands(snapshot.commandHistory);


    runner.actionHistory.push(...snapshot.actionHistory);


    runner.start();
    for (const action of snapshot.actionHistory) {
      const { actionName, args } = deserializeAction(action, runner.game);
      runner.game.continueFlow(actionName, args);
    }

    return runner;
  }
}
````

## File: packages/session/src/ai-controller.ts
````typescript
import type { Game, SerializedAction } from '@boardsmith/engine';
import type { GameRunner } from '@boardsmith/runtime';
import { createBot, parseAILevel } from '@boardsmith/ai';
import type { GameClass, AIConfig } from './types.js';







export class AIController<G extends Game = Game> {
  readonly #aiPlayers: Set<number>;
  readonly #aiLevel: string;
  readonly #GameClass: GameClass<G>;
  readonly #gameType: string;
  #thinking = false;

  constructor(
    GameClass: GameClass<G>,
    gameType: string,
    playerCount: number,
    config: AIConfig
  ) {
    this.#GameClass = GameClass;
    this.#gameType = gameType;
    this.#aiLevel = config.level;
    this.#aiPlayers = new Set(
      config.players.filter(p => p >= 0 && p < playerCount)
    );
  }




  hasAIPlayers(): boolean {
    return this.#aiPlayers.size > 0;
  }




  isAIPlayer(playerIndex: number): boolean {
    return this.#aiPlayers.has(playerIndex);
  }




  isThinking(): boolean {
    return this.#thinking;
  }









  async checkAndPlay(
    runner: GameRunner<G>,
    actionHistory: SerializedAction[],
    onMove: (action: string, player: number, args: Record<string, unknown>) => Promise<boolean>
  ): Promise<{ action: string; player: number; args: Record<string, unknown> } | null> {

    if (this.#thinking) {
      return null;
    }

    const flowState = runner.getFlowState();

    if (!flowState?.awaitingInput || flowState.complete) {
      return null;
    }


    let aiPlayer: number | undefined;


    if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
      for (const playerState of flowState.awaitingPlayers) {
        if (!playerState.completed &&
            playerState.availableActions.length > 0 &&
            this.#aiPlayers.has(playerState.playerIndex)) {
          aiPlayer = playerState.playerIndex;
          break;
        }
      }
    } else if (flowState.currentPlayer !== undefined) {

      if (this.#aiPlayers.has(flowState.currentPlayer)) {
        aiPlayer = flowState.currentPlayer;
      }
    }


    if (aiPlayer === undefined) {
      return null;
    }

    this.#thinking = true;

    try {

      await new Promise(resolve => setTimeout(resolve, 300));



      const currentFlowState = runner.getFlowState();

      if (!currentFlowState?.awaitingInput || currentFlowState.complete) {
        return null;
      }


      let stillOurTurn = false;
      if (currentFlowState.awaitingPlayers && currentFlowState.awaitingPlayers.length > 0) {
        const playerState = currentFlowState.awaitingPlayers.find(
          p => p.playerIndex === aiPlayer && !p.completed && p.availableActions.length > 0
        );
        stillOurTurn = playerState !== undefined;
      } else if (currentFlowState.currentPlayer === aiPlayer) {
        stillOurTurn = true;
      }

      if (!stillOurTurn) {

        return null;
      }


      const difficulty = parseAILevel(this.#aiLevel);
      const bot = createBot(
        runner.game,
        this.#GameClass,
        this.#gameType,
        aiPlayer,
        actionHistory,
        difficulty
      );


      const move = await bot.play();


      const success = await onMove(move.action, aiPlayer, move.args);

      if (success) {
        return { action: move.action, player: aiPlayer, args: move.args };
      }
    } catch (error) {
      console.error(`AI error for player ${aiPlayer}:`, error);
    } finally {
      this.#thinking = false;
    }

    return null;
  }
}
````

## File: packages/testing/src/debug.ts
````typescript
import type { Game, GameElement, Player, FlowEngine, FlowNode, Action, ActionContext } from '@boardsmith/engine';




export interface DebugStringOptions {

  showIds?: boolean;

  maxDepth?: number;

  showHidden?: boolean;

  showAttributes?: boolean;
}




















export function toDebugString(game: Game, options: DebugStringOptions = {}): string {
  const { showIds = true, maxDepth = 3, showAttributes = true } = options;

  const lines: string[] = [];


  lines.push(`Game: ${game.constructor.name}`);
  if ((game as any).phase) {
    lines.push(`Phase: ${(game as any).phase}`);
  }
  if (game.players.current) {
    lines.push(`Current Player: ${game.players.current.name} (position ${game.players.current.position})`);
  }
  lines.push('');

  // Players summary
  lines.push('Players:');
  for (const player of game.players) {
    const attrs: string[] = [];
    const playerAny = player as any;

    // Common attributes
    if (typeof playerAny.score === 'number') attrs.push(`score=${playerAny.score}`);
    if (typeof playerAny.actionsRemaining === 'number') attrs.push(`actions=${playerAny.actionsRemaining}`);
    if (playerAny.eliminated) attrs.push('ELIMINATED');


    const handCount = playerAny.hand?.all?.()?.length;
    const boardCount = playerAny.board?.all?.()?.length;
    if (handCount) attrs.push(`hand(${handCount})`);
    if (boardCount) attrs.push(`board(${boardCount})`);

    lines.push(`  [${player.position}] ${player.name}: ${attrs.join(', ') || '(no attributes)'}`);
  }
  lines.push('');

  // Element tree
  lines.push('Elements:');
  printElementTree(game, lines, 1, maxDepth, showIds, showAttributes);

  return lines.join('\n');
}

function printElementTree(
  element: GameElement,
  lines: string[],
  depth: number,
  maxDepth: number,
  showIds: boolean,
  showAttributes: boolean
): void {
  if (depth > maxDepth) {
    const childCount = element.all?.().length || 0;
    if (childCount > 0) {
      lines.push(`${'  '.repeat(depth)}... (${childCount} more elements)`);
    }
    return;
  }

  const children = element.all?.() || [];
  for (const child of children) {
    const idStr = showIds ? ` (id=${(child as any).id || (child as any)._t?.id || '?'})` : '';
    const name = (child as any).name || child.constructor.name;
    const count = child.all?.().length || 0;

    let attrStr = '';
    if (showAttributes) {
      const attrs: string[] = [];
      const childAny = child as any;
      // Common game element attributes
      if (typeof childAny.value !== 'undefined') attrs.push(`value=${childAny.value}`);
      if (typeof childAny.suit !== 'undefined') attrs.push(`suit=${childAny.suit}`);
      if (typeof childAny.rank !== 'undefined') attrs.push(`rank=${childAny.rank}`);
      if (childAny.isDead) attrs.push('DEAD');
      if (attrs.length > 0) attrStr = ` [${attrs.join(', ')}]`;
    }

    const countStr = count > 0 ? `: ${count} children` : '';
    lines.push(`${'  '.repeat(depth)}${name}${idStr}${attrStr}${countStr}`);

    printElementTree(child, lines, depth + 1, maxDepth, showIds, showAttributes);
  }
}

/**
 * Result from tracing an action's availability
 */
export interface ActionTraceResult {
  actionName: string;
  available: boolean;
  reason: string;
  details: ActionTraceDetail[];
}

export interface ActionTraceDetail {
  step: string;
  passed: boolean;
  info: string;
}














export function traceAction(
  game: Game,
  actionName: string,
  player?: Player
): ActionTraceResult {
  const details: ActionTraceDetail[] = [];
  const currentPlayer = player || game.players.current;


  const actions = (game as any).actions || {};
  const action = actions[actionName];

  if (!action) {
    return {
      actionName,
      available: false,
      reason: `Action '${actionName}' not found in game.actions`,
      details: [{ step: 'Lookup', passed: false, info: `No action named '${actionName}' exists` }],
    };
  }

  details.push({ step: 'Lookup', passed: true, info: `Found action '${actionName}'` });


  if (action.condition) {
    try {
      const ctx: Partial<ActionContext> = {
        game,
        player: currentPlayer,
        args: {},
      };
      const conditionResult = action.condition(ctx);
      details.push({
        step: 'Condition',
        passed: conditionResult,
        info: conditionResult ? 'Condition returned true' : 'Condition returned false',
      });

      if (!conditionResult) {
        return {
          actionName,
          available: false,
          reason: 'Action condition returned false',
          details,
        };
      }
    } catch (error) {
      details.push({
        step: 'Condition',
        passed: false,
        info: `Condition threw error: ${error instanceof Error ? error.message : String(error)}`,
      });
      return {
        actionName,
        available: false,
        reason: `Action condition threw error: ${error instanceof Error ? error.message : String(error)}`,
        details,
      };
    }
  } else {
    details.push({ step: 'Condition', passed: true, info: 'No condition (always allowed)' });
  }


  const selections = action.selections || [];
  for (let i = 0; i < selections.length; i++) {
    const selection = selections[i];
    const selName = selection.name || `selection${i}`;
    const selType = selection.type || 'unknown';

    if (selType === 'element') {
      try {
        const ctx: Partial<ActionContext> = {
          game,
          player: currentPlayer,
          args: {},
        };
        const elements = selection.getElements?.(ctx) || [];
        const filtered = selection.filter
          ? elements.filter((e: any) => selection.filter(e, ctx))
          : elements;

        details.push({
          step: `Selection '${selName}'`,
          passed: filtered.length > 0,
          info: `${filtered.length} valid elements (${elements.length} before filter)`,
        });

        if (filtered.length === 0) {
          return {
            actionName,
            available: false,
            reason: `No valid elements for selection '${selName}'`,
            details,
          };
        }
      } catch (error) {
        details.push({
          step: `Selection '${selName}'`,
          passed: false,
          info: `Error evaluating: ${error instanceof Error ? error.message : String(error)}`,
        });
        return {
          actionName,
          available: false,
          reason: `Error in selection '${selName}'`,
          details,
        };
      }
    } else if (selType === 'choice') {
      try {
        const ctx: Partial<ActionContext> = {
          game,
          player: currentPlayer,
          args: {},
        };
        const choices = selection.getChoices?.(ctx) || [];
        details.push({
          step: `Selection '${selName}'`,
          passed: choices.length > 0,
          info: `${choices.length} choices available`,
        });

        if (choices.length === 0) {
          return {
            actionName,
            available: false,
            reason: `No choices available for selection '${selName}'`,
            details,
          };
        }
      } catch (error) {
        details.push({
          step: `Selection '${selName}'`,
          passed: false,
          info: `Error evaluating: ${error instanceof Error ? error.message : String(error)}`,
        });
      }
    } else {
      details.push({
        step: `Selection '${selName}'`,
        passed: true,
        info: `Type '${selType}' (assumed available)`,
      });
    }
  }

  return {
    actionName,
    available: true,
    reason: 'Action available',
    details,
  };
}

















export function visualizeFlow(flow: FlowNode, indent: string = ''): string {
  const lines: string[] = [];
  const nodeType = flow.type || 'unknown';
  const config = (flow as any).config || {};


  let desc = nodeType;
  if (config.name) desc += ` "${config.name}"`;
  if (nodeType === 'action-step' && config.actions) {
    desc += ` [${Array.isArray(config.actions) ? config.actions.join(', ') : 'dynamic'}]`;
  }
  if (nodeType === 'loop' && config.while) {
    desc += ' (while: ...)';
  }
  if (nodeType === 'switch') {
    desc += ' (cases)';
  }

  lines.push(`${indent}${desc}`);


  const children: FlowNode[] = [];
  if (config.do) {
    if (Array.isArray(config.do)) {
      children.push(...config.do);
    } else {
      children.push(config.do);
    }
  }
  if (config.steps) {
    children.push(...config.steps);
  }
  if (config.cases) {
    for (const [key, caseNode] of Object.entries(config.cases)) {
      lines.push(`${indent}  case "${key}":`);
      lines.push(visualizeFlow(caseNode as FlowNode, indent + '    '));
    }
  }

  const childIndent = indent + '  ';
  for (let i = 0; i < children.length; i++) {
    const isLast = i === children.length - 1;
    const prefix = isLast ? ' ' : ' ';
    const childLines = visualizeFlow(children[i], childIndent + (isLast ? '   ' : '  ')).split('\n');
    lines.push(`${childIndent.slice(0, -2)}${prefix}${childLines[0].trim()}`);
    lines.push(...childLines.slice(1));
  }

  return lines.join('\n');
}














export function logAvailableActions(game: Game, player?: Player): string {
  const currentPlayer = player || game.players.current;
  const lines: string[] = [`Available actions for ${currentPlayer?.name || 'current player'}:`];

  const actions = (game as any).actions || {};
  for (const actionName of Object.keys(actions)) {
    const trace = traceAction(game, actionName, currentPlayer);
    const icon = trace.available ? '' : '';
    lines.push(`  ${icon} ${actionName} - ${trace.reason}`);
  }

  return lines.join('\n');
}




export interface FlowStateDebug {

  currentPhase: string;

  nodeStack: string[];

  currentPlayer?: number;

  availableActions: string[];

  awaitingInput: boolean;

  description: string;
}














export function debugFlowState(testGame: any): FlowStateDebug {
  const runner = testGame.runner;
  const game = testGame.game;


  const flowState = runner?.getFlowState?.() || {};

  const result: FlowStateDebug = {
    currentPhase: flowState.phase || 'unknown',
    nodeStack: [],
    availableActions: flowState.availableActions || [],
    awaitingInput: flowState.awaitingInput || false,
    description: '',
  };

  if (typeof flowState.currentPlayer === 'number') {
    result.currentPlayer = flowState.currentPlayer;
  }


  const flowEngine = runner?.flowEngine || (runner as any)?._flow;
  if (flowEngine) {
    const stack = extractNodeStack(flowEngine);
    result.nodeStack = stack;
  }


  const parts: string[] = [];

  if (result.currentPhase && result.currentPhase !== 'unknown') {
    parts.push(`In phase '${result.currentPhase}'`);
  }

  if (result.awaitingInput) {
    const playerName = result.currentPlayer !== undefined
      ? `Player ${result.currentPlayer}`
      : 'a player';

    if (result.availableActions.length > 0) {
      parts.push(`waiting for ${playerName} to choose: [${result.availableActions.join(', ')}]`);
    } else {
      parts.push(`waiting for ${playerName}`);
    }
  } else {
    parts.push('processing');
  }

  result.description = parts.join(', ');

  return result;
}




function extractNodeStack(flowEngine: any): string[] {
  const stack: string[] = [];


  const frames = flowEngine?.frames || flowEngine?._frames || [];
  for (const frame of frames) {
    const nodeType = frame.node?.type || frame.type || 'node';
    const nodeName = frame.node?.config?.name || frame.name || '';
    stack.push(nodeName ? `${nodeType} '${nodeName}'` : nodeType);
  }

  // If no frames, try to get current node info
  if (stack.length === 0 && flowEngine?.currentNode) {
    const node = flowEngine.currentNode;
    const nodeType = node.type || 'node';
    const nodeName = node.config?.name || '';
    stack.push(nodeName ? `${nodeType} '${nodeName}'` : nodeType);
  }

  return stack;
}

/**
 * Visualize the flow with the current position highlighted.
 * Similar to visualizeFlow but marks where execution currently is.
 *
 * @example
 * ```typescript
 * console.log(visualizeFlowWithPosition(gameDefinition.flow, testGame));
 * // sequence "main"
 * //    phase "setup" 
 * //    loop "rounds"
 * //      eachPlayer
 * //        actionStep [play, draw, pass]  CURRENT
 * //      execute (cleanup)
 * //    execute (endGame)
 * ```
 */
export function visualizeFlowWithPosition(flow: FlowNode, testGame?: any): string {
  const currentInfo = testGame ? debugFlowState(testGame) : null;
  const currentNodeNames = new Set(
    currentInfo?.nodeStack.map(s => {
      const match = s.match(/'([^']+)'/);
      return match ? match[1] : '';
    }).filter(Boolean) || []
  );

  return visualizeFlowWithHighlight(flow, '', currentNodeNames, currentInfo?.currentPhase || '');
}

function visualizeFlowWithHighlight(
  flow: FlowNode,
  indent: string,
  currentNames: Set<string>,
  currentPhase: string
): string {
  const lines: string[] = [];
  const nodeType = flow.type || 'unknown';
  const config = (flow as any).config || {};
  const nodeName = config.name || '';

  // Build node description
  let desc = nodeType;
  if (nodeName) desc += ` "${nodeName}"`;
  if (nodeType === 'action-step' && config.actions) {
    desc += ` [${Array.isArray(config.actions) ? config.actions.join(', ') : 'dynamic'}]`;
  }
  if (nodeType === 'loop' && config.while) {
    desc += ' (while: ...)';
  }


  const isCurrent = (nodeName && currentNames.has(nodeName)) || (nodeType === 'phase' && nodeName === currentPhase);
  if (isCurrent) {
    desc += '  CURRENT';
  }

  lines.push(`${indent}${desc}`);


  const children: FlowNode[] = [];
  if (config.do) {
    if (Array.isArray(config.do)) {
      children.push(...config.do);
    } else {
      children.push(config.do);
    }
  }
  if (config.steps) {
    children.push(...config.steps);
  }
  if (config.cases) {
    for (const [key, caseNode] of Object.entries(config.cases)) {
      lines.push(`${indent}  case "${key}":`);
      lines.push(visualizeFlowWithHighlight(caseNode as FlowNode, indent + '    ', currentNames, currentPhase));
    }
  }

  const childIndent = indent + '  ';
  for (let i = 0; i < children.length; i++) {
    const isLast = i === children.length - 1;
    const prefix = isLast ? ' ' : ' ';
    const childLines = visualizeFlowWithHighlight(
      children[i],
      childIndent + (isLast ? '   ' : '  '),
      currentNames,
      currentPhase
    ).split('\n');
    lines.push(`${childIndent.slice(0, -2)}${prefix}${childLines[0].trim()}`);
    lines.push(...childLines.slice(1));
  }

  return lines.join('\n');
}













export function diffSnapshots(before: string, after: string): string {
  const beforeObj = JSON.parse(before);
  const afterObj = JSON.parse(after);

  const diffs: string[] = [];
  findDiffs(beforeObj, afterObj, '', diffs);

  if (diffs.length === 0) {
    return 'No changes detected';
  }

  return `Changes:\n${diffs.map(d => `  ${d}`).join('\n')}`;
}

function findDiffs(before: any, after: any, path: string, diffs: string[]): void {
  if (typeof before !== typeof after) {
    diffs.push(`${path}: type changed from ${typeof before} to ${typeof after}`);
    return;
  }

  if (typeof before !== 'object' || before === null) {
    if (before !== after) {
      diffs.push(`${path}: ${JSON.stringify(before)}  ${JSON.stringify(after)}`);
    }
    return;
  }

  if (Array.isArray(before)) {
    if (!Array.isArray(after)) {
      diffs.push(`${path}: array  non-array`);
      return;
    }
    if (before.length !== after.length) {
      diffs.push(`${path}: length ${before.length}  ${after.length}`);
    }
    const maxLen = Math.max(before.length, after.length);
    for (let i = 0; i < maxLen; i++) {
      findDiffs(before[i], after[i], `${path}[${i}]`, diffs);
    }
    return;
  }

  const allKeys = new Set([...Object.keys(before), ...Object.keys(after)]);
  for (const key of allKeys) {
    const subPath = path ? `${path}.${key}` : key;
    if (!(key in before)) {
      diffs.push(`${subPath}: added (${JSON.stringify(after[key])})`);
    } else if (!(key in after)) {
      diffs.push(`${subPath}: removed (was ${JSON.stringify(before[key])})`);
    } else {
      findDiffs(before[key], after[key], subPath, diffs);
    }
  }
}
````

## File: docs/actions-and-flow.md
````markdown
# Actions & Flow System

This document covers the Action builder API and the declarative Flow system for controlling game structure.

## Actions

Actions define what players can do during the game. They use a fluent builder pattern.

### Basic Action Structure

```typescript
import { Action, type ActionDefinition } from '@boardsmith/engine';

export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('actionName')
    .prompt('Description shown to player')
    .condition((ctx) => /* when this action is available */)
    .chooseFrom('selection', { /* selection options */ })
    .execute((args, ctx) => {
      // Game logic here
      return { success: true };
    });
}
```

### Selection Methods

#### `chooseFrom<T>` - Choose from a list

```typescript
Action.create('selectRank')
  .chooseFrom<string>('rank', {
    prompt: 'Choose a rank to ask for',
    choices: (ctx) => ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],
  })
```

#### `chooseElement<T>` - Choose a game element

```typescript
Action.create('placeStone')
  .chooseElement<Cell>('cell', {
    prompt: 'Select an empty cell',
    elementClass: Cell,
    filter: (cell, ctx) => cell.isEmpty(),
    display: (cell) => cell.notation,        // Display text
    boardRef: (cell) => ({ id: cell.id }),   // For UI highlighting
  })
```

#### `playerChoices` - Choose a player with chooseFrom

Use the `playerChoices()` helper on your Game class to generate player choices for use with `chooseFrom`:

```typescript
Action.create('askPlayer')
  .chooseFrom('target', {
    prompt: 'Who do you want to ask?',
    choices: (ctx) => game.playerChoices({ excludeSelf: true, currentPlayer: ctx.player }),
  })
  .execute((args, ctx) => {
    // playerChoices returns { value: number; display: string } objects
    const choice = args.target as { value: number; display: string };
    const targetPlayer = game.players[choice.value];
    // ...
  });
```

The `playerChoices()` helper supports:
- `excludeSelf: true` - Filter out the current player
- `currentPlayer` - Required when using excludeSelf
- `filter: (player) => boolean` - Custom filter function

#### `chooseNumber` - Enter a number

```typescript
Action.create('bid')
  .chooseNumber('amount', {
    prompt: 'Enter your bid',
    min: 1,
    max: (ctx) => ctx.player.coins,
  })
```

#### `chooseText` - Enter text

```typescript
Action.create('name')
  .chooseText('name', {
    prompt: 'Enter a name',
    maxLength: 20,
  })
```

### Chaining Selections

Actions can have multiple selections that depend on each other:

```typescript
Action.create('move')
  .chooseElement<Piece>('piece', {
    prompt: 'Select a piece to move',
    elementClass: Piece,
    filter: (p, ctx) => p.player === ctx.player,
  })
  .chooseElement<Cell>('destination', {
    prompt: 'Select destination',
    elementClass: Cell,
    // Filter depends on previously selected piece
    filter: (cell, ctx) => {
      const piece = ctx.args.piece as Piece;
      return piece.canMoveTo(cell);
    },
  })
```

> **IMPORTANT: Handling Undefined in Multi-Step Selections**
>
> BoardSmith evaluates ALL filters during availability checks, even for selections the player hasn't made yet. This means `ctx.args.piece` will be `undefined` when checking if the action should be available.
>
> **This will crash:**
> ```typescript
> filter: (cell, ctx) => {
>   const piece = ctx.args.piece as Piece;
>   return piece.canMoveTo(cell);  // ERROR: Cannot read 'canMoveTo' of undefined
> }
> ```
>
> **Correct pattern:**
> ```typescript
> filter: (cell, ctx) => {
>   const piece = ctx.args?.piece as Piece | undefined;
>
>   if (!piece) {
>     // Availability check - no piece selected yet
>     // Return true if this cell would be valid for ANY movable piece
>     return getMovablePieces(ctx.player).some(p => p.canMoveTo(cell));
>   }
>
>   // Actual selection - piece is selected
>   return piece.canMoveTo(cell);
> }
> ```
>
> See [Common Pitfalls](./common-pitfalls.md#2-multi-step-selection-filters) for more details.

### Conditions

Control when actions are available:

```typescript
Action.create('draw')
  .condition((ctx) => {
    // Only available when deck has cards
    return game.deck.count(Card) > 0;
  })
  .execute(...)
```

### Validation

Validate the complete action before execution:

```typescript
Action.create('play')
  .chooseFrom('cards', { choices: getPlayableCards, multi: true })
  .validate((args, ctx) => {
    const cards = args.cards as Card[];
    if (cards.length < 2) {
      return { valid: false, message: 'Must play at least 2 cards' };
    }
    return { valid: true };
  })
  .execute(...)
```

### Execute Function

The execute function performs the actual game logic:

```typescript
.execute((args, ctx) => {
  const player = ctx.player as MyPlayer;
  const card = args.card as Card;

  // Perform game actions (generates commands automatically)
  card.putInto(game.discardPile);
  player.score += card.value;

  // Add game message
  game.message(`${player.name} played ${card.name}`);

  // Return result
  return {
    success: true,
    message: 'Card played successfully',
    data: { cardId: card.id },
  };
});
```

> **Important:** When using `chooseElement`, the `args` contain the **full serialized element object**, not just the ID. To find the element by ID:
> ```typescript
> const elementId = typeof args.piece === 'object' ? (args.piece as any).id : args.piece;
> const piece = game.all(Piece).find(p => p.id === elementId);
> ```
> Also, always use `ctx.game` instead of a closure reference to the game variable in execute functions to avoid stale references during hot-reload.

### Action Options

```typescript
Action.create('move')
  .prompt('Move your piece')
  .notUndoable()                    // Cannot undo this action
  .skipIf((ctx) => /* condition */) // Skip if condition is true
```

### Example: Go Fish Ask Action

From `packages/games/go-fish/rules/src/actions.ts`:

```typescript
export function createAskAction(game: GoFishGame): ActionDefinition {
  return Action.create('ask')
    .prompt('Ask another player for a card')
    .chooseFrom('target', {
      prompt: 'Who do you want to ask?',
      choices: (ctx) => game.playerChoices({ excludeSelf: true, currentPlayer: ctx.player }),
      boardRefs: (choice: { value: number; display: string }, ctx) => {
        const targetPlayer = game.players[choice.value] as GoFishPlayer;
        return { targetRef: { id: game.getPlayerHand(targetPlayer).id } };
      },
    })
    .chooseFrom<string>('rank', {
      prompt: 'What rank do you want?',
      choices: (ctx) => game.getPlayerRanks(ctx.player as GoFishPlayer),
      display: (rank) => {
        const names: Record<string, string> = {
          'A': 'Aces', '2': 'Twos', '3': 'Threes', '4': 'Fours',
          '5': 'Fives', '6': 'Sixes', '7': 'Sevens', '8': 'Eights',
          '9': 'Nines', '10': 'Tens', 'J': 'Jacks', 'Q': 'Queens', 'K': 'Kings'
        };
        return names[rank] ?? rank;
      },
    })
    .execute((args, ctx) => {
      const player = ctx.player as GoFishPlayer;
      const targetChoice = args.target as { value: number; display: string };
      const target = game.players[targetChoice.value] as GoFishPlayer;
      const rank = args.rank as string;

      const matchingCards = game.getCardsOfRank(target, rank);

      if (matchingCards.length > 0) {
        for (const card of matchingCards) {
          card.putInto(game.getPlayerHand(player));
        }
        game.message(`${player.name} got ${matchingCards.length} ${rank}(s) from ${target.name}!`);
        // Player gets another turn when they receive cards
      } else {
        game.message(`${target.name} says "Go Fish!"`);
        // Player draws from pond
      }

      return { success: true };
    });
}
```

## Flow System

The Flow system defines game structure using composable nodes.

### Flow Definition

```typescript
import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from '@boardsmith/engine';

export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: /* flow node */,
    isComplete: (ctx) => game.isFinished(),
    getWinners: (ctx) => game.getWinners(),
  };
}
```

### Flow Nodes

#### `sequence` - Run steps in order

```typescript
sequence(
  actionStep({ actions: ['draw'] }),
  actionStep({ actions: ['play'] }),
)
```

#### `loop` - Repeat while condition is true

```typescript
loop({
  name: 'game-loop',
  while: (ctx) => !game.isFinished(),
  maxIterations: 1000,  // Safety limit
  do: /* flow node */,
})
```

#### `repeat` - Fixed number of iterations

```typescript
repeat({
  name: 'deal-cards',
  times: 5,
  do: actionStep({ actions: ['deal'] }),
})
```

#### `eachPlayer` - Iterate over players

```typescript
eachPlayer({
  name: 'player-turns',
  order: TurnOrder.clockwise(),
  filter: (player, ctx) => !player.hasPassed,
  do: /* flow node */,
})
```

#### `forEach` - Iterate over array

```typescript
forEach({
  name: 'score-hands',
  collection: (ctx) => game.players,
  do: (player) => execute({
    do: () => game.scoreHand(player),
  }),
})
```

#### `actionStep` - Wait for player action

```typescript
actionStep({
  name: 'move-step',
  actions: ['move', 'jump'],      // Available actions
  prompt: 'Move or jump a piece',
  skipIf: (ctx) => game.isFinished(),
})
```

#### `simultaneousActionStep` - All players act at once

```typescript
simultaneousActionStep({
  name: 'discard-step',
  actions: ['discard'],
  prompt: 'Choose cards to discard',
})
```

#### `phase` - Named game phase

```typescript
phase('setup', {
  do: sequence(
    execute({ do: () => game.deal() }),
    simultaneousActionStep({ actions: ['discard'] }),
  ),
})
```

#### `switchOn` - Conditional branching

```typescript
switchOn({
  value: (ctx) => game.currentPhase,
  cases: {
    'deal': /* flow node */,
    'play': /* flow node */,
    'score': /* flow node */,
  },
  default: /* flow node */,
})
```

#### `ifThen` - If-else logic

```typescript
ifThen({
  if: (ctx) => game.deck.count(Card) > 0,
  then: actionStep({ actions: ['draw'] }),
  else: execute({ do: () => game.endRound() }),
})
```

#### `execute` - Run code

```typescript
execute({
  name: 'shuffle-deck',
  do: (ctx) => {
    game.deck.shuffle();
    game.message('Deck shuffled!');
  },
})
```

#### `setVar` - Set flow variable

```typescript
setVar({
  name: 'roundNumber',
  value: (ctx) => (ctx.vars.roundNumber ?? 0) + 1,
})
```

### Turn Order

Control player order with `TurnOrder`:

```typescript
eachPlayer({
  order: TurnOrder.roundRobin(),       // Default: 0, 1, 2, ...
  order: TurnOrder.clockwise(),        // Same as roundRobin
  order: TurnOrder.counterClockwise(), // Reverse
  order: TurnOrder.custom((players, ctx) => {
    // Return players in custom order
    return players.sort((a, b) => a.score - b.score);
  }),
})
```

### Flow Variables

Access and set variables during flow:

```typescript
// Set variable
setVar({ name: 'dealer', value: (ctx) => ctx.players[0] })

// Access in conditions
loop({
  while: (ctx) => ctx.vars.roundNumber < 10,
  do: ...
})
```

### Example: Cribbage Flow

Complex multi-phase flow from `packages/games/cribbage/`:

```typescript
export function createCribbageFlow(game: CribbageGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: sequence(
        // Deal phase
        phase('deal', {
          do: execute({ do: () => game.dealHands() }),
        }),

        // Discard phase - all players discard simultaneously
        phase('discard', {
          do: simultaneousActionStep({
            actions: ['discard'],
            prompt: 'Discard 2 cards to the crib',
          }),
        }),

        // Play phase - alternating card play
        phase('play', {
          do: loop({
            while: () => !game.playPhaseComplete(),
            do: eachPlayer({
              do: actionStep({
                actions: ['playCard', 'sayGo'],
                skipIf: (ctx) => !game.canPlay(ctx.player),
              }),
            }),
          }),
        }),

        // Show phase - score hands
        phase('show', {
          do: forEach({
            collection: () => game.getShowOrder(),
            do: (player) => execute({
              do: () => game.scoreHand(player),
            }),
          }),
        }),

        // Rotate dealer
        execute({ do: () => game.rotateDealer() }),
      ),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### Example: Simple Turn-Based Flow (Hex)

Minimal flow from `packages/games/hex/`:

```typescript
export function createHexFlow(game: HexGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      maxIterations: 100,
      do: eachPlayer({
        name: 'player-turns',
        filter: (player) => !game.isFinished(),
        do: actionStep({
          name: 'place-stone',
          actions: ['placeStone'],
          skipIf: () => game.isFinished(),
        }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.winner ? [game.winner] : [],
  };
}
```

## Registering Actions

Actions must be registered in your Game constructor:

```typescript
constructor(options) {
  super(options);
  // ... element setup ...

  this.registerAction(createMoveAction(this));
  this.registerAction(createDrawAction(this));
  this.registerAction(createPlayAction(this));

  this.setFlow(createGameFlow(this));
}
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Elements and state management
- [UI Components](./ui-components.md) - Displaying actions in the UI
- [Game Examples](./game-examples.md) - Real implementations
````

## File: docs/llm-overview.md
````markdown
# BoardSmith LLM Overview

This document provides a comprehensive overview of the BoardSmith framework optimized for LLM consumption. Use this to quickly understand the project architecture and key patterns.

## What is BoardSmith?

BoardSmith is a TypeScript framework for building turn-based multiplayer board and card games. It provides:

- **Element-based state management** - Games are trees of typed elements (Board, Deck, Hand, Piece, Card)
- **Declarative flow system** - Define game structure with composable flow nodes
- **Action builder API** - Fluent API for defining player actions with selections and validation
- **Event-sourced commands** - All state mutations are tracked and replayable
- **Automatic UI generation** - AutoUI can render any game without custom components
- **MCTS AI** - Game-agnostic AI opponents using Monte-Carlo Tree Search
- **Multiplayer networking** - WebSocket-based real-time game sessions

## Project Structure

```
BoardSmith/
 packages/
    engine/       # Core framework (~15k lines)
    runtime/      # Game execution
    session/      # Session management
    ai/           # MCTS bot (~700 lines)
    ui/           # Vue 3 components (~15k lines)
    client/       # Browser networking
    server/       # Platform-agnostic server
    worker/       # Cloudflare Workers runtime
    cli/          # Dev tools
    testing/      # Test utilities
    games/        # Example games
        hex/      # Simplest example
        go-fish/  # Card game patterns
        checkers/ # Grid + multi-step
        cribbage/ # Complex multi-phase
 docs/             # Documentation
```

## Key Concepts

### 1. Element Tree

Games are represented as a tree of `GameElement` objects:

```
Game (root)
 Board (Space)
    Cell (Space)  Piece
 Deck (Space)  Card, Card, ...
 Hand (Space)  Card (owner sees)
 Pile (removed elements)
```

**Element types**: `Space` (container), `Deck`, `Hand`, `Grid`, `HexGrid`, `Piece`, `Card`

### 2. Actions vs Commands

**Actions** = What players do (high-level, game-specific)
```typescript
Action.create('move')
  .chooseElement('piece', { filter: p => p.player === ctx.player })
  .chooseElement('dest', { filter: c => c.isEmpty() })
  .execute((args) => args.piece.putInto(args.dest));
```

**Commands** = How state changes (low-level, generic, event-sourced)
```typescript
// Generated automatically by element methods
{ type: 'move', elementId: 42, targetId: 17 }
```

### 3. Flow System

Declarative game flow with composable nodes:

```typescript
const flow: FlowDefinition = {
  root: loop({
    while: () => !game.isFinished(),
    do: eachPlayer({
      do: actionStep({ actions: ['move'] }),
    }),
  }),
  isComplete: () => game.isFinished(),
  getWinners: () => game.getWinners(),
};
```

**Flow nodes**: `sequence`, `loop`, `repeat`, `eachPlayer`, `forEach`, `actionStep`, `simultaneousActionStep`, `phase`, `switchOn`, `ifThen`, `execute`, `setVar`

### 4. Visibility System

Control what players can see:

```typescript
deck.contentsHidden();           // Hidden from all
hand.contentsVisibleToOwner();   // Only owner sees
board.contentsVisible();         // Everyone sees
```

## Creating a Game

### 1. Initialize Project

```bash
npx boardsmith init my-game
cd my-game
npm install
boardsmith dev
```

### 2. Define Elements

```typescript
// elements.ts
export class Card extends BaseCard {
  suit!: 'H' | 'D' | 'C' | 'S';
  rank!: string;
}
export class Hand extends BaseHand {}
export class Deck extends BaseDeck {}
```

### 3. Define Actions

```typescript
// actions.ts
export function createPlayAction(game: MyGame): ActionDefinition {
  return Action.create('play')
    .chooseFrom<Card>('card', {
      choices: (ctx) => [...ctx.player.hand.all(Card)],
    })
    .execute((args) => {
      const card = args.card as Card;
      card.remove();
      ctx.player.score += 1;
    });
}
```

### 4. Define Flow

```typescript
// flow.ts
export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: actionStep({ actions: ['play'] }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### 5. Game Class

```typescript
// game.ts
export class MyGame extends Game<MyGame, MyPlayer> {
  deck!: Deck;

  constructor(options: MyGameOptions) {
    super(options);
    this.registerElements([Card, Hand, Deck]);
    this.deck = this.create(Deck, 'deck');
    // ... setup ...
    this.registerAction(createPlayAction(this));
    this.setFlow(createGameFlow(this));
  }

  override isFinished(): boolean {
    return this.deck.count(Card) === 0;
  }
}
```

## Common Patterns

### Conditional Turns (Go Again)

```typescript
.execute((args, ctx) => {
  if (gotMatch) {
    return { success: true, data: { extraTurn: true } };
  }
  return { success: true, data: { extraTurn: false } };
});

// In flow
execute((ctx) => {
  if (!ctx.lastActionResult?.data?.extraTurn) {
    ctx.set('turnEnded', true);
  }
})
```

### Multi-Step Actions (Jump Chains)

```typescript
.execute((args, ctx) => {
  if (canContinueJumping) {
    game.pendingJumpPiece = piece;
    game.setPlayerGoesAgain(true);
  }
});
```

### Simultaneous Actions

```typescript
simultaneousActionStep({
  actions: ['discard'],
  playerDone: (ctx, player) => player.hand.count(Card) <= 4,
  allDone: (ctx) => game.allPlayersDiscarded(),
})
```

### Phase-Based Games

```typescript
sequence(
  phase('deal', { do: execute(() => game.deal()) }),
  phase('discard', { do: simultaneousActionStep({ actions: ['discard'] }) }),
  phase('play', { do: playLoop }),
  phase('score', { do: execute(() => game.score()) }),
)
```

## UI Components

**Core**: `GameShell`, `DebugPanel`, `PlayersPanel`, `GameHistory`

**Helpers**: `Draggable`, `DiceRoller`, `CardFan`, `DeckPile`, `FlyingCardsOverlay`

**Auto-UI**: `AutoUI`, `AutoGameBoard`, `AutoElement`, `ActionPanel`

**Composables**:
- `useBoardInteraction` - Board  ActionPanel communication
- `useElementAnimation` - FLIP animations
- `useCardFlip`, `useFlyingCards` - Card animations
- `useGameViewHelpers` - Query game state
- `useGameGrid`, `useHexGrid` - Grid utilities
- `useCardDisplay` - Card formatting

## Dice & Scoring Systems

### Dice Elements

```typescript
// Die extends Piece with sides/value
class MyDie extends Die<MyGame, MyPlayer> {
  color?: 'red' | 'blue';
}

// DicePool is a Space for holding dice
this.shelf = this.create(DicePool, 'shelf');
this.shelf.create(MyDie, 'd6-1', { sides: 6 });
```

### Ability System

```typescript
import { AbilityManager } from '@boardsmith/engine';

type PowerUp = 'reroll' | 'flip' | 'bonus';

class MyPlayer extends Player<MyGame, MyPlayer> {
  abilities = new AbilityManager<PowerUp>();

  constructor() {
    this.abilities.add('reroll', 'starting');
  }
}

// Usage
if (player.abilities.hasUnused('reroll')) {
  player.abilities.use('reroll');
}
```

### Scoring Tracks

```typescript
import { MonotonicTrack, UniqueTrack, CounterTrack } from '@boardsmith/engine';

// Increasing/decreasing sequence tracks
const track = new MonotonicTrack({
  id: 'score',
  direction: 'increasing',  // or 'decreasing'
  maxEntries: 10,
  pointsPerEntry: [0, 1, 3, 6, 11, 16, 23, 30, 40, 50],
});

track.canAdd(15);   // Check if value fits sequence
track.add(15);      // Add value, returns points earned

// Simple counter tracks
const counter = new CounterTrack({
  id: 'bonus',
  maxEntries: 6,
  pointsPerCount: 10,
});

counter.increment();
counter.calculatePoints();  // Returns total points
```

## AI System

```typescript
import { createBot } from '@boardsmith/ai';

const bot = createBot(game, MyGame, 'my-game', 1, [], 'hard');
const move = await bot.play();
```

**Difficulty levels**: `easy` (3 iter), `medium` (5 iter), `hard` (8 iter)

**Custom objectives** for better play:
```typescript
const aiConfig = {
  objectives: (game, playerIndex) => ({
    materialAdvantage: {
      checker: (g, p) => myPieces > oppPieces,
      weight: 0.5,
    },
  }),
};
```

## CLI Commands

```bash
boardsmith init <name>    # Create new game
boardsmith dev            # Start dev server
boardsmith dev --ai 1     # Player 1 is AI
boardsmith test           # Run tests
boardsmith validate       # Validate before publish
boardsmith build          # Production build
boardsmith publish        # Publish to boardsmith.io
```

## Example Games Reference

| Game | File | Key Patterns |
|------|------|--------------|
| Hex | `packages/games/hex/rules/src/` | Simple flow, hex grid, single action |
| Go Fish | `packages/games/go-fish/rules/src/` | Cards, hidden info, conditional turns |
| Checkers | `packages/games/checkers/rules/src/` | Grid, multi-step jumps, promotion |
| Cribbage | `packages/games/cribbage/rules/src/` | Multi-phase, simultaneous, scoring |
| Polyhedral Potions | `packages/games/polyhedral-potions/rules/src/` | Dice, 3D rendering, abilities, scoring tracks |

## Key Files to Understand

1. **Engine core**: `packages/engine/src/`
   - `game.ts` - Game base class
   - `element/` - Element system
   - `action/` - Action builder
   - `flow/` - Flow system
   - `command/` - Command types

2. **Example game**: `packages/games/hex/rules/src/`
   - `game.ts` - Minimal game class
   - `elements.ts` - Custom elements
   - `actions.ts` - Action definitions
   - `flow.ts` - Simple flow

3. **UI**: `packages/ui/src/`
   - `components/GameShell.vue` - Main wrapper
   - `composables/` - Reusable logic

## Architecture Summary

```
User Action  Action System  Commands  State Change
                                           
            Flow System  Game State  Serialization
                                     
                              Player Views  UI Render
```

- **Actions** validate and execute player intent
- **Commands** are event-sourced state mutations
- **Flow** controls game structure and turn order
- **State** is an element tree, serializable to JSON
- **Player Views** filter state by visibility rules
- **UI** renders views and submits actions

## Common Pitfalls

### Custom Player Properties Not Showing in UI

If your custom Player class has properties (score, abilities, etc.) that aren't appearing in the UI, you need to override `toJSON()`:

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  score: number = 0;
  abilities: Record<string, number> = { reroll: 1 };

  // REQUIRED: Include custom properties in serialization
  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      score: this.score,
      abilities: this.abilities,
    };
  }
}
```

The base `Player.toJSON()` only serializes `position`, `name`, `color`, `avatar`.

### PlayerCollection Array Subclass Gotcha

`game.players` is a `PlayerCollection` (Array subclass). When mapping player data, **always spread to a plain Array**:

```typescript
//  WRONG: map() returns PlayerCollection, which has its own toJSON()
const data = game.players.map(p => p.toJSON());

//  CORRECT: Spread converts to plain Array
const data = [...game.players.map(p => p.toJSON())];
```

This is because JavaScript's `.map()` on an Array subclass returns an instance of the same subclass, and `PlayerCollection.toJSON()` will re-serialize the data, losing custom properties.

### chooseElement Args Are Objects, Not IDs

When using `chooseElement` in actions, the args passed to `execute()` contain the **full serialized element object**, not just the element ID:

```typescript
//  WRONG: args.die is an object, not a number
.chooseElement<Die>('die', { ... })
.execute((args, ctx) => {
  const dieId = args.die as number;  // This is actually an object!
  const die = game.all(Die).find(d => d.id === dieId);  // Never finds it
});

//  CORRECT: Extract the ID from the object
.execute((args, ctx) => {
  const dieId = typeof args.die === 'object' ? (args.die as any).id : args.die as number;
  const die = game.all(Die).find(d => d.id === dieId);
});
```

The args object looks like: `{ die: { className: "Die", id: 3, attributes: {...} } }`

### Action Closures and ctx.game

In action execute functions, always use `ctx.game` instead of a closure reference to the game:

```typescript
//  WRONG: Closure reference can become stale
export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('myAction')
    .execute((args, ctx) => {
      game.doSomething();  // Uses closure - may be stale after hot-reload
    });
}

//  CORRECT: Use ctx.game for the current game instance
export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('myAction')
    .execute((args, ctx) => {
      const currentGame = ctx.game as MyGame;
      currentGame.doSomething();  // Always uses current game
    });
}
```
````

## File: packages/engine/src/player/index.ts
````typescript
export { Player, PlayerCollection } from './player.js';

export { AbilityManager } from './abilities.js';

export type { Ability } from './abilities.js';
````

## File: packages/engine/src/utils/snapshot.ts
````typescript
import type { Game } from '../element/game.js';
import type { GameCommand } from '../command/types.js';
import type { SerializedAction } from '../action/types.js';
import type { FlowState } from '../flow/types.js';
import type { ElementJSON } from '../element/types.js';




export interface GameStateSnapshot {

  version: number;


  gameType: string;


  state: {
    players: Record<string, unknown>[];
    phase: string;
    messages: Array<{ text: string; data?: Record<string, unknown> }>;
    settings: Record<string, unknown>;
  };


  flowState?: FlowState;


  commandHistory: GameCommand[];


  actionHistory: SerializedAction[];


  seed?: string;
}




export interface PlayerStateView {

  player: number;


  state: ElementJSON;


  flowState?: {
    awaitingInput: boolean;
    isMyTurn: boolean;
    availableActions?: string[];
  };


  messages: Array<{ text: string; data?: Record<string, unknown> }>;


  phase: string;


  complete: boolean;


  winners?: number[];
}




export function createSnapshot(
  game: Game,
  gameType: string,
  actionHistory: SerializedAction[] = [],
  seed?: string
): GameStateSnapshot {
  const flowState = game.getFlowState();

  return {
    version: 1,
    gameType,
    state: game.toJSON() as GameStateSnapshot['state'],
    flowState: flowState ?? undefined,
    commandHistory: [...game.commandHistory],
    actionHistory: [...actionHistory],
    seed,
  };
}




export function createPlayerView(
  game: Game,
  playerPosition: number
): PlayerStateView {
  const flowState = game.getFlowState();
  const currentPlayer = flowState?.currentPlayer;

  return {
    player: playerPosition,
    state: game.toJSONForPlayer(playerPosition),
    flowState: flowState ? {
      awaitingInput: flowState.awaitingInput,
      isMyTurn: currentPlayer === playerPosition,
      availableActions: flowState.awaitingInput && currentPlayer === playerPosition
        ? flowState.availableActions
        : undefined,
    } : undefined,
    messages: game.getFormattedMessages().map(text => ({ text })),
    phase: game.phase,
    complete: flowState?.complete ?? false,
    winners: flowState?.complete ? game.getWinners().map(p => p.position) : undefined,
  };
}




export function createAllPlayerViews(game: Game): PlayerStateView[] {
  return game.players.map((_, i) => createPlayerView(game, i));
}
````

## File: packages/testing/src/index.ts
````typescript
export {
  TestGame,
  createTestGame,
  type TestGameOptions,
} from './test-game.js';


export {
  simulateAction,
  simulateActions,
  assertActionSucceeds,
  assertActionFails,
  type SimulateActionResult,
} from './simulate-action.js';


export {
  simulateRandomGames,
  type SimulateRandomGamesOptions,
  type SingleGameResult,
  type SimulationResults,
} from './random-simulation.js';


export {
  assertFlowState,
  assertPlayerHas,
  assertElementCount,
  assertGameFinished,
  assertActionAvailable,
  assertActionNotAvailable,
  type ExpectedFlowState,
  type FlowStateAssertionResult,
} from './assertions.js';


export {
  ScenarioBuilder,
  scenario,
  quickGame,
  playSequence,
  playUntil,
  createMultiple,
} from './fixtures.js';


export {
  toDebugString,
  traceAction,
  visualizeFlow,
  visualizeFlowWithPosition,
  debugFlowState,
  logAvailableActions,
  diffSnapshots,
  type DebugStringOptions,
  type ActionTraceResult,
  type ActionTraceDetail,
  type FlowStateDebug,
} from './debug.js';
````

## File: packages/testing/README.md
````markdown
# @boardsmith/testing

Testing utilities for BoardSmith games. Provides helpers for simulating games, asserting state, and debugging issues.

## Installation

```bash
npm install --save-dev @boardsmith/testing
```

## Quick Start

```typescript
import { createTestGame, simulateAction, assertFlowState } from '@boardsmith/testing';
import { gameDefinition } from './game';

describe('MyGame', () => {
  it('should deal cards to all players', async () => {
    const testGame = await createTestGame(gameDefinition, {
      playerCount: 2,
      seed: 12345,
    });

    // Verify initial state
    assertFlowState(testGame, { phase: 'setup' });

    // Each player should have 5 cards
    for (const player of testGame.game.players) {
      expect(player.hand.count()).toBe(5);
    }
  });
});
```

## Test Game Setup

### createTestGame

Create a game instance for testing:

```typescript
const testGame = await createTestGame(gameDefinition, {
  playerCount: 3,
  playerNames: ['Alice', 'Bob', 'Carol'],
  seed: 42,  // Optional: deterministic randomness
  gameOptions: { variant: 'advanced' },
});
```

### TestGame Object

```typescript
interface TestGame {
  game: Game;           // The game instance
  runner: GameRunner;   // Flow/action runner
  session: GameSession; // Full session (for state access)
}
```

## Simulating Actions

### simulateAction

Execute a single action:

```typescript
import { simulateAction, assertActionSucceeds } from '@boardsmith/testing';

const result = await simulateAction(testGame, 'playCard', {
  card: testGame.game.players[0].hand.first(),
});

// Or assert it succeeds
await assertActionSucceeds(testGame, 'playCard', { card: someCard });
```

### simulateActions

Execute multiple actions in sequence:

```typescript
import { simulateActions } from '@boardsmith/testing';

await simulateActions(testGame, [
  { name: 'draw', args: {} },
  { name: 'playCard', args: { card: firstCard } },
  { name: 'endTurn', args: {} },
]);
```

### assertActionFails

Verify an action cannot be taken:

```typescript
import { assertActionFails } from '@boardsmith/testing';

// Ensure player can't play a card they don't have
await assertActionFails(testGame, 'playCard', {
  card: otherPlayerCard,
});
```

## Assertions

### assertFlowState

Check the current flow state:

```typescript
import { assertFlowState } from '@boardsmith/testing';

assertFlowState(testGame, {
  phase: 'playing',
  currentPlayer: 0,  // Player position
  actions: ['play', 'draw', 'pass'],  // Available actions
});
```

### assertPlayerHas

Check elements in player zones:

```typescript
import { assertPlayerHas } from '@boardsmith/testing';

assertPlayerHas(testGame, 0, 'hand', { count: 5 });
assertPlayerHas(testGame, 0, 'hand', { element: specificCard });
assertPlayerHas(testGame, 0, 'board', { elementType: Piece, count: 3 });
```

### assertElementCount

Check element counts globally:

```typescript
import { assertElementCount } from '@boardsmith/testing';

assertElementCount(testGame, Card, 52);
assertElementCount(testGame, Piece, { min: 1, max: 10 });
```

### assertGameFinished

Verify game completion:

```typescript
import { assertGameFinished } from '@boardsmith/testing';

assertGameFinished(testGame, {
  winner: testGame.game.players[0],
});

// Or just check it's finished
assertGameFinished(testGame);
```

### assertActionAvailable / assertActionNotAvailable

Check action availability:

```typescript
import { assertActionAvailable, assertActionNotAvailable } from '@boardsmith/testing';

assertActionAvailable(testGame, 0, 'draw');  // Player 0 can draw
assertActionNotAvailable(testGame, 1, 'draw');  // Player 1 cannot
```

## Fixtures and Scenarios

### ScenarioBuilder

Build game scenarios fluently:

```typescript
import { scenario } from '@boardsmith/testing';

const testGame = await scenario(gameDefinition)
  .withPlayers(3)
  .withSeed(42)
  .setup((game) => {
    // Custom setup
    game.deck.shuffle();
    game.players[0].hand.createMany(3, Card, 'card', { suit: 'hearts' });
  })
  .build();
```

### quickGame

Create a game and advance to a specific state:

```typescript
import { quickGame } from '@boardsmith/testing';

const testGame = await quickGame(gameDefinition, {
  players: 2,
  advanceTo: 'playing',  // Phase name or predicate
});
```

### playSequence

Play a sequence of actions:

```typescript
import { playSequence } from '@boardsmith/testing';

const { testGame, results } = await playSequence(gameDefinition, [
  { player: 0, action: 'draw' },
  { player: 0, action: 'playCard', args: { cardIndex: 0 } },
  { player: 1, action: 'draw' },
]);
```

### playUntil

Play random actions until a condition:

```typescript
import { playUntil } from '@boardsmith/testing';

const testGame = await playUntil(
  gameDefinition,
  (game) => game.phase === 'endgame',
  { maxActions: 100 }
);
```

### createMultiple

Create multiple elements easily:

```typescript
import { createMultiple } from '@boardsmith/testing';

// In scenario setup:
createMultiple(player.hand, Card, 5, (i) => ({
  suit: 'hearts',
  rank: i + 1,
}));
```

## Debug Utilities

### toDebugString

Get a human-readable game state:

```typescript
import { toDebugString } from '@boardsmith/testing';

console.log(toDebugString(testGame.game));
// Game: MyGame
// Phase: playing
// Current Player: Alice (position 0)
//
// Players:
//   [0] Alice: hand(5), score=10
//   [1] Bob: hand(4), score=15
//
// Elements:
//   Deck (id=1): 32 children
//   DiscardPile (id=2): 10 children
```

### traceAction

Debug why an action is/isn't available:

```typescript
import { traceAction } from '@boardsmith/testing';

const trace = traceAction(testGame.game, 'move', player);
console.log(trace.reason);
// "No valid elements for selection 'destination'"

for (const detail of trace.details) {
  console.log(`${detail.step}: ${detail.passed ? '' : ''} ${detail.info}`);
}
// Lookup:  Found action 'move'
// Condition:  Condition returned true
// Selection 'piece':  3 valid elements (5 before filter)
// Selection 'destination':  0 valid elements (24 before filter)
```

### visualizeFlow

Print the flow structure:

```typescript
import { visualizeFlow } from '@boardsmith/testing';

console.log(visualizeFlow(gameDefinition.flow));
// sequence "main"
//    phase "setup"
//      execute
//    loop (while: ...)
//      eachPlayer
//         action-step [play, draw, pass]
//    execute
```

### logAvailableActions

Show all actions and their status:

```typescript
import { logAvailableActions } from '@boardsmith/testing';

console.log(logAvailableActions(testGame.game));
// Available actions for Alice:
//    playCard - Action available
//    draw - Action available
//    attack - No valid elements for selection 'target'
//    rest - Action condition returned false
```

### diffSnapshots

Compare game states before/after:

```typescript
import { diffSnapshots } from '@boardsmith/testing';

const before = JSON.stringify(getSnapshot(testGame.game));
await simulateAction(testGame, 'move', args);
const after = JSON.stringify(getSnapshot(testGame.game));

console.log(diffSnapshots(before, after));
// Changes:
//   players[0].position: 3  5
//   board.cells[5].occupant: null  {id: 42}
```

### debugFlowState

Get detailed info about current flow position:

```typescript
import { debugFlowState } from '@boardsmith/testing';

const flowState = debugFlowState(testGame);
console.log(flowState.description);
// "In phase 'playing', waiting for Player 0 to choose: [play, draw, pass]"

console.log(flowState.nodeStack);
// ["sequence 'main'", "loop 'rounds'", "eachPlayer", "actionStep"]

console.log(flowState.currentPhase);      // "playing"
console.log(flowState.currentPlayer);      // 0
console.log(flowState.availableActions);   // ["play", "draw", "pass"]
console.log(flowState.awaitingInput);      // true
```

### visualizeFlowWithPosition

Show flow structure with current position highlighted:

```typescript
import { visualizeFlowWithPosition } from '@boardsmith/testing';

console.log(visualizeFlowWithPosition(gameDefinition.flow, testGame));
// sequence "main"
//    phase "setup"
//    loop "rounds"
//      eachPlayer
//        actionStep [play, draw, pass]  CURRENT
//      execute
//    phase "endgame"
```

## Random Simulation

### simulateRandomGames

Run random games for stress testing:

```typescript
import { simulateRandomGames } from '@boardsmith/testing';

const results = await simulateRandomGames(gameDefinition, {
  count: 100,
  maxActionsPerGame: 500,
  playerCount: 4,
});

console.log(`Completed: ${results.completed}/${results.total}`);
console.log(`Avg actions: ${results.averageActions}`);
console.log(`Errors: ${results.errors.length}`);
```

## Best Practices

1. **Use deterministic seeds** for reproducible tests
2. **Test edge cases** with specific scenarios
3. **Use assertions** instead of manual checks
4. **Use traceAction** to debug failing action tests
5. **Run random simulations** to catch edge cases

## API Reference

### Test Game Creation

```typescript
function createTestGame(definition, options): Promise<TestGame>;
function scenario(definition): ScenarioBuilder;
function quickGame(definition, options): Promise<TestGame>;
```

### Action Simulation

```typescript
function simulateAction(testGame, name, args): Promise<SimulateActionResult>;
function simulateActions(testGame, actions): Promise<SimulateActionResult[]>;
function assertActionSucceeds(testGame, name, args): Promise<void>;
function assertActionFails(testGame, name, args): Promise<void>;
```

### Assertions

```typescript
function assertFlowState(testGame, expected): void;
function assertPlayerHas(testGame, playerIndex, zone, criteria): void;
function assertElementCount(testGame, elementClass, count): void;
function assertGameFinished(testGame, options?): void;
function assertActionAvailable(testGame, playerIndex, actionName, options?): void;
function assertActionNotAvailable(testGame, playerIndex, actionName, options?): void;
```

### Debug Utilities

```typescript
function toDebugString(game, options?): string;
function traceAction(game, actionName, player?): ActionTraceResult;
function visualizeFlow(flow): string;
function visualizeFlowWithPosition(flow, testGame?): string;
function debugFlowState(testGame): FlowStateDebug;
function logAvailableActions(game, player?): string;
function diffSnapshots(before, after): string;
```
````

## File: docs/core-concepts.md
````markdown
# Core Concepts

This document explains the fundamental concepts and architecture of BoardSmith.

## Overview

BoardSmith uses a hierarchical element tree to represent game state, with a clear separation between:
- **Actions** (what players do) - high-level, game-specific
- **Commands** (how state changes) - low-level, generic, event-sourced

## Element Tree

Games are represented as a tree of `GameElement` objects:

```
Game (root)
 Board/Grid/Deck (Spaces - containers)
    Piece/Card (game pieces)
    More spaces...
 Player Hands (Spaces)
 Pile (removed elements)
```

### Element Types

| Class | Purpose | Example |
|-------|---------|---------|
| `GameElement` | Base class (never instantiate directly) | - |
| `Space` | Container for other elements | Board, pile, zone |
| `Deck` | Stack of cards (shuffleable) | Draw pile, discard |
| `Hand` | Player's private cards | Player's hand |
| `Grid` | Square grid | Chess/checkers board |
| `HexGrid` | Hexagonal grid | Hex game board |
| `Piece` | Physical game piece | Checker, stone |
| `Card` | Playing card | Standard deck card |

### Creating Elements

Elements are created as children of other elements:

```typescript
// In your Game constructor
class MyGame extends Game<MyGame, MyPlayer> {
  constructor(options) {
    super(options);

    // Register element classes (required for serialization)
    this.registerElements([Card, Hand, Deck, Board]);

    // Create elements as children of the game
    this.deck = this.create(Deck, 'deck');
    this.board = this.create(Board, 'board');

    // Create cards inside the deck
    for (const suit of suits) {
      for (const rank of ranks) {
        this.deck.create(Card, `${rank}${suit}`, { suit, rank });
      }
    }
  }
}
```

### Element Operations

```typescript
// Query elements
const card = deck.first(Card);              // First card
const cards = deck.all(Card);               // All cards
const count = deck.count(Card);             // Count cards
const aceOfSpades = deck.first(Card, c => c.rank === 'A' && c.suit === 'S');

// Move elements
card.putInto(hand);                         // Move card to hand
card.putInto(hand, { position: 'first' }); // Put at beginning

// Remove elements
card.remove();                              // Remove from game

// Create elements
const stone = cell.create(Stone, 'stone-1', { player });

// Shuffle (Deck only)
deck.shuffle();

// Element ordering
deck.setOrder('stacking');                  // Last in, first out
```

### Custom Element Classes

Extend base classes to add game-specific properties:

```typescript
// elements.ts
import { Card as BaseCard, Piece as BasePiece } from '@boardsmith/engine';

export class Card extends BaseCard {
  suit!: 'H' | 'D' | 'C' | 'S';
  rank!: string;

  get value(): number {
    const values: Record<string, number> = { 'A': 1, 'J': 11, 'Q': 12, 'K': 13 };
    return values[this.rank] ?? parseInt(this.rank);
  }
}

export class CheckerPiece extends BasePiece {
  player!: CheckersPlayer;
  isKing: boolean = false;

  promote(): void {
    this.isKing = true;
  }
}
```

## Visibility System

Control what each player can see.

### Element Visibility

```typescript
// Make contents visible to everyone
deck.contentsVisible();

// Hide contents from everyone
deck.contentsHidden();

// Only owner can see contents
hand.contentsVisibleToOwner();
```

### Attribute Visibility

Use static `visibleAttributes` to control which attributes are visible:

```typescript
class Card extends BaseCard {
  suit!: Suit;
  rank!: Rank;
  secretValue!: number;  // Hidden from players

  // Only suit and rank are visible in hidden contexts
  static visibleAttributes = ['suit', 'rank'];
}
```

## Actions vs Commands

BoardSmith separates player intent from state mutations.

### Actions (High-Level)

Actions are what players do - game-specific operations with prompts, selections, and validation:

```typescript
const moveAction = Action.create('move')
  .prompt('Move a piece')
  .chooseElement('piece', { filter: p => p.player === ctx.player })
  .chooseElement('destination', { filter: c => c.isEmpty() })
  .execute((args, ctx) => {
    args.piece.putInto(args.destination);  // Generates MoveCommand
  });
```

### Commands (Low-Level)

Commands are generic state mutations that happen automatically when you call element methods:

| Element Method | Generated Command |
|---------------|-------------------|
| `parent.create(Class, name, attrs)` | `CreateElementCommand` |
| `element.putInto(target)` | `MoveCommand` |
| `element.remove()` | `RemoveCommand` |
| `deck.shuffle()` | `ShuffleCommand` |
| `element.setAttribute(key, value)` | `SetAttributeCommand` |
| `element.contentsVisible()` | `SetVisibilityCommand` |

### Why This Matters

1. **Event Sourcing**: Commands form a replayable event log
2. **Undo/Redo**: Actions can be undone by reversing commands
3. **Networking**: Only commands are sent over the network
4. **Security**: Players can't directly manipulate state
5. **Debugging**: Full history of what happened

### Best Practices

```typescript
// DO: Use element methods in action execute functions
.execute((args, ctx) => {
  card.putInto(hand);
  player.score += 10;
});

// DON'T: Try to create commands manually
// DON'T: Bypass actions for player operations
```

## Player System

### Custom Player Classes

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  hand!: Hand;
  score: number = 0;
  abilities: Record<string, number> = { reroll: 1 };

  constructor(position: number, name: string, game: MyGame) {
    super(position, name);
    this.game = game;

    // Create player's hand
    this.hand = game.create(Hand, `hand-${position}`);
    this.hand.player = this;
    this.hand.contentsVisibleToOwner();
  }

  // IMPORTANT: Override toJSON() to include custom properties in network state
  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      score: this.score,
      abilities: this.abilities,
    };
  }
}
```

> **Important**: If your custom Player class has properties that need to be visible to the UI (like `score`, `abilities`, custom stats), you **must** override `toJSON()` to include them. The base `Player.toJSON()` only serializes `position`, `name`, `color`, and `avatar`.

### Player Properties

- `position`: 0-indexed player position
- `name`: Display name
- `game`: Reference to the game instance

### Accessing Players

```typescript
// In game class
this.players                    // All players array
this.players[0]                 // First player
this.currentPlayer              // Player whose turn it is

// In action context
ctx.player                      // Current action's player
```

## Game State Serialization

BoardSmith automatically handles serialization for:
- Network transmission
- State persistence
- Replays

### PlayerCollection Serialization Warning

`game.players` is a `PlayerCollection` (an Array subclass), not a plain Array. This has important implications when working with player data:

```typescript
//  WRONG: Returns a PlayerCollection, not a plain Array
// When JSON.stringify() is called, PlayerCollection.toJSON() re-serializes
// the elements, losing any custom properties
const playerData = game.players.map(p => p.toJSON());

//  CORRECT: Spread to convert to plain Array
const playerData = [...game.players.map(p => p.toJSON())];

//  ALSO CORRECT: Use Array.from()
const playerData = Array.from(game.players.map(p => p.toJSON()));
```

This is a JavaScript quirk: when you call `.map()` on an Array subclass, the result is an instance of the same subclass, not a plain Array. The `PlayerCollection.toJSON()` method then gets called during serialization, which re-processes the already-serialized data.

### Registering Elements

All custom element classes must be registered:

```typescript
this.registerElements([Card, Hand, Deck, Board, Piece]);
```

### State Snapshots

```typescript
// Get complete state snapshot
const snapshot = game.getSnapshot();

// Get player-specific view (with visibility applied)
const playerView = game.getPlayerView(playerPosition);
```

### Player Views

Each player receives a filtered view of the game state:
- Hidden elements show only `visibleAttributes`
- Private zones of other players are hidden
- Server-side information is stripped

## Game Lifecycle

```
1. Constructor
   - Register elements
   - Create initial state
   - Register actions
   - Set flow

2. setup() - Called after constructor
   - Additional initialization

3. start() - Game begins
   - Flow starts executing
   - Players take actions

4. isFinished() returns true
   - Game ends
   - getWinners() called
```

## Game Definition Metadata

Games export a `gameDefinition` object that describes the game to the framework. This metadata enables:
- Dynamic lobby UI generation
- Game options configuration
- Per-player settings (colors, roles)
- Quick-start presets

### Basic Structure

```typescript
// index.ts
export const gameDefinition = {
  gameClass: MyGame,
  gameType: 'my-game',
  displayName: 'My Game',
  minPlayers: 2,
  maxPlayers: 4,
  ai: {
    objectives: getMyGameObjectives,  // Optional AI support
  },
  gameOptions: { /* ... */ },         // Optional game-level options
  playerOptions: { /* ... */ },       // Optional per-player options
  presets: [ /* ... */ ],             // Optional quick-start presets
};
```

### Game Options

Game-level configuration options that appear in the lobby.

```typescript
gameOptions: {
  boardSize: {
    type: 'number',
    label: 'Board Size',
    description: 'Number of hexes per side',
    min: 5,
    max: 19,
    step: 1,
    default: 11,
  },
  targetScore: {
    type: 'number',
    label: 'Target Score',
    description: 'Points needed to win',
    min: 31,
    max: 121,
    default: 121,
  },
  variant: {
    type: 'select',
    label: 'Game Variant',
    choices: [
      { value: 'standard', label: 'Standard' },
      { value: 'speed', label: 'Speed Mode' },
    ],
    default: 'standard',
  },
  allowUndo: {
    type: 'boolean',
    label: 'Allow Undo',
    default: true,
  },
}
```

### Player Options

Per-player settings that appear for each player slot in the lobby.

```typescript
import { createColorOption } from '@boardsmith/session';

playerOptions: {
  // Standard color picker (8 colors)
  color: createColorOption(),

  // Custom color picker
  color: createColorOption([
    { value: '#ff0000', label: 'Red Team' },
    { value: '#0000ff', label: 'Blue Team' },
  ], 'Team'),

  // Role selector (for symmetric options)
  role: {
    type: 'select',
    label: 'Role',
    choices: [
      { value: 'attacker', label: 'Attacker' },
      { value: 'defender', label: 'Defender' },
    ],
    default: 'attacker',
  },
}
```

### Exclusive Player Options

For asymmetric games where exactly one player must have a specific role (e.g., 1 Dictator vs many Rebels), use the `exclusive` type. This renders as a radio button on each player row.

```typescript
playerOptions: {
  isDictator: {
    type: 'exclusive',
    label: 'Dictator',
    description: 'Select which player is the dictator',
    default: 'last',  // 'first', 'last', or player index number
  },
}
```

### Presets

Quick-start configurations for common game setups.

```typescript
presets: [
  {
    name: 'Quick Game',
    description: '7x7 board',
    options: { boardSize: 7 },
    players: [
      { color: '#e74c3c' },
      { color: '#3498db' },
    ],
  },
  {
    name: 'vs AI',
    description: 'Play against AI',
    options: { boardSize: 9 },
    players: [
      { isAI: false, color: '#e74c3c' },
      { isAI: true, aiLevel: 'medium', color: '#3498db' },
    ],
  },
]
```

### Receiving Options in Game Constructor

Options are passed to your game constructor via `CreateGameRequest`:

```typescript
export interface CreateGameRequest {
  gameType: string;
  playerCount: number;
  playerNames?: string[];
  gameOptions?: Record<string, unknown>;    // From gameOptions
  playerConfigs?: PlayerConfig[];           // From playerOptions
  aiPlayers?: number[];
  aiLevel?: string;
}

// In your game
class MyGame extends Game<MyGame, MyPlayer> {
  constructor(options: MyGameOptions) {
    super(options);

    // Access game options
    const boardSize = options.boardSize ?? 11;

    // Access player configs
    for (let i = 0; i < this.players.length; i++) {
      const config = options.playerConfigs?.[i];
      if (config?.color) {
        this.players[i].color = config.color;
      }
    }
  }
}
```

## Example: Hex Game

A minimal but complete example from `packages/games/hex/`:

```typescript
// game.ts
export class HexGame extends Game<HexGame, HexPlayer> {
  board!: Board;
  winner?: HexPlayer;

  constructor(options: HexOptions) {
    super(options);

    this.registerElements([Board, Cell, Stone]);

    // Create hex board
    this.board = this.create(Board, 'board', { boardSize: 7 });
    for (let r = 0; r < 7; r++) {
      for (let q = 0; q < 7; q++) {
        this.board.create(Cell, `cell-${q}-${r}`, { q, r });
      }
    }

    this.registerAction(createPlaceStoneAction(this));
    this.setFlow(createHexFlow(this));
  }

  override isFinished(): boolean {
    return !!this.winner;
  }

  override getWinners(): HexPlayer[] {
    return this.winner ? [this.winner] : [];
  }
}
```

## Related Documentation

- [Actions & Flow](./actions-and-flow.md) - Deep dive on actions and game flow
- [UI Components](./ui-components.md) - Building game UIs
- [Game Examples](./game-examples.md) - Real game implementations
````

## File: packages/engine/src/element/deck.ts
````typescript
import { Space } from './space.js';
import { Piece } from './piece.js';
import type { ElementContext, ElementClass } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';























export class Deck<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'deck';

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'deck';


    this.setOrder('stacking');


    this.$direction = 'vertical';
    this.$overlap = 0.95;
    this.$align = 'center';
  }





























  drawTo<T extends Piece>(
    destination: Space<G, P>,
    count: number = 1,
    elementClass?: ElementClass<T>
  ): T[] {
    const drawn: T[] = [];
    const cls = elementClass ?? (Piece as unknown as ElementClass<T>);

    for (let i = 0; i < count; i++) {
      const card = this.first(cls);
      if (!card) break;
      card.putInto(destination);
      drawn.push(card);
    }

    return drawn;
  }
}
````

## File: packages/engine/src/element/game-element.ts
````typescript
import { ElementCollection } from './element-collection.js';
import type {
  ElementClass,
  ElementContext,
  ElementTree,
  ElementJSON,
  ElementFinder,
  ElementAttributes,
  ImageRef,
} from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';
import type { VisibilityState } from '../command/visibility.js';
import { DEFAULT_VISIBILITY, canPlayerSee, resolveVisibility } from '../command/visibility.js';





export class GameElement<G extends Game = any, P extends Player = any> {

  name?: string;


  player?: P;


  row?: number;


  column?: number;






  $image?: ImageRef;






  $images?: Record<string, ImageRef>;


  game!: G;


  _ctx!: ElementContext;


  _t: ElementTree<GameElement>;


  _visibility?: VisibilityState;


  static isGameElement = true;


  static unserializableAttributes = ['_ctx', '_t', 'game', '_visibility'];


  static visibleAttributes: string[] | undefined;

  constructor(ctx: Partial<ElementContext>) {
    this._ctx = ctx as ElementContext;


    if (this._ctx.sequence === undefined) {
      this._ctx.sequence = 0;
    }


    if (!this._ctx.classRegistry) {
      this._ctx.classRegistry = new Map();
    }


    const id = this._ctx.sequence++;
    this._t = {
      children: [],
      id,
      order: 'normal',
    };
  }




  toString(): string {
    return this.name ?? this.constructor.name.replace(/([a-z0-9])([A-Z])/g, '$1 $2');
  }








  get parent(): GameElement | undefined {
    return this._t.parent;
  }




  get children(): ElementCollection<GameElement> {
    return new ElementCollection(...this._t.children);
  }




  isEmpty(): boolean {
    return this._t.children.length === 0;
  }




  isMine(): boolean {
    if (!this._ctx.player) return false;
    return this.player === this._ctx.player;
  }




  branch(): string {
    const path: number[] = [];
    let current: GameElement | undefined = this as GameElement;

    while (current?._t.parent) {
      const parent: GameElement = current._t.parent;
      const index = parent._t.children.indexOf(current);
      path.unshift(index);
      current = parent;
    }

    return path.join('/');
  }




  atBranch(branch: string): GameElement | undefined {
    if (!branch) return this;

    const indices = branch.split('/').map(Number);
    let current: GameElement = this;

    for (const index of indices) {
      const child = current._t.children[index];
      if (!child) return undefined;
      current = child;
    }

    return current;
  }




  atId(id: number): GameElement | undefined {
    if (this._t.id === id) return this;

    for (const child of this._t.children) {
      const found = child.atId(id);
      if (found) return found;
    }

    return undefined;
  }









  create<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T>
  ): T {
    return this.createInternal(elementClass, name, attributes);
  }




  createInternal<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: Record<string, unknown>
  ): T {

    if (!elementClass) {
      throw new Error(
        `Cannot create element: elementClass is ${elementClass}.\n` +
        `Parent: ${this.constructor.name} "${this.name}"\n` +
        `Hint: Make sure you imported the element class correctly.`
      );
    }

    if (typeof elementClass !== 'function') {
      throw new Error(
        `Cannot create element: expected a class constructor, got ${typeof elementClass}.\n` +
        `Parent: ${this.constructor.name} "${this.name}"\n` +
        `Value: ${JSON.stringify(elementClass)}`
      );
    }

    let element: T;
    try {
      element = new elementClass(this._ctx);
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : String(error);
      throw new Error(
        `Failed to instantiate ${elementClass.name}:\n` +
        `  Error: ${errMsg}\n` +
        `  Parent: ${this.constructor.name} "${this.name}"\n` +
        `  Hint: Check that ${elementClass.name} constructor accepts a context parameter.`
      );
    }

    element.name = name;
    element.game = this.game;


    if (attributes) {
      try {
        for (const [key, value] of Object.entries(attributes)) {
          if (key === 'id' || key === '_t' || key === '_ctx') {
            console.warn(
              `Warning: Setting reserved property "${key}" on ${elementClass.name} "${name}" - ` +
              `this may cause unexpected behavior.`
            );
          }
          (element as any)[key] = value;
        }
      } catch (error) {
        const errMsg = error instanceof Error ? error.message : String(error);
        throw new Error(
          `Failed to set attributes on ${elementClass.name} "${name}":\n` +
          `  Error: ${errMsg}\n` +
          `  Attributes: ${JSON.stringify(attributes)}`
        );
      }
    }


    this.addChild(element);


    const className = elementClass.name;
    if (!this._ctx.classRegistry.has(className)) {
      this._ctx.classRegistry.set(className, elementClass);
    }

    return element;
  }




  createMany<T extends GameElement>(
    count: number,
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T> | ((index: number) => ElementAttributes<T>)
  ): ElementCollection<T> {
    const elements = new ElementCollection<T>();

    for (let i = 0; i < count; i++) {
      const attrs = typeof attributes === 'function' ? attributes(i) : attributes;
      elements.push(this.create(elementClass, name, attrs));
    }

    return elements;
  }




  protected addChild(element: GameElement): void {
    element._t.parent = this;

    if (this._t.order === 'stacking') {
      this._t.children.unshift(element);
    } else {
      this._t.children.push(element);
    }
  }




  protected removeChild(element: GameElement): void {
    const index = this._t.children.indexOf(element);
    if (index !== -1) {
      this._t.children.splice(index, 1);
      element._t.parent = undefined;
    }
  }




  setOrder(order: 'normal' | 'stacking'): void {
    this._t.order = order;
  }








  all<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  all(...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
  all<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const collection = new ElementCollection(...this._t.children);
    return collection.all(classNameOrFinder as ElementClass<F>, ...finders);
  }




  first<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  first(...finders: ElementFinder<GameElement>[]): GameElement | undefined;
  first<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    const collection = new ElementCollection(...this._t.children);
    return collection.first(classNameOrFinder as ElementClass<F>, ...finders);
  }




  firstN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  firstN(n: number, ...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
  firstN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const collection = new ElementCollection(...this._t.children);
    return collection.firstN(n, classNameOrFinder as ElementClass<F>, ...finders);
  }




  last<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  last(...finders: ElementFinder<GameElement>[]): GameElement | undefined;
  last<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    const collection = new ElementCollection(...this._t.children);
    return collection.last(classNameOrFinder as ElementClass<F>, ...finders);
  }




  lastN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  lastN(n: number, ...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
  lastN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const collection = new ElementCollection(...this._t.children);
    return collection.lastN(n, classNameOrFinder as ElementClass<F>, ...finders);
  }




  has<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): boolean;
  has(...finders: ElementFinder<GameElement>[]): boolean;
  has<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): boolean {
    const collection = new ElementCollection(...this._t.children);
    return collection.has(classNameOrFinder as ElementClass<F>, ...finders);
  }




  count<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): number;
  count(...finders: ElementFinder<GameElement>[]): number;
  count<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): number {
    return this.all(classNameOrFinder as ElementClass<F>, ...finders).length;
  }








  getEffectiveVisibility(): VisibilityState {

    if (this._visibility?.explicit) {
      return this._visibility;
    }

    return resolveVisibility(this._visibility, this.getParentZoneVisibility());
  }




  protected getParentZoneVisibility(): VisibilityState | undefined {

    const parent = this._t.parent;
    if (!parent) return undefined;


    if ('getZoneVisibility' in parent && typeof parent.getZoneVisibility === 'function') {
      const zoneVis = (parent as any).getZoneVisibility();
      if (zoneVis) return zoneVis;
    }


    return parent.getParentZoneVisibility?.();
  }




  isVisibleTo(player: Player | number): boolean {
    const position = typeof player === 'number' ? player : player.position;
    const visibility = this.getEffectiveVisibility();


    const ownerPosition = this.getEffectiveOwner()?.position;
    return canPlayerSee(visibility, position, ownerPosition);
  }





  getEffectiveOwner(): Player | undefined {
    if (this.player) return this.player;
    return this._t.parent?.getEffectiveOwner();
  }




  isVisible(): boolean {
    if (!this._ctx.player) return true;
    return this.isVisibleTo(this._ctx.player);
  }




  setVisibilityInternal(visibility: VisibilityState): void {
    this._visibility = visibility;
  }




  addVisibleToInternal(players: number[]): void {
    if (!this._visibility) {
      this._visibility = { ...DEFAULT_VISIBILITY, explicit: true };
    }
    this._visibility.addPlayers = Array.from(
      new Set([...(this._visibility.addPlayers ?? []), ...players])
    );
  }








  toJSON(): ElementJSON {
    const className = this.constructor.name;
    const unserializable = new Set(
      (this.constructor as typeof GameElement).unserializableAttributes
    );


    const attributes: Record<string, unknown> = {};
    for (const key of Object.keys(this)) {
      if (!unserializable.has(key) && !key.startsWith('_')) {
        const value = (this as Record<string, unknown>)[key];
        if (value !== undefined) {
          attributes[key] = this.serializeValue(value);
        }
      }
    }

    const json: ElementJSON = {
      className,
      id: this._t.id,
      attributes,
    };

    if (this.name) {
      json.name = this.name;
    }


    if (this._visibility?.explicit) {
      json.visibility = this._visibility;
    }

    if (this._t.children.length > 0) {
      json.children = this._t.children.map((child) => child.toJSON());
    }

    return json;
  }




  protected serializeValue(value: unknown): unknown {
    if (value instanceof GameElement) {

      return { __elementRef: value.branch() };
    }
    if (Array.isArray(value)) {
      return value.map((v) => this.serializeValue(v));
    }
    if (value && typeof value === 'object') {
      const result: Record<string, unknown> = {};
      for (const [k, v] of Object.entries(value)) {
        result[k] = this.serializeValue(v);
      }
      return result;
    }
    return value;
  }






  resolveElementReferences(game: Game): void {
    const unserializable = new Set(
      (this.constructor as typeof GameElement).unserializableAttributes
    );


    for (const key of Object.keys(this)) {
      if (!unserializable.has(key) && !key.startsWith('_')) {
        const value = (this as Record<string, unknown>)[key];
        if (value !== undefined) {
          (this as Record<string, unknown>)[key] = this.deserializeValue(value, game);
        }
      }
    }


    for (const child of this._t.children) {
      child.resolveElementReferences(game);
    }
  }




  protected deserializeValue(value: unknown, game: Game): unknown {
    if (value === null || value === undefined) {
      return value;
    }


    if (typeof value === 'object' && value !== null && '__elementRef' in value) {
      const ref = value as { __elementRef: string };
      return game.atBranch(ref.__elementRef);
    }


    if (typeof value === 'object' && value !== null && '__elementId' in value) {
      const ref = value as { __elementId: number };
      return game.getElementById(ref.__elementId);
    }


    if (typeof value === 'object' && value !== null && '__playerRef' in value) {
      const ref = value as { __playerRef: number };
      return game.players[ref.__playerRef];
    }


    if (Array.isArray(value)) {
      return value.map(item => this.deserializeValue(item, game));
    }


    if (typeof value === 'object' && value !== null) {
      const result: Record<string, unknown> = {};
      for (const [k, v] of Object.entries(value)) {
        result[k] = this.deserializeValue(v, game);
      }
      return result;
    }

    return value;
  }




  static fromJSON<T extends GameElement>(
    json: ElementJSON,
    ctx: ElementContext,
    classRegistry: Map<string, ElementClass>
  ): T {
    const ElementClass = classRegistry.get(json.className);
    if (!ElementClass) {
      const registeredClasses = Array.from(classRegistry.keys()).join(', ');
      throw new Error(
        `Unknown element class: "${json.className}"\n\n` +
        `This error occurs when deserializing game state (e.g., after restart, undo, or AI move).\n\n` +
        `Registered classes: ${registeredClasses || '(none)'}\n\n` +
        `To fix this, register the class in your Game constructor:\n` +
        `  this.registerElements([${json.className}, ...]);\n\n` +
        `Or check that "${json.className}" is spelled correctly and imported.`
      );
    }

    const element = new ElementClass(ctx);
    element._t.id = json.id;

    if (json.name) {
      element.name = json.name;
    }


    if (json.visibility) {
      element._visibility = json.visibility;
    }


    for (const [key, value] of Object.entries(json.attributes)) {
      (element as unknown as Record<string, unknown>)[key] = value;
    }


    if (json.children) {
      for (const childJson of json.children) {
        const child = GameElement.fromJSON(childJson, ctx, classRegistry);
        child._t.parent = element;
        element._t.children.push(child);
      }
    }

    return element as T;
  }








  get id(): number {
    return this._t.id;
  }









  equals(other: GameElement | null | undefined): boolean {
    if (!other) return false;
    return this._t.id === other._t.id;
  }




  hasId(id: number): boolean {
    return this._t.id === id;
  }
}
````

## File: packages/engine/src/element/index.ts
````typescript
export { GameElement } from './game-element.js';
export { Space } from './space.js';
export { Piece } from './piece.js';
export { Card } from './card.js';
export { Hand } from './hand.js';
export { Deck } from './deck.js';
export { Die } from './die.js';
export { DicePool } from './dice-pool.js';
export { Grid, GridCell } from './grid.js';
export { HexGrid, HexCell } from './hex-grid.js';
export { Game } from './game.js';
export { ElementCollection } from './element-collection.js';

export type {
  ElementClass,
  ElementContext,
  ElementTree,
  ElementJSON,
  ElementFinder,
  ElementAttributes,
  Sorter,
  ImageRef,
} from './types.js';

export type { GameOptions, GamePhase, PlayerViewFunction } from './game.js';
export type { ElementLayout } from './grid.js';
export type { HexOrientation, HexCoordSystem } from './hex-grid.js';
export type { LayoutDirection, LayoutAlignment } from './space.js';
export type { DieSides } from './die.js';
````

## File: packages/engine/src/flow/builders.ts
````typescript
import type { Player } from '../player/player.js';
import type {
  FlowNode,
  FlowContext,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  FlowDefinition,
  PhaseConfig,
} from './types.js';












export function sequence(...steps: FlowNode[]): FlowNode {
  return {
    type: 'sequence',
    config: { steps },
  };
}




export function namedSequence(name: string, ...steps: FlowNode[]): FlowNode {
  return {
    type: 'sequence',
    config: { name, steps },
  };
}























export function phase(name: string, config: { do: FlowNode }): FlowNode {
  return {
    type: 'phase',
    config: {
      name,
      do: config.do,
    },
  };
}












export function loop(config: {
  name?: string;
  while?: (context: FlowContext) => boolean;
  maxIterations?: number;
  do: FlowNode;
}): FlowNode {
  return {
    type: 'loop',
    config: {
      name: config.name,
      while: config.while,
      maxIterations: config.maxIterations,
      do: config.do,
    },
  };
}









export function repeat(times: number, body: FlowNode): FlowNode {
  let count = 0;
  return loop({
    while: () => {
      count++;
      return count <= times;
    },
    maxIterations: times,
    do: body,
  });
}











export function eachPlayer(config: {
  name?: string;
  filter?: (player: Player, context: FlowContext) => boolean;
  direction?: 'forward' | 'backward';
  startingPlayer?: (context: FlowContext) => Player;
  do: FlowNode;
}): FlowNode {
  return {
    type: 'each-player',
    config: {
      name: config.name,
      filter: config.filter,
      direction: config.direction,
      startingPlayer: config.startingPlayer,
      do: config.do,
    },
  };
}













export function forEach<T>(config: {
  name?: string;
  collection: T[] | ((context: FlowContext) => T[]);
  as: string;
  do: FlowNode;
}): FlowNode {
  return {
    type: 'for-each',
    config: {
      name: config.name,
      collection: config.collection as unknown[] | ((context: FlowContext) => unknown[]),
      as: config.as,
      do: config.do,
    },
  };
}





















export function actionStep(config: {
  name?: string;
  player?: (context: FlowContext) => Player;
  actions: string[] | ((context: FlowContext) => string[]);
  repeatUntil?: (context: FlowContext) => boolean;
  skipIf?: (context: FlowContext) => boolean;
  minMoves?: number;
  maxMoves?: number;
}): FlowNode {
  return {
    type: 'action-step',
    config: {
      name: config.name,
      player: config.player,
      actions: config.actions,
      repeatUntil: config.repeatUntil,
      skipIf: config.skipIf,
      minMoves: config.minMoves,
      maxMoves: config.maxMoves,
    },
  };
}












export function playerActions(config: {
  name?: string;
  actions: string[] | ((context: FlowContext) => string[]);
  repeatUntil?: (context: FlowContext) => boolean;
  skipIf?: (context: FlowContext) => boolean;
}): FlowNode {
  return actionStep({
    name: config.name,
    actions: config.actions,
    repeatUntil: config.repeatUntil,
    skipIf: config.skipIf,
  });
}















export function simultaneousActionStep(config: {
  name?: string;
  players?: (context: FlowContext) => Player[];
  actions: string[] | ((context: FlowContext, player: Player) => string[]);
  playerDone?: (context: FlowContext, player: Player) => boolean;
  allDone?: (context: FlowContext) => boolean;
  skipPlayer?: (context: FlowContext, player: Player) => boolean;
}): FlowNode {
  return {
    type: 'simultaneous-action-step',
    config: {
      name: config.name,
      players: config.players,
      actions: config.actions,
      playerDone: config.playerDone,
      allDone: config.allDone,
      skipPlayer: config.skipPlayer,
    },
  };
}
















export function switchOn(config: {
  name?: string;
  on: (context: FlowContext) => unknown;
  cases: Record<string, FlowNode>;
  default?: FlowNode;
}): FlowNode {
  return {
    type: 'switch',
    config: {
      name: config.name,
      on: config.on,
      cases: config.cases,
      default: config.default,
    },
  };
}













export function ifThen(config: {
  name?: string;
  condition: (context: FlowContext) => boolean;
  then: FlowNode;
  else?: FlowNode;
}): FlowNode {
  return {
    type: 'if',
    config: {
      name: config.name,
      condition: config.condition,
      then: config.then,
      else: config.else,
    },
  };
}





































export function defineFlow(config: {
  setup?: (context: FlowContext) => void;
  root: FlowNode;
  isComplete?: (context: FlowContext) => boolean;
  getWinners?: (context: FlowContext) => Player[];
  onEnterPhase?: (phaseName: string, context: FlowContext) => void;
  onExitPhase?: (phaseName: string, context: FlowContext) => void;
}): FlowDefinition {
  return {
    setup: config.setup,
    root: config.root,
    isComplete: config.isComplete,
    getWinners: config.getWinners,
    onEnterPhase: config.onEnterPhase,
    onExitPhase: config.onExitPhase,
  };
}




export function noop(): FlowNode {
  return sequence();
}












export function execute(fn: (context: FlowContext) => void): FlowNode {
  return {
    type: 'execute',
    config: { fn },
  };
}









export function setVar(
  name: string,
  value: unknown | ((context: FlowContext) => unknown)
): FlowNode {
  return execute((ctx) => {
    const resolvedValue = typeof value === 'function' ? (value as Function)(ctx) : value;
    ctx.set(name, resolvedValue);
  });
}















































export function turnLoop(config: {

  name?: string;

  actions: string[] | ((context: FlowContext) => string[]);

  while?: (context: FlowContext) => boolean;

  maxIterations?: number;
}): FlowNode {
  return loop({
    name: config.name,
    while: (ctx) => {

      if (ctx.game.isFinished()) return false;

      if (config.while) {
        return config.while(ctx);
      }

      return true;
    },
    maxIterations: config.maxIterations ?? 100,
    do: actionStep({
      actions: config.actions,
    }),
  });
}
````

## File: packages/engine/src/flow/index.ts
````typescript
export { FlowEngine } from './engine.js';


export {
  sequence,
  namedSequence,
  phase,
  loop,
  repeat,
  eachPlayer,
  forEach,
  actionStep,
  simultaneousActionStep,
  playerActions,
  switchOn,
  ifThen,
  defineFlow,
  noop,
  execute,
  setVar,
  turnLoop,
} from './builders.js';


export { TurnOrder } from './turn-order.js';
export type { TurnOrderConfig } from './turn-order.js';


export type {
  FlowNodeType,
  FlowStepResult,
  FlowPosition,
  FlowContext,
  FlowNode,
  FlowState,
  FlowDefinition,
  BaseFlowConfig,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  ExecuteConfig,
  PhaseConfig,
  PlayerAwaitingState,
} from './types.js';
````

## File: docs/ui-components.md
````markdown
# UI Components & Composables

BoardSmith provides Vue 3 components and composables for building game UIs. The `@boardsmith/ui` package includes everything from high-level shells to low-level animation utilities.

## Core Components

### GameShell

The main wrapper component that provides the complete game UI structure: header, player panels, game board area, action panel, and game history.

```vue
<template>
  <GameShell
    game-type="my-game"
    display-name="My Game"
    :player-count="2"
  >
    <!-- Custom game board -->
    <template #game-board="{
      state,
      gameView,
      playerPosition,
      isMyTurn,
      availableActions,
      action,
      actionArgs,
      executeAction,
      setBoardPrompt
    }">
      <GameBoard
        :game-view="gameView"
        :player-position="playerPosition"
        :is-my-turn="isMyTurn"
        :available-actions="availableActions"
        :action="action"
        :action-args="actionArgs"
        :execute-action="executeAction"
        :set-board-prompt="setBoardPrompt"
      />
    </template>

    <!-- Custom player stats display -->
    <template #player-stats="{ player, gameView }">
      <div class="player-stat">
        <span class="label">Score:</span>
        <span class="value">{{ player.score }}</span>
      </div>
    </template>
  </GameShell>
</template>

<script setup lang="ts">
import { GameShell } from '@boardsmith/ui';
import GameBoard from './components/GameBoard.vue';
</script>
```

#### Slot Props

The `#game-board` slot receives:

| Prop | Type | Description |
|------|------|-------------|
| `state` | `GameState` | Full game state |
| `gameView` | `object` | Player-filtered view of game state |
| `playerPosition` | `number` | Current player's position |
| `isMyTurn` | `boolean` | Whether it's this player's turn |
| `availableActions` | `string[]` | Actions available to the player |
| `action` | `function` | Execute an action: `(name, args) => Promise` |
| `actionArgs` | `object` | Shared reactive object for action selections (bidirectional sync with ActionPanel) |
| `executeAction` | `function` | Execute current action: `(name) => Promise` |
| `setBoardPrompt` | `function` | Set a prompt message: `(text) => void` |
| `startAction` | `function` | Trigger ActionPanel to start an action: `(name) => void` |

#### Shared Action State (actionArgs)

The `actionArgs` object provides **bidirectional synchronization** between custom game boards and ActionPanel:

- **ActionPanel writes** to `actionArgs` when users make selections in the auto-generated UI
- **Custom boards can write** to `actionArgs` to pre-fill selections or respond to board interactions
- **Both see updates** immediately due to Vue's reactivity

This enables powerful hybrid UIs where users can interact with either the game board or the action panel.

**Example: Board pre-filling selections with startAction**
```vue
<script setup lang="ts">
const props = defineProps<{
  actionArgs: Record<string, unknown>;
  startAction: (name: string, initialArgs?: Record<string, unknown>) => void;
}>();

// When user clicks a piece on the board, start the action with that piece pre-selected
function onPieceClick(pieceId: number) {
  // Pass initial args to startAction - they're applied after clearing
  props.startAction('move', { piece: pieceId });
}
</script>
```

**Example: Board reading from actionArgs**
```vue
<template>
  <div
    v-for="card in cards"
    :key="card.id"
    class="card"
    :class="{ selected: actionArgs.card === card.id }"
  >
    <!-- Card shows selected state from ActionPanel selections -->
  </div>
</template>
```

**Example: Writable computed for card selection**
```typescript
const selectedCards = computed({
  get: () => (props.actionArgs.cards as string[]) || [],
  set: (value: string[]) => {
    props.actionArgs.cards = value;
  }
});
```

**ActionPanel owns the clear lifecycle**

ActionPanel clears `actionArgs` when starting, canceling, or completing actions. To pre-fill selections when starting an action, use the `initialArgs` parameter:

```typescript
// Correct: Pass initial values to startAction
startAction('move', { piece: pieceId });

// Incorrect: Writing then starting loses the value (cleared on start)
actionArgs.piece = pieceId;
startAction('move');  // piece gets cleared!
```

For ongoing updates during an action (after it's started), write directly to `actionArgs`.

### AutoUI

Automatic UI generation from game state. Useful for prototyping or as a reference implementation.

```vue
<template>
  <AutoUI
    :game-view="gameView"
    :player-position="playerPosition"
    :flow-state="flowState"
  />
</template>

<script setup lang="ts">
import { AutoUI } from '@boardsmith/ui';
</script>
```

The auto-generated UI includes:
- **AutoGameBoard**: Renders the game element tree
- **AutoElement**: Renders individual elements based on type
- **ActionPanel**: Displays available actions with selection UI

### DebugPanel

Development tool for inspecting game state, history, and debugging.

```vue
<template>
  <DebugPanel
    :state="state"
    :game-view="gameView"
    :action-history="actionHistory"
  />
</template>
```

## Lobby Components

BoardSmith provides a complete lobby system for configuring games before they start. The lobby dynamically renders controls based on game definition metadata.

### GameLobby

The main lobby component that fetches game definition metadata and renders configuration UI.

```vue
<template>
  <GameLobby
    :game-type="gameType"
    :player-count="playerCount"
    @create="handleCreate"
  />
</template>

<script setup lang="ts">
import { GameLobby } from '@boardsmith/ui';

const gameType = 'hex';
const playerCount = 2;

function handleCreate(config: { gameOptions: Record<string, unknown>; playerConfigs: PlayerConfig[] }) {
  // Create game with the configured options
}
</script>
```

The lobby automatically:
- Fetches game definition from `/games/definitions` endpoint
- Renders game options (number inputs, selects, toggles)
- Renders per-player configuration (name, AI toggle, color picker)
- Shows preset cards for quick setup
- Validates player count against game limits

### GameOptionsForm

Dynamic form that renders game-level options from metadata.

```vue
<template>
  <GameOptionsForm
    :options="gameDefinition.gameOptions"
    v-model="gameOptions"
  />
</template>
```

Supports three option types:

| Type | Control | Properties |
|------|---------|------------|
| `number` | Number input | `min`, `max`, `step`, `default` |
| `select` | Dropdown | `choices` (array of `{ value, label }`) |
| `boolean` | Toggle switch | `default` |

### PlayerConfigList

Per-player configuration with AI toggle and custom options.

```vue
<template>
  <PlayerConfigList
    :player-count="2"
    :has-ai="true"
    :player-options="gameDefinition.playerOptions"
    v-model="playerConfigs"
  />
</template>
```

Features:
- Player name input
- AI toggle with level selector (when game has AI)
- Dynamic rendering of per-player options (color picker, role select, etc.)
- Shows taken options as disabled with visual indicator
- Exclusive options render as radio buttons (exactly one player can be selected)

### PresetsPanel

Quick-start preset cards for common game configurations.

```vue
<template>
  <PresetsPanel
    :presets="gameDefinition.presets"
    @select="applyPreset"
  />
</template>

<script setup lang="ts">
function applyPreset(preset: GamePreset) {
  // Apply preset.options to gameOptions
  // Apply preset.players to playerConfigs
}
</script>
```

### Standard Color Picker

BoardSmith provides a standard color palette and utilities for player color selection.

```typescript
import {
  STANDARD_PLAYER_COLORS,
  DEFAULT_PLAYER_COLORS,
  createColorOption
} from '@boardsmith/session';

// Standard 8-color palette
STANDARD_PLAYER_COLORS
// [{ value: '#e74c3c', label: 'Red' }, { value: '#3498db', label: 'Blue' }, ...]

// Default 2-player colors (Red, Blue)
DEFAULT_PLAYER_COLORS
// ['#e74c3c', '#3498db']

// Create a color option for game definition
export const gameDefinition = {
  // ...
  playerOptions: {
    color: createColorOption(), // Uses standard colors
  },
};

// Or with custom colors
playerOptions: {
  color: createColorOption([
    { value: '#ff0000', label: 'Fire' },
    { value: '#0000ff', label: 'Ice' },
  ], 'Team Color'),
}
```

The color picker in PlayerConfigList:
- Shows color swatches with labels
- Disables already-selected colors with X overlay
- Automatically applies first available color as default

## Helper Components

### DeckPile

Visual representation of a deck/pile of cards.

```vue
<template>
  <DeckPile
    :count="deckCount"
    :clickable="canDraw"
    @click="onDrawCard"
  />
</template>
```

### CardFan

Display cards in a fanned layout (like a hand of cards).

```vue
<template>
  <CardFan
    :cards="playerHand"
    :selectable="isMyTurn"
    @select="onCardSelect"
  />
</template>
```

### DiceRoller

Animated dice rolling component.

```vue
<template>
  <DiceRoller
    :value="diceResult"
    :rolling="isRolling"
    @roll-complete="onRollComplete"
  />
</template>
```

### Draggable

Wrapper for drag-and-drop interactions.

```vue
<template>
  <Draggable
    :disabled="!canDrag"
    @drag-start="onDragStart"
    @drag-end="onDragEnd"
  >
    <Card :card="card" />
  </Draggable>
</template>
```

### FlyingCardsOverlay

Overlay for card flight animations between positions.

```vue
<template>
  <FlyingCardsOverlay
    :flying-cards="flyingCards"
  />
</template>
```

## Composables

### useBoardInteraction

Bidirectional interaction between action panel and game board.

```typescript
import { useBoardInteraction, createBoardInteraction, provideBoardInteraction } from '@boardsmith/ui';

// In GameShell (provide)
const boardInteraction = createBoardInteraction();
provideBoardInteraction(boardInteraction);

// In GameBoard or ActionPanel (inject)
const boardInteraction = useBoardInteraction();

// Check element states
boardInteraction.isHighlighted(element)  // Hovered in action panel
boardInteraction.isSelected(element)     // Currently selected
boardInteraction.isValidTarget(element)  // Valid drop/selection target
boardInteraction.isSelectableElement(element)  // Can be clicked to select

// Trigger selections
boardInteraction.triggerElementSelect(element)

// Drag and drop
boardInteraction.startDrag(element)
boardInteraction.endDrag()
boardInteraction.isDropTarget(element)
boardInteraction.isDraggedElement(element)
```

### useElementAnimation

FLIP animations for smooth element movement.

```typescript
import { useElementAnimation } from '@boardsmith/ui';

const { capturePositions, animateToCurrentPositions, cancelAll } = useElementAnimation();

// Before state changes
capturePositions(containerRef.value);

// After state changes (in nextTick or watch)
animateToCurrentPositions(containerRef.value, {
  duration: 300,
  selector: '[data-animatable="true"]',
});
```

Elements must have `data-animatable="true"` and `data-element-id="..."` attributes.

### useCardFlip / useCardReveal

Card flip and reveal animations.

```typescript
import { useCardFlip, useCardReveal } from '@boardsmith/ui';

const { isFlipped, flip, flipBack } = useCardFlip({
  duration: 300,
});

const { isRevealed, reveal } = useCardReveal({
  delay: 100,
});
```

### useFlyingCards

Manage cards flying between positions.

```typescript
import { useFlyingCards, type FlyingCard } from '@boardsmith/ui';

const { flyingCards, flyCard, clearFlying } = useFlyingCards();

// Fly a card from one position to another
flyCard({
  id: card.id,
  from: { x: 100, y: 200 },
  to: { x: 500, y: 300 },
  duration: 500,
  onComplete: () => console.log('Card arrived'),
});
```

### useFlyOnAppear

Animate elements flying in when they appear.

```typescript
import { useFlyOnAppear } from '@boardsmith/ui';

const { trackElement, getInitialPosition } = useFlyOnAppear({
  from: 'deck',  // Element ID to fly from
  duration: 400,
});
```

### usePlayerStatAnimation

Animate stat changes and fly elements to player stat displays.

```typescript
import { usePlayerStatAnimation, flyToPlayerStat } from '@boardsmith/ui';

// Fly a card to a player's score display
flyToPlayerStat({
  cardElement: cardEl,
  playerPosition: 0,
  statName: 'score',
  onComplete: () => updateScore(),
});
```

### useAutoFlyAnimation

Automatic flying animations when elements leave a zone. This composable provides a unified, foolproof way to animate elements flying from a game zone to a player stat display.

```typescript
import { useAutoFlyAnimation } from '@boardsmith/ui';

const { flyingCards, watchZone } = useAutoFlyAnimation();

// Watch a zone for removals and fly to a stat
watchZone({
  containerRef: myHandRef,
  gameView: () => props.gameView,
  getElementIds: (gv) => getHandCardIds(gv),
  targetStat: 'books',
  getTargetPlayer: (elementData) => props.playerPosition,
});
```

**Setup Requirements:**

1. Add data attributes to game elements:
```html
<div
  data-element-id="123"
  data-face-image="/cards/ah.png"
  data-back-image="/cards/back.png"
  data-rank="A"
  data-suit="H"
  data-player-position="0"
  data-face-up="true"
>...</div>
```

2. Add data attributes to player stat targets:
```html
<span data-player-stat="books" data-player-position="0">{{ count }}</span>
```

3. Include the FlyingCardsOverlay in your template:
```vue
<template>
  <div class="game-board">
    <!-- Your game content -->
  </div>
  <FlyingCardsOverlay :flying-cards="flyingCards" />
</template>
```

**Data Attributes:**

| Attribute | Purpose | Example |
|-----------|---------|---------|
| `data-element-id` | Unique ID for tracking | "123" |
| `data-face-image` | URL of card/piece face | "/cards/ah.png" |
| `data-back-image` | URL of card/piece back | "/cards/back.png" |
| `data-rank` | Card rank | "A", "K", "10" |
| `data-suit` | Card suit | "H", "D", "C", "S" |
| `data-player-position` | Owner position | "0" |
| `data-face-up` | Whether element shows face | "true" |

**Why This Works:**

Previous implementations had problems where imagery was extracted from game state, which changes before animation. This solution:
- Uses DOM data attributes as the source of truth for imagery
- Captures data BEFORE state changes (using `flush: 'sync'` watcher)
- Provides standard attribute names all games can use
- Requires zero game-specific animation code

**Helper Function:**

```typescript
import { getElementDataAttrs } from '@boardsmith/ui';

// In template - automatically generate data attributes
<div v-bind="getElementDataAttrs({
  id: card.id,
  faceImage: card.image,
  backImage: '/cards/back.png',
  rank: card.rank,
  suit: card.suit,
  playerPosition: card.owner,
  faceUp: card.faceUp,
})">
```

### useGameViewHelpers

Utilities for querying game state.

```typescript
import {
  useGameViewHelpers,
  findElement,
  findElements,
  findPlayerHand,
  getCards,
  getElementOwner,
  isMyElement,
} from '@boardsmith/ui';

// Find specific element
const deck = findElement(gameView, { type: 'deck' });

// Find player's hand
const myHand = findPlayerHand(gameView, playerPosition);

// Get all cards in an element
const cardsInHand = getCards(myHand);

// Check ownership
const owner = getElementOwner(card);
const isMine = isMyElement(card, playerPosition);
```

### useGameGrid

Utilities for square grids (chess notation, etc.).

```typescript
import { useGameGrid, toAlgebraicNotation, fromAlgebraicNotation } from '@boardsmith/ui';

const { getCellAt, getAlgebraic, pixelToCell } = useGameGrid({
  rows: 8,
  cols: 8,
  cellSize: 60,
});

// Convert coordinates
const notation = toAlgebraicNotation(0, 0);  // "a1"
const { col, row } = fromAlgebraicNotation('e4');  // { col: 4, row: 3 }
```

### useHexGrid

Utilities for hexagonal grids.

```typescript
import {
  useHexGrid,
  hexToPixel,
  getHexPolygonPoints,
  calculateHexDistance
} from '@boardsmith/ui';

const {
  hexToPixel,
  pixelToHex,
  getHexCorners,
  getNeighbors
} = useHexGrid({
  size: 30,
  orientation: 'flat',  // or 'pointy'
});

// Convert hex coords to pixel position
const { x, y } = hexToPixel(3, 2, 30, 'flat');

// Get SVG polygon points for a hex cell
const points = getHexPolygonPoints(cx, cy, size, 'flat');

// Calculate distance between hexes
const dist = calculateHexDistance(q1, r1, q2, r2);
```

### useCardDisplay

Card display formatting utilities.

```typescript
import {
  useCardDisplay,
  getSuitSymbol,
  getSuitColor,
  getRankName,
  isRedSuit
} from '@boardsmith/ui';

getSuitSymbol('H');  // ""
getSuitSymbol('D');  // ""
getSuitSymbol('C');  // ""
getSuitSymbol('S');  // ""

getSuitColor('H');   // "#e74c3c" (red)
getSuitColor('S');   // "#2c3e50" (black)

getRankName('K');    // "King"
isRedSuit('D');      // true
```

### useElementChangeTracker

Track element position and count changes for animations.

```typescript
import { useElementChangeTracker, useCountTracker } from '@boardsmith/ui';

const { trackElements, getChanges } = useElementChangeTracker();

// Track element movements
trackElements(gameView);
// ... state changes ...
const changes = getChanges(gameView);  // { added, removed, moved }

// Track count changes
const { track, getChange } = useCountTracker();
track('deckCount', deck.children.length);
const delta = getChange('deckCount');  // e.g., -3 (deck lost 3 cards)
```

### useFLIPAnimation

Low-level FLIP (First, Last, Invert, Play) animation utility.

```typescript
import { useFLIPAnimation, createFLIPSnapshot } from '@boardsmith/ui';

const { recordFirst, recordLast, play } = useFLIPAnimation({
  duration: 300,
  easing: 'ease-out',
});

// Before change
recordFirst(elements);

// After change
recordLast(elements);

// Animate
play();
```

## Theming

Customize the UI appearance with themes.

```typescript
import { applyTheme, type ThemeConfig } from '@boardsmith/ui';

const customTheme: ThemeConfig = {
  primary: '#00d9ff',
  secondary: '#00ff88',
  background: '#1a1a2e',
  surface: '#16213e',
  text: '#ffffff',
  textMuted: '#888888',
  error: '#e74c3c',
  success: '#00ff88',
};

applyTheme(customTheme);
```

## Building Custom UIs

### Example: Custom Game Board

```vue
<script setup lang="ts">
import { computed, ref } from 'vue';
import { useBoardInteraction, useElementAnimation, findPlayerHand, getCards } from '@boardsmith/ui';

const props = defineProps<{
  gameView: any;
  playerPosition: number;
  isMyTurn: boolean;
  availableActions: string[];
  action: (name: string, args: Record<string, unknown>) => Promise<any>;
}>();

const boardInteraction = useBoardInteraction();
const { capturePositions, animateToCurrentPositions } = useElementAnimation();
const containerRef = ref<HTMLElement>();

// Extract data from game view
const myHand = computed(() => {
  const hand = findPlayerHand(props.gameView, props.playerPosition);
  return hand ? getCards(hand) : [];
});

// Handle card click
async function onCardClick(card: any) {
  if (!props.isMyTurn) return;
  if (!props.availableActions.includes('play')) return;

  // Check if card is selectable via board interaction
  if (boardInteraction?.isSelectableElement(card)) {
    boardInteraction.triggerElementSelect(card);
  } else {
    // Direct action
    await props.action('play', { card: card.id });
  }
}

// Animate state changes
watch(() => props.gameView, (newView, oldView) => {
  if (containerRef.value && oldView) {
    capturePositions(containerRef.value);
    nextTick(() => {
      animateToCurrentPositions(containerRef.value!);
    });
  }
});
</script>

<template>
  <div ref="containerRef" class="game-board">
    <div class="hand">
      <div
        v-for="card in myHand"
        :key="card.id"
        class="card"
        :class="{
          'highlighted': boardInteraction?.isHighlighted(card),
          'selected': boardInteraction?.isSelected(card),
          'selectable': boardInteraction?.isSelectableElement(card),
        }"
        data-animatable="true"
        :data-element-id="card.id"
        @click="onCardClick(card)"
      >
        {{ card.attributes?.rank }}{{ card.attributes?.suit }}
      </div>
    </div>
  </div>
</template>
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Understanding game state
- [Actions & Flow](./actions-and-flow.md) - How actions work
- [Game Examples](./game-examples.md) - Real UI implementations
````

## File: packages/engine/src/action/index.ts
````typescript
export { Action, ActionExecutor, ConditionTracer } from './action.js';
export type {
  SelectionType,
  Selection,
  BaseSelection,
  ChoiceSelection,
  ElementSelection,
  TextSelection,
  NumberSelection,
  ActionContext,
  ActionDefinition,
  ActionResult,
  SerializedAction,
  ValidationResult,
  BoardElementRef,
  ChoiceBoardRefs,
  DependentFilter,

  ConditionDetail,
  SelectionTrace,
  ActionTrace,

  RepeatConfig,
  RepeatingSelectionState,
  PendingActionState,
} from './types.js';


export {
  dependentFilter,
  adjacentToSelection,
  excludeAlreadySelected,
  allOf,
  anyOf,
  not,
  type DependentFilterOptions,
} from './helpers.js';
````

## File: packages/engine/src/flow/types.ts
````typescript
import type { Game } from '../element/game.js';
import type { Player } from '../player/player.js';
import type { ActionDefinition, ActionResult } from '../action/types.js';




export type FlowNodeType =
  | 'sequence'
  | 'loop'
  | 'each-player'
  | 'for-each'
  | 'action-step'
  | 'simultaneous-action-step'
  | 'switch'
  | 'if'
  | 'execute'
  | 'phase';




export interface FlowStepResult {

  continue: boolean;

  awaitingInput: boolean;

  availableActions?: string[];

  currentPlayer?: Player;
}




export interface FlowPosition {

  path: number[];

  iterations: Record<string, number>;

  playerIndex?: number;

  variables: Record<string, unknown>;
}




export interface FlowContext<G extends Game = Game> {

  game: G;

  player?: Player;

  variables: Record<string, unknown>;

  set: (name: string, value: unknown) => void;

  get: <T = unknown>(name: string) => T | undefined;

  lastActionResult?: ActionResult;
}




export interface BaseFlowConfig {

  name?: string;
}




export interface SequenceConfig extends BaseFlowConfig {

  steps: FlowNode[];
}




export interface LoopConfig extends BaseFlowConfig {

  while?: (context: FlowContext) => boolean;

  maxIterations?: number;

  do: FlowNode;
}




export interface EachPlayerConfig extends BaseFlowConfig {

  filter?: (player: Player, context: FlowContext) => boolean;

  direction?: 'forward' | 'backward';

  startingPlayer?: (context: FlowContext) => Player;

  do: FlowNode;
}




export interface ForEachConfig<T = unknown> extends BaseFlowConfig {

  collection: T[] | ((context: FlowContext) => T[]);

  as: string;

  do: FlowNode;
}




export interface ActionStepConfig extends BaseFlowConfig {

  player?: (context: FlowContext) => Player;

  actions: string[] | ((context: FlowContext) => string[]);

  repeatUntil?: (context: FlowContext) => boolean;

  skipIf?: (context: FlowContext) => boolean;

  minMoves?: number;

  maxMoves?: number;
}




export interface SimultaneousActionStepConfig extends BaseFlowConfig {

  players?: (context: FlowContext) => Player[];

  actions: string[] | ((context: FlowContext, player: Player) => string[]);

  playerDone?: (context: FlowContext, player: Player) => boolean;

  allDone?: (context: FlowContext) => boolean;

  skipPlayer?: (context: FlowContext, player: Player) => boolean;
}




export interface SwitchConfig extends BaseFlowConfig {

  on: (context: FlowContext) => unknown;

  cases: Record<string, FlowNode>;

  default?: FlowNode;
}




export interface IfConfig extends BaseFlowConfig {

  condition: (context: FlowContext) => boolean;

  then: FlowNode;

  else?: FlowNode;
}




export interface ExecuteConfig extends BaseFlowConfig {

  fn: (context: FlowContext) => void;
}




export interface PhaseConfig extends BaseFlowConfig {

  name: string;

  do: FlowNode;
}




export type FlowNode =
  | { type: 'sequence'; config: SequenceConfig }
  | { type: 'loop'; config: LoopConfig }
  | { type: 'each-player'; config: EachPlayerConfig }
  | { type: 'for-each'; config: ForEachConfig }
  | { type: 'action-step'; config: ActionStepConfig }
  | { type: 'simultaneous-action-step'; config: SimultaneousActionStepConfig }
  | { type: 'switch'; config: SwitchConfig }
  | { type: 'if'; config: IfConfig }
  | { type: 'execute'; config: ExecuteConfig }
  | { type: 'phase'; config: PhaseConfig };




export interface PlayerAwaitingState {

  playerIndex: number;

  availableActions: string[];

  completed: boolean;
}




export interface FlowState {

  position: FlowPosition;

  complete: boolean;

  awaitingInput: boolean;

  currentPlayer?: number;

  availableActions?: string[];

  awaitingPlayers?: PlayerAwaitingState[];

  currentPhase?: string;

  moveCount?: number;

  movesRemaining?: number;

  movesRequired?: number;
}




export interface FlowDefinition {

  root: FlowNode;

  setup?: (context: FlowContext) => void;

  isComplete?: (context: FlowContext) => boolean;

  getWinners?: (context: FlowContext) => Player[];

  onEnterPhase?: (phaseName: string, context: FlowContext) => void;

  onExitPhase?: (phaseName: string, context: FlowContext) => void;
}
````

## File: packages/session/src/index.ts
````typescript
export type {
  GameClass,
  GameDefinition,
  GameConfig,
  StoredGameState,
  PlayerGameState,
  SessionInfo,
  StateUpdate,
  AIConfig,
  StorageAdapter,
  BroadcastAdapter,
  CreateGameRequest,
  ActionRequest,
  WebSocketMessage,

  PlayerOptionDefinition,
  StandardPlayerOption,
  ExclusivePlayerOption,
  PlayerConfig,
  GamePreset,

  GameOptionDefinition,
  NumberOption,
  SelectOption,
  BooleanOption,

  LobbyState,
  SlotStatus,
  LobbySlot,
  LobbyInfo,
  LobbyUpdate,
  ClaimPositionRequest,
  ClaimPositionResponse,
  UpdateNameRequest,
} from './types.js';





export {
  generateGameId,
  isPlayersTurn,
  buildPlayerState,
} from './utils.js';





export {
  STANDARD_PLAYER_COLORS,
  DEFAULT_PLAYER_COLORS,
  createColorOption,
  type ColorChoice,
  type ColorOptionDefinition,
} from './colors.js';





export {
  GameSession,
  type GameSessionOptions,
  type ActionResult,
  type UndoResult,
} from './game-session.js';

export { AIController } from './ai-controller.js';
````

## File: packages/engine/src/action/types.ts
````typescript
import type { GameElement } from '../element/game-element.js';
import type { Player } from '../player/player.js';
import type { Game } from '../element/game.js';
import type { ElementClass } from '../element/types.js';




export type SelectionType = 'element' | 'choice' | 'text' | 'number';




export interface BaseSelection<T = unknown> {

  name: string;




  prompt?: string | ((context: ActionContext) => string);

  optional?: boolean;

  validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;
}




export interface BoardElementRef {
  id?: number;
  name?: string;
  notation?: string;
}




export interface ChoiceBoardRefs {
  sourceRef?: BoardElementRef;
  targetRef?: BoardElementRef;
}




export interface DependentFilter {

  key: string;

  selectionName: string;
}









export interface RepeatConfig<T = unknown> {




  until: (context: ActionContext, lastChoice: T) => boolean;




  onEach?: (context: ActionContext, choice: T) => void;
}





export interface MultiSelectConfig {

  min?: number;

  max?: number;
}




export interface RepeatingSelectionState {

  selectionName: string;

  accumulated: unknown[];

  iterationCount: number;
}





export interface PendingActionState {

  actionName: string;

  playerPosition: number;

  collectedArgs: Record<string, unknown>;

  repeating?: RepeatingSelectionState;

  currentSelectionIndex: number;
}




export interface ChoiceSelection<T = unknown> extends BaseSelection<T> {
  type: 'choice';

  choices: T[] | ((context: ActionContext) => T[]);

  display?: (choice: T) => string;

  boardRefs?: (choice: T, context: ActionContext) => ChoiceBoardRefs;

  filterBy?: DependentFilter;






  dependsOn?: string;





  repeat?: RepeatConfig<T>;




  repeatUntil?: T;





























  multiSelect?: number | MultiSelectConfig | ((context: ActionContext) => number | MultiSelectConfig | undefined);
}




export interface ElementSelection<T extends GameElement = GameElement> extends BaseSelection<T> {
  type: 'element';

  filter?: (element: GameElement, context: ActionContext) => boolean;

  elementClass?: ElementClass<T>;

  from?: GameElement | ((context: ActionContext) => GameElement);

  display?: (element: T, context: ActionContext) => string;

  boardRef?: (element: T, context: ActionContext) => BoardElementRef;
}




export interface TextSelection extends BaseSelection<string> {
  type: 'text';

  pattern?: RegExp;

  minLength?: number;

  maxLength?: number;
}




export interface NumberSelection extends BaseSelection<number> {
  type: 'number';

  min?: number;

  max?: number;

  integer?: boolean;
}




export type Selection =
  | ChoiceSelection
  | ElementSelection
  | TextSelection
  | NumberSelection;




export interface ActionContext {

  game: Game;

  player: Player;

  args: Record<string, unknown>;
}


import type { ConditionTracer } from './action.js';




export interface ActionDefinition {

  name: string;

  prompt?: string;

  selections: Selection[];





  condition?: (context: ActionContext, tracer?: ConditionTracer) => boolean;

  execute: (args: Record<string, unknown>, context: ActionContext) => ActionResult | void;






  undoable?: boolean;
}




export interface ActionResult {

  success: boolean;

  error?: string;

  data?: Record<string, unknown>;

  message?: string;
}




export interface SerializedAction {

  name: string;

  player: number;

  args: Record<string, unknown>;

  timestamp?: number;

  undoable?: boolean;
}




export interface ValidationResult {
  valid: boolean;
  errors: string[];
}









export interface ConditionDetail {

  label: string;

  value: unknown;

  passed: boolean;

  children?: ConditionDetail[];
}




export interface SelectionTrace {

  name: string;

  type: string;

  choiceCount: number;

  skipped?: boolean;

  optional?: boolean;

  filterApplied?: boolean;

  dependentOn?: string;
}





export interface ActionTrace {

  actionName: string;

  available: boolean;

  conditionResult?: boolean;

  conditionError?: string;

  conditionDetails?: ConditionDetail[];

  selections: SelectionTrace[];
}
````

## File: packages/engine/src/flow/engine.ts
````typescript
import type { Game } from '../element/game.js';
import type { Player } from '../player/player.js';
import type { ActionResult } from '../action/types.js';
import type {
  FlowNode,
  FlowContext,
  FlowPosition,
  FlowState,
  FlowStepResult,
  FlowDefinition,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  ExecuteConfig,
  PhaseConfig,
  PlayerAwaitingState,
} from './types.js';




const DEFAULT_MAX_ITERATIONS = 10000;




function createContext<G extends Game>(
  game: G,
  player?: Player,
  variables: Record<string, unknown> = {}
): FlowContext<G> {
  return {
    game,
    player,
    variables,
    set: (name: string, value: unknown) => {
      variables[name] = value;
    },
    get: <T = unknown>(name: string): T | undefined => {
      return variables[name] as T | undefined;
    },
  };
}




interface ExecutionFrame {
  node: FlowNode;
  index: number;
  completed: boolean;
  data?: Record<string, unknown>;
}





export class FlowEngine<G extends Game = Game> {
  private game: G;
  private definition: FlowDefinition;
  private stack: ExecutionFrame[] = [];
  private variables: Record<string, unknown> = {};
  private currentPlayer?: Player;
  private awaitingInput = false;
  private availableActions: string[] = [];
  private complete = false;
  private lastActionResult?: ActionResult;

  private awaitingPlayers: PlayerAwaitingState[] = [];

  private currentPhase?: string;

  private moveCount = 0;

  private currentActionConfig?: ActionStepConfig;

  constructor(game: G, definition: FlowDefinition) {
    this.game = game;
    this.definition = definition;
  }




  start(): FlowState {

    const context = this.createContext();
    if (this.definition.setup) {
      this.definition.setup(context);
    }


    this.stack = [{ node: this.definition.root, index: 0, completed: false }];
    this.variables = { ...context.variables };
    this.currentPlayer = this.game.players.current;
    this.awaitingInput = false;
    this.complete = false;


    return this.run();
  }







  resume(actionName: string, args: Record<string, unknown>, playerIndex?: number): FlowState {
    if (!this.awaitingInput) {
      throw new Error('Flow is not awaiting input');
    }

    const currentFrame = this.stack[this.stack.length - 1];


    if (currentFrame?.node.type === 'simultaneous-action-step') {
      return this.resumeSimultaneousAction(actionName, args, playerIndex, currentFrame);
    }


    const result = this.game.performAction(actionName, this.currentPlayer!, args);
    this.lastActionResult = result;

    if (!result.success) {

      return this.getState();
    }


    this.awaitingInput = false;


    if (currentFrame?.node.type === 'action-step') {
      const config = currentFrame.node.config as ActionStepConfig;


      const currentMoveCount = (currentFrame.data?.moveCount as number) ?? 0;
      const newMoveCount = currentMoveCount + 1;
      currentFrame.data = { ...currentFrame.data, moveCount: newMoveCount };


      if (config.maxMoves && newMoveCount >= config.maxMoves) {
        currentFrame.completed = true;
        this.currentActionConfig = undefined;
        this.moveCount = 0;
      }

      else if (config.repeatUntil) {
        const minMovesMet = !config.minMoves || newMoveCount >= config.minMoves;
        if (config.repeatUntil(this.createContext()) && minMovesMet) {
          currentFrame.completed = true;
          this.currentActionConfig = undefined;
          this.moveCount = 0;
        }
      }

      else if (!config.minMoves && !config.maxMoves) {
        currentFrame.completed = true;
        this.currentActionConfig = undefined;
        this.moveCount = 0;
      }


    }

    return this.run();
  }






  resumeAfterExternalAction(result: ActionResult): FlowState {
    if (!this.awaitingInput) {
      throw new Error('Flow is not awaiting input');
    }

    this.lastActionResult = result;

    if (!result.success) {

      return this.getState();
    }


    this.awaitingInput = false;


    const currentFrame = this.stack[this.stack.length - 1];
    if (currentFrame?.node.type === 'action-step') {
      const config = currentFrame.node.config as ActionStepConfig;


      const currentMoveCount = (currentFrame.data?.moveCount as number) ?? 0;
      const newMoveCount = currentMoveCount + 1;
      currentFrame.data = { ...currentFrame.data, moveCount: newMoveCount };


      if (config.maxMoves && newMoveCount >= config.maxMoves) {
        currentFrame.completed = true;
        this.currentActionConfig = undefined;
        this.moveCount = 0;
      }

      else if (config.repeatUntil) {
        const minMovesMet = !config.minMoves || newMoveCount >= config.minMoves;
        if (config.repeatUntil(this.createContext()) && minMovesMet) {
          currentFrame.completed = true;
          this.currentActionConfig = undefined;
          this.moveCount = 0;
        }
      }

      else if (!config.minMoves && !config.maxMoves) {
        currentFrame.completed = true;
        this.currentActionConfig = undefined;
        this.moveCount = 0;
      }
    }

    return this.run();
  }




  private resumeSimultaneousAction(
    actionName: string,
    args: Record<string, unknown>,
    playerIndex: number | undefined,
    frame: ExecutionFrame
  ): FlowState {
    const config = frame.node.config as SimultaneousActionStepConfig;


    let actingPlayerIndex = playerIndex;
    if (actingPlayerIndex === undefined) {

      const firstAwaiting = this.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
      if (firstAwaiting) {
        actingPlayerIndex = firstAwaiting.playerIndex;
      }
    }

    if (actingPlayerIndex === undefined) {
      throw new Error('No player specified and no awaiting players found');
    }


    const playerState = this.awaitingPlayers.find(p => p.playerIndex === actingPlayerIndex);
    if (!playerState) {
      throw new Error(`Player ${actingPlayerIndex} is not awaiting action`);
    }
    if (playerState.completed) {
      throw new Error(`Player ${actingPlayerIndex} has already completed their action`);
    }
    if (!playerState.availableActions.includes(actionName)) {
      throw new Error(`Action ${actionName} is not available for player ${actingPlayerIndex}`);
    }


    const player = this.game.players[actingPlayerIndex];
    const result = this.game.performAction(actionName, player as any, args);
    this.lastActionResult = result;

    if (!result.success) {

      return this.getState();
    }


    const context = this.createContext();
    if (config.playerDone) {
      playerState.completed = config.playerDone(context, player);
    }


    if (!playerState.completed) {
      const actions = typeof config.actions === 'function'
        ? config.actions(context, player)
        : config.actions;
      playerState.availableActions = actions.filter((actionName) => {
        const action = this.game.getAction(actionName);
        if (!action) return false;
        return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
      });

      if (playerState.availableActions.length === 0) {
        playerState.completed = true;
      }
    }


    const allDone = config.allDone
      ? config.allDone(context)
      : this.awaitingPlayers.every(p => p.completed);

    if (allDone) {

      this.awaitingInput = false;
      this.awaitingPlayers = [];
      frame.completed = true;
      return this.run();
    }


    return this.getState();
  }




  getState(): FlowState {
    const state: FlowState = {
      position: this.getPosition(),
      complete: this.complete,
      awaitingInput: this.awaitingInput,
      currentPlayer: this.currentPlayer?.position,
      availableActions: this.awaitingInput ? this.availableActions : undefined,
      awaitingPlayers: this.awaitingPlayers.length > 0 ? this.awaitingPlayers : undefined,
      currentPhase: this.currentPhase,
    };


    if (this.currentActionConfig && (this.currentActionConfig.minMoves || this.currentActionConfig.maxMoves)) {
      state.moveCount = this.moveCount;
      if (this.currentActionConfig.maxMoves) {
        state.movesRemaining = this.currentActionConfig.maxMoves - this.moveCount;
      }
      if (this.currentActionConfig.minMoves) {
        state.movesRequired = Math.max(0, this.currentActionConfig.minMoves - this.moveCount);
      }
    }

    return state;
  }




  restore(position: FlowPosition): void {
    this.variables = { ...position.variables };
    this.stack = [];


    let currentNode = this.definition.root;
    for (let i = 0; i < position.path.length; i++) {
      const index = position.path[i];
      const iterationKey = `__iter_${i}`;
      const iteration = position.iterations[iterationKey] ?? 0;

      this.stack.push({
        node: currentNode,
        index,
        completed: false,
        data: { iteration },
      });


      currentNode = this.getChildNode(currentNode, index);
    }


    if (position.playerIndex !== undefined) {
      this.currentPlayer = this.game.players[position.playerIndex];
    }
  }




  isComplete(): boolean {
    return this.complete;
  }




  getWinners(): Player[] {
    if (!this.complete) return [];
    if (this.definition.getWinners) {
      return this.definition.getWinners(this.createContext());
    }
    return [];
  }





  private createContext(): FlowContext<G> {
    const context = createContext(this.game, this.currentPlayer, this.variables);
    context.lastActionResult = this.lastActionResult;
    return context;
  }

  private getPosition(): FlowPosition {
    const path: number[] = [];
    const iterations: Record<string, number> = {};

    for (let i = 0; i < this.stack.length; i++) {
      const frame = this.stack[i];
      path.push(frame.index);
      if (frame.data?.iteration !== undefined) {
        iterations[`__iter_${i}`] = frame.data.iteration as number;
      }
    }

    return {
      path,
      iterations,
      playerIndex: this.currentPlayer?.position,
      variables: { ...this.variables },
    };
  }

  private getChildNode(node: FlowNode, index: number): FlowNode {
    switch (node.type) {
      case 'sequence':
        return node.config.steps[index];
      case 'loop':
      case 'each-player':
      case 'for-each':
      case 'phase':
        return node.config.do;
      case 'if':
        return index === 0 ? node.config.then : (node.config.else ?? node.config.then);
      case 'switch': {
        const cases = Object.values(node.config.cases);
        return cases[index] ?? node.config.default ?? cases[0];
      }
      default:
        return node;
    }
  }




  private run(): FlowState {
    let iterations = 0;

    while (this.stack.length > 0 && !this.awaitingInput && !this.complete) {
      iterations++;
      if (iterations > DEFAULT_MAX_ITERATIONS) {

        const frame = this.stack[this.stack.length - 1];
        const nodeName = frame?.node?.config?.name ?? frame?.node?.type ?? 'unknown';
        const nodeType = frame?.node?.type ?? 'unknown';
        const stackTrace = this.stack.map((f, i) =>
          `  ${i}: ${f.node.type}${f.node.config?.name ? ` "${f.node.config.name}"` : ''} (index: ${f.index})`
        ).join('\n');

        throw new Error(
          `Flow exceeded ${DEFAULT_MAX_ITERATIONS} iterations - possible infinite loop.\n\n` +
          `Current node: ${nodeType}${nodeName !== nodeType ? ` "${nodeName}"` : ''}\n` +
          `Flow stack:\n${stackTrace}\n\n` +
          `Common causes:\n` +
          `- A while() condition that never becomes false\n` +
          `- Missing state update that should break the loop\n` +
          `- Condition references stale game state\n` +
          `- isFinished() never returns true\n\n` +
          `Fix: Check the while/repeatUntil conditions in the nodes above.`
        );
      }

      const frame = this.stack[this.stack.length - 1];


      if (frame.completed) {
        this.stack.pop();
        continue;
      }

      const result = this.executeNode(frame);

      if (result.awaitingInput) {
        this.awaitingInput = true;
        break;
      }

      if (frame.completed) {
        this.stack.pop();
      }


      if (this.definition.isComplete?.(this.createContext())) {
        this.complete = true;
        break;
      }
    }


    if (this.stack.length === 0 || this.definition.isComplete?.(this.createContext())) {
      this.complete = true;
    }

    return this.getState();
  }




  private executeNode(frame: ExecutionFrame): FlowStepResult {
    const context = this.createContext();

    switch (frame.node.type) {
      case 'sequence':
        return this.executeSequence(frame, frame.node.config, context);
      case 'loop':
        return this.executeLoop(frame, frame.node.config, context);
      case 'each-player':
        return this.executeEachPlayer(frame, frame.node.config, context);
      case 'for-each':
        return this.executeForEach(frame, frame.node.config, context);
      case 'action-step':
        return this.executeActionStep(frame, frame.node.config, context);
      case 'simultaneous-action-step':
        return this.executeSimultaneousActionStep(frame, frame.node.config, context);
      case 'switch':
        return this.executeSwitch(frame, frame.node.config, context);
      case 'if':
        return this.executeIf(frame, frame.node.config, context);
      case 'execute':
        return this.executeExecute(frame, frame.node.config, context);
      case 'phase':
        return this.executePhase(frame, frame.node.config, context);
      default:
        frame.completed = true;
        return { continue: true, awaitingInput: false };
    }
  }

  private executeSequence(
    frame: ExecutionFrame,
    config: SequenceConfig,
    context: FlowContext
  ): FlowStepResult {
    if (frame.index >= config.steps.length) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    const nextStep = config.steps[frame.index];
    this.stack.push({ node: nextStep, index: 0, completed: false });
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeLoop(
    frame: ExecutionFrame,
    config: LoopConfig,
    context: FlowContext
  ): FlowStepResult {
    const iteration = (frame.data?.iteration as number) ?? 0;
    const maxIterations = config.maxIterations ?? DEFAULT_MAX_ITERATIONS;


    if (iteration >= maxIterations) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    if (config.while && !config.while(context)) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    this.stack.push({ node: config.do, index: 0, completed: false });
    frame.data = { ...frame.data, iteration: iteration + 1 };
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeEachPlayer(
    frame: ExecutionFrame,
    config: EachPlayerConfig,
    context: FlowContext
  ): FlowStepResult {

    let players = [...this.game.players];

    if (config.filter) {
      players = players.filter((p) => config.filter!(p, context));
    }

    if (config.direction === 'backward') {
      players.reverse();
    }


    if (frame.data?.playerIndex === undefined) {
      let startIndex = 0;
      if (config.startingPlayer) {
        const startPlayer = config.startingPlayer(context);
        startIndex = players.findIndex((p) => p === startPlayer);
        if (startIndex === -1) startIndex = 0;
      }
      frame.data = { ...frame.data, playerIndex: startIndex, players };
    }

    const playerIndex = frame.data.playerIndex as number;
    const playerList = (frame.data.players as Player[]) ?? players;

    if (playerIndex >= playerList.length) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    this.currentPlayer = playerList[playerIndex];
    this.variables[config.name ?? 'currentPlayer'] = this.currentPlayer;

    this.stack.push({ node: config.do, index: 0, completed: false });
    frame.data = { ...frame.data, playerIndex: playerIndex + 1 };
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeForEach(
    frame: ExecutionFrame,
    config: ForEachConfig,
    context: FlowContext
  ): FlowStepResult {

    const items = typeof config.collection === 'function'
      ? config.collection(context)
      : config.collection;

    const itemIndex = (frame.data?.itemIndex as number) ?? 0;

    if (itemIndex >= items.length) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    this.variables[config.as] = items[itemIndex];

    this.stack.push({ node: config.do, index: 0, completed: false });
    frame.data = { ...frame.data, itemIndex: itemIndex + 1 };
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeActionStep(
    frame: ExecutionFrame,
    config: ActionStepConfig,
    context: FlowContext
  ): FlowStepResult {

    if (config.skipIf?.(context)) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    if (frame.data?.moveCount === undefined) {
      frame.data = { ...frame.data, moveCount: 0 };
    }
    const moveCount = frame.data.moveCount as number;


    if (config.maxMoves && moveCount >= config.maxMoves) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    const minMovesMet = !config.minMoves || moveCount >= config.minMoves;
    if (this.lastActionResult && config.repeatUntil?.(context) && minMovesMet) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      this.lastActionResult = undefined;
      return { continue: true, awaitingInput: false };
    }


    const player = config.player ? config.player(context) : context.player;
    if (!player) {
      throw new Error('ActionStep requires a player');
    }


    const actions = typeof config.actions === 'function'
      ? config.actions(context)
      : config.actions;


    const allAvailable = this.game.getAvailableActions(player as any);
    const available = actions.filter((actionName) => {
      const action = this.game.getAction(actionName);
      if (!action) return false;
      return allAvailable.some((a) => a.name === actionName);
    });


    if (available.length === 0 && minMovesMet) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    if (available.length === 0 && !minMovesMet) {
      throw new Error(`ActionStep requires ${config.minMoves} moves but only ${moveCount} were possible`);
    }


    this.currentActionConfig = config;
    this.moveCount = moveCount;


    this.currentPlayer = player;
    this.availableActions = available;


    return {
      continue: false,
      awaitingInput: true,
      availableActions: available,
      currentPlayer: player,
    };
  }

  private executeSimultaneousActionStep(
    frame: ExecutionFrame,
    config: SimultaneousActionStepConfig,
    context: FlowContext
  ): FlowStepResult {

    const players = config.players
      ? config.players(context)
      : [...this.game.players];


    this.awaitingPlayers = [];

    for (const player of players) {

      if (config.skipPlayer?.(context, player)) {
        continue;
      }


      if (config.playerDone?.(context, player)) {
        continue;
      }


      const actions = typeof config.actions === 'function'
        ? config.actions(context, player)
        : config.actions;

      const available = actions.filter((actionName) => {
        const action = this.game.getAction(actionName);
        if (!action) return false;
        return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
      });


      if (available.length > 0) {
        this.awaitingPlayers.push({
          playerIndex: player.position,
          availableActions: available,
          completed: false,
        });
      }
    }


    if (this.awaitingPlayers.length === 0) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    if (config.allDone?.(context)) {
      this.awaitingPlayers = [];
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    return {
      continue: false,
      awaitingInput: true,
    };
  }

  private executeSwitch(
    frame: ExecutionFrame,
    config: SwitchConfig,
    context: FlowContext
  ): FlowStepResult {

    if (frame.data?.branchPushed) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    const value = config.on(context);
    const stringValue = String(value);

    const branch = config.cases[stringValue] ?? config.default;
    if (!branch) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    this.stack.push({ node: branch, index: 0, completed: false });
    frame.data = { branchPushed: true };

    return { continue: true, awaitingInput: false };
  }

  private executeIf(
    frame: ExecutionFrame,
    config: IfConfig,
    context: FlowContext
  ): FlowStepResult {

    if (frame.data?.branchPushed) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    const condition = config.condition(context);

    if (condition) {
      this.stack.push({ node: config.then, index: 0, completed: false });
      frame.data = { branchPushed: true };
    } else if (config.else) {
      this.stack.push({ node: config.else, index: 0, completed: false });
      frame.data = { branchPushed: true };
    } else {

      frame.completed = true;
    }

    return { continue: true, awaitingInput: false };
  }

  private executeExecute(
    frame: ExecutionFrame,
    config: ExecuteConfig,
    context: FlowContext
  ): FlowStepResult {

    config.fn(context);

    this.variables = { ...context.variables };
    frame.completed = true;
    return { continue: true, awaitingInput: false };
  }

  private executePhase(
    frame: ExecutionFrame,
    config: PhaseConfig,
    context: FlowContext
  ): FlowStepResult {

    if (!frame.data?.entered) {

      const previousPhase = this.currentPhase;
      this.currentPhase = config.name;


      if (this.definition.onEnterPhase) {
        this.definition.onEnterPhase(config.name, context);
      }


      this.stack.push({ node: config.do, index: 0, completed: false });
      frame.data = { entered: true, previousPhase };

      return { continue: true, awaitingInput: false };
    }


    if (this.definition.onExitPhase) {
      this.definition.onExitPhase(config.name, context);
    }


    this.currentPhase = frame.data.previousPhase as string | undefined;
    frame.completed = true;

    return { continue: true, awaitingInput: false };
  }
}
````

## File: packages/session/src/utils.ts
````typescript
import type { FlowState, Game, Player, Selection, ActionDefinition, ActionTrace } from '@boardsmith/engine';
import type { GameRunner } from '@boardsmith/runtime';
import type { PlayerGameState, ActionMetadata, SelectionMetadata } from './types.js';





function defaultChoiceDisplay(value: unknown): string {
  if (value === null || value === undefined) {
    return String(value);
  }


  if (typeof value !== 'object') {
    return String(value);
  }


  const obj = value as Record<string, unknown>;
  if (typeof obj.name === 'string') {
    return obj.name;
  }
  if (typeof obj.label === 'string') {
    return obj.label;
  }


  try {
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}




export function generateGameId(): string {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let id = '';
  for (let i = 0; i < 8; i++) {
    id += chars[Math.floor(Math.random() * chars.length)];
  }
  return id;
}

/**
 * Check if it's a specific player's turn
 */
export function isPlayersTurn(flowState: FlowState | undefined, playerPosition: number): boolean {
  if (!flowState?.awaitingInput) return false;


  if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
    const playerState = flowState.awaitingPlayers.find(p => p.playerIndex === playerPosition);
    return playerState ? !playerState.completed && playerState.availableActions.length > 0 : false;
  }


  return flowState.currentPlayer === playerPosition;
}




export function buildActionMetadata(
  game: Game,
  player: Player,
  availableActionNames: string[]
): Record<string, ActionMetadata> {
  const metadata: Record<string, ActionMetadata> = {};

  for (const actionName of availableActionNames) {

    const actions = (game as any)._actions as Map<string, ActionDefinition>;
    const actionDef = actions?.get(actionName);

    if (!actionDef) {
      console.warn(`[buildActionMetadata] Action "${actionName}" not found in game._actions`);
      continue;
    }



    if (actionDef.condition) {
      const ctx = { game, player, args: {} };
      try {
        if (!actionDef.condition(ctx)) {
          continue;
        }
      } catch (error) {
        console.error(`[buildActionMetadata] Error checking condition for "${actionName}":`, error);
        continue;
      }
    }

    const selectionMetas: SelectionMetadata[] = [];

    const selectionValues: Map<string, { type: string; values: unknown[] }> = new Map();

    for (const selection of actionDef.selections) {
      const selMeta = buildSelectionMetadata(game, player, selection, selectionValues);
      selectionMetas.push(selMeta);


      if (selection.type === 'element' && selMeta.validElements) {
        selectionValues.set(selection.name, {
          type: 'element',
          values: selMeta.validElements.map(ve => ve.id),
        });
      } else if (selection.type === 'choice' && selMeta.choices) {
        selectionValues.set(selection.name, {
          type: 'choice',
          values: selMeta.choices.map(c => c.value),
        });
      }
    }

    metadata[actionName] = {
      name: actionName,
      prompt: actionDef.prompt,
      selections: selectionMetas,
    };
  }

  return metadata;
}




function buildSelectionMetadata(
  game: Game,
  player: Player,
  selection: Selection,
  selectionValues: Map<string, { type: string; values: unknown[] }>
): SelectionMetadata {

  const ctx = { game, player, args: {} as Record<string, unknown> };


  const evaluatedPrompt = typeof selection.prompt === 'function'
    ? selection.prompt(ctx)
    : selection.prompt;

  const base: SelectionMetadata = {
    name: selection.name,
    type: selection.type,
    prompt: evaluatedPrompt,
    optional: selection.optional,
  };


  switch (selection.type) {
    case 'choice': {
      const choiceSel = selection as any;


      if (choiceSel.dependsOn && typeof choiceSel.choices === 'function') {
        const dependentInfo = selectionValues.get(choiceSel.dependsOn);

        if (dependentInfo) {
          base.dependsOn = choiceSel.dependsOn;
          base.choicesByDependentValue = {};


          for (const depValue of dependentInfo.values) {


            let argValue: unknown = depValue;
            if (dependentInfo.type === 'element' && typeof depValue === 'number') {
              argValue = game.getElementById(depValue);
            }

            const argsWithDep = { [choiceSel.dependsOn]: argValue };
            const ctxWithDep = { game, player, args: argsWithDep };

            let choices: unknown[];
            try {
              choices = choiceSel.choices(ctxWithDep);
            } catch (error) {
              console.error(`[buildSelectionMetadata] Error getting choices for "${selection.name}" with ${choiceSel.dependsOn}=${depValue}:`, error);
              choices = [];
            }


            const formattedChoices = choices.map(value => {
              const choice: any = {
                value,
                display: choiceSel.display ? choiceSel.display(value) : defaultChoiceDisplay(value),
              };

              if (choiceSel.boardRefs) {
                try {
                  const refs = choiceSel.boardRefs(value, ctxWithDep);
                  if (refs.sourceRef) choice.sourceRef = refs.sourceRef;
                  if (refs.targetRef) choice.targetRef = refs.targetRef;
                } catch {

                }
              }

              return choice;
            });


            const key = String(depValue);
            base.choicesByDependentValue[key] = formattedChoices;
          }


          if (choiceSel.repeat || choiceSel.repeatUntil !== undefined) {
            base.repeat = {
              hasOnEach: !!choiceSel.repeat?.onEach,
              terminator: choiceSel.repeatUntil,
            };
          }



          if (choiceSel.multiSelect !== undefined) {
            base.multiSelectByDependentValue = {};

            for (const depValue of dependentInfo.values) {

              let argValue: unknown = depValue;
              if (dependentInfo.type === 'element' && typeof depValue === 'number') {
                argValue = game.getElementById(depValue);
              }

              const argsWithDep = { [choiceSel.dependsOn]: argValue };
              const ctxWithDep = { game, player, args: argsWithDep };

              const multiSelectConfig = typeof choiceSel.multiSelect === 'function'
                ? choiceSel.multiSelect(ctxWithDep)
                : choiceSel.multiSelect;

              const key = String(depValue);
              if (multiSelectConfig !== undefined) {
                if (typeof multiSelectConfig === 'number') {
                  base.multiSelectByDependentValue[key] = { min: 1, max: multiSelectConfig };
                } else {
                  base.multiSelectByDependentValue[key] = {
                    min: multiSelectConfig.min ?? 1,
                    max: multiSelectConfig.max,
                  };
                }
              } else {

                base.multiSelectByDependentValue[key] = undefined;
              }
            }
          }


          break;
        }
      }


      let choices: unknown[];
      if (typeof choiceSel.choices === 'function') {
        try {
          choices = choiceSel.choices(ctx);
        } catch (error) {
          console.error(`[buildSelectionMetadata] Error getting choices for selection "${selection.name}":`, error);
          choices = [];
        }
      } else {
        choices = choiceSel.choices || [];
      }


      base.choices = choices.map(value => {
        const choice: any = {
          value,
          display: choiceSel.display ? choiceSel.display(value) : defaultChoiceDisplay(value),
        };


        if (choiceSel.boardRefs) {
          try {
            const refs = choiceSel.boardRefs(value, ctx);
            if (refs.sourceRef) choice.sourceRef = refs.sourceRef;
            if (refs.targetRef) choice.targetRef = refs.targetRef;
          } catch {

          }
        }

        return choice;
      });


      if (choiceSel.filterBy) {
        base.filterBy = choiceSel.filterBy;
      }


      if (choiceSel.repeat || choiceSel.repeatUntil !== undefined) {
        base.repeat = {
          hasOnEach: !!choiceSel.repeat?.onEach,
          terminator: choiceSel.repeatUntil,
        };
      }


      if (choiceSel.multiSelect !== undefined) {
        const multiSelectConfig = typeof choiceSel.multiSelect === 'function'
          ? choiceSel.multiSelect(ctx)
          : choiceSel.multiSelect;

        if (multiSelectConfig !== undefined) {
          if (typeof multiSelectConfig === 'number') {

            base.multiSelect = { min: 1, max: multiSelectConfig };
          } else {

            base.multiSelect = {
              min: multiSelectConfig.min ?? 1,
              max: multiSelectConfig.max,
            };
          }
        }
      }
      break;
    }

    case 'element': {
      const elemSel = selection as any;
      if (elemSel.elementClass?.name) {
        base.elementClassName = elemSel.elementClass.name;
      }


      const from = typeof elemSel.from === 'function'
        ? elemSel.from(ctx)
        : elemSel.from ?? game;

      let elements: any[];
      if (elemSel.elementClass) {
        elements = [...from.all(elemSel.elementClass)];
      } else {
        elements = [...from.all()];
      }

      if (elemSel.filter) {
        elements = elements.filter((e: any) => elemSel.filter!(e, ctx));
      }


      base.validElements = elements.map((element: any) => {
        const validElem: any = { id: element.id };


        if (elemSel.display) {
          try {
            validElem.display = elemSel.display(element, ctx);
          } catch {
            validElem.display = element.name || String(element.id);
          }
        } else {

          validElem.display = element.notation || element.name || String(element.id);
        }


        if (elemSel.boardRef) {
          try {
            validElem.ref = elemSel.boardRef(element, ctx);
          } catch {

          }
        } else {

          validElem.ref = { id: element.id };
          if (element.notation) {
            validElem.ref.notation = element.notation;
          }
        }

        return validElem;
      });
      break;
    }

    case 'number': {
      const numSel = selection as any;
      base.min = numSel.min;
      base.max = numSel.max;
      base.integer = numSel.integer;
      break;
    }

    case 'text': {
      const textSel = selection as any;
      base.pattern = textSel.pattern?.source;
      base.minLength = textSel.minLength;
      base.maxLength = textSel.maxLength;
      break;
    }
  }

  return base;
}
















export function computeUndoInfo(
  actionHistory: Array<{ player: number; undoable?: boolean }>,
  currentPlayer: number | undefined,
  moveCount?: number
): { turnStartActionIndex: number; actionsThisTurn: number; hasNonUndoableAction: boolean } {
  if (currentPlayer === undefined || actionHistory.length === 0) {
    return { turnStartActionIndex: 0, actionsThisTurn: 0, hasNonUndoableAction: false };
  }




  if (moveCount !== undefined) {


    let hasNonUndoableAction = false;
    const turnStartActionIndex = Math.max(0, actionHistory.length - moveCount);

    for (let i = actionHistory.length - 1; i >= turnStartActionIndex; i--) {
      if (actionHistory[i].undoable === false) {
        hasNonUndoableAction = true;
        break;
      }
    }

    return { turnStartActionIndex, actionsThisTurn: moveCount, hasNonUndoableAction };
  }





  let actionsThisTurn = 0;
  let hasNonUndoableAction = false;

  for (let i = actionHistory.length - 1; i >= 0; i--) {
    if (actionHistory[i].player === currentPlayer) {
      actionsThisTurn++;

      if (actionHistory[i].undoable === false) {
        hasNonUndoableAction = true;
      }
    } else {

      return { turnStartActionIndex: i + 1, actionsThisTurn, hasNonUndoableAction };
    }
  }


  return { turnStartActionIndex: 0, actionsThisTurn, hasNonUndoableAction };
}




export function buildPlayerState(
  runner: GameRunner,
  playerNames: string[],
  playerPosition: number,
  options?: { includeActionMetadata?: boolean; includeDebugData?: boolean }
): PlayerGameState {
  const flowState = runner.getFlowState();
  const view = runner.getPlayerView(playerPosition);


  let availableActions: string[];
  if (flowState?.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
    const playerState = flowState.awaitingPlayers.find(p => p.playerIndex === playerPosition);
    availableActions = playerState?.availableActions ?? [];
  } else {
    availableActions = flowState?.availableActions ?? [];
  }

  const isMyTurn = isPlayersTurn(flowState, playerPosition);




  const { turnStartActionIndex, actionsThisTurn, hasNonUndoableAction } = computeUndoInfo(
    runner.actionHistory,
    flowState?.currentPlayer,
    flowState?.moveCount
  );


  const canUndo = isMyTurn && actionsThisTurn > 0 && flowState?.currentPlayer === playerPosition && !hasNonUndoableAction;





  const fullPlayerData = [...runner.game.players.map((player: Player) => {
    if (typeof player.toJSON === 'function') {
      return player.toJSON() as { name: string; position: number; [key: string]: unknown };
    }

    return { name: player.name, position: player.position };
  })];

  const state: PlayerGameState = {
    phase: runner.game.phase,
    players: fullPlayerData,
    currentPlayer: flowState?.currentPlayer,
    availableActions,
    isMyTurn,
    view: view.state,
    canUndo,
    actionsThisTurn: isMyTurn ? actionsThisTurn : 0,
    turnStartActionIndex: isMyTurn ? turnStartActionIndex : undefined,
  };


  if (options?.includeActionMetadata && availableActions.length > 0) {
    const player = runner.game.players[playerPosition];
    if (player) {
      state.actionMetadata = buildActionMetadata(runner.game, player, availableActions);
    }
  }


  if (options?.includeDebugData) {
    const customDebug = runner.game.getCustomDebugData();
    if (Object.keys(customDebug).length > 0) {
      state.customDebug = customDebug;
    }
  }

  return state;
}





export function buildActionTraces(
  runner: GameRunner,
  playerPosition: number
): ActionTrace[] {
  const player = runner.game.players[playerPosition];
  if (!player) {
    return [];
  }
  return runner.game.getActionTraces(player);
}
````

## File: packages/engine/src/action/action.ts
````typescript
import type { GameElement } from '../element/game-element.js';
import type { Player } from '../player/player.js';
import type { Game } from '../element/game.js';
import type {
  ActionDefinition,
  ActionContext,
  ActionResult,
  Selection,
  ChoiceSelection,
  ElementSelection,
  TextSelection,
  NumberSelection,
  ValidationResult,
  ChoiceBoardRefs,
  DependentFilter,
  BoardElementRef,
  ConditionDetail,
  ActionTrace,
  SelectionTrace,
  RepeatConfig,
  PendingActionState,
  MultiSelectConfig,
} from './types.js';
import type { ElementClass } from '../element/types.js';





















export class ConditionTracer {
  private details: ConditionDetail[] = [];







  check(label: string, value: unknown): boolean {
    const passed = Boolean(value);
    this.details.push({ label, value, passed });
    return passed;
  }







  nested(label: string, fn: (tracer: ConditionTracer) => boolean): boolean {
    const childTracer = new ConditionTracer();
    const result = fn(childTracer);
    this.details.push({
      label,
      value: result,
      passed: result,
      children: childTracer.getDetails(),
    });
    return result;
  }




  getDetails(): ConditionDetail[] {
    return this.details;
  }
}





function wrapFilterWithHelpfulErrors<T>(
  filter: (item: T, context: ActionContext) => boolean,
  selectionName: string
): (item: T, context: ActionContext) => boolean {
  return (item: T, context: ActionContext) => {
    try {
      return filter(item, context);
    } catch (error) {
      if (error instanceof TypeError && error.message.includes('Cannot read properties of undefined')) {

        const match = error.message.match(/reading '(\w+)'/);
        const prop = match?.[1] || 'unknown';


        const argsKeys = Object.keys(context.args || {});
        const undefinedArgs = argsKeys.filter(k => context.args[k] === undefined);

        if (undefinedArgs.length > 0 || argsKeys.length === 0) {
          const undefinedList = undefinedArgs.length > 0
            ? undefinedArgs.join(', ')
            : '(no previous selections made yet)';

          throw new Error(
            `Filter for selection '${selectionName}' crashed accessing undefined property '${prop}'.\n\n` +
            `This likely happened because the filter runs during availability checks when ` +
            `previous selections haven't been made yet.\n\n` +
            `Undefined args: ${undefinedList}\n\n` +
            `Fix: Use the dependentFilter helper or add a null check:\n\n` +
            `  // Option 1: Use dependentFilter (recommended)\n` +
            `  import { dependentFilter } from '@boardsmith/engine';\n` +
            `  filter: dependentFilter({\n` +
            `    dependsOn: 'previousSelection',\n` +
            `    whenUndefined: (element) => true, // Allow during availability check\n` +
            `    whenSelected: (element, prev) => /* your filter logic */,\n` +
            `  })\n\n` +
            `  // Option 2: Manual null check\n` +
            `  filter: (element, ctx) => {\n` +
            `    const prev = ctx.args?.previousSelection;\n` +
            `    if (!prev) return true; // Allow during availability check\n` +
            `    return /* your actual filter logic */;\n` +
            `  }`
          );
        }
      }

      throw error;
    }
  };
}



























export class Action {
  private definition: ActionDefinition;

  private constructor(name: string) {
    this.definition = {
      name,
      selections: [],
      execute: () => {},
    };
  }




  static create(name: string): Action {
    return new Action(name);
  }




  prompt(prompt: string): this {
    this.definition.prompt = prompt;
    return this;
  }




  condition(fn: (context: ActionContext) => boolean): this {
    this.definition.condition = fn;
    return this;
  }






  notUndoable(): this {
    this.definition.undoable = false;
    return this;
  }




  chooseFrom<T>(
    name: string,
    options: {
      prompt?: string;
      choices: T[] | ((context: ActionContext) => T[]);
      display?: (choice: T) => string;
      optional?: boolean;
      validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;

      boardRefs?: (choice: T, context: ActionContext) => ChoiceBoardRefs;

      filterBy?: DependentFilter;





      dependsOn?: string;




      repeat?: RepeatConfig<T>;




      repeatUntil?: T;




      multiSelect?: number | MultiSelectConfig | ((context: ActionContext) => number | MultiSelectConfig | undefined);
    }
  ): this {
    const selection: ChoiceSelection<T> = {
      type: 'choice',
      name,
      prompt: options.prompt,
      choices: options.choices,
      display: options.display,
      optional: options.optional,
      validate: options.validate,
      boardRefs: options.boardRefs,
      filterBy: options.filterBy,
      dependsOn: options.dependsOn,
      repeat: options.repeat,
      repeatUntil: options.repeatUntil,
      multiSelect: options.multiSelect,
    };
    this.definition.selections.push(selection as Selection);
    return this;
  }




  chooseElement<T extends GameElement>(
    name: string,
    options: {
      prompt?: string;
      elementClass?: ElementClass<T>;
      from?: GameElement | ((context: ActionContext) => GameElement);
      filter?: (element: GameElement, context: ActionContext) => boolean;
      optional?: boolean;
      validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;

      display?: (element: T, context: ActionContext) => string;

      boardRef?: (element: T, context: ActionContext) => BoardElementRef;
    } = {}
  ): this {
    const selection: ElementSelection<T> = {
      type: 'element',
      name,
      prompt: options.prompt,
      elementClass: options.elementClass,
      from: options.from,
      filter: options.filter,
      optional: options.optional,
      validate: options.validate,
      display: options.display as ElementSelection<T>['display'],
      boardRef: options.boardRef as ElementSelection<T>['boardRef'],
    };
    this.definition.selections.push(selection as Selection);
    return this;
  }




  enterText(
    name: string,
    options: {
      prompt?: string;
      pattern?: RegExp;
      minLength?: number;
      maxLength?: number;
      optional?: boolean;
      validate?: (value: string, args: Record<string, unknown>, context: ActionContext) => boolean | string;
    } = {}
  ): this {
    const selection: TextSelection = {
      type: 'text',
      name,
      prompt: options.prompt,
      pattern: options.pattern,
      minLength: options.minLength,
      maxLength: options.maxLength,
      optional: options.optional,
      validate: options.validate,
    };
    this.definition.selections.push(selection);
    return this;
  }




  enterNumber(
    name: string,
    options: {
      prompt?: string;
      min?: number;
      max?: number;
      integer?: boolean;
      optional?: boolean;
      validate?: (value: number, args: Record<string, unknown>, context: ActionContext) => boolean | string;
    } = {}
  ): this {
    const selection: NumberSelection = {
      type: 'number',
      name,
      prompt: options.prompt,
      min: options.min,
      max: options.max,
      integer: options.integer,
      optional: options.optional,
      validate: options.validate,
    };
    this.definition.selections.push(selection);
    return this;
  }




  execute(
    fn: (args: Record<string, unknown>, context: ActionContext) => ActionResult | void
  ): ActionDefinition {
    this.definition.execute = fn;
    return this.definition;
  }




  build(): ActionDefinition {
    return this.definition;
  }
}




export class ActionExecutor {
  private game: Game;

  constructor(game: Game) {
    this.game = game;
  }





  resolveArgs(
    action: ActionDefinition,
    args: Record<string, unknown>
  ): Record<string, unknown> {
    const resolved = { ...args };

    for (const selection of action.selections) {
      const value = args[selection.name];
      if (value === undefined) continue;

      switch (selection.type) {
        case 'element': {

          if (typeof value === 'number') {
            const element = this.game.getElementById(value);
            if (element) {
              resolved[selection.name] = element;
            }
          }
          break;
        }
      }
    }

    return resolved;
  }




  getChoices(
    selection: Selection,
    player: Player,
    args: Record<string, unknown>
  ): unknown[] {
    const context: ActionContext = {
      game: this.game,
      player,
      args,
    };

    switch (selection.type) {
      case 'choice': {
        const choiceSel = selection as ChoiceSelection;
        let choices = typeof choiceSel.choices === 'function'
          ? choiceSel.choices(context)
          : [...choiceSel.choices];


        if (choiceSel.filterBy) {
          const { key, selectionName } = choiceSel.filterBy;
          const previousValue = args[selectionName];

          if (previousValue !== undefined) {


            let filterValue: unknown;
            if (typeof previousValue === 'object' && previousValue !== null) {
              const prevObj = previousValue as Record<string, unknown>;

              filterValue = prevObj[key] !== undefined ? prevObj[key] : prevObj['id'];
            } else {
              filterValue = previousValue;
            }


            choices = choices.filter((choice) => {
              if (typeof choice === 'object' && choice !== null) {
                return (choice as Record<string, unknown>)[key] === filterValue;
              }
              return choice === filterValue;
            });
          }
        }

        return choices;
      }

      case 'element': {
        const elementSel = selection as ElementSelection;
        const from =
          typeof elementSel.from === 'function'
            ? elementSel.from(context)
            : elementSel.from ?? this.game;

        let elements: GameElement[];
        if (elementSel.elementClass) {
          elements = [...from.all(elementSel.elementClass)];
        } else {
          elements = [...from.all()];
        }

        if (elementSel.filter) {
          const wrappedFilter = wrapFilterWithHelpfulErrors(elementSel.filter, selection.name);
          elements = elements.filter((e) => wrappedFilter(e, context));
        }

        return elements;
      }

      case 'text':
      case 'number':

        return [];

      default:
        return [];
    }
  }







  shouldSkip(
    _selection: Selection,
    _player: Player,
    _args: Record<string, unknown>
  ): { skip: boolean; value?: unknown } {

    return { skip: false };
  }




  private valuesEqual(a: unknown, b: unknown): boolean {
    if (a === b) return true;
    if (typeof a !== typeof b) return false;
    if (typeof a === 'object' && a !== null && b !== null) {

      return JSON.stringify(a) === JSON.stringify(b);
    }
    return false;
  }




  private choicesContain(choices: unknown[], value: unknown): boolean {
    return choices.some(choice => this.valuesEqual(choice, value));
  }




  validateSelection(
    selection: Selection,
    value: unknown,
    player: Player,
    args: Record<string, unknown>
  ): ValidationResult {
    const errors: string[] = [];
    const context: ActionContext = {
      game: this.game,
      player,
      args,
    };


    if (selection.type === 'choice' || selection.type === 'element') {
      const choices = this.getChoices(selection, player, args);


      if (Array.isArray(value)) {
        for (const v of value) {
          if (!this.choicesContain(choices, v)) {
            errors.push(`Invalid selection for ${selection.name}: ${JSON.stringify(v)}`);
          }
        }
      } else if (!this.choicesContain(choices, value)) {
        errors.push(`Invalid selection for ${selection.name}`);
      }
    }


    switch (selection.type) {
      case 'text': {
        const textSel = selection as TextSelection;
        const str = value as string;
        if (typeof str !== 'string') {
          errors.push(`${selection.name} must be a string`);
        } else {
          if (textSel.minLength !== undefined && str.length < textSel.minLength) {
            errors.push(`${selection.name} must be at least ${textSel.minLength} characters`);
          }
          if (textSel.maxLength !== undefined && str.length > textSel.maxLength) {
            errors.push(`${selection.name} must be at most ${textSel.maxLength} characters`);
          }
          if (textSel.pattern && !textSel.pattern.test(str)) {
            errors.push(`${selection.name} does not match required pattern`);
          }
        }
        break;
      }

      case 'number': {
        const numSel = selection as NumberSelection;
        const num = value as number;
        if (typeof num !== 'number' || isNaN(num)) {
          errors.push(`${selection.name} must be a number`);
        } else {
          if (numSel.min !== undefined && num < numSel.min) {
            errors.push(`${selection.name} must be at least ${numSel.min}`);
          }
          if (numSel.max !== undefined && num > numSel.max) {
            errors.push(`${selection.name} must be at most ${numSel.max}`);
          }
          if (numSel.integer && !Number.isInteger(num)) {
            errors.push(`${selection.name} must be an integer`);
          }
        }
        break;
      }
    }


    if (selection.validate && errors.length === 0) {

      const result = (selection.validate as (v: unknown, a: Record<string, unknown>, c: ActionContext) => boolean | string)(value, args, context);
      if (result !== true) {
        errors.push(typeof result === 'string' ? result : `Invalid ${selection.name}`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }




  validateAction(
    action: ActionDefinition,
    player: Player,
    args: Record<string, unknown>
  ): ValidationResult {
    const allErrors: string[] = [];
    const context: ActionContext = {
      game: this.game,
      player,
      args,
    };


    if (action.condition && !action.condition(context)) {
      return {
        valid: false,
        errors: ['Action is not available'],
      };
    }


    for (const selection of action.selections) {
      const value = args[selection.name];


      if (value === undefined) {
        if (!selection.optional) {
          allErrors.push(`Missing required selection: ${selection.name}`);
        }
        continue;
      }

      const result = this.validateSelection(selection, value, player, args);
      allErrors.push(...result.errors);
    }

    return {
      valid: allErrors.length === 0,
      errors: allErrors,
    };
  }




  executeAction(
    action: ActionDefinition,
    player: Player,
    args: Record<string, unknown>
  ): ActionResult {

    const resolvedArgs = this.resolveArgs(action, args);


    const validation = this.validateAction(action, player, resolvedArgs);
    if (!validation.valid) {
      return {
        success: false,
        error: validation.errors.join('; '),
      };
    }

    const context: ActionContext = {
      game: this.game,
      player,
      args: resolvedArgs,
    };

    try {
      const result = action.execute(resolvedArgs, context);
      return result ?? { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }






  isActionAvailable(action: ActionDefinition, player: Player): boolean {
    const context: ActionContext = {
      game: this.game,
      player,
      args: {},
    };

    if (action.condition && !action.condition(context)) {
      return false;
    }


    return this.hasValidSelectionPath(action.selections, player, {}, 0);
  }





  traceActionAvailability(action: ActionDefinition, player: Player): ActionTrace {
    const trace: ActionTrace = {
      actionName: action.name,
      available: false,
      selections: [],
    };

    const context: ActionContext = {
      game: this.game,
      player,
      args: {},
    };


    if (action.condition) {
      try {
        const tracer = new ConditionTracer();

        trace.conditionResult = action.condition(context, tracer);
        const details = tracer.getDetails();
        if (details.length > 0) {
          trace.conditionDetails = details;
        }

        if (!trace.conditionResult) {

          return trace;
        }
      } catch (error) {
        trace.conditionError = error instanceof Error ? error.message : String(error);
        return trace;
      }
    } else {

      trace.conditionResult = true;
    }


    trace.available = this.traceSelectionPath(action.selections, player, {}, 0, trace.selections);
    return trace;
  }





  private traceSelectionPath(
    selections: Selection[],
    player: Player,
    args: Record<string, unknown>,
    index: number,
    selectionTraces: SelectionTrace[]
  ): boolean {

    if (index >= selections.length) {
      return true;
    }

    const selection = selections[index];
    const selTrace: SelectionTrace = {
      name: selection.name,
      type: selection.type,
      choiceCount: 0,
      optional: selection.optional,
    };


    if (selection.optional) {
      selectionTraces.push(selTrace);
      return this.traceSelectionPath(selections, player, args, index + 1, selectionTraces);
    }


    if (selection.type === 'text' || selection.type === 'number') {
      selTrace.choiceCount = -1;
      selectionTraces.push(selTrace);
      return this.traceSelectionPath(selections, player, args, index + 1, selectionTraces);
    }


    if (selection.type === 'choice') {
      const choiceSel = selection as ChoiceSelection;
      if (choiceSel.filterBy) {
        selTrace.filterApplied = true;
      }
      if (choiceSel.dependsOn) {
        selTrace.dependentOn = choiceSel.dependsOn;
      }
    }


    const choices = this.getChoices(selection, player, args);
    selTrace.choiceCount = choices.length;
    selectionTraces.push(selTrace);

    if (choices.length === 0) {
      return false;
    }



    return this.traceSelectionPath(selections, player, args, index + 1, selectionTraces);
  }




  private getChoiceFilterValue(choice: unknown, key: string): unknown {
    if (typeof choice === 'object' && choice !== null) {
      return (choice as Record<string, unknown>)[key];
    }
    return choice;
  }




  private hasDependentSelection(
    selections: Selection[],
    afterIndex: number,
    selectionName: string
  ): boolean {
    for (let i = afterIndex; i < selections.length; i++) {
      const sel = selections[i];
      if (sel.type === 'choice') {
        const choiceSel = sel as ChoiceSelection;
        if (choiceSel.filterBy?.selectionName === selectionName) {
          return true;
        }
      }
    }
    return false;
  }











  private hasValidSelectionPath(
    selections: Selection[],
    player: Player,
    args: Record<string, unknown>,
    index: number
  ): boolean {

    if (index >= selections.length) {
      return true;
    }

    const selection = selections[index];


    if (selection.optional) {
      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }


    if (selection.type === 'text' || selection.type === 'number') {
      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }



    if (selection.type === 'element') {
      const choices = this.getChoices(selection, player, args);
      if (choices.length === 0) {
        return false;
      }
      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }



    if (selection.type === 'choice') {
      const choiceSel = selection as ChoiceSelection;
      if (typeof choiceSel.choices === 'function') {
        const choices = this.getChoices(selection, player, args);
        if (choices.length === 0) {
          return false;
        }
        return this.hasValidSelectionPath(selections, player, args, index + 1);
      }
    }


    const choices = this.getChoices(selection, player, args);
    if (choices.length === 0) {
      return false;
    }


    const hasDependent = this.hasDependentSelection(selections, index + 1, selection.name);

    if (!hasDependent) {

      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }



    for (const choice of choices) {

      const newArgs = { ...args, [selection.name]: choice };


      if (this.hasValidSelectionPath(selections, player, newArgs, index + 1)) {
        return true;
      }
    }


    return false;
  }








  isRepeatingSelection(selection: Selection): boolean {
    if (selection.type !== 'choice') return false;
    const cs = selection as ChoiceSelection;
    return cs.repeat !== undefined || cs.repeatUntil !== undefined;
  }




  hasRepeatingSelections(action: ActionDefinition): boolean {
    return action.selections.some(s => this.isRepeatingSelection(s));
  }











  processRepeatingStep(
    action: ActionDefinition,
    player: Player,
    pendingState: PendingActionState,
    value: unknown
  ): { done: boolean; nextChoices?: unknown[]; error?: string } {
    const selection = action.selections[pendingState.currentSelectionIndex];
    if (!selection || selection.type !== 'choice') {
      return { done: true, error: `Selection at index ${pendingState.currentSelectionIndex} not found or not a choice` };
    }

    const choiceSel = selection as ChoiceSelection;
    if (!choiceSel.repeat && choiceSel.repeatUntil === undefined) {
      return { done: true, error: `Selection ${selection.name} is not repeating` };
    }


    if (!pendingState.repeating) {
      pendingState.repeating = {
        selectionName: selection.name,
        accumulated: [],
        iterationCount: 0,
      };
    }




    const resolvedArgs = this.resolveArgs(action, pendingState.collectedArgs);


    const context: ActionContext = {
      game: this.game,
      player,
      args: {
        ...resolvedArgs,
        [selection.name]: pendingState.repeating.accumulated,
      },
    };

    const currentChoices = this.getChoices(selection, player, context.args);
    if (!this.choicesContain(currentChoices, value)) {
      return { done: false, error: `Invalid choice: ${JSON.stringify(value)}`, nextChoices: currentChoices };
    }


    pendingState.repeating.accumulated.push(value);
    pendingState.repeating.iterationCount++;


    context.args[selection.name] = pendingState.repeating.accumulated;


    if (choiceSel.repeat?.onEach) {
      try {
        choiceSel.repeat.onEach(context, value);
      } catch (error) {
        return { done: true, error: error instanceof Error ? error.message : String(error) };
      }
    }


    let isDone = false;
    if (choiceSel.repeatUntil !== undefined) {

      isDone = this.valuesEqual(value, choiceSel.repeatUntil);
    } else if (choiceSel.repeat?.until) {

      try {
        isDone = choiceSel.repeat.until(context, value);
      } catch (error) {
        return { done: true, error: error instanceof Error ? error.message : String(error) };
      }
    }

    if (isDone) {

      pendingState.collectedArgs[selection.name] = pendingState.repeating.accumulated;
      pendingState.repeating = undefined;
      pendingState.currentSelectionIndex++;
      return { done: true };
    }



    const nextResolvedArgs = this.resolveArgs(action, pendingState.collectedArgs);
    const nextContext: ActionContext = {
      game: this.game,
      player,
      args: {
        ...nextResolvedArgs,
        [selection.name]: pendingState.repeating.accumulated,
      },
    };
    const nextChoices = this.getChoices(selection, player, nextContext.args);


    if (nextChoices.length === 0) {
      pendingState.collectedArgs[selection.name] = pendingState.repeating.accumulated;
      pendingState.repeating = undefined;
      pendingState.currentSelectionIndex++;
      return { done: true };
    }

    return { done: false, nextChoices };
  }




  createPendingActionState(actionName: string, playerPosition: number): PendingActionState {
    return {
      actionName,
      playerPosition,
      collectedArgs: {},
      currentSelectionIndex: 0,
    };
  }





  processSelectionStep(
    action: ActionDefinition,
    player: Player,
    pendingState: PendingActionState,
    selectionName: string,
    value: unknown
  ): { success: boolean; error?: string } {
    const selectionIndex = action.selections.findIndex(s => s.name === selectionName);
    if (selectionIndex === -1) {
      return { success: false, error: `Selection ${selectionName} not found` };
    }


    if (selectionIndex !== pendingState.currentSelectionIndex) {
      return { success: false, error: `Expected selection at index ${pendingState.currentSelectionIndex}, got ${selectionName} at index ${selectionIndex}` };
    }

    const selection = action.selections[selectionIndex];


    if (this.isRepeatingSelection(selection)) {
      const result = this.processRepeatingStep(action, player, pendingState, value);
      return { success: !result.error, error: result.error };
    }


    const validationResult = this.validateSelection(selection, value, player, pendingState.collectedArgs);
    if (!validationResult.valid) {
      return { success: false, error: validationResult.errors.join('; ') };
    }


    pendingState.collectedArgs[selectionName] = value;
    pendingState.currentSelectionIndex++;

    return { success: true };
  }




  isPendingActionComplete(action: ActionDefinition, pendingState: PendingActionState): boolean {
    return pendingState.currentSelectionIndex >= action.selections.length && !pendingState.repeating;
  }




  executePendingAction(
    action: ActionDefinition,
    player: Player,
    pendingState: PendingActionState
  ): ActionResult {
    if (!this.isPendingActionComplete(action, pendingState)) {
      return { success: false, error: 'Action is not complete' };
    }


    const resolvedArgs = this.resolveArgs(action, pendingState.collectedArgs);

    const context: ActionContext = {
      game: this.game,
      player,
      args: resolvedArgs,
    };

    try {
      const result = action.execute(resolvedArgs, context);
      return result ?? { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}
````

## File: packages/engine/src/element/game.ts
````typescript
import { Space } from './space.js';
import { GameElement } from './game-element.js';
import type { ElementContext, ElementClass, ElementJSON } from './types.js';
import { Player, PlayerCollection } from '../player/player.js';
import type { GameCommand, CommandResult } from '../command/types.js';
import { executeCommand } from '../command/executor.js';
import type { ActionDefinition, ActionResult, SerializedAction, ActionTrace } from '../action/types.js';
import { ActionExecutor } from '../action/action.js';
import type { FlowDefinition, FlowState, FlowPosition } from '../flow/types.js';
import { FlowEngine } from '../flow/engine.js';




export type GameOptions = {

  playerCount: number;

  playerNames?: string[];

  seed?: string;
};




export type GamePhase = 'setup' | 'started' | 'finished';











export type PlayerViewFunction<G extends Game = Game> = (
  state: ElementJSON,
  playerPosition: number | null,
  game: G
) => ElementJSON;




function createSeededRandom(seed: string): () => number {

  let h = 0;
  for (let i = 0; i < seed.length; i++) {
    h = Math.imul(31, h) + seed.charCodeAt(i) | 0;
  }

  return function () {
    h |= 0;
    h = h + 0x6D2B79F5 | 0;
    let t = Math.imul(h ^ h >>> 15, 1 | h);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}





export class Game<
  G extends Game = any,
  P extends Player = any
> extends Space<G, P> {




  static playerView?: PlayerViewFunction;


  pile!: GameElement;


  players: PlayerCollection<P> = new PlayerCollection<P>();


  phase: GamePhase = 'setup';


  random: () => number;


  messages: Array<{ text: string; data?: Record<string, unknown> }> = [];


  settings: Record<string, unknown> = {};


  commandHistory: GameCommand[] = [];


  private _actions: Map<string, ActionDefinition> = new Map();


  private _actionExecutor!: ActionExecutor;


  private _flowDefinition?: FlowDefinition;


  private _flowEngine?: FlowEngine;


  private _debugRegistry: Map<string, () => unknown> = new Map();

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
    'pile',
    'players',
    'random',
    'commandHistory',
    '_actions',
    '_actionExecutor',
    '_flowDefinition',
    '_flowEngine',
    '_debugRegistry',
  ];

  constructor(options: GameOptions) {

    const seed = options.seed ?? Math.random().toString(36).substring(2);
    const random = createSeededRandom(seed);


    const ctx: Partial<ElementContext> = {
      sequence: 0,
      classRegistry: new Map(),
      random,
    };

    super(ctx);

    this.random = random;
    this.game = this as unknown as G;
    this._ctx.game = this;


    this._ctx.classRegistry.set('Space', Space as unknown as ElementClass);
    this._ctx.classRegistry.set('GameElement', GameElement as unknown as ElementClass);


    this.pile = this.createElement(Space, '__pile__');
    this.pile._t.parent = undefined;


    for (let i = 0; i < options.playerCount; i++) {
      const name = options.playerNames?.[i] ?? `Player ${i + 1}`;
      const player = this.createPlayer(i, name);
      player.game = this as unknown as Game;
      this.players.push(player as P);
    }


    if (this.players.length > 0) {
      this.players.setCurrent(0);
    }


    this._actionExecutor = new ActionExecutor(this);
  }




  protected createPlayer(position: number, name: string): P {
    return new Player(position, name) as P;
  }














  protected registerElements(
    classes: (new (...args: any[]) => GameElement)[]
  ): void {
    for (const cls of classes) {
      const className = cls.name;
      if (!this._ctx.classRegistry.has(className)) {
        this._ctx.classRegistry.set(className, cls as ElementClass);
      }
    }
  }




  protected createElement<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string
  ): T {
    const element = new elementClass(this._ctx);
    element.name = name;
    element.game = this as unknown as Game;

    const className = elementClass.name;
    if (!this._ctx.classRegistry.has(className)) {
      this._ctx.classRegistry.set(className, elementClass);
    }

    return element;
  }








  getElementById(id: number): GameElement | undefined {

    const found = this.atId(id);
    if (found) return found;


    return this.pile.atId(id);
  }




  getElementClass(className: string): ElementClass | undefined {
    return this._ctx.classRegistry.get(className);
  }








  execute(command: GameCommand): CommandResult {
    const result = executeCommand(this, command);
    if (result.success) {
      this.commandHistory.push(command);
    }
    return result;
  }




  replayCommands(commands: GameCommand[]): void {
    for (const command of commands) {
      const result = executeCommand(this, command);
      if (!result.success) {
        throw new Error(`Failed to replay command: ${result.error}`);
      }
      this.commandHistory.push(command);
    }
  }








  registerAction(action: ActionDefinition): void {
    this._actions.set(action.name, action);
  }




  registerActions(...actions: ActionDefinition[]): void {
    for (const action of actions) {
      this.registerAction(action);
    }
  }




  getAction(name: string): ActionDefinition | undefined {
    return this._actions.get(name);
  }




  getActionNames(): string[] {
    return [...this._actions.keys()];
  }




  getAvailableActions(player: P): ActionDefinition[] {
    const available: ActionDefinition[] = [];
    for (const action of this._actions.values()) {
      if (this._actionExecutor.isActionAvailable(action, player)) {
        available.push(action);
      }
    }
    return available;
  }




  getActionExecutor(): ActionExecutor {
    return this._actionExecutor;
  }




  getSelectionChoices(
    actionName: string,
    selectionName: string,
    player: P,
    args: Record<string, unknown> = {}
  ): unknown[] {
    const action = this._actions.get(actionName);
    if (!action) return [];

    const selection = action.selections.find(s => s.name === selectionName);
    if (!selection) return [];

    return this._actionExecutor.getChoices(selection, player, args);
  }




  performAction(
    actionName: string,
    player: P,
    args: Record<string, unknown>
  ): ActionResult {
    const action = this._actions.get(actionName);
    if (!action) {
      return { success: false, error: `Unknown action: ${actionName}` };
    }

    return this._actionExecutor.executeAction(action, player, args);
  }




  performSerializedAction(serialized: SerializedAction): ActionResult {
    const player = this.players[serialized.player];
    if (!player) {
      return { success: false, error: `Invalid player: ${serialized.player}` };
    }

    return this.performAction(serialized.name, player as P, serialized.args);
  }






















  registerDebug(name: string, fn: () => unknown): void {
    this._debugRegistry.set(name, fn);
  }





  getCustomDebugData(): Record<string, unknown> {
    const data: Record<string, unknown> = {};
    for (const [name, fn] of this._debugRegistry) {
      try {
        data[name] = fn();
      } catch (error) {
        data[name] = { error: error instanceof Error ? error.message : String(error) };
      }
    }
    return data;
  }






  getActionTraces(player: P): ActionTrace[] {
    const traces: ActionTrace[] = [];
    for (const action of this._actions.values()) {
      traces.push(this._actionExecutor.traceActionAvailability(action, player));
    }
    return traces;
  }








  setFlow(definition: FlowDefinition): void {
    this._flowDefinition = definition;
  }




  getFlow(): FlowDefinition | undefined {
    return this._flowDefinition;
  }




  startFlow(): FlowState {
    if (!this._flowDefinition) {
      throw new Error('No flow definition set');
    }

    this._flowEngine = new FlowEngine(this, this._flowDefinition);
    const state = this._flowEngine.start();


    if (this.phase === 'setup') {
      this.phase = 'started';
    }
    if (state.complete) {
      this.phase = 'finished';
    }

    return state;
  }







  continueFlow(actionName: string, args: Record<string, unknown>, playerIndex?: number): FlowState {
    if (!this._flowEngine) {
      throw new Error('Flow not started');
    }

    const state = this._flowEngine.resume(actionName, args, playerIndex);

    if (state.complete) {
      this.phase = 'finished';
      const winners = this._flowEngine.getWinners();
      if (winners.length > 0) {
        this.settings.winners = winners.map(p => p.position);
      }
    }

    return state;
  }






  continueFlowAfterPendingAction(result: ActionResult): FlowState {
    if (!this._flowEngine) {
      throw new Error('Flow not started');
    }

    const state = this._flowEngine.resumeAfterExternalAction(result);

    if (state.complete) {
      this.phase = 'finished';
      const winners = this._flowEngine.getWinners();
      if (winners.length > 0) {
        this.settings.winners = winners.map(p => p.position);
      }
    }

    return state;
  }




  getFlowState(): FlowState | undefined {
    return this._flowEngine?.getState();
  }




  restoreFlow(position: FlowPosition): void {
    if (!this._flowDefinition) {
      throw new Error('No flow definition set');
    }

    this._flowEngine = new FlowEngine(this, this._flowDefinition);
    this._flowEngine.restore(position);
  }




  isAwaitingInput(): boolean {
    return this._flowEngine?.getState().awaitingInput ?? false;
  }




  getCurrentFlowPlayer(): P | undefined {
    const state = this._flowEngine?.getState();
    if (state?.currentPlayer !== undefined) {
      return this.players[state.currentPlayer];
    }
    return undefined;
  }




  getFlowAvailableActions(): string[] {
    return this._flowEngine?.getState().availableActions ?? [];
  }





  getAwaitingPlayers(): { playerIndex: number; availableActions: string[]; completed: boolean }[] | undefined {
    const state = this._flowEngine?.getState();
    return state?.awaitingPlayers;
  }




  canPlayerAct(playerIndex: number): boolean {
    const state = this._flowEngine?.getState();
    if (!state?.awaitingInput) return false;


    if (state.awaitingPlayers && state.awaitingPlayers.length > 0) {
      const playerState = state.awaitingPlayers.find(p => p.playerIndex === playerIndex);
      return playerState ? !playerState.completed && playerState.availableActions.length > 0 : false;
    }


    return state.currentPlayer === playerIndex;
  }





















  playerChoices(options: {
    excludeSelf?: boolean;
    filter?: (player: P) => boolean;
    currentPlayer?: Player;
  } = {}): { value: number; display: string }[] {
    let players = [...this.players] as P[];

    if (options.excludeSelf && options.currentPlayer) {
      players = players.filter(p => p.position !== options.currentPlayer!.position);
    }

    if (options.filter) {
      players = players.filter(options.filter);
    }

    return players.map(p => ({
      value: p.position,
      display: p.name,
    }));
  }








  start(): void {
    if (this.phase !== 'setup') {
      throw new Error('Game has already started');
    }
    this.phase = 'started';
  }




  finish(winners?: P[]): void {
    this.phase = 'finished';
    if (winners) {
      this.settings.winners = winners.map(p => p.position);
    }
  }




  isFinished(): boolean {
    return this.phase === 'finished';
  }




  getWinners(): P[] {
    const positions = this.settings.winners as number[] | undefined;
    if (!positions) return [];
    return positions.map(pos => this.players[pos]);
  }








  setPlayerContext(player: P | number | undefined): void {
    if (player === undefined) {
      this._ctx.player = undefined;
    } else if (typeof player === 'number') {
      this._ctx.player = this.players[player];
    } else {
      this._ctx.player = player;
    }
  }




  getPlayerContext(): P | undefined {
    return this._ctx.player as P | undefined;
  }








  message(text: string, data?: Record<string, unknown>): void {
    this.addMessageInternal(text, data);
  }




  addMessageInternal(text: string, data?: Record<string, unknown>): void {
    this.messages.push({ text, data });
  }




  getFormattedMessages(): string[] {
    return this.messages.map(({ text, data }) => {
      if (!data) return text;
      let processed = text;
      for (const [key, value] of Object.entries(data)) {
        const replacement = value instanceof GameElement
          ? value.toString()
          : value instanceof Player
            ? value.name
            : String(value);
        processed = processed.replace(new RegExp(`{{${key}}}`, 'g'), replacement);
      }
      return processed;
    });
  }








  override toJSON(): ElementJSON & {
    players: Record<string, unknown>[];
    phase: GamePhase;
    messages: Array<{ text: string; data?: Record<string, unknown> }>;
    settings: Record<string, unknown>;
  } {
    return {
      ...super.toJSON(),
      players: this.players.toJSON(),
      phase: this.phase,
      messages: this.messages,
      settings: this.settings,
    };
  }






  toJSONForPlayer(player: P | number | null): ElementJSON {
    const position = player === null ? null : (typeof player === 'number' ? player : player.position);

    const visibilityPosition = position ?? -1;

    const filterElement = (json: ElementJSON, element: GameElement): ElementJSON | null => {
      const visibility = element.getEffectiveVisibility();



      if (visibility.mode === 'count-only' && !element.isVisibleTo(visibilityPosition)) {
        const systemAttrs: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(json.attributes ?? {})) {
          if (key.startsWith('$')) {
            systemAttrs[key] = value;
          }
        }
        return {
          className: json.className,
          id: json.id,
          name: json.name,
          attributes: systemAttrs,
          childCount: element._t.children.length,
        };
      }


      if (!element.isVisibleTo(visibilityPosition)) {

        return {
          className: json.className,
          id: json.id,
          attributes: { __hidden: true },
        };
      }


      const zoneVisibility = (element as any).getZoneVisibility?.();


      if (zoneVisibility) {
        if (zoneVisibility.mode === 'hidden' || zoneVisibility.mode === 'count-only') {



          return {
            ...json,
            children: undefined,
            childCount: element._t.children.length,
          };
        } else if (zoneVisibility.mode === 'owner' && element.player?.position !== visibilityPosition) {


          const hiddenChildren: ElementJSON[] = [];
          if (json.children) {
            for (const childJson of json.children) {
              const systemAttrs: Record<string, unknown> = { __hidden: true };
              for (const [key, value] of Object.entries(childJson.attributes ?? {})) {
                if (key.startsWith('$')) {
                  systemAttrs[key] = value;
                }
              }
              hiddenChildren.push({
                className: childJson.className,
                id: childJson.id,
                attributes: systemAttrs,
              });
            }
          }
          return {
            ...json,
            children: hiddenChildren.length > 0 ? hiddenChildren : undefined,
          };
        }
      }


      const filteredChildren: ElementJSON[] = [];
      if (json.children) {
        for (let i = 0; i < json.children.length; i++) {
          const childJson = json.children[i];
          const childElement = element._t.children[i];
          const filtered = filterElement(childJson, childElement);
          if (filtered) {
            filteredChildren.push(filtered);
          }
        }
      }

      return {
        ...json,
        children: filteredChildren.length > 0 ? filteredChildren : undefined,
      };
    };

    const fullJson = this.toJSON();
    let filteredState = filterElement(fullJson, this) ?? fullJson;


    const GameClass = this.constructor as typeof Game;
    if (GameClass.playerView) {
      filteredState = GameClass.playerView(filteredState, position, this);
    }

    return filteredState;
  }




  static restoreGame<G extends Game>(
    json: ReturnType<G['toJSON']>,
    GameClass: new (options: GameOptions) => G,
    classRegistry: Map<string, ElementClass>
  ): G {
    const game = new GameClass({
      playerCount: json.players.length,
      playerNames: json.players.map(p => p.name as string),
    });


    for (const [name, cls] of classRegistry) {
      game._ctx.classRegistry.set(name, cls);
    }


    game.phase = json.phase;
    game.messages = json.messages;
    game.settings = json.settings;


    game._t.children = [];
    if (json.children) {
      for (const childJson of json.children) {
        const child = GameElement.fromJSON(childJson, game._ctx, game._ctx.classRegistry);
        child._t.parent = game;
        (child as GameElement).game = game;
        game._t.children.push(child);
      }
    }



    game.resolveElementReferences(game);

    return game;
  }
}
````

## File: packages/session/src/types.ts
````typescript
import type { FlowState, SerializedAction, Game } from '@boardsmith/engine';


export type { ActionTrace, SelectionTrace, ConditionDetail } from '@boardsmith/engine';


export type { PendingActionState, RepeatingSelectionState, RepeatConfig } from '@boardsmith/engine';








export type GameClass<G extends Game = Game> = new (options: {
  playerCount: number;
  playerNames?: string[];
  seed?: string;
}) => G;




export interface GameDefinition {
  gameClass: GameClass;
  gameType: string;
  minPlayers: number;
  maxPlayers: number;
  displayName?: string;

  ai?: {
    objectives: (...args: unknown[]) => unknown;
  };

  gameOptions?: Record<string, GameOptionDefinition>;

  playerOptions?: Record<string, PlayerOptionDefinition>;

  presets?: GamePreset[];
}








export interface NumberOption {
  type: 'number';
  label: string;
  description?: string;
  default?: number;
  min?: number;
  max?: number;
  step?: number;
}




export interface SelectOption {
  type: 'select';
  label: string;
  description?: string;
  default?: string | number;
  choices: Array<{ value: string | number; label: string }>;
}




export interface BooleanOption {
  type: 'boolean';
  label: string;
  description?: string;
  default?: boolean;
}




export type GameOptionDefinition = NumberOption | SelectOption | BooleanOption;




export interface StandardPlayerOption {
  type: 'select' | 'color' | 'text';
  label: string;
  description?: string;
  default?: string;
  choices?: Array<{ value: string; label: string }> | string[];
}


















export interface ExclusivePlayerOption {
  type: 'exclusive';
  label: string;
  description?: string;






  default?: 'first' | 'last' | number;
}




export type PlayerOptionDefinition = StandardPlayerOption | ExclusivePlayerOption;




export interface PlayerConfig {
  name?: string;
  isAI?: boolean;
  aiLevel?: string;

  [key: string]: unknown;
}




export interface GamePreset {
  name: string;
  description?: string;

  options: Record<string, unknown>;

  players?: PlayerConfig[];
}




export interface GameConfig {
  minPlayers: number;
  maxPlayers: number;
}








export interface StoredGameState {
  gameType: string;
  playerCount: number;
  playerNames: string[];
  playerIds?: string[];
  seed?: string;
  actionHistory: SerializedAction[];
  createdAt: number;
  aiConfig?: AIConfig;

  gameOptions?: Record<string, unknown>;

  lobbyState?: LobbyState;

  lobbySlots?: LobbySlot[];

  creatorId?: string;

  minPlayers?: number;
  maxPlayers?: number;

  playerOptionsDefinitions?: Record<string, PlayerOptionDefinition>;

  gameOptionsDefinitions?: Record<string, GameOptionDefinition>;
}




export interface ElementRef {
  id?: number;
  name?: string;
  notation?: string;
}




export interface ChoiceWithRefs {
  value: unknown;
  display: string;

  sourceRef?: ElementRef;

  targetRef?: ElementRef;
}




export interface ValidElement {
  id: number;

  display?: string;

  ref?: ElementRef;
}




export interface SelectionFilter {

  key: string;

  selectionName: string;
}




export interface SelectionMetadata {
  name: string;
  type: 'choice' | 'element' | 'number' | 'text';
  prompt?: string;
  optional?: boolean;

  choices?: ChoiceWithRefs[];
  min?: number;
  max?: number;
  integer?: boolean;
  pattern?: string;
  minLength?: number;
  maxLength?: number;
  elementClassName?: string;

  validElements?: ValidElement[];

  filterBy?: SelectionFilter;





  dependsOn?: string;




  choicesByDependentValue?: Record<string, ChoiceWithRefs[]>;

  repeat?: {

    hasOnEach: boolean;

    terminator?: unknown;
  };





  multiSelectByDependentValue?: Record<string, { min: number; max?: number } | undefined>;

  multiSelect?: {

    min: number;

    max?: number;
  };
}




export interface ActionMetadata {
  name: string;
  prompt?: string;
  selections: SelectionMetadata[];
}




export interface PlayerGameState {
  phase: string;

  players: Array<{ name: string; position: number; [key: string]: unknown }>;
  currentPlayer?: number;
  availableActions?: string[];
  isMyTurn: boolean;
  view: unknown;

  actionMetadata?: Record<string, ActionMetadata>;

  canUndo?: boolean;

  actionsThisTurn?: number;

  turnStartActionIndex?: number;

  customDebug?: Record<string, unknown>;
}








export type LobbyState = 'waiting' | 'playing' | 'finished';




export type SlotStatus = 'open' | 'ai' | 'claimed';




export interface LobbySlot {

  position: number;

  status: SlotStatus;

  name: string;

  playerId?: string;

  aiLevel?: string;

  playerOptions?: Record<string, unknown>;

  ready: boolean;

  connected?: boolean;
}




export interface LobbyInfo {

  state: LobbyState;

  gameType: string;

  displayName?: string;

  slots: LobbySlot[];

  gameOptions?: Record<string, unknown>;

  gameOptionsDefinitions?: Record<string, GameOptionDefinition>;

  creatorId?: string;

  openSlots: number;

  isReady: boolean;

  minPlayers?: number;

  maxPlayers?: number;
}








export interface SessionInfo {
  playerId?: string;
  playerPosition: number;
  isSpectator: boolean;
}




export interface StateUpdate {
  type: 'state';
  flowState: FlowState | undefined;
  state: PlayerGameState;
  playerPosition: number;
  isSpectator: boolean;
}








export interface AIConfig {
  players: number[];
  level: string;
}








export interface StorageAdapter {
  save(state: StoredGameState): Promise<void>;
  load(): Promise<StoredGameState | null>;
}




export interface BroadcastAdapter<TSession = SessionInfo> {
  getSessions(): TSession[];
  send(session: TSession, message: unknown): void;
}








export interface CreateGameRequest {
  gameType: string;
  playerCount: number;
  playerNames?: string[];
  playerIds?: string[];
  seed?: string;
  aiPlayers?: number[];
  aiLevel?: string;

  gameOptions?: Record<string, unknown>;

  playerConfigs?: PlayerConfig[];
}




export interface ActionRequest {
  action: string;
  player: number;
  args: Record<string, unknown>;
}




export interface WebSocketMessage {
  type: 'action' | 'ping' | 'getState' | 'getLobby' | 'claimPosition' | 'updateName' | 'setReady' | 'addSlot' | 'removeSlot' | 'setSlotAI' | 'leavePosition' | 'kickPlayer' | 'updatePlayerOptions' | 'updateSlotPlayerOptions' | 'updateGameOptions';
  action?: string;
  args?: Record<string, unknown>;

  position?: number;

  name?: string;

  ready?: boolean;

  isAI?: boolean;

  aiLevel?: string;

  playerOptions?: Record<string, unknown>;

  gameOptions?: Record<string, unknown>;
}








export interface ClaimPositionRequest {

  position: number;

  name: string;

  playerId: string;
}




export interface ClaimPositionResponse {
  success: boolean;
  error?: string;

  lobby?: LobbyInfo;
}




export interface UpdateNameRequest {

  playerId: string;

  name: string;
}




export interface LobbyUpdate {
  type: 'lobby';
  lobby: LobbyInfo;
}
````

## File: packages/engine/src/index.ts
````typescript
export {
  GameElement,
  Space,
  Piece,
  Card,
  Hand,
  Deck,
  Die,
  DicePool,
  Grid,
  GridCell,
  HexGrid,
  HexCell,
  Game,
  ElementCollection,
} from './element/index.js';

export type {
  ElementClass,
  ElementContext,
  ElementTree,
  ElementJSON,
  ElementFinder,
  ElementAttributes,
  Sorter,
  GameOptions,
  GamePhase,
  PlayerViewFunction,
  ElementLayout,
  HexOrientation,
  HexCoordSystem,
  LayoutDirection,
  LayoutAlignment,
  DieSides,
} from './element/index.js';


export {
  Player,
  PlayerCollection,
  AbilityManager,
} from './player/index.js';

export type { Ability } from './player/index.js';


export {
  Track,
  MonotonicTrack,
  UniqueTrack,
  CounterTrack,
} from './scoring/index.js';

export type {
  TrackEntry,
  TrackConfig,
  MonotonicTrackConfig,
  UniqueTrackConfig,
  CounterTrackConfig,
} from './scoring/index.js';


export {
  executeCommand,
  canPlayerSee,
  visibilityFromMode,
  resolveVisibility,
  DEFAULT_VISIBILITY,
} from './command/index.js';

export type {
  GameCommand,
  CommandResult,
  BaseCommand,
  CreateElementCommand,
  CreateManyCommand,
  MoveCommand,
  RemoveCommand,
  ShuffleCommand,
  SetAttributeCommand,
  SetVisibilityCommand,
  AddVisibleToCommand,
  SetCurrentPlayerCommand,
  MessageCommand,
  StartGameCommand,
  EndGameCommand,
  SetOrderCommand,
  VisibilityConfig,
  VisibilityMode,
  VisibilityState,
} from './command/index.js';


export { Action, ActionExecutor, ConditionTracer } from './action/index.js';


export {
  dependentFilter,
  adjacentToSelection,
  excludeAlreadySelected,
  allOf,
  anyOf,
  not,
} from './action/index.js';

export type {
  SelectionType,
  Selection,
  BaseSelection,
  ChoiceSelection,
  ElementSelection,
  TextSelection,
  NumberSelection,
  ActionContext,
  ActionDefinition,
  ActionResult,
  SerializedAction,
  ValidationResult,
  BoardElementRef,
  ChoiceBoardRefs,
  DependentFilter,
  DependentFilterOptions,

  ConditionDetail,
  SelectionTrace,
  ActionTrace,

  RepeatConfig,
  RepeatingSelectionState,
  PendingActionState,
} from './action/index.js';


export {
  FlowEngine,
  sequence,
  namedSequence,
  phase,
  loop,
  repeat,
  eachPlayer,
  forEach,
  actionStep,
  simultaneousActionStep,
  playerActions,
  switchOn,
  ifThen,
  defineFlow,
  noop,
  execute,
  setVar,
  turnLoop,
  TurnOrder,
} from './flow/index.js';

export type {
  FlowNodeType,
  FlowStepResult,
  FlowPosition,
  FlowContext,
  FlowNode,
  FlowState,
  FlowDefinition,
  BaseFlowConfig,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  ExecuteConfig,
  PhaseConfig,
  PlayerAwaitingState,
  TurnOrderConfig,
} from './flow/index.js';


export {
  serializeValue,
  deserializeValue,
  serializeAction,
  deserializeAction,
  isSerializedReference,
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
  createReplayFile,
  validateReplayFile,
  parseReplayFile,
} from './utils/index.js';

export type {
  SerializedReference,
  SerializeOptions,
  GameStateSnapshot,
  PlayerStateView,
  ReplayFile,
} from './utils/index.js';


export {
  ExecutionContext,
  ExecutionLimitError,
  withLimits,
  withLimitsAsync,
  guard,
  validateCode,
  DEFAULT_LIMITS,
} from './sandbox/index.js';

export type {
  ExecutionLimits,
} from './sandbox/index.js';
````

## File: packages/session/src/game-session.ts
````typescript
import type { FlowState, SerializedAction, Game, PendingActionState } from '@boardsmith/engine';
import { GameRunner } from '@boardsmith/runtime';
import type {
  GameClass,
  GameDefinition,
  StoredGameState,
  PlayerGameState,
  SessionInfo,
  StateUpdate,
  StorageAdapter,
  BroadcastAdapter,
  AIConfig,
  LobbyState,
  LobbySlot,
  LobbyInfo,
  LobbyUpdate,
  PlayerConfig,
  PlayerOptionDefinition,
  GameOptionDefinition,
} from './types.js';
import { buildPlayerState, computeUndoInfo, buildActionTraces } from './utils.js';
import { AIController } from './ai-controller.js';








export interface GameSessionOptions<G extends Game = Game> {
  gameType: string;
  GameClass: GameClass<G>;
  playerCount: number;
  playerNames: string[];
  playerIds?: string[];
  seed?: string;
  storage?: StorageAdapter;
  aiConfig?: AIConfig;

  gameOptions?: Record<string, unknown>;

  displayName?: string;

  playerConfigs?: PlayerConfig[];

  creatorId?: string;

  useLobby?: boolean;

  playerOptionsDefinitions?: Record<string, PlayerOptionDefinition>;

  gameOptionsDefinitions?: Record<string, GameOptionDefinition>;
}




export interface ActionResult {
  success: boolean;
  error?: string;
  flowState?: FlowState;
  state?: PlayerGameState;
  serializedAction?: SerializedAction;
}




export interface UndoResult {
  success: boolean;
  error?: string;
  flowState?: FlowState;
  state?: PlayerGameState;

  actionsUndone?: number;
}




export interface ElementDiff {

  added: number[];

  removed: number[];

  changed: number[];

  fromIndex: number;

  toIndex: number;
}


































export class GameSession<G extends Game = Game, TSession extends SessionInfo = SessionInfo> {

  static readonly DISCONNECT_TIMEOUT_MS = 30000;

  #runner: GameRunner<G>;
  readonly #storedState: StoredGameState;
  #GameClass: GameClass<G>;
  readonly #storage?: StorageAdapter;
  #aiController?: AIController<G>;
  #broadcaster?: BroadcastAdapter<TSession>;
  #displayName?: string;

  #disconnectTimeouts: Map<string, ReturnType<typeof setTimeout>> = new Map();

  #pendingActions: Map<number, PendingActionState> = new Map();

  private constructor(
    runner: GameRunner<G>,
    storedState: StoredGameState,
    GameClass: GameClass<G>,
    storage?: StorageAdapter,
    aiController?: AIController<G>,
    displayName?: string
  ) {
    this.#runner = runner;
    this.#storedState = storedState;
    this.#GameClass = GameClass;
    this.#storage = storage;
    this.#aiController = aiController;
    this.#displayName = displayName;
  }








  static create<G extends Game = Game>(options: GameSessionOptions<G>): GameSession<G> {
    const {
      gameType,
      GameClass,
      playerCount,
      playerNames,
      playerIds,
      seed,
      storage,
      aiConfig,
      gameOptions: customGameOptions,
      displayName,
      playerConfigs,
      creatorId,
      useLobby,
      playerOptionsDefinitions,
      gameOptionsDefinitions,
    } = options;

    const gameSeed = seed ?? Math.random().toString(36).substring(2) + Date.now().toString(36);

    const runner = new GameRunner<G>({
      GameClass,
      gameType,
      gameOptions: { playerCount, playerNames, seed: gameSeed, ...customGameOptions },
    });


    let lobbySlots: LobbySlot[] | undefined;
    let lobbyState: LobbyState | undefined;

    if (useLobby && playerConfigs) {
      lobbySlots = playerConfigs.map((config, i) => {
        const isAI = config.isAI ?? false;
        const isCreator = i === 0;


        const playerOptions: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(config)) {
          if (!['name', 'isAI', 'aiLevel'].includes(key)) {
            playerOptions[key] = value;
          }
        }

        return {
          position: i,
          status: isAI ? 'ai' : (isCreator ? 'claimed' : 'open'),
          name: config.name ?? (isAI ? 'Bot' : `Player ${i + 1}`),
          playerId: isCreator ? creatorId : undefined,
          aiLevel: isAI ? (config.aiLevel ?? 'medium') : undefined,
          playerOptions: Object.keys(playerOptions).length > 0 ? playerOptions : undefined,

          ready: isAI ? true : false,
        } as LobbySlot;
      });


      if (playerOptionsDefinitions && lobbySlots[0]?.status === 'claimed') {
        lobbySlots[0].playerOptions = GameSession.computeDefaultPlayerOptions(
          0,
          playerOptionsDefinitions,
          lobbySlots,
          playerCount
        );
      }



      lobbyState = 'waiting';
    }

    const storedState: StoredGameState = {
      gameType,
      playerCount,
      playerNames,
      playerIds,
      seed: gameSeed,
      actionHistory: [],
      createdAt: Date.now(),
      aiConfig,
      gameOptions: customGameOptions,
      lobbyState,
      lobbySlots,
      creatorId,
      playerOptionsDefinitions,
      gameOptionsDefinitions,
    };

    runner.start();

    const aiController = aiConfig
      ? new AIController(GameClass, gameType, playerCount, aiConfig)
      : undefined;

    const session = new GameSession(runner, storedState, GameClass, storage, aiController, displayName);


    if (storage) {
      storage.save(storedState).catch(err => {
        console.error('Failed to save initial game state:', err);
      });
    }


    if (lobbyState !== 'waiting' && aiController?.hasAIPlayers()) {
      session.#scheduleAICheck();
    }

    return session;
  }




  static restore<G extends Game = Game>(
    storedState: StoredGameState,
    GameClass: GameClass<G>,
    storage?: StorageAdapter
  ): GameSession<G> {
    const runner = GameRunner.replay<G>(
      {
        GameClass,
        gameType: storedState.gameType,
        gameOptions: {
          playerCount: storedState.playerCount,
          playerNames: storedState.playerNames,
          seed: storedState.seed,
          ...storedState.gameOptions,
        },
      },
      storedState.actionHistory
    );

    const aiController = storedState.aiConfig
      ? new AIController(GameClass, storedState.gameType, storedState.playerCount, storedState.aiConfig)
      : undefined;

    return new GameSession(runner, storedState, GameClass, storage, aiController);
  }








  setBroadcaster(broadcaster: BroadcastAdapter<TSession>): void {
    this.#broadcaster = broadcaster;
  }




  get runner(): GameRunner<G> {
    return this.#runner;
  }




  get storedState(): StoredGameState {
    return this.#storedState;
  }




  get gameType(): string {
    return this.#storedState.gameType;
  }




  get playerCount(): number {
    return this.#storedState.playerCount;
  }




  get playerNames(): string[] {
    return this.#storedState.playerNames;
  }








  getFlowState(): FlowState | undefined {
    return this.#runner.getFlowState();
  }







  getState(
    playerPosition: number,
    options?: { includeActionMetadata?: boolean; includeDebugData?: boolean }
  ): { success: boolean; flowState?: FlowState; state?: PlayerGameState } {
    const flowState = this.#runner.getFlowState();
    const state = buildPlayerState(
      this.#runner,
      this.#storedState.playerNames,
      playerPosition,
      { includeActionMetadata: options?.includeActionMetadata ?? true, includeDebugData: options?.includeDebugData ?? true }
    );
    return { success: true, flowState, state };
  }




  buildPlayerState(playerPosition: number, options?: { includeActionMetadata?: boolean; includeDebugData?: boolean }): PlayerGameState {
    return buildPlayerState(
      this.#runner,
      this.#storedState.playerNames,
      playerPosition,
      { includeActionMetadata: options?.includeActionMetadata ?? true, includeDebugData: options?.includeDebugData ?? true }
    );
  }






  updatePlayerName(position: number, name: string): void {
    if (position < 0 || position >= this.#storedState.playerCount) {
      throw new Error(`Invalid player position: ${position}`);
    }
    this.#storedState.playerNames[position] = name;


    this.broadcast();
  }




  getHistory(): { actionHistory: SerializedAction[]; createdAt: number } {
    return {
      actionHistory: this.#storedState.actionHistory,
      createdAt: this.#storedState.createdAt,
    };
  }





  getStateAtAction(actionIndex: number, playerPosition: number): { success: boolean; state?: PlayerGameState; error?: string } {
    const history = this.#storedState.actionHistory;


    if (actionIndex < 0 || actionIndex > history.length) {
      return { success: false, error: `Invalid action index: ${actionIndex}. History has ${history.length} actions.` };
    }

    try {

      const actionsToReplay = history.slice(0, actionIndex);


      const tempRunner = GameRunner.replay<G>(
        {
          GameClass: this.#GameClass,
          gameType: this.#storedState.gameType,
          gameOptions: {
            playerCount: this.#storedState.playerCount,
            playerNames: this.#storedState.playerNames,
            seed: this.#storedState.seed,
            ...this.#storedState.gameOptions,
          },
        },
        actionsToReplay
      );


      const state = buildPlayerState(
        tempRunner,
        this.#storedState.playerNames,
        playerPosition,
        { includeActionMetadata: false }
      );

      return { success: true, state };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to replay game state',
      };
    }
  }





  getStateDiff(
    fromIndex: number,
    toIndex: number,
    playerPosition: number
  ): { success: boolean; diff?: ElementDiff; error?: string } {
    const history = this.#storedState.actionHistory;


    if (fromIndex < 0 || fromIndex > history.length) {
      return { success: false, error: `Invalid fromIndex: ${fromIndex}` };
    }
    if (toIndex < 0 || toIndex > history.length) {
      return { success: false, error: `Invalid toIndex: ${toIndex}` };
    }

    try {

      const fromResult = this.getStateAtAction(fromIndex, playerPosition);
      const toResult = this.getStateAtAction(toIndex, playerPosition);

      if (!fromResult.success || !fromResult.state) {
        return { success: false, error: fromResult.error || 'Failed to get from state' };
      }
      if (!toResult.success || !toResult.state) {
        return { success: false, error: toResult.error || 'Failed to get to state' };
      }



      const fromElements = new Map<number, { parentId: number | null; attrs: string }>();
      const toElements = new Map<number, { parentId: number | null; attrs: string }>();

      function getComparableAttrs(obj: Record<string, unknown>): string {

        const attrs = obj.attributes as Record<string, unknown> | undefined;
        if (!attrs) return '';
        // Filter out player object (has _isCurrent that changes), keep game-relevant attrs
        const filtered: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(attrs)) {
          // Skip player objects and internal metadata
          if (key === 'player' || key === 'game' || key.startsWith('_')) continue;
          filtered[key] = value;
        }
        return JSON.stringify(filtered);
      }

      function collectElements(node: unknown, map: Map<number, { parentId: number | null; attrs: string }>, parentId: number | null = null) {
        if (!node || typeof node !== 'object') return;
        const obj = node as Record<string, unknown>;
        if (typeof obj.id === 'number') {
          map.set(obj.id, {
            parentId,
            attrs: getComparableAttrs(obj),
          });

          if (Array.isArray(obj.children)) {
            for (const child of obj.children) {
              collectElements(child, map, obj.id);
            }
          }
        } else if (Array.isArray(obj.children)) {

          for (const child of obj.children) {
            collectElements(child, map, parentId);
          }
        }
      }

      collectElements(fromResult.state.view, fromElements);
      collectElements(toResult.state.view, toElements);


      const added: number[] = [];
      const removed: number[] = [];
      const changed: number[] = [];

      for (const [id, toData] of toElements.entries()) {
        const fromData = fromElements.get(id);
        if (!fromData) {
          added.push(id);
        } else if (fromData.parentId !== toData.parentId || fromData.attrs !== toData.attrs) {

          changed.push(id);
        }
      }

      for (const id of fromElements.keys()) {
        if (!toElements.has(id)) {
          removed.push(id);
        }
      }

      return {
        success: true,
        diff: { added, removed, changed, fromIndex, toIndex },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to compute diff',
      };
    }
  }





  getActionTraces(playerPosition: number): { success: boolean; traces?: import('./types.js').ActionTrace[]; error?: string } {
    if (playerPosition < 0 || playerPosition >= this.#storedState.playerCount) {
      return { success: false, error: `Invalid player position: ${playerPosition}` };
    }

    try {
      const traces = buildActionTraces(this.#runner, playerPosition);
      return { success: true, traces };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get action traces',
      };
    }
  }








  async performAction(
    action: string,
    player: number,
    args: Record<string, unknown>
  ): Promise<ActionResult> {
    if (player < 0 || player >= this.#storedState.playerCount) {
      return { success: false, error: `Invalid player: ${player}` };
    }

    const result = this.#runner.performAction(action, player, args);

    if (!result.success) {
      return { success: false, error: result.error };
    }


    this.#storedState.actionHistory = this.#runner.actionHistory;


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcast();


    this.#scheduleAICheck();

    return {
      success: true,
      flowState: result.flowState,
      state: buildPlayerState(this.#runner, this.#storedState.playerNames, player, { includeActionMetadata: true, includeDebugData: true }),
      serializedAction: result.serializedAction,
    };
  }









  reloadWithCurrentRules(definition: GameDefinition): void {

    if (definition.gameType !== this.#storedState.gameType) {
      throw new Error(`Cannot reload: game type mismatch (expected ${this.#storedState.gameType}, got ${definition.gameType})`);
    }


    const newRunner = GameRunner.replay<G>(
      {
        GameClass: definition.gameClass as GameClass<G>,
        gameType: this.#storedState.gameType,
        gameOptions: {
          playerCount: this.#storedState.playerCount,
          playerNames: this.#storedState.playerNames,
          seed: this.#storedState.seed,
          ...this.#storedState.gameOptions,
        },
      },
      this.#storedState.actionHistory
    );


    this.#runner = newRunner;
    this.#GameClass = definition.gameClass as GameClass<G>;


    this.#pendingActions.clear();


    this.broadcast();
  }









  async undoToTurnStart(playerPosition: number): Promise<UndoResult> {

    if (playerPosition < 0 || playerPosition >= this.#storedState.playerCount) {
      return { success: false, error: `Invalid player: ${playerPosition}` };
    }


    const flowState = this.#runner.getFlowState();
    if (flowState?.currentPlayer !== playerPosition) {
      return { success: false, error: "It's not your turn" };
    }


    const { turnStartActionIndex, actionsThisTurn } = computeUndoInfo(
      this.#storedState.actionHistory,
      flowState.currentPlayer
    );


    if (actionsThisTurn === 0) {
      return { success: false, error: 'No actions to undo' };
    }


    const actionsToReplay = this.#storedState.actionHistory.slice(0, turnStartActionIndex);

    try {

      const newRunner = GameRunner.replay<G>(
        {
          GameClass: this.#GameClass,
          gameType: this.#storedState.gameType,
          gameOptions: {
            playerCount: this.#storedState.playerCount,
            playerNames: this.#storedState.playerNames,
            seed: this.#storedState.seed,
            ...this.#storedState.gameOptions,
          },
        },
        actionsToReplay
      );


      this.#runner = newRunner;


      this.#storedState.actionHistory = actionsToReplay;


      if (this.#storage) {
        await this.#storage.save(this.#storedState);
      }


      this.broadcast();

      const newFlowState = this.#runner.getFlowState();

      return {
        success: true,
        flowState: newFlowState,
        state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true, includeDebugData: true }),
        actionsUndone: actionsThisTurn,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to undo',
      };
    }
  }






  async rewindToAction(targetActionIndex: number): Promise<{
    success: boolean;
    error?: string;
    actionsDiscarded?: number;
    state?: PlayerGameState;
  }> {
    const currentLength = this.#storedState.actionHistory.length;


    if (targetActionIndex < 0) {
      return { success: false, error: `Invalid action index: ${targetActionIndex}` };
    }

    if (targetActionIndex >= currentLength) {
      return { success: false, error: `Cannot rewind forward: target ${targetActionIndex} >= current ${currentLength}` };
    }


    const actionsToReplay = this.#storedState.actionHistory.slice(0, targetActionIndex);
    const actionsDiscarded = currentLength - targetActionIndex;

    try {

      const newRunner = GameRunner.replay<G>(
        {
          GameClass: this.#GameClass,
          gameType: this.#storedState.gameType,
          gameOptions: {
            playerCount: this.#storedState.playerCount,
            playerNames: this.#storedState.playerNames,
            seed: this.#storedState.seed,
            ...this.#storedState.gameOptions,
          },
        },
        actionsToReplay
      );


      this.#runner = newRunner;
      this.#storedState.actionHistory = actionsToReplay;


      this.#pendingActions.clear();


      if (this.#storage) {
        await this.#storage.save(this.#storedState);
      }


      this.broadcast();


      return {
        success: true,
        actionsDiscarded,
        state: buildPlayerState(this.#runner, this.#storedState.playerNames, 0, { includeActionMetadata: true, includeDebugData: true }),
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to rewind',
      };
    }
  }









  startPendingAction(actionName: string, playerPosition: number): {
    success: boolean;
    error?: string;
    pendingState?: PendingActionState;
  } {
    if (playerPosition < 0 || playerPosition >= this.#storedState.playerCount) {
      return { success: false, error: `Invalid player: ${playerPosition}` };
    }

    const action = this.#runner.game.getAction(actionName);
    if (!action) {
      return { success: false, error: `Action not found: ${actionName}` };
    }

    const executor = this.#runner.game.getActionExecutor();
    const pendingState = executor.createPendingActionState(actionName, playerPosition);
    this.#pendingActions.set(playerPosition, pendingState);

    return { success: true, pendingState };
  }







  async processSelectionStep(
    playerPosition: number,
    selectionName: string,
    value: unknown,
    actionName?: string,
    initialArgs?: Record<string, unknown>
  ): Promise<{
    success: boolean;
    error?: string;
    done?: boolean;
    nextChoices?: unknown[];
    actionComplete?: boolean;
    actionResult?: ActionResult;
    state?: PlayerGameState;
  }> {
    let pendingState = this.#pendingActions.get(playerPosition);


    if (!pendingState && actionName) {
      const startResult = this.startPendingAction(actionName, playerPosition);
      if (!startResult.success) {
        return { success: false, error: startResult.error };
      }
      pendingState = startResult.pendingState;
      this.#pendingActions.set(playerPosition, pendingState!);


      if (initialArgs && Object.keys(initialArgs).length > 0) {
        const action = this.#runner.game.getAction(actionName);
        if (action) {

          for (const [key, val] of Object.entries(initialArgs)) {
            if (val !== undefined && val !== null) {
              pendingState!.collectedArgs[key] = val;
            }
          }


          const targetIndex = action.selections.findIndex(s => s.name === selectionName);
          if (targetIndex > 0) {
            pendingState!.currentSelectionIndex = targetIndex;
          }
        }
      }
    }

    if (!pendingState) {
      return { success: false, error: 'No pending action for this player. Provide actionName to auto-create.' };
    }

    const action = this.#runner.game.getAction(pendingState.actionName);
    if (!action) {
      return { success: false, error: `Action not found: ${pendingState.actionName}` };
    }

    const executor = this.#runner.game.getActionExecutor();
    const player = this.#runner.game.players[playerPosition];
    const selection = action.selections[pendingState.currentSelectionIndex];

    if (!selection) {
      return { success: false, error: 'No current selection' };
    }


    if (selection.name !== selectionName) {
      return { success: false, error: `Expected selection at index ${pendingState.currentSelectionIndex}, got ${selectionName} at index ${action.selections.findIndex(s => s.name === selectionName)}` };
    }


    if (executor.isRepeatingSelection(selection)) {
      const result = executor.processRepeatingStep(action, player, pendingState, value);

      if (result.error) {
        return { success: false, error: result.error, nextChoices: result.nextChoices };
      }


      if (this.#storage) {
        await this.#storage.save(this.#storedState);
      }


      this.broadcast();


      if (result.done && executor.isPendingActionComplete(action, pendingState)) {

        const actionResult = executor.executePendingAction(action, player, pendingState);
        this.#pendingActions.delete(playerPosition);

        if (actionResult.success) {

          this.#runner.game.continueFlowAfterPendingAction(actionResult);


          this.#storedState.actionHistory = this.#runner.actionHistory;


          if (this.#storage) {
            await this.#storage.save(this.#storedState);
          }


          this.broadcast();


          this.#scheduleAICheck();
        }

        return {
          success: actionResult.success,
          error: actionResult.error,
          done: true,
          actionComplete: true,
          actionResult: {
            success: actionResult.success,
            error: actionResult.error,
            flowState: this.#runner.getFlowState(),
            state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true, includeDebugData: true }),
          },
          state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true, includeDebugData: true }),
        };
      }


      return {
        success: true,
        done: result.done,
        nextChoices: result.nextChoices,
        actionComplete: false,
        state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true, includeDebugData: true }),
      };
    }


    const stepResult = executor.processSelectionStep(action, player, pendingState, selectionName, value);

    if (!stepResult.success) {
      return { success: false, error: stepResult.error };
    }


    if (executor.isPendingActionComplete(action, pendingState)) {
      const actionResult = executor.executePendingAction(action, player, pendingState);
      this.#pendingActions.delete(playerPosition);

      if (actionResult.success) {

        this.#runner.game.continueFlowAfterPendingAction(actionResult);


        this.#storedState.actionHistory = this.#runner.actionHistory;


        if (this.#storage) {
          await this.#storage.save(this.#storedState);
        }


        this.broadcast();


        this.#scheduleAICheck();
      }

      return {
        success: actionResult.success,
        error: actionResult.error,
        done: true,
        actionComplete: true,
        actionResult: {
          success: actionResult.success,
          error: actionResult.error,
          flowState: this.#runner.getFlowState(),
          state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true, includeDebugData: true }),
        },
        state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true, includeDebugData: true }),
      };
    }


    return {
      success: true,
      done: true,
      actionComplete: false,
      state: buildPlayerState(this.#runner, this.#storedState.playerNames, playerPosition, { includeActionMetadata: true, includeDebugData: true }),
    };
  }




  getPendingAction(playerPosition: number): PendingActionState | undefined {
    return this.#pendingActions.get(playerPosition);
  }




  cancelPendingAction(playerPosition: number): void {
    this.#pendingActions.delete(playerPosition);
  }




  hasRepeatingSelections(actionName: string): boolean {
    const action = this.#runner.game.getAction(actionName);
    if (!action) return false;
    const executor = this.#runner.game.getActionExecutor();
    return executor.hasRepeatingSelections(action);
  }








  broadcast(): void {
    if (!this.#broadcaster) return;

    const flowState = this.#runner.getFlowState();
    const sessions = this.#broadcaster.getSessions();

    for (const session of sessions) {
      const effectivePosition = session.isSpectator ? 0 : session.playerPosition;
      const state = buildPlayerState(this.#runner, this.#storedState.playerNames, effectivePosition, { includeActionMetadata: true, includeDebugData: true });

      const update: StateUpdate = {
        type: 'state',
        flowState,
        state,
        playerPosition: session.playerPosition,
        isSpectator: session.isSpectator,
      };

      try {
        this.#broadcaster.send(session, update);
      } catch (error) {
        console.error('Broadcast error:', error);
      }
    }
  }








  #scheduleAICheck(): void {
    if (!this.#aiController?.hasAIPlayers()) return;


    const schedule = typeof setImmediate !== 'undefined'
      ? setImmediate
      : (fn: () => void) => setTimeout(fn, 0);

    schedule(() => this.#checkAITurn());
  }




  async #checkAITurn(): Promise<void> {
    if (!this.#aiController) return;

    const move = await this.#aiController.checkAndPlay(
      this.#runner,
      this.#storedState.actionHistory,
      async (action, player, args) => {
        const result = this.#runner.performAction(action, player, args);
        if (result.success) {
          this.#storedState.actionHistory = this.#runner.actionHistory;
          if (this.#storage) {
            await this.#storage.save(this.#storedState);
          }
          this.broadcast();
          return true;
        }
        return false;
      }
    );


    if (move) {
      this.#scheduleAICheck();
    } else {


      const flowState = this.#runner.getFlowState();
      if (flowState?.awaitingInput && !flowState.complete) {
        this.#scheduleAICheck();
      }
    }
  }








  isWaitingForPlayers(): boolean {
    return this.#storedState.lobbyState === 'waiting';
  }




  getLobbyState(): LobbyState | undefined {
    return this.#storedState.lobbyState;
  }




  getLobbyInfo(): LobbyInfo | null {
    if (!this.#storedState.lobbySlots) {
      return null;
    }

    const slots = this.#storedState.lobbySlots;
    const openSlots = slots.filter(s => s.status === 'open').length;


    const allReady = openSlots === 0 &&
      slots.every(s => s.status === 'ai' || s.ready);

    return {
      state: this.#storedState.lobbyState ?? 'playing',
      gameType: this.#storedState.gameType,
      displayName: this.#displayName,
      slots,
      gameOptions: this.#storedState.gameOptions,
      gameOptionsDefinitions: this.#storedState.gameOptionsDefinitions,
      creatorId: this.#storedState.creatorId,
      openSlots,
      isReady: allReady,
      minPlayers: this.#storedState.minPlayers,
      maxPlayers: this.#storedState.maxPlayers,
    };
  }









  async claimPosition(
    position: number,
    playerId: string,
    name: string
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }

    if (position < 0 || position >= this.#storedState.lobbySlots.length) {
      return { success: false, error: 'Invalid position' };
    }

    const slot = this.#storedState.lobbySlots[position];

    if (slot.status === 'ai') {
      return { success: false, error: 'This position is reserved for AI' };
    }

    if (slot.status === 'claimed' && slot.playerId !== playerId) {
      return { success: false, error: 'This position is already taken' };
    }


    const existingSlot = this.#storedState.lobbySlots.find(
      s => s.playerId === playerId && s.position !== position
    );
    if (existingSlot) {

      existingSlot.status = 'open';
      existingSlot.playerId = undefined;
      existingSlot.name = `Player ${existingSlot.position + 1}`;
      existingSlot.ready = false;
    }


    slot.status = 'claimed';
    slot.playerId = playerId;
    slot.name = name;
    slot.ready = false;


    if (this.#storedState.playerOptionsDefinitions) {
      slot.playerOptions = this.#computeDefaultPlayerOptions(position);
    }


    this.#storedState.playerNames[position] = name;





    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();




    return { success: true, lobby: this.getLobbyInfo()! };
  }







  async updateSlotName(
    playerId: string,
    name: string
  ): Promise<{ success: boolean; error?: string }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    const slot = this.#storedState.lobbySlots.find(s => s.playerId === playerId);
    if (!slot) {
      return { success: false, error: 'Player not found in lobby' };
    }

    slot.name = name;
    this.#storedState.playerNames[slot.position] = name;


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true };
  }








  async setReady(
    playerId: string,
    ready: boolean
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }

    const slot = this.#storedState.lobbySlots.find(s => s.playerId === playerId);
    if (!slot) {
      return { success: false, error: 'Player not found in lobby' };
    }

    if (slot.status === 'ai') {
      return { success: false, error: 'Cannot change ready state for AI' };
    }

    slot.ready = ready;


    await this.#checkAndStartGame();


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();


    const lobbyInfo = this.getLobbyInfo()!;
    if (lobbyInfo.state === 'playing') {
      this.broadcast();
    }

    return { success: true, lobby: lobbyInfo };
  }







  async addSlot(
    playerId: string
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }

    if (playerId !== this.#storedState.creatorId) {
      return { success: false, error: 'Only the host can add slots' };
    }

    const currentCount = this.#storedState.lobbySlots.length;
    const maxPlayers = this.#storedState.maxPlayers ?? 10;

    if (currentCount >= maxPlayers) {
      return { success: false, error: `Cannot exceed ${maxPlayers} players` };
    }

    const newPosition = currentCount;
    this.#storedState.lobbySlots.push({
      position: newPosition,
      status: 'open',
      name: `Player ${newPosition + 1}`,
      ready: false,
    });


    this.#storedState.playerCount = currentCount + 1;
    this.#storedState.playerNames.push(`Player ${newPosition + 1}`);


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true, lobby: this.getLobbyInfo()! };
  }








  async removeSlot(
    playerId: string,
    position: number
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }

    if (playerId !== this.#storedState.creatorId) {
      return { success: false, error: 'Only the host can remove slots' };
    }

    const currentCount = this.#storedState.lobbySlots.length;
    const minPlayers = this.#storedState.minPlayers ?? 1;

    if (currentCount <= minPlayers) {
      return { success: false, error: `Cannot have fewer than ${minPlayers} players` };
    }

    if (position === 0) {
      return { success: false, error: 'Cannot remove the host slot' };
    }

    if (position < 0 || position >= currentCount) {
      return { success: false, error: 'Invalid position' };
    }

    const slot = this.#storedState.lobbySlots[position];
    if (slot.status === 'claimed') {
      return { success: false, error: 'Cannot remove a slot with a player - they must leave first' };
    }


    this.#storedState.lobbySlots.splice(position, 1);
    this.#storedState.playerNames.splice(position, 1);
    this.#storedState.playerCount = this.#storedState.lobbySlots.length;


    this.#storedState.lobbySlots.forEach((s, i) => {
      s.position = i;
      if (s.status === 'open') {
        s.name = `Player ${i + 1}`;
      }
    });


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true, lobby: this.getLobbyInfo()! };
  }










  async setSlotAI(
    playerId: string,
    position: number,
    isAI: boolean,
    aiLevel: string = 'medium'
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }

    if (playerId !== this.#storedState.creatorId) {
      return { success: false, error: 'Only the host can modify slots' };
    }

    if (position === 0) {
      return { success: false, error: 'Cannot change the host slot to AI' };
    }

    if (position < 0 || position >= this.#storedState.lobbySlots.length) {
      return { success: false, error: 'Invalid position' };
    }

    const slot = this.#storedState.lobbySlots[position];

    if (slot.status === 'claimed') {
      return { success: false, error: 'Cannot change a claimed slot - player must leave first' };
    }

    if (isAI) {
      slot.status = 'ai';
      slot.name = 'Bot';
      slot.aiLevel = aiLevel;
      slot.playerId = undefined;
      slot.ready = true;
    } else {
      slot.status = 'open';
      slot.name = `Player ${position + 1}`;
      slot.aiLevel = undefined;
      slot.playerId = undefined;
      slot.ready = false;
    }


    this.#updateAIConfig();


    await this.#checkAndStartGame();


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();


    const lobbyInfo = this.getLobbyInfo()!;
    if (lobbyInfo.state === 'playing') {
      this.broadcast();
    }

    return { success: true, lobby: lobbyInfo };
  }




  async #checkAndStartGame(): Promise<void> {
    if (!this.#storedState.lobbySlots) return;
    if (this.#storedState.lobbyState !== 'waiting') return;

    const slots = this.#storedState.lobbySlots;
    const openSlots = slots.filter(s => s.status === 'open').length;


    const allReady = openSlots === 0 &&
      slots.every(s => s.status === 'ai' || s.ready);

    if (allReady) {
      this.#storedState.lobbyState = 'playing';


      this.clearDisconnectTimeouts();


      if (this.#aiController?.hasAIPlayers()) {
        this.#scheduleAICheck();
      }
    }
  }




  #updateAIConfig(): void {
    if (!this.#storedState.lobbySlots) return;

    const aiSlots = this.#storedState.lobbySlots.filter(s => s.status === 'ai');

    if (aiSlots.length === 0) {
      this.#storedState.aiConfig = undefined;
      this.#aiController = undefined;
    } else {
      const aiPlayers = aiSlots.map(s => s.position);
      const aiLevel = aiSlots[0].aiLevel || 'medium';

      this.#storedState.aiConfig = {
        players: aiPlayers,
        level: aiLevel as 'easy' | 'medium' | 'hard',
      };


      this.#aiController = new AIController(
        this.#GameClass,
        this.#storedState.gameType,
        this.#storedState.playerCount,
        this.#storedState.aiConfig
      );
    }
  }





  static computeDefaultPlayerOptions(
    position: number,
    definitions: Record<string, PlayerOptionDefinition>,
    lobbySlots: LobbySlot[],
    playerCount: number
  ): Record<string, unknown> {
    const result: Record<string, unknown> = {};


    const takenValues: Record<string, Set<string>> = {};
    for (const slot of lobbySlots) {
      if (slot.position !== position && slot.playerOptions) {
        for (const [key, value] of Object.entries(slot.playerOptions)) {
          if (!takenValues[key]) {
            takenValues[key] = new Set();
          }
          takenValues[key].add(String(value));
        }
      }
    }

    for (const [key, opt] of Object.entries(definitions)) {
      if (opt.type === 'select' || opt.type === 'color') {

        const choices = opt.choices ?? [];
        const taken = takenValues[key] ?? new Set();

        for (const choice of choices) {
          const value = typeof choice === 'string' ? choice : choice.value;
          if (!taken.has(value)) {
            result[key] = value;
            break;
          }
        }


        if (result[key] === undefined) {
          if (opt.default !== undefined) {
            result[key] = opt.default;
          } else if (choices.length > 0) {
            const firstChoice = choices[0];
            result[key] = typeof firstChoice === 'string' ? firstChoice : firstChoice.value;
          }
        }
      } else if (opt.type === 'exclusive') {

        let defaultIndex: number;
        if (opt.default === 'first' || opt.default === undefined) {
          defaultIndex = 0;
        } else if (opt.default === 'last') {
          defaultIndex = playerCount - 1;
        } else {
          defaultIndex = opt.default;
        }
        result[key] = position === defaultIndex;
      } else if (opt.type === 'text') {

        if (opt.default !== undefined) {
          result[key] = opt.default;
        }
      }
    }

    return result;
  }




  #computeDefaultPlayerOptions(position: number): Record<string, unknown> {
    const definitions = this.#storedState.playerOptionsDefinitions;
    if (!definitions || !this.#storedState.lobbySlots) return {};

    return GameSession.computeDefaultPlayerOptions(
      position,
      definitions,
      this.#storedState.lobbySlots,
      this.#storedState.playerCount
    );
  }




  getPositionForPlayer(playerId: string): number | undefined {
    if (!this.#storedState.lobbySlots) return undefined;
    const slot = this.#storedState.lobbySlots.find(s => s.playerId === playerId);
    return slot?.position;
  }




  broadcastLobby(): void {
    if (!this.#broadcaster) return;

    const lobby = this.getLobbyInfo();
    if (!lobby) return;

    const sessions = this.#broadcaster.getSessions();
    const update: LobbyUpdate = { type: 'lobby', lobby };

    for (const session of sessions) {
      try {
        this.#broadcaster.send(session, update);
      } catch (error) {
        console.error('Lobby broadcast error:', error);
      }
    }
  }













  async leavePosition(playerId: string): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    console.log('[GameSession] leavePosition called with playerId:', playerId);
    console.log('[GameSession] lobbySlots:', JSON.stringify(this.#storedState.lobbySlots?.map(s => ({ pos: s.position, playerId: s.playerId, status: s.status }))));

    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }


    const slot = this.#storedState.lobbySlots.find(s => s.playerId === playerId);
    console.log('[GameSession] Found slot:', slot ? `position ${slot.position}` : 'none');
    if (!slot) {
      return { success: false, error: 'Player has not claimed a position' };
    }


    if (slot.position === 0) {
      return { success: false, error: 'Host cannot leave. Cancel the game instead.' };
    }


    slot.status = 'open';
    slot.playerId = undefined;
    slot.name = `Player ${slot.position + 1}`;
    slot.ready = false;
    slot.connected = undefined;


    this.#storedState.playerNames[slot.position] = slot.name;


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true, lobby: this.getLobbyInfo() ?? undefined };
  }

  async setPlayerConnected(playerId: string, connected: boolean): Promise<boolean> {
    if (!this.#storedState.lobbySlots) return false;

    const slot = this.#storedState.lobbySlots.find(s => s.playerId === playerId);
    if (!slot) return false;


    if (connected) {

      const existingTimeout = this.#disconnectTimeouts.get(playerId);
      if (existingTimeout) {
        clearTimeout(existingTimeout);
        this.#disconnectTimeouts.delete(playerId);
      }
    } else {

      if (slot.ready && this.#storedState.lobbyState === 'waiting') {
        slot.ready = false;
      }


      if (slot.position !== 0 && this.#storedState.lobbyState === 'waiting') {

        const existingTimeout = this.#disconnectTimeouts.get(playerId);
        if (existingTimeout) {
          clearTimeout(existingTimeout);
        }

        const timeout = setTimeout(async () => {
          this.#disconnectTimeouts.delete(playerId);

          if (this.#storedState.lobbyState === 'waiting') {
            await this.leavePosition(playerId);
          }
        }, GameSession.DISCONNECT_TIMEOUT_MS);

        this.#disconnectTimeouts.set(playerId, timeout);
      }
    }


    if (slot.connected === connected) return false;

    slot.connected = connected;


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return true;
  }








  async kickPlayer(
    hostPlayerId: string,
    position: number
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }


    if (hostPlayerId !== this.#storedState.creatorId) {
      return { success: false, error: 'Only the host can kick players' };
    }


    if (position === 0) {
      return { success: false, error: 'Cannot kick the host' };
    }

    if (position < 0 || position >= this.#storedState.lobbySlots.length) {
      return { success: false, error: 'Invalid position' };
    }

    const slot = this.#storedState.lobbySlots[position];

    if (slot.status !== 'claimed') {
      return { success: false, error: 'Position is not occupied by a player' };
    }


    if (slot.playerId) {
      const timeout = this.#disconnectTimeouts.get(slot.playerId);
      if (timeout) {
        clearTimeout(timeout);
        this.#disconnectTimeouts.delete(slot.playerId);
      }
    }


    slot.status = 'open';
    slot.playerId = undefined;
    slot.name = `Player ${slot.position + 1}`;
    slot.ready = false;
    slot.connected = undefined;


    this.#storedState.playerNames[position] = slot.name;


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true, lobby: this.getLobbyInfo() ?? undefined };
  }




  clearDisconnectTimeouts(): void {
    for (const timeout of this.#disconnectTimeouts.values()) {
      clearTimeout(timeout);
    }
    this.#disconnectTimeouts.clear();
  }








  async updatePlayerOptions(
    playerId: string,
    options: Record<string, unknown>
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }

    const slot = this.#storedState.lobbySlots.find(s => s.playerId === playerId);
    if (!slot) {
      return { success: false, error: 'Player not found in lobby' };
    }


    slot.playerOptions = {
      ...slot.playerOptions,
      ...options,
    };


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true, lobby: this.getLobbyInfo() ?? undefined };
  }










  async updateSlotPlayerOptions(
    hostPlayerId: string,
    position: number,
    options: Record<string, unknown>
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }


    if (hostPlayerId !== this.#storedState.creatorId) {
      return { success: false, error: 'Only the host can modify other players\' options' };
    }

    const slot = this.#storedState.lobbySlots.find(s => s.position === position);
    if (!slot) {
      return { success: false, error: 'Slot not found' };
    }

    if (slot.status === 'open') {
      return { success: false, error: 'Cannot set options for an open slot' };
    }


    slot.playerOptions = {
      ...slot.playerOptions,
      ...options,
    };


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true, lobby: this.getLobbyInfo() ?? undefined };
  }








  async updateGameOptions(
    hostPlayerId: string,
    options: Record<string, unknown>
  ): Promise<{ success: boolean; error?: string; lobby?: LobbyInfo }> {
    if (!this.#storedState.lobbySlots) {
      return { success: false, error: 'Game does not have a lobby' };
    }

    if (this.#storedState.lobbyState !== 'waiting') {
      return { success: false, error: 'Game has already started' };
    }


    if (hostPlayerId !== this.#storedState.creatorId) {
      return { success: false, error: 'Only the host can modify game options' };
    }


    this.#storedState.gameOptions = {
      ...this.#storedState.gameOptions,
      ...options,
    };


    if (this.#storage) {
      await this.#storage.save(this.#storedState);
    }


    this.broadcastLobby();

    return { success: true, lobby: this.getLobbyInfo() ?? undefined };
  }
}
````
