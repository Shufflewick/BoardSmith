# User Provided Header
# BoardSmith - Turn-Based Game Framework

BoardSmith is a TypeScript framework for building multiplayer turn-based board and card games.

## Quick Reference

- `docs/llm-overview.md` - comprehensive summary
- `docs/core-concepts.md` - element tree, actions, commands
- `docs/game-examples.md` - example code snippets

# Directory Structure
```
docs/
  actions-and-flow.md
  ai-system.md
  core-concepts.md
  dice-and-scoring.md
  game-examples.md
  getting-started.md
  llm-overview.md
  README.md
  ui-components.md
packages/
  ai/
    src/
      index.ts
      mcts-bot.ts
      types.ts
      utils.ts
  engine/
    src/
      action/
        action.ts
        index.ts
        types.ts
      command/
        executor.ts
        index.ts
        types.ts
        visibility.ts
      element/
        card.ts
        deck.ts
        dice-pool.ts
        die.ts
        element-collection.ts
        game-element.ts
        game.ts
        grid.ts
        hand.ts
        hex-grid.ts
        index.ts
        piece.ts
        space.ts
        types.ts
      flow/
        builders.ts
        engine.ts
        index.ts
        turn-order.ts
        types.ts
      player/
        abilities.ts
        index.ts
        player.ts
      sandbox/
        index.ts
      scoring/
        index.ts
        track.ts
      utils/
        index.ts
        replay.ts
        serializer.ts
        snapshot.ts
      index.ts
    ARCHITECTURE.md
  runtime/
    src/
      index.ts
      runner.ts
```

# Files

## File: docs/ai-system.md
````markdown
# AI System

BoardSmith includes a game-agnostic AI system using Monte-Carlo Tree Search (MCTS). The AI works with any game without game-specific tuning.

## Overview

The `@boardsmith/ai` package provides:
- **MCTSBot**: MCTS-based AI player
- **Difficulty presets**: easy, medium, hard
- **Custom objectives**: Guide AI behavior for specific games

## How MCTS Works

Monte-Carlo Tree Search builds a game tree by repeatedly:

1. **SELECT**: Walk down the tree using UCT (Upper Confidence Bound for Trees) to balance exploration vs exploitation
2. **EXPAND**: Try one unexplored action from a leaf node
3. **PLAYOUT**: Random moves until game ends (or depth limit)
4. **BACKPROPAGATE**: Update win counts back up the tree

After many iterations, the bot chooses the most-visited child of the root (robust choice).

## Basic Usage

### Using the CLI

The easiest way to add AI players is via the CLI:

```bash
# Player 1 is AI (medium difficulty)
boardsmith dev --ai 1

# Players 0 and 2 are AI
boardsmith dev --ai 0 2

# Set difficulty level
boardsmith dev --ai 1 --ai-level hard

# Custom iteration count
boardsmith dev --ai 1 --ai-level 50
```

### Difficulty Levels

| Level | Iterations | Playout Depth | Timeout |
|-------|-----------|---------------|---------|
| easy | 3 | 3 | 1000ms |
| medium | 5 | 4 | 1500ms |
| hard | 8 | 5 | 2000ms |

Note: Iterations are kept low because game operations can be slow (~18ms per move). The timeout ensures responsive behavior.

### Programmatic Usage

```typescript
import { createBot, parseAILevel } from '@boardsmith/ai';
import { MyGame } from './game.js';

// Create a bot for player 1
const bot = createBot(
  game,                    // Game instance
  MyGame,                  // Game class constructor
  'my-game',               // Game type identifier
  1,                       // Player index (0-based)
  actionHistory,           // History of actions taken so far
  'hard'                   // Difficulty level or iteration count
);

// Get the bot's move
const move = await bot.play();
console.log(`Bot plays: ${move.action}`, move.args);

// Execute the move
game.continueFlow(move.action, move.args, 1);
```

## Custom Objectives

For games where win/loss isn't sufficient guidance, you can define objectives that give the AI partial credit during playouts.

### Defining Objectives

```typescript
import type { AIConfig, Game } from '@boardsmith/ai';

const aiConfig: AIConfig = {
  objectives: (game: Game, playerIndex: number) => ({
    // Positive weight = good for the player
    controlCenter: {
      checker: (g, p) => {
        const center = g.board.cells.filter(c => c.isCentral);
        const playerPieces = center.filter(c => c.piece?.player?.position === p);
        return playerPieces.length >= 2;
      },
      weight: 0.3,
    },

    // Negative weight = bad for the player
    exposedKing: {
      checker: (g, p) => {
        const king = g.players[p].king;
        return king.isExposed();
      },
      weight: -0.5,
    },

    // Material advantage
    materialAdvantage: {
      checker: (g, p) => {
        const myPieces = g.pieces.filter(pc => pc.player?.position === p);
        const oppPieces = g.pieces.filter(pc => pc.player?.position !== p);
        return myPieces.length > oppPieces.length;
      },
      weight: 0.4,
    },
  }),
};

// Use with createBot
const bot = createBot(game, MyGame, 'my-game', 1, [], 'medium', aiConfig);
```

### Objective Evaluation

During playouts that don't reach a terminal state:
- If total objective score > 0: returns 0.6 (slightly favorable)
- If total objective score < 0: returns 0.4 (slightly unfavorable)
- If total objective score = 0: returns 0.5 (neutral)

Terminal states always use actual win/loss (1.0/0.0).

## Example: Checkers AI

From `packages/games/checkers/rules/src/ai.ts`:

```typescript
import type { AIConfig, Game } from '@boardsmith/ai';

export const checkersAIConfig: AIConfig = {
  objectives: (game: Game, playerIndex: number) => ({
    // Having more pieces is good
    morePieces: {
      checker: (g, p) => {
        const myPieces = countPieces(g, p);
        const oppPieces = countPieces(g, 1 - p);
        return myPieces > oppPieces;
      },
      weight: 0.5,
    },

    // Having kings is good
    hasKings: {
      checker: (g, p) => {
        const myKings = countKings(g, p);
        return myKings > 0;
      },
      weight: 0.3,
    },

    // Controlling the center is good
    centerControl: {
      checker: (g, p) => {
        const centerCells = getCenterCells(g);
        const myPiecesInCenter = centerCells.filter(
          c => c.piece?.player?.position === p
        );
        return myPiecesInCenter.length >= 2;
      },
      weight: 0.2,
    },
  }),
};
```

## Integration with GameSession

The `@boardsmith/session` package integrates AI automatically:

```typescript
import { GameSession } from '@boardsmith/session';
import { MyGame } from './game.js';
import { myGameAIConfig } from './ai.js';

const session = new GameSession({
  gameClass: MyGame,
  gameType: 'my-game',
  playerCount: 2,
  aiPlayers: [1],           // Player 1 is AI
  aiLevel: 'hard',
  aiConfig: myGameAIConfig,  // Optional custom objectives
});

// AI will automatically play when it's player 1's turn
session.start();
```

## BotConfig Options

```typescript
interface BotConfig {
  /** Number of MCTS iterations (higher = stronger but slower). Default: 100 */
  iterations: number;

  /** Maximum playout depth before evaluating position. Default: 5 */
  playoutDepth: number;

  /** Random seed for reproducible behavior */
  seed?: string;

  /** Run async to yield to event loop (prevents UI freezing). Default: true */
  async?: boolean;

  /** Maximum time in milliseconds before returning best move found. Default: 2000 */
  timeout?: number;
}
```

## Performance Considerations

1. **Iteration count**: More iterations = better play, but slower. The default presets are tuned for responsiveness.

2. **Playout depth**: Deeper playouts give more accurate evaluations but take longer. 3-5 is usually sufficient.

3. **Timeout**: The timeout ensures the bot always returns within a reasonable time, even if iterations haven't completed.

4. **Branching factor**: Games with many possible moves per turn will have fewer iterations explored per move. The bot samples up to 20 choices per selection to limit combinatorial explosion.

5. **Game complexity**: Simple games (Hex, Checkers) work well. Complex games (Cribbage with many scoring possibilities) may need custom objectives.

## Limitations

- **No learning**: The AI doesn't learn from past games. Each game starts fresh.
- **Text/number inputs**: The AI can't handle actions that require text or number input (it can only choose from discrete options).
- **Determinism**: With a seed, the bot is deterministic. Without a seed, it uses `Math.random()`.

## API Reference

### createBot()

```typescript
function createBot<G extends Game>(
  game: G,
  GameClass: new (options: GameOptions) => G,
  gameType: string,
  playerIndex: number,
  actionHistory?: SerializedAction[],
  difficulty?: DifficultyLevel | number,
  aiConfig?: AIConfig
): MCTSBot<G>
```

### MCTSBot.play()

```typescript
async play(): Promise<BotMove>
```

Returns the best move found after running MCTS iterations.

### parseAILevel()

```typescript
function parseAILevel(level: string): DifficultyLevel | number
```

Parse an AI level string (e.g., from CLI arguments).

## Related Documentation

- [Core Concepts](./core-concepts.md) - Understanding game state
- [Actions & Flow](./actions-and-flow.md) - How actions work
- [Game Examples](./game-examples.md) - Games with AI implementations
````

## File: docs/dice-and-scoring.md
````markdown
# Dice & Scoring Systems

BoardSmith provides comprehensive support for dice games and roll-and-write style scoring. This document covers the engine's dice elements, 3D dice rendering, ability management, and scoring track systems.

## Dice Elements

### Die

The base `Die` class extends `Piece` with dice-specific properties:

```typescript
import { Die } from '@boardsmith/engine';

class MyDie extends Die<MyGame, MyPlayer> {
  // Inherited properties:
  // sides: number - Number of faces (4, 6, 8, 10, 12, 20)
  // value: number - Current face value

  // Add custom properties
  color?: 'red' | 'blue' | 'green';
}
```

#### Die Sides

The engine supports standard polyhedral dice:

| Type | Geometry | Values |
|------|----------|--------|
| D4 | Tetrahedron | 1-4 |
| D6 | Cube | 1-6 |
| D8 | Octahedron | 1-8 |
| D10 | Trapezohedron | 0-9 or 1-10 |
| D12 | Dodecahedron | 1-12 |
| D20 | Icosahedron | 1-20 |

### DicePool

A `DicePool` is a `Space` designed to hold multiple dice:

```typescript
import { DicePool, Die } from '@boardsmith/engine';

class MyGame extends Game<MyGame, MyPlayer> {
  shelf!: DicePool;

  constructor(options: GameOptions) {
    super(options);

    this.registerElements([DicePool, MyDie]);

    // Create the dice pool
    this.shelf = this.create(DicePool, 'shelf');

    // Create dice inside the pool
    this.shelf.create(MyDie, 'd6-1', { sides: 6 });
    this.shelf.create(MyDie, 'd6-2', { sides: 6 });
    this.shelf.create(MyDie, 'd8-1', { sides: 8 });
  }
}
```

### Rolling Dice

Dice are rolled by setting their values randomly:

```typescript
const rollAction = Action.create('roll')
  .prompt('Roll all dice')
  .execute((args, ctx) => {
    const dice = ctx.game.shelf.all(MyDie);
    for (const die of dice) {
      die.value = Math.floor(Math.random() * die.sides) + 1;
    }
  });
```

For D10s that can show 0:
```typescript
// D10 can be 0-9 or 1-10 depending on game rules
die.value = Math.floor(Math.random() * 10);  // 0-9
die.value = Math.floor(Math.random() * 10) + 1;  // 1-10
```

## 3D Dice UI

The `@boardsmith/ui` package includes a WebGL-based 3D dice renderer that displays accurate polyhedral geometry with smooth roll animations.

### Die3D Component

```vue
<script setup lang="ts">
import { Die3D } from '@boardsmith/ui';

const props = defineProps<{
  die: {
    id: string;
    sides: number;
    value: number;
  };
}>();
</script>

<template>
  <Die3D
    :die-id="die.id"
    :sides="die.sides"
    :value="die.value"
    :size="80"
    style="--die-color: #2196F3"
  />
</template>
```

#### Props

| Prop | Type | Description |
|------|------|-------------|
| `dieId` | `string` | Unique identifier for the die |
| `sides` | `4 \| 6 \| 8 \| 10 \| 12 \| 20` | Number of faces |
| `value` | `number` | Current face value to display |
| `size` | `number` | Size in pixels (default: 60) |

#### CSS Custom Properties

Style dice using CSS variables:

```css
.my-die {
  --die-color: #FF5722;           /* Face color */
  --die-pip-color: #FFFFFF;       /* Number/pip color */
  --die-edge-color: #333333;      /* Edge color */
}
```

### Roll Animations

The Die3D component automatically animates when the value changes:

```typescript
// In your game board component
watch(() => props.gameView.dice, (newDice) => {
  // Die3D components will automatically animate to new values
}, { deep: true });
```

### Zoom Preview

Enable Alt+hover zoom by adding `data-die-preview` attribute:

```vue
<template>
  <div
    class="die-slot"
    :data-die-preview="JSON.stringify({ sides: die.sides, value: die.value })"
  >
    <Die3D :die-id="die.id" :sides="die.sides" :value="die.value" />
  </div>
</template>
```

The zoom preview provides a larger, centered view of the die for accessibility.

## Ability System

The `AbilityManager` provides a reusable system for games where players earn and use special abilities/powers. Common in dice games with unlockable abilities.

### Basic Usage

```typescript
import { AbilityManager, Player } from '@boardsmith/engine';

// Define your ability types
type MyAbility = 'reroll' | 'flip' | 'bonus' | 'skip';

class MyPlayer extends Player<MyGame, MyPlayer> {
  abilities = new AbilityManager<MyAbility>();

  constructor(position: number, name: string) {
    super(position, name);
    // Give each player a starting ability
    this.abilities.add('reroll', 'starting');
  }

  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      abilities: this.abilities.toJSON(),
    };
  }
}
```

### AbilityManager API

```typescript
const abilities = new AbilityManager<MyAbility>();

// Adding abilities
abilities.add('reroll');                    // Add an ability
abilities.add('reroll', 'from-track');      // With source description

// Checking abilities
abilities.hasUnused('reroll');              // Has unused ability?
abilities.has('reroll');                    // Has any (used or unused)?
abilities.countUnused('reroll');            // Count unused of type
abilities.countAllUnused();                 // Total unused count

// Using abilities
if (abilities.hasUnused('reroll')) {
  abilities.use('reroll');                  // Marks one as used
}

// Querying
abilities.getAll();                         // All abilities
abilities.getUnused();                      // Only unused
abilities.getUsed();                        // Only used
abilities.getTypes();                       // Unique types ['reroll', 'flip']
abilities.getGrouped();                     // [{ type, total, unused }]

// Management
abilities.resetAll();                       // Reset all to unused
abilities.clear();                          // Remove all

// Serialization
const data = abilities.toJSON();
abilities.fromJSON(data);
AbilityManager.fromJSON(data);              // Static factory
```

### Display Info

Create UI-friendly ability descriptions:

```typescript
import { createAbilityDisplayMap, type AbilityDisplayInfo } from '@boardsmith/engine';

const ABILITY_INFO = createAbilityDisplayMap<MyAbility>({
  'reroll': {
    icon: 'ðŸŽ²',
    label: 'Reroll',
    color: '#2196F3',
    description: 'Reroll up to 2 dice'
  },
  'flip': {
    icon: 'â†»',
    label: 'Flip',
    color: '#9C27B0',
    description: 'Flip a die to its opposite face'
  },
  'bonus': {
    icon: '+',
    label: 'Bonus',
    color: '#4CAF50',
    description: 'Add +1 or +2 to your total'
  },
  'skip': {
    icon: 'â­',
    label: 'Skip',
    color: '#FF9800',
    description: 'Skip this round'
  },
});
```

## Scoring Tracks

BoardSmith provides abstract track classes for dice/roll-and-write games where players record values on scoring sheets.

### Track Types

| Class | Use Case | Example |
|-------|----------|---------|
| `Track` | Base class | - |
| `MonotonicTrack` | Increasing or decreasing sequences | Distillation, Fulminate |
| `UniqueTrack` | No duplicate values allowed | Yahtzee upper section |
| `CounterTrack` | Simple count/tally | Poison skulls, bonus boxes |

### MonotonicTrack

For tracks where values must increase or decrease:

```typescript
import { MonotonicTrack } from '@boardsmith/engine';

// Increasing track (values must go up)
const fulminateTrack = new MonotonicTrack({
  id: 'fulminate',
  name: 'Fulminate',
  direction: 'increasing',
  maxEntries: 10,
  pointsPerEntry: [0, 1, 3, 6, 11, 16, 23, 30, 40, 50],
  completionBonus: 65,
});

// Decreasing track (values must go down)
const distillTrack = new MonotonicTrack({
  id: 'distill-1',
  name: 'Distillation Column 1',
  direction: 'decreasing',
  maxEntries: 5,
  pointsPerEntry: [0, -10, -5, -2, 10],
  completionBonus: 25,
  allowSpecialEntries: true,  // Special entries can equal previous
});
```

#### API

```typescript
// Check if a value can be added
track.canAdd(15);                    // Returns true/false
track.canAdd(15, isSpecial);         // With special entry flag

// Add a value (returns points earned)
const points = track.add(15);

// Query state
track.getEntries();                  // [{ value, points, special }]
track.isEmpty();
track.isComplete();
track.calculatePoints();             // Total including completion bonus

// Serialization
const data = track.toJSON();
track.fromJSON(data);
```

### UniqueTrack

For tracks where each value can only appear once:

```typescript
import { UniqueTrack } from '@boardsmith/engine';

const upperSection = new UniqueTrack({
  id: 'ones',
  name: 'Ones',
  maxEntries: 1,
  pointsPerEntry: (value) => value,  // Function-based points
});

// Will reject if value already used
upperSection.canAdd(3);  // true (first time)
upperSection.add(3);
upperSection.canAdd(3);  // false (already used)
```

### CounterTrack

For simple counting/tallying:

```typescript
import { CounterTrack } from '@boardsmith/engine';

const poisonTrack = new CounterTrack({
  id: 'poison',
  name: 'Poison',
  maxEntries: 6,
  pointsPerCount: 2,       // 2 points per mark
  completionBonus: 10,     // Bonus for filling all 6
});

// Increment the counter
poisonTrack.increment();
poisonTrack.increment();

// Query
poisonTrack.count;         // 2
poisonTrack.isComplete();  // false
poisonTrack.calculatePoints();  // 4 (2 * 2)
```

## Example: Dice Game Player

Here's a complete example combining dice, abilities, and tracks:

```typescript
import {
  Player,
  AbilityManager,
  MonotonicTrack,
  CounterTrack
} from '@boardsmith/engine';

type PowerUp = 'reroll-2' | 'flip' | 'refresh' | 'adjust';

class DiceGamePlayer extends Player<DiceGame, DiceGamePlayer> {
  abilities: AbilityManager<PowerUp>;
  scoreTrack: MonotonicTrack;
  bonusTrack: CounterTrack;

  constructor(position: number, name: string) {
    super(position, name);

    // Initialize ability manager
    this.abilities = new AbilityManager<PowerUp>();
    this.abilities.add('reroll-2', 'starting');

    // Initialize scoring tracks
    this.scoreTrack = new MonotonicTrack({
      id: 'score',
      name: 'Score',
      direction: 'increasing',
      maxEntries: 10,
      pointsPerEntry: [1, 2, 3, 5, 8, 13, 21, 34, 55, 89],
    });

    this.bonusTrack = new CounterTrack({
      id: 'bonus',
      name: 'Bonus Stars',
      maxEntries: 5,
      pointsPerCount: 10,
    });
  }

  get totalScore(): number {
    return this.scoreTrack.calculatePoints() + this.bonusTrack.calculatePoints();
  }

  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      totalScore: this.totalScore,
      abilities: this.abilities.toJSON(),
      scoreTrack: this.scoreTrack.toJSON(),
      bonusTrack: this.bonusTrack.toJSON(),
    };
  }
}
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Element tree and game structure
- [UI Components](./ui-components.md) - Vue components and composables
- [Actions & Flow](./actions-and-flow.md) - Building game actions
- [Game Examples](./game-examples.md) - Complete game implementations
````

## File: docs/getting-started.md
````markdown
# Getting Started with BoardSmith

BoardSmith is a TypeScript framework for building turn-based board and card games with built-in multiplayer support, AI opponents, and automatic UI generation.

## Prerequisites

- Node.js 20+
- npm, pnpm, or yarn

## Quick Start

### 1. Create a New Game Project

```bash
npx boardsmith init my-game
cd my-game
npm install
```

This creates a new game project with the following structure:

```
my-game/
â”œâ”€â”€ boardsmith.json          # Game configuration
â”œâ”€â”€ package.json             # Dependencies
â”œâ”€â”€ tsconfig.json            # TypeScript config
â”œâ”€â”€ vite.config.ts           # Vite bundler config
â”œâ”€â”€ index.html               # Entry HTML
â”œâ”€â”€ public/                  # Static assets
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.ts              # App entry point
â”‚   â”œâ”€â”€ rules/               # Game logic
â”‚   â”‚   â”œâ”€â”€ game.ts          # Main Game class
â”‚   â”‚   â”œâ”€â”€ elements.ts      # Custom element classes
â”‚   â”‚   â”œâ”€â”€ actions.ts       # Player action definitions
â”‚   â”‚   â”œâ”€â”€ flow.ts          # Game flow definition
â”‚   â”‚   â””â”€â”€ index.ts         # Exports
â”‚   â””â”€â”€ ui/                  # Vue UI components
â”‚       â”œâ”€â”€ App.vue          # Main app component
â”‚       â”œâ”€â”€ components/      # Custom components
â”‚       â”‚   â””â”€â”€ GameBoard.vue
â”‚       â””â”€â”€ index.ts         # UI exports
â””â”€â”€ tests/
    â””â”€â”€ game.test.ts         # Game tests
```

### 2. Start Development Server

```bash
boardsmith dev
```

This starts:
- A Vite dev server on port 5173 (UI)
- A game server on port 8787 (API/WebSocket)
- Automatically opens browser tabs for each player

#### Dev Server Options

```bash
# Specify number of players
boardsmith dev --players 3

# Add AI opponents
boardsmith dev --ai 1              # Player 1 is AI
boardsmith dev --ai 0 2            # Players 0 and 2 are AI

# Set AI difficulty
boardsmith dev --ai 1 --ai-level hard    # easy, medium, hard, expert

# Custom ports
boardsmith dev --port 3000 --worker-port 9000
```

### 3. Run Tests

```bash
boardsmith test           # Run once
boardsmith test --watch   # Watch mode
```

### 4. Validate Before Publishing

```bash
boardsmith validate
```

This runs:
- TypeScript compilation checks
- Configuration validation
- Random game simulation to detect infinite loops or game-ending bugs

### 5. Build for Production

```bash
boardsmith build
```

### 6. Publish to boardsmith.io

```bash
boardsmith publish
```

## Understanding the Generated Code

### Game Configuration (boardsmith.json)

```json
{
  "$schema": "https://boardsmith.io/schemas/game.json",
  "name": "my-game",
  "displayName": "My Game",
  "description": "A fun game for 2-4 players",
  "playerCount": { "min": 2, "max": 4 },
  "estimatedDuration": "15-30 minutes",
  "complexity": 2,
  "categories": ["card-game"],
  "thumbnail": "./public/thumbnail.png",
  "scoreboard": { "stats": ["score"] }
}
```

### Game Class (src/rules/game.ts)

The Game class is the heart of your game. It:
- Extends `Game<YourGame, YourPlayer>`
- Registers element classes
- Creates the initial game state (deck, board, etc.)
- Registers actions players can take
- Defines the game flow

```typescript
export class MyGame extends Game<MyGame, MyPlayer> {
  deck!: Deck;

  constructor(options: MyGameOptions) {
    super(options);

    // Register element classes (required for serialization)
    this.registerElements([Card, Hand, Deck]);

    // Create game elements
    this.deck = this.create(Deck, 'deck');

    // Set up initial state
    this.deck.shuffle();
    for (const player of this.players) {
      // Deal cards...
    }

    // Register player actions
    this.registerAction(createDrawAction(this));
    this.registerAction(createPlayAction(this));

    // Set up game flow
    this.setFlow(createGameFlow(this));
  }

  override isFinished(): boolean {
    return this.deck.count(Card) === 0;
  }

  override getWinners(): MyPlayer[] {
    // Return winning player(s)
  }
}
```

### Element Classes (src/rules/elements.ts)

Elements are the building blocks of your game state. BoardSmith provides base classes:

- **Space** - Containers that hold other elements
  - **Deck** - Stackable card pile (can shuffle)
  - **Hand** - Player's private cards
  - **Grid** - Square grid (e.g., chess board)
  - **HexGrid** - Hexagonal grid
- **Piece** - Physical game pieces
- **Card** - Playing cards

```typescript
import { Card as BaseCard, Hand as BaseHand, Deck as BaseDeck } from '@boardsmith/engine';

export type Suit = 'H' | 'D' | 'C' | 'S';
export type Rank = 'A' | '2' | '3' | ... | 'K';

export class Card extends BaseCard {
  suit!: Suit;
  rank!: Rank;
}

export class Hand extends BaseHand {}
export class Deck extends BaseDeck {}
```

### Actions (src/rules/actions.ts)

Actions define what players can do. Use the fluent builder API:

```typescript
import { Action, type ActionDefinition } from '@boardsmith/engine';

export function createPlayAction(game: MyGame): ActionDefinition {
  return Action.create('play')
    .prompt('Play a card from your hand')
    .chooseFrom<Card>('card', {
      prompt: 'Select a card to play',
      choices: (ctx) => [...ctx.player.hand.all(Card)],
    })
    .execute((args, ctx) => {
      const card = args.card as Card;
      card.remove();
      ctx.player.score += 1;
      return { success: true };
    });
}
```

### Flow (src/rules/flow.ts)

The flow defines turn structure and game phases:

```typescript
import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from '@boardsmith/engine';

export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: eachPlayer({
        name: 'player-turns',
        do: sequence(
          actionStep({ actions: ['draw'] }),
          actionStep({ actions: ['play'] }),
        ),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### UI (src/ui/App.vue)

The UI uses Vue 3 and the `@boardsmith/ui` package:

```vue
<template>
  <GameShell
    game-type="my-game"
    display-name="My Game"
    :player-count="2"
  >
    <template #game-board="{ gameView, playerPosition, isMyTurn, availableActions, action }">
      <GameBoard
        :game-view="gameView"
        :player-position="playerPosition"
        :is-my-turn="isMyTurn"
        :available-actions="availableActions"
        :action="action"
      />
    </template>
  </GameShell>
</template>
```

## Next Steps

- Read [Core Concepts](./core-concepts.md) to understand elements, actions, and commands
- Learn about [Actions & Flow](./actions-and-flow.md) for complex game logic
- Explore [UI Components](./ui-components.md) for building custom UIs
- See [Game Examples](./game-examples.md) for real implementations

## Example Games

BoardSmith includes several example games in `packages/games/`:

| Game | Complexity | Key Features |
|------|-----------|--------------|
| **Hex** | Simple | Hex grid, path-finding win condition |
| **Go Fish** | Medium | Cards, hidden information, player interaction |
| **Checkers** | Medium | Square grid, multi-step moves, piece promotion |
| **Cribbage** | Complex | Multi-phase flow, simultaneous actions, scoring |

Study these to learn common patterns and best practices.
````

## File: docs/ui-components.md
````markdown
# UI Components & Composables

BoardSmith provides Vue 3 components and composables for building game UIs. The `@boardsmith/ui` package includes everything from high-level shells to low-level animation utilities.

## Core Components

### GameShell

The main wrapper component that provides the complete game UI structure: header, player panels, game board area, action panel, and game history.

```vue
<template>
  <GameShell
    game-type="my-game"
    display-name="My Game"
    :player-count="2"
  >
    <!-- Custom game board -->
    <template #game-board="{
      state,
      gameView,
      playerPosition,
      isMyTurn,
      availableActions,
      action,
      actionArgs,
      executeAction,
      setBoardPrompt
    }">
      <GameBoard
        :game-view="gameView"
        :player-position="playerPosition"
        :is-my-turn="isMyTurn"
        :available-actions="availableActions"
        :action="action"
        :action-args="actionArgs"
        :execute-action="executeAction"
        :set-board-prompt="setBoardPrompt"
      />
    </template>

    <!-- Custom player stats display -->
    <template #player-stats="{ player, gameView }">
      <div class="player-stat">
        <span class="label">Score:</span>
        <span class="value">{{ player.score }}</span>
      </div>
    </template>
  </GameShell>
</template>

<script setup lang="ts">
import { GameShell } from '@boardsmith/ui';
import GameBoard from './components/GameBoard.vue';
</script>
```

#### Slot Props

The `#game-board` slot receives:

| Prop | Type | Description |
|------|------|-------------|
| `state` | `GameState` | Full game state |
| `gameView` | `object` | Player-filtered view of game state |
| `playerPosition` | `number` | Current player's position |
| `isMyTurn` | `boolean` | Whether it's this player's turn |
| `availableActions` | `string[]` | Actions available to the player |
| `action` | `function` | Execute an action: `(name, args) => Promise` |
| `actionArgs` | `object` | Current action arguments |
| `executeAction` | `function` | Execute current action: `(name) => Promise` |
| `setBoardPrompt` | `function` | Set a prompt message: `(text) => void` |

### AutoUI

Automatic UI generation from game state. Useful for prototyping or as a reference implementation.

```vue
<template>
  <AutoUI
    :game-view="gameView"
    :player-position="playerPosition"
    :flow-state="flowState"
  />
</template>

<script setup lang="ts">
import { AutoUI } from '@boardsmith/ui';
</script>
```

The auto-generated UI includes:
- **AutoGameBoard**: Renders the game element tree
- **AutoElement**: Renders individual elements based on type
- **ActionPanel**: Displays available actions with selection UI

### DebugPanel

Development tool for inspecting game state, history, and debugging.

```vue
<template>
  <DebugPanel
    :state="state"
    :game-view="gameView"
    :action-history="actionHistory"
  />
</template>
```

## Helper Components

### DeckPile

Visual representation of a deck/pile of cards.

```vue
<template>
  <DeckPile
    :count="deckCount"
    :clickable="canDraw"
    @click="onDrawCard"
  />
</template>
```

### CardFan

Display cards in a fanned layout (like a hand of cards).

```vue
<template>
  <CardFan
    :cards="playerHand"
    :selectable="isMyTurn"
    @select="onCardSelect"
  />
</template>
```

### DiceRoller

Animated dice rolling component.

```vue
<template>
  <DiceRoller
    :value="diceResult"
    :rolling="isRolling"
    @roll-complete="onRollComplete"
  />
</template>
```

### Draggable

Wrapper for drag-and-drop interactions.

```vue
<template>
  <Draggable
    :disabled="!canDrag"
    @drag-start="onDragStart"
    @drag-end="onDragEnd"
  >
    <Card :card="card" />
  </Draggable>
</template>
```

### FlyingCardsOverlay

Overlay for card flight animations between positions.

```vue
<template>
  <FlyingCardsOverlay
    :flying-cards="flyingCards"
  />
</template>
```

## Composables

### useBoardInteraction

Bidirectional interaction between action panel and game board.

```typescript
import { useBoardInteraction, createBoardInteraction, provideBoardInteraction } from '@boardsmith/ui';

// In GameShell (provide)
const boardInteraction = createBoardInteraction();
provideBoardInteraction(boardInteraction);

// In GameBoard or ActionPanel (inject)
const boardInteraction = useBoardInteraction();

// Check element states
boardInteraction.isHighlighted(element)  // Hovered in action panel
boardInteraction.isSelected(element)     // Currently selected
boardInteraction.isValidTarget(element)  // Valid drop/selection target
boardInteraction.isSelectableElement(element)  // Can be clicked to select

// Trigger selections
boardInteraction.triggerElementSelect(element)

// Drag and drop
boardInteraction.startDrag(element)
boardInteraction.endDrag()
boardInteraction.isDropTarget(element)
boardInteraction.isDraggedElement(element)
```

### useElementAnimation

FLIP animations for smooth element movement.

```typescript
import { useElementAnimation } from '@boardsmith/ui';

const { capturePositions, animateToCurrentPositions, cancelAll } = useElementAnimation();

// Before state changes
capturePositions(containerRef.value);

// After state changes (in nextTick or watch)
animateToCurrentPositions(containerRef.value, {
  duration: 300,
  selector: '[data-animatable="true"]',
});
```

Elements must have `data-animatable="true"` and `data-element-id="..."` attributes.

### useCardFlip / useCardReveal

Card flip and reveal animations.

```typescript
import { useCardFlip, useCardReveal } from '@boardsmith/ui';

const { isFlipped, flip, flipBack } = useCardFlip({
  duration: 300,
});

const { isRevealed, reveal } = useCardReveal({
  delay: 100,
});
```

### useFlyingCards

Manage cards flying between positions.

```typescript
import { useFlyingCards, type FlyingCard } from '@boardsmith/ui';

const { flyingCards, flyCard, clearFlying } = useFlyingCards();

// Fly a card from one position to another
flyCard({
  id: card.id,
  from: { x: 100, y: 200 },
  to: { x: 500, y: 300 },
  duration: 500,
  onComplete: () => console.log('Card arrived'),
});
```

### useFlyOnAppear

Animate elements flying in when they appear.

```typescript
import { useFlyOnAppear } from '@boardsmith/ui';

const { trackElement, getInitialPosition } = useFlyOnAppear({
  from: 'deck',  // Element ID to fly from
  duration: 400,
});
```

### usePlayerStatAnimation

Animate stat changes and fly elements to player stat displays.

```typescript
import { usePlayerStatAnimation, flyToPlayerStat } from '@boardsmith/ui';

// Fly a card to a player's score display
flyToPlayerStat({
  cardElement: cardEl,
  playerPosition: 0,
  statName: 'score',
  onComplete: () => updateScore(),
});
```

### useGameViewHelpers

Utilities for querying game state.

```typescript
import {
  useGameViewHelpers,
  findElement,
  findElements,
  findPlayerHand,
  getCards,
  getElementOwner,
  isMyElement,
} from '@boardsmith/ui';

// Find specific element
const deck = findElement(gameView, { type: 'deck' });

// Find player's hand
const myHand = findPlayerHand(gameView, playerPosition);

// Get all cards in an element
const cardsInHand = getCards(myHand);

// Check ownership
const owner = getElementOwner(card);
const isMine = isMyElement(card, playerPosition);
```

### useGameGrid

Utilities for square grids (chess notation, etc.).

```typescript
import { useGameGrid, toAlgebraicNotation, fromAlgebraicNotation } from '@boardsmith/ui';

const { getCellAt, getAlgebraic, pixelToCell } = useGameGrid({
  rows: 8,
  cols: 8,
  cellSize: 60,
});

// Convert coordinates
const notation = toAlgebraicNotation(0, 0);  // "a1"
const { col, row } = fromAlgebraicNotation('e4');  // { col: 4, row: 3 }
```

### useHexGrid

Utilities for hexagonal grids.

```typescript
import {
  useHexGrid,
  hexToPixel,
  getHexPolygonPoints,
  calculateHexDistance
} from '@boardsmith/ui';

const {
  hexToPixel,
  pixelToHex,
  getHexCorners,
  getNeighbors
} = useHexGrid({
  size: 30,
  orientation: 'flat',  // or 'pointy'
});

// Convert hex coords to pixel position
const { x, y } = hexToPixel(3, 2, 30, 'flat');

// Get SVG polygon points for a hex cell
const points = getHexPolygonPoints(cx, cy, size, 'flat');

// Calculate distance between hexes
const dist = calculateHexDistance(q1, r1, q2, r2);
```

### useCardDisplay

Card display formatting utilities.

```typescript
import {
  useCardDisplay,
  getSuitSymbol,
  getSuitColor,
  getRankName,
  isRedSuit
} from '@boardsmith/ui';

getSuitSymbol('H');  // "â™¥"
getSuitSymbol('D');  // "â™¦"
getSuitSymbol('C');  // "â™£"
getSuitSymbol('S');  // "â™ "

getSuitColor('H');   // "#e74c3c" (red)
getSuitColor('S');   // "#2c3e50" (black)

getRankName('K');    // "King"
isRedSuit('D');      // true
```

### useElementChangeTracker

Track element position and count changes for animations.

```typescript
import { useElementChangeTracker, useCountTracker } from '@boardsmith/ui';

const { trackElements, getChanges } = useElementChangeTracker();

// Track element movements
trackElements(gameView);
// ... state changes ...
const changes = getChanges(gameView);  // { added, removed, moved }

// Track count changes
const { track, getChange } = useCountTracker();
track('deckCount', deck.children.length);
const delta = getChange('deckCount');  // e.g., -3 (deck lost 3 cards)
```

### useFLIPAnimation

Low-level FLIP (First, Last, Invert, Play) animation utility.

```typescript
import { useFLIPAnimation, createFLIPSnapshot } from '@boardsmith/ui';

const { recordFirst, recordLast, play } = useFLIPAnimation({
  duration: 300,
  easing: 'ease-out',
});

// Before change
recordFirst(elements);

// After change
recordLast(elements);

// Animate
play();
```

## Theming

Customize the UI appearance with themes.

```typescript
import { applyTheme, type ThemeConfig } from '@boardsmith/ui';

const customTheme: ThemeConfig = {
  primary: '#00d9ff',
  secondary: '#00ff88',
  background: '#1a1a2e',
  surface: '#16213e',
  text: '#ffffff',
  textMuted: '#888888',
  error: '#e74c3c',
  success: '#00ff88',
};

applyTheme(customTheme);
```

## Building Custom UIs

### Example: Custom Game Board

```vue
<script setup lang="ts">
import { computed, ref } from 'vue';
import { useBoardInteraction, useElementAnimation, findPlayerHand, getCards } from '@boardsmith/ui';

const props = defineProps<{
  gameView: any;
  playerPosition: number;
  isMyTurn: boolean;
  availableActions: string[];
  action: (name: string, args: Record<string, unknown>) => Promise<any>;
}>();

const boardInteraction = useBoardInteraction();
const { capturePositions, animateToCurrentPositions } = useElementAnimation();
const containerRef = ref<HTMLElement>();

// Extract data from game view
const myHand = computed(() => {
  const hand = findPlayerHand(props.gameView, props.playerPosition);
  return hand ? getCards(hand) : [];
});

// Handle card click
async function onCardClick(card: any) {
  if (!props.isMyTurn) return;
  if (!props.availableActions.includes('play')) return;

  // Check if card is selectable via board interaction
  if (boardInteraction?.isSelectableElement(card)) {
    boardInteraction.triggerElementSelect(card);
  } else {
    // Direct action
    await props.action('play', { card: card.id });
  }
}

// Animate state changes
watch(() => props.gameView, (newView, oldView) => {
  if (containerRef.value && oldView) {
    capturePositions(containerRef.value);
    nextTick(() => {
      animateToCurrentPositions(containerRef.value!);
    });
  }
});
</script>

<template>
  <div ref="containerRef" class="game-board">
    <div class="hand">
      <div
        v-for="card in myHand"
        :key="card.id"
        class="card"
        :class="{
          'highlighted': boardInteraction?.isHighlighted(card),
          'selected': boardInteraction?.isSelected(card),
          'selectable': boardInteraction?.isSelectableElement(card),
        }"
        data-animatable="true"
        :data-element-id="card.id"
        @click="onCardClick(card)"
      >
        {{ card.attributes?.rank }}{{ card.attributes?.suit }}
      </div>
    </div>
  </div>
</template>
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Understanding game state
- [Actions & Flow](./actions-and-flow.md) - How actions work
- [Game Examples](./game-examples.md) - Real UI implementations
````

## File: packages/ai/src/index.ts
````typescript
import type { Game, GameOptions, SerializedAction } from '@boardsmith/engine';
import { MCTSBot } from './mcts-bot.js';
import type { BotConfig, AIConfig, DifficultyLevel } from './types.js';
import { DIFFICULTY_PRESETS } from './types.js';


export { MCTSBot } from './mcts-bot.js';
export type {
  BotConfig,
  BotMove,
  AIConfig,
  Objective,
  DifficultyLevel,
} from './types.js';
export { DIFFICULTY_PRESETS, DEFAULT_CONFIG } from './types.js';


type GameClass<G extends Game = Game> = new (options: GameOptions) => G;

























export function createBot<G extends Game>(
  game: G,
  GameClass: GameClass<G>,
  gameType: string,
  playerIndex: number,
  actionHistory: SerializedAction[] = [],
  difficulty: DifficultyLevel | number = 'medium',
  aiConfig?: AIConfig
): MCTSBot<G> {
  const config: Partial<BotConfig> = typeof difficulty === 'number'
    ? { iterations: difficulty }
    : DIFFICULTY_PRESETS[difficulty];

  return new MCTSBot(
    game,
    GameClass,
    gameType,
    playerIndex,
    actionHistory,
    config,
    aiConfig
  );
}




export function parseAILevel(level: string): DifficultyLevel | number {

  if (level in DIFFICULTY_PRESETS) {
    return level as DifficultyLevel;
  }


  const num = parseInt(level, 10);
  if (!isNaN(num) && num > 0) {
    return num;
  }


  return 'medium';
}
````

## File: packages/ai/src/mcts-bot.ts
````typescript
import type {
  Game,
  GameOptions,
  Player,
  FlowState,
  SerializedAction,
  ActionDefinition,
  Selection,
  GameStateSnapshot,
} from '@boardsmith/engine';
import { createSnapshot, deserializeAction } from '@boardsmith/engine';
import type { BotConfig, BotMove, MCTSNode, AIConfig, Objective } from './types.js';
import { DEFAULT_CONFIG } from './types.js';
import { createSeededRandom, randomChoice } from './utils.js';


type GameClass<G extends Game = Game> = new (options: GameOptions) => G;










export class MCTSBot<G extends Game = Game> {
  private game: G;
  private GameClass: GameClass<G>;
  private gameType: string;
  private playerIndex: number;
  private config: BotConfig;
  private objectives?: (game: Game, playerIndex: number) => Record<string, Objective>;
  private rng: () => number;
  private actionHistory: SerializedAction[];
  private seed?: string;

  constructor(
    game: G,
    GameClass: GameClass<G>,
    gameType: string,
    playerIndex: number,
    actionHistory: SerializedAction[] = [],
    config: Partial<BotConfig> = {},
    aiConfig?: AIConfig
  ) {
    this.game = game;
    this.GameClass = GameClass;
    this.gameType = gameType;
    this.playerIndex = playerIndex;
    this.actionHistory = actionHistory;
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.objectives = aiConfig?.objectives;
    this.seed = this.config.seed;
    this.rng = createSeededRandom(this.config.seed);
  }




  async play(): Promise<BotMove> {
    const flowState = this.game.getFlowState();
    if (!flowState?.awaitingInput) {
      throw new Error('Game is not awaiting input');
    }


    if (!this.canBotAct(flowState)) {
      throw new Error(`Not bot's turn (player ${this.playerIndex})`);
    }


    const moves = this.enumerateMoves(this.game, flowState);
    if (moves.length === 0) {
      throw new Error('No available moves');
    }


    if (moves.length === 1) {
      return moves[0];
    }


    const root = this.createNode(
      this.captureSnapshot(),
      flowState,
      null,
      null,
      moves
    );


    const startTime = Date.now();
    const timeout = this.config.timeout ?? 2000;
    const chunkSize = 1;

    for (let i = 0; i < this.config.iterations; i++) {

      if (Date.now() - startTime > timeout) {
        console.log(`MCTS timeout after ${i} iterations`);
        break;
      }

      const leaf = this.select(root);
      const { child, game } = this.expand(leaf);
      const result = this.playout(child, game);
      this.backpropagate(child, result);


      if (this.config.async) {
        await new Promise(resolve => setImmediate(resolve));
      }
    }


    if (root.children.length === 0) {

      return randomChoice(moves, this.rng);
    }

    const best = root.children.reduce((a, b) =>
      a.visits > b.visits ? a : b
    );

    return best.parentMove!;
  }




  private select(node: MCTSNode): MCTSNode {
    while (node.untriedMoves.length === 0 && node.children.length > 0) {
      node = this.selectChild(node);
    }
    return node;
  }




  private selectChild(node: MCTSNode): MCTSNode {
    const C = Math.sqrt(2);
    let best = node.children[0];
    let bestUCT = -Infinity;

    for (const child of node.children) {
      const visits = child.visits + 1e-6;
      const exploitation = child.value / visits;
      const exploration = C * Math.sqrt(Math.log(node.visits + 1) / visits);
      const uct = exploitation + exploration;

      if (uct > bestUCT) {
        bestUCT = uct;
        best = child;
      }
    }
    return best;
  }





  private expand(node: MCTSNode): { child: MCTSNode; game: Game | null } {
    if (node.untriedMoves.length === 0 || node.flowState.complete) {
      return { child: node, game: null };
    }


    const idx = Math.floor(this.rng() * node.untriedMoves.length);
    const move = node.untriedMoves.splice(idx, 1)[0];


    const game = this.restoreGame(node.snapshot);
    if (!game) {

      return { child: node, game: null };
    }


    const currentPlayer = this.getCurrentPlayerFromFlowState(node.flowState);


    let flowState: FlowState;
    try {
      flowState = game.continueFlow(move.action, move.args, currentPlayer);
    } catch (error) {


      return { child: node, game: null };
    }


    const newMoves = flowState.complete ? [] : this.enumerateMovesForSimulation(game as G, flowState);


    const newActionHistory = [
      ...node.snapshot.actionHistory,
      {
        name: move.action,
        player: currentPlayer,
        args: move.args,
        timestamp: Date.now(),
      },
    ];
    const snapshot = createSnapshot(game, this.gameType, newActionHistory, node.snapshot.seed);

    const child = this.createNode(snapshot, flowState, node, move, newMoves);
    node.children.push(child);

    return { child, game };
  }





  private playout(node: MCTSNode, existingGame: Game | null): number {

    const game = existingGame ?? this.restoreGame(node.snapshot);
    if (!game) {

      return 0.5;
    }

    let flowState = node.flowState;
    let depth = 0;

    while (!flowState.complete && depth < this.config.playoutDepth) {

      const moves = this.enumerateMovesForSimulation(game as G, flowState);
      if (moves.length === 0) {
        break;
      }


      const move = randomChoice(moves, this.rng);


      const currentPlayer = this.getCurrentPlayerFromFlowState(flowState);


      try {
        flowState = game.continueFlow(move.action, move.args, currentPlayer);
      } catch (error) {

        break;
      }
      depth++;
    }


    return this.evaluateTerminalFromGame(game, flowState);
  }




  private backpropagate(node: MCTSNode | null, result: number): void {
    while (node !== null) {
      node.visits++;



      const isOurPerspective = node.parent === null ||
        node.parent.currentPlayer === this.playerIndex;
      node.value += isOurPerspective ? result : (1 - result);
      node = node.parent;
    }
  }




  private canBotAct(flowState: FlowState): boolean {

    if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
      const playerState = flowState.awaitingPlayers.find(
        p => p.playerIndex === this.playerIndex && !p.completed
      );
      return playerState !== undefined && playerState.availableActions.length > 0;
    }


    if (flowState.currentPlayer !== undefined) {
      return flowState.currentPlayer === this.playerIndex;
    }

    return false;
  }




  private getAvailableActionsForBot(flowState: FlowState): string[] {

    if (flowState.awaitingPlayers) {
      const playerState = flowState.awaitingPlayers.find(
        p => p.playerIndex === this.playerIndex && !p.completed
      );
      if (playerState && playerState.availableActions.length > 0) {
        return playerState.availableActions;
      }
    }


    if (flowState.availableActions && flowState.availableActions.length > 0 &&
        flowState.currentPlayer === this.playerIndex) {
      return flowState.availableActions;
    }


    if (flowState.availableActions && flowState.availableActions.length > 0) {
      return flowState.availableActions;
    }

    return [];
  }





  private enumerateMoves(game: G, flowState: FlowState): BotMove[] {
    const moves: BotMove[] = [];
    const actions = this.getAvailableActionsForBot(flowState);
    const player = game.players[this.playerIndex];

    for (const actionName of actions) {
      const actionDef = game.getAction(actionName);
      if (!actionDef) continue;


      const argCombos = this.enumerateSelections(game, actionDef, player);
      for (const args of argCombos) {
        moves.push({ action: actionName, args });
      }
    }

    return moves;
  }





  private enumerateMovesForSimulation(game: G, flowState: FlowState): BotMove[] {
    const moves: BotMove[] = [];


    let currentPlayerIndex = flowState.currentPlayer;
    let actions: string[] = flowState.availableActions ?? [];


    if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
      const firstAwaiting = flowState.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
      if (firstAwaiting) {
        currentPlayerIndex = firstAwaiting.playerIndex;
        actions = firstAwaiting.availableActions;
      }
    }

    if (currentPlayerIndex === undefined) {
      return moves;
    }

    const player = game.players[currentPlayerIndex];
    if (!player) {
      return moves;
    }

    for (const actionName of actions) {
      const actionDef = game.getAction(actionName);
      if (!actionDef) continue;


      const argCombos = this.enumerateSelections(game, actionDef, player);
      for (const args of argCombos) {
        moves.push({ action: actionName, args });
      }
    }

    return moves;
  }




  private getCurrentPlayerFromFlowState(flowState: FlowState): number {

    if (flowState.awaitingPlayers && flowState.awaitingPlayers.length > 0) {
      const firstAwaiting = flowState.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
      if (firstAwaiting) {
        return firstAwaiting.playerIndex;
      }
    }
    return flowState.currentPlayer ?? this.playerIndex;
  }




  private enumerateMovesFromSnapshot(snapshot: GameStateSnapshot, flowState: FlowState): BotMove[] {
    const game = this.restoreGame(snapshot);
    if (!game) return [];
    return this.enumerateMoves(game as G, flowState);
  }




  private enumerateSelections(
    game: Game,
    actionDef: ActionDefinition,
    player: Player
  ): Record<string, unknown>[] {
    if (actionDef.selections.length === 0) {
      return [{}];
    }

    return this.enumerateSelectionsRecursive(game, actionDef, player, 0, {});
  }




  private enumerateSelectionsRecursive(
    game: Game,
    actionDef: ActionDefinition,
    player: Player,
    index: number,
    currentArgs: Record<string, unknown>
  ): Record<string, unknown>[] {
    if (index >= actionDef.selections.length) {
      return [{ ...currentArgs }];
    }

    const selection = actionDef.selections[index];
    const choices = this.getChoicesForSelection(game, actionDef.name, selection, player, currentArgs);


    if (selection.type === 'text' || selection.type === 'number') {
      if (selection.optional) {
        return this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, currentArgs);
      }

      return [];
    }

    if (choices.length === 0) {
      if (selection.optional) {
        return this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, currentArgs);
      }
      return [];
    }

    const results: Record<string, unknown>[] = [];


    const maxChoices = 20;
    const sampledChoices = choices.length > maxChoices
      ? this.sampleChoices(choices, maxChoices)
      : choices;

    for (const choice of sampledChoices) {

      const serializedChoice = this.serializeChoice(choice, selection);
      const newArgs = { ...currentArgs, [selection.name]: serializedChoice };
      const subResults = this.enumerateSelectionsRecursive(game, actionDef, player, index + 1, newArgs);
      results.push(...subResults);
    }

    return results;
  }




  private getChoicesForSelection(
    game: Game,
    actionName: string,
    selection: Selection,
    player: Player,
    currentArgs: Record<string, unknown>
  ): unknown[] {
    return game.getSelectionChoices(actionName, selection.name, player as any, currentArgs);
  }




  private serializeChoice(choice: unknown, selection: Selection): unknown {
    if (selection.type === 'player') {
      return (choice as Player).position;
    }
    if (selection.type === 'element') {
      return (choice as { _t: { id: number } })._t.id;
    }
    return choice;
  }




  private sampleChoices<T>(choices: T[], maxCount: number): T[] {
    if (choices.length <= maxCount) return choices;

    const sampled: T[] = [];
    const indices = new Set<number>();

    while (sampled.length < maxCount) {
      const idx = Math.floor(this.rng() * choices.length);
      if (!indices.has(idx)) {
        indices.add(idx);
        sampled.push(choices[idx]);
      }
    }

    return sampled;
  }




  private captureSnapshot(): GameStateSnapshot {
    return createSnapshot(this.game, this.gameType, this.actionHistory, this.seed);
  }





  private restoreGame(snapshot: GameStateSnapshot): Game | null {
    try {
      const game = new this.GameClass({
        playerCount: snapshot.state.players.length,
        playerNames: snapshot.state.players.map(p => p.name as string),
        seed: snapshot.seed,
      });


      game.replayCommands(snapshot.commandHistory);


      game.startFlow();
      for (const action of snapshot.actionHistory) {
        const { actionName, player, args } = deserializeAction(action, game);

        game.continueFlow(actionName, args, player.position);
      }

      return game;
    } catch (error) {

      return null;
    }
  }





  private applyMove(
    snapshot: GameStateSnapshot,
    move: BotMove
  ): { snapshot: GameStateSnapshot; flowState: FlowState } | null {
    const game = this.restoreGame(snapshot);
    if (!game) return null;

    const currentPlayer = game.getFlowState()?.currentPlayer ?? this.playerIndex;


    let flowState: FlowState;
    try {
      flowState = game.continueFlow(move.action, move.args, currentPlayer);
    } catch (error) {
      return null;
    }


    const newActionHistory = [
      ...snapshot.actionHistory,
      {
        name: move.action,
        player: currentPlayer,
        args: move.args,
        timestamp: Date.now(),
      },
    ];

    const newSnapshot = createSnapshot(game, this.gameType, newActionHistory, snapshot.seed);

    return { snapshot: newSnapshot, flowState };
  }




  private createNode(
    snapshot: GameStateSnapshot,
    flowState: FlowState,
    parent: MCTSNode | null,
    parentMove: BotMove | null,
    untriedMoves: BotMove[]
  ): MCTSNode {
    return {
      snapshot,
      flowState,
      parent,
      parentMove,
      children: [],
      untriedMoves: [...untriedMoves],
      visits: 0,
      value: 0,
      currentPlayer: flowState.currentPlayer ?? this.playerIndex,
    };
  }




  private evaluateObjectives(snapshot: GameStateSnapshot): number {
    if (!this.objectives) return 0;

    const game = this.restoreGame(snapshot);
    if (!game) return 0;

    const objectives = this.objectives(game, this.playerIndex);

    let totalScore = 0;
    for (const obj of Object.values(objectives)) {
      if (obj.checker(game, this.playerIndex)) {
        totalScore += obj.weight;
      }
    }

    return totalScore;
  }




  private evaluateTerminal(snapshot: GameStateSnapshot, flowState: FlowState): number {
    if (!flowState.complete) {

      if (this.objectives) {
        const score = this.evaluateObjectives(snapshot);

        return score > 0 ? 0.6 : (score < 0 ? 0.4 : 0.5);
      }
      return 0.5;
    }


    const winners = snapshot.state.settings.winners as number[] | undefined;
    if (!winners || winners.length === 0) {
      return 0.5;
    }

    if (winners.includes(this.playerIndex)) {
      return 1;
    }

    return 0;
  }




  private evaluateTerminalFromGame(game: Game, flowState: FlowState): number {
    if (!flowState.complete) {

      if (this.objectives) {
        const objectives = this.objectives(game, this.playerIndex);
        let totalScore = 0;
        for (const obj of Object.values(objectives)) {
          if (obj.checker(game, this.playerIndex)) {
            totalScore += obj.weight;
          }
        }

        return totalScore > 0 ? 0.6 : (totalScore < 0 ? 0.4 : 0.5);
      }
      return 0.5;
    }


    const winners = (game as any).settings?.winners as number[] | undefined;
    if (!winners || winners.length === 0) {
      return 0.5;
    }

    if (winners.includes(this.playerIndex)) {
      return 1;
    }

    return 0;
  }
}
````

## File: packages/ai/src/types.ts
````typescript
import type { Game, Player, FlowState, GameStateSnapshot } from '@boardsmith/engine';




export interface BotConfig {

  iterations: number;

  playoutDepth: number;

  seed?: string;

  async?: boolean;

  timeout?: number;
}




export interface BotMove {

  action: string;

  args: Record<string, unknown>;
}




export interface MCTSNode {

  snapshot: GameStateSnapshot;

  flowState: FlowState;

  parent: MCTSNode | null;

  parentMove: BotMove | null;

  children: MCTSNode[];

  untriedMoves: BotMove[];

  visits: number;

  value: number;

  currentPlayer: number;
}




export interface Objective {

  checker: (game: Game, playerIndex: number) => boolean;

  weight: number;
}




export interface AIConfig {




  objectives?: (game: Game, playerIndex: number) => Record<string, Objective>;
}




export const DEFAULT_CONFIG: BotConfig = {
  iterations: 100,
  playoutDepth: 5,
  async: true,
  timeout: 2000,
};






export const DIFFICULTY_PRESETS: Record<string, Partial<BotConfig>> = {
  easy: { iterations: 3, playoutDepth: 3, timeout: 1000 },
  medium: { iterations: 5, playoutDepth: 4, timeout: 1500 },
  hard: { iterations: 8, playoutDepth: 5, timeout: 2000 },
};




export type DifficultyLevel = keyof typeof DIFFICULTY_PRESETS;
````

## File: packages/ai/src/utils.ts
````typescript
export function createSeededRandom(seed?: string): () => number {

  let h = 0;
  const seedStr = seed ?? Math.random().toString(36).substring(2);
  for (let i = 0; i < seedStr.length; i++) {
    h = Math.imul(31, h) + seedStr.charCodeAt(i) | 0;
  }


  return function () {
    h |= 0;
    h = h + 0x6D2B79F5 | 0;
    let t = Math.imul(h ^ h >>> 15, 1 | h);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}




export function randomChoice<T>(array: T[], rng: () => number): T {
  return array[Math.floor(rng() * array.length)];
}




export function shuffle<T>(array: T[], rng: () => number): T[] {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
````

## File: packages/engine/src/command/executor.ts
````typescript
import type {
  GameCommand,
  CommandResult,
  CreateElementCommand,
  CreateManyCommand,
  MoveCommand,
  RemoveCommand,
  ShuffleCommand,
  SetAttributeCommand,
  SetVisibilityCommand,
  AddVisibleToCommand,
  SetCurrentPlayerCommand,
  MessageCommand,
  StartGameCommand,
  EndGameCommand,
  SetOrderCommand,
  VisibilityConfig,
} from './types.js';
import type { Game } from '../element/game.js';
import type { GameElement } from '../element/game-element.js';
import type { Space } from '../element/space.js';
import type { Piece } from '../element/piece.js';
import type { ElementClass } from '../element/types.js';
import { visibilityFromMode, type VisibilityMode, type VisibilityState } from './visibility.js';




export function executeCommand(game: Game, command: GameCommand): CommandResult {
  try {
    switch (command.type) {
      case 'CREATE':
        return executeCreate(game, command);
      case 'CREATE_MANY':
        return executeCreateMany(game, command);
      case 'MOVE':
        return executeMove(game, command);
      case 'REMOVE':
        return executeRemove(game, command);
      case 'SHUFFLE':
        return executeShuffle(game, command);
      case 'SET_ATTRIBUTE':
        return executeSetAttribute(game, command);
      case 'SET_VISIBILITY':
        return executeSetVisibility(game, command);
      case 'ADD_VISIBLE_TO':
        return executeAddVisibleTo(game, command);
      case 'SET_CURRENT_PLAYER':
        return executeSetCurrentPlayer(game, command);
      case 'MESSAGE':
        return executeMessage(game, command);
      case 'START_GAME':
        return executeStartGame(game, command);
      case 'END_GAME':
        return executeEndGame(game, command);
      case 'SET_ORDER':
        return executeSetOrder(game, command);
      default:
        return { success: false, error: `Unknown command type: ${(command as any).type}` };
    }
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

function executeCreate(game: Game, command: CreateElementCommand): CommandResult {
  const parent = game.getElementById(command.parentId);
  if (!parent) {
    return { success: false, error: `Parent element not found: ${command.parentId}` };
  }

  const ElementClass = game.getElementClass(command.className);
  if (!ElementClass) {
    return { success: false, error: `Unknown element class: ${command.className}` };
  }

  const element = parent.createInternal(ElementClass, command.name, command.attributes);
  return { success: true, createdIds: [element.id] };
}

function executeCreateMany(game: Game, command: CreateManyCommand): CommandResult {
  const parent = game.getElementById(command.parentId);
  if (!parent) {
    return { success: false, error: `Parent element not found: ${command.parentId}` };
  }

  const ElementClass = game.getElementClass(command.className);
  if (!ElementClass) {
    return { success: false, error: `Unknown element class: ${command.className}` };
  }

  const createdIds: number[] = [];
  for (let i = 0; i < command.count; i++) {
    const attrs = command.attributesList?.[i] ?? {};
    const element = parent.createInternal(ElementClass, command.name, attrs);
    createdIds.push(element.id);
  }

  return { success: true, createdIds };
}

function executeMove(game: Game, command: MoveCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  const destination = game.getElementById(command.destinationId);
  if (!destination) {
    return { success: false, error: `Destination not found: ${command.destinationId}` };
  }


  (element as Piece).moveToInternal(destination, command.position);
  return { success: true };
}

function executeRemove(game: Game, command: RemoveCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  (element as Piece).moveToInternal(game.pile);
  return { success: true };
}

function executeShuffle(game: Game, command: ShuffleCommand): CommandResult {
  const space = game.getElementById(command.spaceId) as Space | undefined;
  if (!space) {
    return { success: false, error: `Space not found: ${command.spaceId}` };
  }

  space.shuffleInternal();
  return { success: true };
}

function executeSetAttribute(game: Game, command: SetAttributeCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  (element as any)[command.attribute] = command.value;
  return { success: true };
}

function executeSetVisibility(game: Game, command: SetVisibilityCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  let visibility: VisibilityState;
  if (typeof command.visibility === 'string') {
    visibility = visibilityFromMode(command.visibility);
  } else {
    visibility = {
      mode: command.visibility.mode,
      addPlayers: command.visibility.addPlayers,
      exceptPlayers: command.visibility.exceptPlayers,
      explicit: true,
    };
  }

  element.setVisibilityInternal(visibility);
  return { success: true };
}

function executeAddVisibleTo(game: Game, command: AddVisibleToCommand): CommandResult {
  const element = game.getElementById(command.elementId);
  if (!element) {
    return { success: false, error: `Element not found: ${command.elementId}` };
  }

  element.addVisibleToInternal(command.players);
  return { success: true };
}

function executeSetCurrentPlayer(game: Game, command: SetCurrentPlayerCommand): CommandResult {
  game.players.setCurrent(command.playerPosition);
  return { success: true };
}

function executeMessage(game: Game, command: MessageCommand): CommandResult {
  game.addMessageInternal(command.text, command.data);
  return { success: true };
}

function executeStartGame(game: Game, command: StartGameCommand): CommandResult {
  if (game.phase !== 'setup') {
    return { success: false, error: 'Game has already started' };
  }
  game.phase = 'started';
  return { success: true };
}

function executeEndGame(game: Game, command: EndGameCommand): CommandResult {
  game.phase = 'finished';
  if (command.winners) {
    game.settings.winners = command.winners;
  }
  return { success: true };
}

function executeSetOrder(game: Game, command: SetOrderCommand): CommandResult {
  const space = game.getElementById(command.spaceId);
  if (!space) {
    return { success: false, error: `Space not found: ${command.spaceId}` };
  }

  space._t.order = command.order;
  return { success: true };
}
````

## File: packages/engine/src/command/index.ts
````typescript
export type {
  GameCommand,
  CommandResult,
  BaseCommand,
  CreateElementCommand,
  CreateManyCommand,
  MoveCommand,
  RemoveCommand,
  ShuffleCommand,
  SetAttributeCommand,
  SetVisibilityCommand,
  AddVisibleToCommand,
  SetCurrentPlayerCommand,
  MessageCommand,
  StartGameCommand,
  EndGameCommand,
  SetOrderCommand,
  VisibilityConfig,
} from './types.js';

export {
  type VisibilityMode,
  type VisibilityState,
  canPlayerSee,
  visibilityFromMode,
  resolveVisibility,
  DEFAULT_VISIBILITY,
} from './visibility.js';

export { executeCommand } from './executor.js';
````

## File: packages/engine/src/command/types.ts
````typescript
import type { ElementClass, ElementAttributes } from '../element/types.js';
import type { GameElement } from '../element/game-element.js';
import type { VisibilityMode } from './visibility.js';




export interface BaseCommand {
  type: string;

  timestamp?: number;
}




export interface CreateElementCommand extends BaseCommand {
  type: 'CREATE';

  className: string;

  name: string;

  parentId: number;

  attributes?: Record<string, unknown>;
}




export interface CreateManyCommand extends BaseCommand {
  type: 'CREATE_MANY';

  className: string;

  name: string;

  parentId: number;

  count: number;

  attributesList?: Record<string, unknown>[];
}




export interface MoveCommand extends BaseCommand {
  type: 'MOVE';

  elementId: number;

  destinationId: number;

  position?: 'first' | 'last';
}




export interface RemoveCommand extends BaseCommand {
  type: 'REMOVE';

  elementId: number;
}




export interface ShuffleCommand extends BaseCommand {
  type: 'SHUFFLE';

  spaceId: number;
}




export interface SetAttributeCommand extends BaseCommand {
  type: 'SET_ATTRIBUTE';

  elementId: number;

  attribute: string;

  value: unknown;
}




export interface SetVisibilityCommand extends BaseCommand {
  type: 'SET_VISIBILITY';

  elementId: number;

  visibility: VisibilityMode | VisibilityConfig;
}




export interface AddVisibleToCommand extends BaseCommand {
  type: 'ADD_VISIBLE_TO';

  elementId: number;

  players: number[];
}




export interface SetCurrentPlayerCommand extends BaseCommand {
  type: 'SET_CURRENT_PLAYER';

  playerPosition: number;
}




export interface MessageCommand extends BaseCommand {
  type: 'MESSAGE';

  text: string;

  data?: Record<string, unknown>;
}




export interface StartGameCommand extends BaseCommand {
  type: 'START_GAME';
}




export interface EndGameCommand extends BaseCommand {
  type: 'END_GAME';

  winners?: number[];
}




export interface SetOrderCommand extends BaseCommand {
  type: 'SET_ORDER';

  spaceId: number;

  order: 'normal' | 'stacking';
}




export interface VisibilityConfig {

  mode: VisibilityMode;

  addPlayers?: number[];

  exceptPlayers?: number[];
}




export type GameCommand =
  | CreateElementCommand
  | CreateManyCommand
  | MoveCommand
  | RemoveCommand
  | ShuffleCommand
  | SetAttributeCommand
  | SetVisibilityCommand
  | AddVisibleToCommand
  | SetCurrentPlayerCommand
  | MessageCommand
  | StartGameCommand
  | EndGameCommand
  | SetOrderCommand;




export interface CommandResult {

  success: boolean;

  error?: string;

  createdIds?: number[];
}
````

## File: packages/engine/src/command/visibility.ts
````typescript
export type VisibilityMode = 'all' | 'owner' | 'hidden' | 'count-only' | 'unordered';




export interface VisibilityState {

  mode: VisibilityMode;

  addPlayers?: number[];

  exceptPlayers?: number[];

  explicit: boolean;
}




export function canPlayerSee(
  visibility: VisibilityState,
  playerPosition: number,
  ownerPosition: number | undefined
): boolean {

  if (visibility.exceptPlayers?.includes(playerPosition)) {
    return false;
  }


  if (visibility.addPlayers?.includes(playerPosition)) {
    return true;
  }


  switch (visibility.mode) {
    case 'all':
      return true;
    case 'owner':
      return ownerPosition !== undefined && playerPosition === ownerPosition;
    case 'hidden':
    case 'count-only':
    case 'unordered':
      return false;
    default:
      return true;
  }
}




export const DEFAULT_VISIBILITY: VisibilityState = {
  mode: 'all',
  explicit: false,
};




export function visibilityFromMode(mode: VisibilityMode): VisibilityState {
  return {
    mode,
    explicit: true,
  };
}




export function resolveVisibility(
  childVisibility: VisibilityState | undefined,
  parentVisibility: VisibilityState | undefined
): VisibilityState {

  if (childVisibility?.explicit) {
    return childVisibility;
  }


  if (parentVisibility) {
    return {
      ...parentVisibility,
      explicit: false,
    };
  }


  return DEFAULT_VISIBILITY;
}
````

## File: packages/engine/src/element/card.ts
````typescript
import { Piece } from './piece.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';



















export class Card<G extends Game = any, P extends Player = any> extends Piece<G, P> {




  $type!: 'card';


  faceUp: boolean = true;

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'card';
  }




  flip(): void {
    this.faceUp = !this.faceUp;
  }




  showFace(): void {
    this.faceUp = true;
  }




  hideFace(): void {
    this.faceUp = false;
  }
}
````

## File: packages/engine/src/element/dice-pool.ts
````typescript
import { Space } from './space.js';
import { Die } from './die.js';
import type { DieSides } from './die.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';




















export class DicePool<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'dice-pool';

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'dice-pool';


    this.$direction = 'horizontal';
    this.$gap = '12px';
    this.$align = 'center';
  }




  getDice(): Die[] {
    return this.all(Die) as unknown as Die[];
  }




  getDiceByType(sides: DieSides): Die[] {
    return this.getDice().filter(d => d.sides === sides);
  }





  rollAll(): Array<[Die, number]> {
    const results: Array<[Die, number]> = [];
    for (const die of this.getDice()) {
      const value = die.roll();
      results.push([die, value]);
    }
    return results;
  }






  rollByName(...names: string[]): Array<[Die, number]> {
    const results: Array<[Die, number]> = [];
    for (const name of names) {
      const die = this.first(Die, { name }) as Die | undefined;
      if (die) {
        const value = die.roll();
        results.push([die, value]);
      }
    }
    return results;
  }






  rollByType(sides: DieSides): Array<[Die, number]> {
    const results: Array<[Die, number]> = [];
    for (const die of this.getDiceByType(sides)) {
      const value = die.roll();
      results.push([die, value]);
    }
    return results;
  }




  getTotal(): number {
    return this.getDice().reduce((sum, die) => sum + die.value, 0);
  }




  getValues(): number[] {
    return this.getDice().map(d => d.value);
  }




  hasValue(value: number): boolean {
    return this.getDice().some(d => d.value === value);
  }




  countValue(value: number): number {
    return this.getDice().filter(d => d.value === value).length;
  }





  createPolySet(colors?: Partial<Record<DieSides, string>>): void {
    const defaultColors: Record<DieSides, string> = {
      4: '#4CAF50',
      6: '#9C27B0',
      8: '#2196F3',
      10: '#FF9800',
      12: '#E91E63',
      20: '#F44336',
    };

    const dieTypes: DieSides[] = [4, 6, 8, 10, 12, 20];
    for (const sides of dieTypes) {
      this.create(Die, `d${sides}`, {
        sides,
        color: colors?.[sides] ?? defaultColors[sides],
      });
    }
  }






  createRPGSet(colors?: Partial<Record<DieSides, string>>): void {
    const defaultColors: Record<DieSides, string> = {
      4: '#4CAF50',
      6: '#9C27B0',
      8: '#2196F3',
      10: '#FF9800',
      12: '#E91E63',
      20: '#F44336',
    };


    this.create(Die, 'd4', { sides: 4, color: colors?.[4] ?? defaultColors[4] });
    this.create(Die, 'd6', { sides: 6, color: colors?.[6] ?? defaultColors[6] });
    this.create(Die, 'd8', { sides: 8, color: colors?.[8] ?? defaultColors[8] });
    this.create(Die, 'd10', { sides: 10, color: colors?.[10] ?? defaultColors[10] });
    this.create(Die, 'd10-percent', { sides: 10, color: colors?.[10] ?? defaultColors[10] });
    this.create(Die, 'd12', { sides: 12, color: colors?.[12] ?? defaultColors[12] });
    this.create(Die, 'd20', { sides: 20, color: colors?.[20] ?? defaultColors[20] });
  }
}
````

## File: packages/engine/src/element/die.ts
````typescript
import { Piece } from './piece.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';




export type DieSides = 4 | 6 | 8 | 10 | 12 | 20;





















export class Die<G extends Game = any, P extends Player = any> extends Piece<G, P> {




  $type!: 'die';




  sides!: DieSides;




  value: number = 0;




  color: string = '#ffffff';






  faceLabels?: string[];





  rolling: boolean = false;





  rollCount: number = 0;

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'die';
  }







  roll(): number {
    this.rollCount++;
    this.value = Math.floor(this.game.random() * this.sides) + 1;
    return this.value;
  }





  stopRolling(): void {
    this.rolling = false;
  }






  setValue(n: number): void {
    if (n < 1 || n > this.sides) {
      throw new Error(`Invalid die value ${n} for d${this.sides}`);
    }
    this.value = n;
  }






  getOpposite(): number {
    if (this.sides === 4) {

      const others = [1, 2, 3, 4].filter(n => n !== this.value);
      return others[Math.floor(this.game.random() * others.length)];
    }

    return this.sides + 1 - this.value;
  }





  flip(): void {
    this.value = this.getOpposite();
  }





  getLabel(): string {
    if (this.faceLabels && this.faceLabels.length === this.sides) {
      return this.faceLabels[this.value - 1];
    }
    return String(this.value);
  }




  isD4(): boolean { return this.sides === 4; }
  isD6(): boolean { return this.sides === 6; }
  isD8(): boolean { return this.sides === 8; }
  isD10(): boolean { return this.sides === 10; }
  isD12(): boolean { return this.sides === 12; }
  isD20(): boolean { return this.sides === 20; }
}
````

## File: packages/engine/src/element/element-collection.ts
````typescript
import type { GameElement } from './game-element.js';
import type { ElementClass, ElementFinder, Sorter } from './types.js';




type FinderOptions = {
  limit?: number;
  order?: 'asc' | 'desc';
  noRecursive?: boolean;
};





export class ElementCollection<T extends GameElement = GameElement> extends Array<T> {



  override slice(...args: Parameters<Array<T>['slice']>): ElementCollection<T> {
    return super.slice(...args) as ElementCollection<T>;
  }




  override filter(
    predicate: (value: T, index: number, array: T[]) => boolean
  ): ElementCollection<T> {
    return super.filter(predicate) as ElementCollection<T>;
  }




  all<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  all(...finders: ElementFinder<T>[]): ElementCollection<T>;
  all<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, {}, ...finders);
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, {}, ...finders) as ElementCollection<F>;
  }




  first<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  first(...finders: ElementFinder<T>[]): T | undefined;
  first<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: 1 }, ...finders)[0];
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: 1 }, ...finders)[0] as F | undefined;
  }




  firstN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  firstN(n: number, ...finders: ElementFinder<T>[]): ElementCollection<T>;
  firstN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: n }, ...finders);
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: n }, ...finders) as ElementCollection<F>;
  }




  last<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  last(...finders: ElementFinder<T>[]): T | undefined;
  last<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: 1, order: 'desc' }, ...finders)[0];
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: 1, order: 'desc' }, ...finders)[0] as F | undefined;
  }




  lastN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  lastN(n: number, ...finders: ElementFinder<T>[]): ElementCollection<T>;
  lastN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    if (this.isElementClass(classNameOrFinder)) {
      return this._finder(classNameOrFinder, { limit: n, order: 'desc' }, ...finders);
    }
    if (classNameOrFinder !== undefined) {
      finders = [classNameOrFinder as ElementFinder<F>, ...finders];
    }
    return this._finder(undefined, { limit: n, order: 'desc' }, ...finders) as ElementCollection<F>;
  }




  has<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): boolean;
  has(...finders: ElementFinder<T>[]): boolean;
  has<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): boolean {
    return this.first(classNameOrFinder as ElementClass<F>, ...finders) !== undefined;
  }




  sortBy<K extends Sorter<T>>(key: K, direction: 'asc' | 'desc' = 'asc'): ElementCollection<T> {
    const sorted = new ElementCollection<T>(...this);
    sorted.sort((a, b) => {
      const aVal = typeof key === 'function' ? key(a) : a[key as keyof T];
      const bVal = typeof key === 'function' ? key(b) : b[key as keyof T];
      if (aVal < bVal) return direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return direction === 'asc' ? 1 : -1;
      return 0;
    });
    return sorted;
  }




  sum(key: keyof T | ((element: T) => number)): number {
    return this.reduce((acc, el) => {
      const val = typeof key === 'function' ? key(el) : el[key as keyof T];
      return acc + (typeof val === 'number' ? val : 0);
    }, 0);
  }




  min(key: keyof T | ((element: T) => number)): T | undefined {
    if (this.length === 0) return undefined;
    return this.reduce((min, el) => {
      const minVal = typeof key === 'function' ? key(min) : min[key as keyof T];
      const elVal = typeof key === 'function' ? key(el) : el[key as keyof T];
      return elVal < minVal ? el : min;
    });
  }




  max(key: keyof T | ((element: T) => number)): T | undefined {
    if (this.length === 0) return undefined;
    return this.reduce((max, el) => {
      const maxVal = typeof key === 'function' ? key(max) : max[key as keyof T];
      const elVal = typeof key === 'function' ? key(el) : el[key as keyof T];
      return elVal > maxVal ? el : max;
    });
  }




  shuffle(random: () => number = Math.random): ElementCollection<T> {
    for (let i = this.length - 1; i > 0; i--) {
      const j = Math.floor(random() * (i + 1));
      [this[i], this[j]] = [this[j], this[i]];
    }
    return this;
  }




  unique<K extends keyof T>(key: K): T[K][] {
    const seen = new Set<T[K]>();
    for (const el of this) {
      seen.add(el[key]);
    }
    return Array.from(seen);
  }




  _finder<F extends GameElement>(
    className: ElementClass<F> | undefined,
    options: FinderOptions,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const result = new ElementCollection<F>();
    if (options.limit !== undefined && options.limit <= 0) return result;


    const predicates = finders.map((finder) => this.finderToPredicate<F>(finder));

    const process = (elements: GameElement[], order: 'asc' | 'desc') => {
      const items = order === 'desc' ? [...elements].reverse() : elements;

      for (const el of items) {
        if (options.limit !== undefined && result.length >= options.limit) break;


        const matchesClass = !className || el instanceof className;
        const matchesPredicates = predicates.every((pred) => pred(el as F));

        if (matchesClass && matchesPredicates) {
          if (order === 'desc') {
            result.unshift(el as F);
          } else {
            result.push(el as F);
          }
        }


        if (!options.noRecursive && el._t.children.length > 0) {
          const childCollection = new ElementCollection(...el._t.children);
          const remaining = options.limit !== undefined
            ? options.limit - result.length
            : undefined;
          const childResults = childCollection._finder(className, {
            ...options,
            limit: remaining,
          }, ...finders);
          result.push(...childResults);
        }
      }
    };

    process(this as unknown as GameElement[], options.order ?? 'asc');
    return result;
  }




  private finderToPredicate<F extends GameElement>(finder: ElementFinder<F>): (el: F) => boolean {
    if (typeof finder === 'string') {
      return (el) => el.name === finder;
    }
    if (typeof finder === 'function') {
      return finder;
    }

    return (el) => {
      for (const [key, value] of Object.entries(finder)) {
        if (key === 'empty') {
          if (value !== el.isEmpty()) return false;
        } else if (key === 'mine') {
          if (value !== el.isMine()) return false;
        } else {
          if ((el as Record<string, unknown>)[key] !== value) return false;
        }
      }
      return true;
    };
  }




  private isElementClass<F extends GameElement>(
    value: unknown
  ): value is ElementClass<F> {
    return (
      typeof value === 'function' &&
      'isGameElement' in value &&
      (value as ElementClass<F>).isGameElement === true
    );
  }
}
````

## File: packages/engine/src/element/grid.ts
````typescript
import { Space } from './space.js';
import type { Game } from './game.js';
import type { Player } from '../player/player.js';





export type ElementLayout =
  | 'grid'
  | 'hex-grid'
  | 'list'
  | 'stack'
  | 'hand'
  | 'free-form';














export class Grid<G extends Game = any, P extends Player = any> extends Space<G, P> {





  readonly $layout: ElementLayout = 'grid';






  $rowLabels?: string[];






  $columnLabels?: string[];






  $rowCoord?: string;






  $colCoord?: string;

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}






















export class GridCell<G extends Game = any, P extends Player = any> extends Space<G, P> {





  readonly $layout: ElementLayout = 'list';

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}
````

## File: packages/engine/src/element/hex-grid.ts
````typescript
import { Space } from './space.js';
import type { Game } from './game.js';
import type { Player } from '../player/player.js';
import type { ElementLayout } from './grid.js';




export type HexOrientation = 'flat' | 'pointy';







export type HexCoordSystem = 'offset' | 'axial' | 'cube';













export class HexGrid<G extends Game = any, P extends Player = any> extends Space<G, P> {





  readonly $layout: ElementLayout = 'hex-grid';







  $hexOrientation: HexOrientation = 'pointy';





  $coordSystem: HexCoordSystem = 'axial';





  $qCoord?: string;





  $rCoord?: string;





  $sCoord?: string;





  $hexSize?: number;

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}

















export class HexCell<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'hex-cell';

  constructor(ctx: Partial<import('./types.js').ElementContext>) {
    super(ctx);
    this.$type = 'hex-cell';
  }

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
  ];
}
````

## File: packages/engine/src/element/piece.ts
````typescript
import { GameElement } from './game-element.js';
import { Space } from './space.js';
import type { ElementClass, ElementAttributes, ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';
import type { VisibilityMode } from '../command/visibility.js';
import { visibilityFromMode } from '../command/visibility.js';










export class Piece<G extends Game = any, P extends Player = any> extends GameElement<G, P> {
  constructor(ctx: Partial<ElementContext>) {
    super(ctx);
  }








  putInto(destination: GameElement, options?: { position?: 'first' | 'last' }): void {
    this.moveToInternal(destination, options?.position);
  }




  moveToInternal(destination: GameElement, position?: 'first' | 'last'): void {
    const oldParent = this._t.parent;


    if (oldParent) {
      const index = oldParent._t.children.indexOf(this);
      if (index !== -1) {
        oldParent._t.children.splice(index, 1);
      }


      if (oldParent instanceof Space) {
        oldParent.triggerEvent('exit', this);
      }
    }


    this._t.parent = destination;

    const pos = position ?? (destination._t.order === 'stacking' ? 'first' : 'last');
    if (pos === 'first') {
      destination._t.children.unshift(this);
    } else {
      destination._t.children.push(this);
    }


    if (destination instanceof Space) {
      destination.triggerEvent('enter', this);
    }
  }




  remove(): void {
    if (this.game.pile) {
      this.putInto(this.game.pile);
    }
  }








  setVisibility(mode: VisibilityMode): void {
    this._visibility = visibilityFromMode(mode);
  }




  showToAll(): void {
    this.setVisibility('all');
  }




  showToOwner(): void {
    this.setVisibility('owner');
  }




  hideFromAll(): void {
    this.setVisibility('hidden');
  }




  addVisibleTo(...players: (Player | number)[]): void {
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    this.addVisibleToInternal(positions);
  }




  showOnlyTo(player: Player | number): void {
    const position = typeof player === 'number' ? player : player.position;
    this._visibility = {
      mode: 'hidden',
      addPlayers: [position],
      explicit: true,
    };
  }




  hideFrom(...players: (Player | number)[]): void {
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    this._visibility = {
      mode: 'all',
      exceptPlayers: positions,
      explicit: true,
    };
  }




  clearVisibility(): void {
    this._visibility = undefined;
  }








  override create<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T>
  ): T {
    if (elementClass === Space as unknown as ElementClass<T> ||
        Object.prototype.isPrototypeOf.call(Space, elementClass)) {
      throw new Error(`Cannot create Space "${name}" inside Piece "${this.name}"`);
    }
    return super.create(elementClass, name, attributes);
  }








  isPiece(): boolean {
    return true;
  }
}
````

## File: packages/engine/src/flow/turn-order.ts
````typescript
import type { Player } from '../player/player.js';
import type { FlowContext } from './types.js';




export interface TurnOrderConfig {
  direction?: 'forward' | 'backward';
  filter?: (player: Player, context: FlowContext) => boolean;
  startingPlayer?: (context: FlowContext) => Player;
}

















export const TurnOrder = {



  DEFAULT: {
    direction: 'forward' as const,
  } satisfies TurnOrderConfig,




  REVERSE: {
    direction: 'backward' as const,
  } satisfies TurnOrderConfig,







  CONTINUE: {
    direction: 'forward' as const,
    startingPlayer: (ctx: FlowContext) => ctx.game.players.current,
  } satisfies TurnOrderConfig,




  ACTIVE_ONLY: {
    direction: 'forward' as const,
    filter: (player: Player) => !(player as any).eliminated,
  } satisfies TurnOrderConfig,




















  START_FROM: (getPlayer: number | ((ctx: FlowContext) => Player)): TurnOrderConfig => ({
    direction: 'forward' as const,
    startingPlayer: (ctx: FlowContext) => {
      if (typeof getPlayer === 'number') {
        return ctx.game.players[getPlayer];
      }
      return getPlayer(ctx);
    },
  }),














  ONLY: (positions: number[]): TurnOrderConfig => ({
    direction: 'forward' as const,
    filter: (player: Player) => positions.includes(player.position),
  }),
};
````

## File: packages/engine/src/player/abilities.ts
````typescript
export interface Ability<T extends string = string> {

  type: T;

  used: boolean;

  earnedFrom?: string;
}




export interface AbilityDisplayInfo {

  icon: string;

  label: string;

  color?: string;

  description?: string;
}






















export class AbilityManager<T extends string = string> {
  private abilities: Ability<T>[] = [];






  add(type: T, earnedFrom?: string): void {
    this.abilities.push({ type, used: false, earnedFrom });
  }




  hasUnused(type: T): boolean {
    return this.abilities.some(a => a.type === type && !a.used);
  }




  has(type: T): boolean {
    return this.abilities.some(a => a.type === type);
  }




  countUnused(type: T): number {
    return this.abilities.filter(a => a.type === type && !a.used).length;
  }




  count(type: T): number {
    return this.abilities.filter(a => a.type === type).length;
  }




  countAllUnused(): number {
    return this.abilities.filter(a => !a.used).length;
  }





  use(type: T): boolean {
    const ability = this.abilities.find(a => a.type === type && !a.used);
    if (ability) {
      ability.used = true;
      return true;
    }
    return false;
  }




  getAll(): readonly Ability<T>[] {
    return this.abilities;
  }




  getUnused(): Ability<T>[] {
    return this.abilities.filter(a => !a.used);
  }




  getUsed(): Ability<T>[] {
    return this.abilities.filter(a => a.used);
  }




  getTypes(): T[] {
    return [...new Set(this.abilities.map(a => a.type))];
  }




  getGrouped(): Array<{ type: T; total: number; unused: number }> {
    const grouped = new Map<T, { total: number; unused: number }>();

    for (const ability of this.abilities) {
      const current = grouped.get(ability.type) ?? { total: 0, unused: 0 };
      current.total++;
      if (!ability.used) {
        current.unused++;
      }
      grouped.set(ability.type, current);
    }

    return Array.from(grouped.entries()).map(([type, counts]) => ({
      type,
      ...counts,
    }));
  }




  resetAll(): void {
    for (const ability of this.abilities) {
      ability.used = false;
    }
  }




  clear(): void {
    this.abilities = [];
  }




  toJSON(): Ability<T>[] {
    return this.abilities.map(a => ({ ...a }));
  }




  fromJSON(data: Ability<T>[]): void {
    this.abilities = data.map(a => ({ ...a }));
  }




  static fromJSON<T extends string>(data: Ability<T>[]): AbilityManager<T> {
    const manager = new AbilityManager<T>();
    manager.fromJSON(data);
    return manager;
  }
}












export function createAbilityDisplayMap<T extends string>(
  info: Record<T, AbilityDisplayInfo>
): Map<T, AbilityDisplayInfo> {
  return new Map(Object.entries(info) as [T, AbilityDisplayInfo][]);
}
````

## File: packages/engine/src/player/player.ts
````typescript
import type { Game } from '../element/game.js';
import type { GameElement, ElementClass, ElementFinder } from '../element/index.js';
import { ElementCollection } from '../element/element-collection.js';




export class Player<G extends Game = Game> {

  readonly position: number;


  name: string;


  color?: string;


  avatar?: string;


  game!: G;


  private _isCurrent: boolean = false;


  static hiddenAttributes: string[] = [];

  constructor(position: number, name: string) {
    this.position = position;
    this.name = name;
  }




  isCurrent(): boolean {
    return this._isCurrent;
  }




  setCurrent(isCurrent: boolean): void {
    this._isCurrent = isCurrent;
  }




  allMy<T extends GameElement>(
    className: ElementClass<T>,
    ...finders: ElementFinder<T>[]
  ): ElementCollection<T> {
    return this.game.all(className, { player: this } as ElementFinder<T>, ...finders);
  }




  my<T extends GameElement>(
    className: ElementClass<T>,
    ...finders: ElementFinder<T>[]
  ): T | undefined {
    return this.game.first(className, { player: this } as ElementFinder<T>, ...finders);
  }




  has<T extends GameElement>(
    className: ElementClass<T>,
    ...finders: ElementFinder<T>[]
  ): boolean {
    return this.my(className, ...finders) !== undefined;
  }




  toString(): string {
    return this.name;
  }




  toJSON(): Record<string, unknown> {
    return {
      position: this.position,
      name: this.name,
      color: this.color,
      avatar: this.avatar,
    };
  }
}




export class PlayerCollection<P extends Player = Player> extends Array<P> {

  private _currentIndex: number = 0;




  get current(): P | undefined {
    return this[this._currentIndex];
  }




  setCurrent(player: P | number): void {
    const index = typeof player === 'number' ? player : player.position;


    if (this[this._currentIndex]) {
      this[this._currentIndex].setCurrent(false);
    }

    this._currentIndex = index;


    if (this[this._currentIndex]) {
      this[this._currentIndex].setCurrent(true);
    }
  }




  next(from?: P): P {
    const currentPos = from?.position ?? this._currentIndex;
    const nextPos = (currentPos + 1) % this.length;
    return this[nextPos];
  }




  previous(from?: P): P {
    const currentPos = from?.position ?? this._currentIndex;
    const prevPos = (currentPos - 1 + this.length) % this.length;
    return this[prevPos];
  }




  others(excluding?: P): PlayerCollection<P> {
    const excludePos = excluding?.position ?? this._currentIndex;
    const result = new PlayerCollection<P>();
    for (const player of this) {
      if (player.position !== excludePos) {
        result.push(player);
      }
    }
    return result;
  }




  other(from?: P): P | undefined {
    if (this.length !== 2) {
      throw new Error('other() can only be used in 2-player games');
    }
    const fromPos = from?.position ?? this._currentIndex;
    return this.find(p => p.position !== fromPos);
  }




  byPosition(position: number): P | undefined {
    return this.find(p => p.position === position);
  }




  inOrderFrom(startPlayer: P): PlayerCollection<P> {
    const result = new PlayerCollection<P>();
    const startIndex = startPlayer.position;

    for (let i = 0; i < this.length; i++) {
      const index = (startIndex + i) % this.length;
      result.push(this[index]);
    }

    return result;
  }




  toJSON(): Record<string, unknown>[] {
    return this.map(p => {

      if (typeof p.toJSON === 'function') {
        return p.toJSON();
      }

      return {
        position: p.position,
        name: p.name,
        color: p.color,
        avatar: p.avatar,
      };
    });
  }
}
````

## File: packages/engine/src/sandbox/index.ts
````typescript
export interface ExecutionLimits {

  actionTimeout: number;

  maxOperations: number;

  maxRecursionDepth: number;
}




export const DEFAULT_LIMITS: ExecutionLimits = {
  actionTimeout: 100,
  maxOperations: 100000,
  maxRecursionDepth: 100,
};




export class ExecutionLimitError extends Error {
  constructor(
    public readonly limitType: 'timeout' | 'operations' | 'recursion',
    message: string
  ) {
    super(message);
    this.name = 'ExecutionLimitError';
  }
}




export class ExecutionContext {
  private operationCount = 0;
  private recursionDepth = 0;
  private startTime: number | null = null;
  private limits: ExecutionLimits;

  constructor(limits: Partial<ExecutionLimits> = {}) {
    this.limits = { ...DEFAULT_LIMITS, ...limits };
  }




  start(): void {
    this.operationCount = 0;
    this.recursionDepth = 0;
    this.startTime = Date.now();
  }




  stop(): void {
    this.startTime = null;
    this.operationCount = 0;
    this.recursionDepth = 0;
  }





  tick(): void {
    this.operationCount++;


    if (this.operationCount > this.limits.maxOperations) {
      throw new ExecutionLimitError(
        'operations',
        `Maximum operation count (${this.limits.maxOperations}) exceeded. ` +
        'This may indicate an infinite loop in your game logic.'
      );
    }


    if (this.startTime !== null) {
      const elapsed = Date.now() - this.startTime;
      if (elapsed > this.limits.actionTimeout) {
        throw new ExecutionLimitError(
          'timeout',
          `Action timeout (${this.limits.actionTimeout}ms) exceeded. ` +
          'Game actions must complete quickly.'
        );
      }
    }
  }





  enterFunction(): void {
    this.recursionDepth++;
    if (this.recursionDepth > this.limits.maxRecursionDepth) {
      throw new ExecutionLimitError(
        'recursion',
        `Maximum recursion depth (${this.limits.maxRecursionDepth}) exceeded. ` +
        'This may indicate infinite recursion in your game logic.'
      );
    }
  }




  exitFunction(): void {
    this.recursionDepth = Math.max(0, this.recursionDepth - 1);
  }




  getStats(): {
    operations: number;
    recursionDepth: number;
    elapsedMs: number | null;
  } {
    return {
      operations: this.operationCount,
      recursionDepth: this.recursionDepth,
      elapsedMs: this.startTime ? Date.now() - this.startTime : null,
    };
  }
}








export function withLimits<T>(
  fn: (ctx: ExecutionContext) => T,
  limits?: Partial<ExecutionLimits>
): T {
  const ctx = new ExecutionContext(limits);
  ctx.start();
  try {
    return fn(ctx);
  } finally {
    ctx.stop();
  }
}




export async function withLimitsAsync<T>(
  fn: (ctx: ExecutionContext) => Promise<T>,
  limits?: Partial<ExecutionLimits>
): Promise<T> {
  const ctx = new ExecutionContext(limits);
  ctx.start();
  try {
    return await fn(ctx);
  } finally {
    ctx.stop();
  }
}




export function guard<T extends (...args: unknown[]) => unknown>(
  fn: T,
  ctx: ExecutionContext
): T {
  return ((...args: Parameters<T>) => {
    ctx.tick();
    ctx.enterFunction();
    try {
      return fn(...args);
    } finally {
      ctx.exitFunction();
    }
  }) as T;
}





export function validateCode(code: string): { valid: boolean; issues: string[] } {
  const issues: string[] = [];

  const forbiddenPatterns = [
    { pattern: /\bfetch\s*\(/, message: 'Network access (fetch) is forbidden' },
    { pattern: /\bXMLHttpRequest\b/, message: 'Network access (XMLHttpRequest) is forbidden' },
    { pattern: /\beval\s*\(/, message: 'Code evaluation (eval) is forbidden' },
    { pattern: /\bnew\s+Function\s*\(/, message: 'Code evaluation (Function) is forbidden' },
    { pattern: /\bsetTimeout\s*\(/, message: 'Timers (setTimeout) are forbidden' },
    { pattern: /\bsetInterval\s*\(/, message: 'Timers (setInterval) are forbidden' },
    { pattern: /\bMath\.random\s*\(/, message: 'Math.random() is forbidden - use game.random instead' },
    { pattern: /\bDate\.now\s*\(/, message: 'Date.now() is forbidden' },
    { pattern: /\brequire\s*\(\s*['"]fs/, message: 'Filesystem access is forbidden' },
    { pattern: /\bimport\s*\(\s*['"]fs/, message: 'Filesystem access is forbidden' },
  ];

  for (const { pattern, message } of forbiddenPatterns) {
    if (pattern.test(code)) {
      issues.push(message);
    }
  }

  return {
    valid: issues.length === 0,
    issues,
  };
}
````

## File: packages/engine/src/scoring/index.ts
````typescript
export {
  Track,
  MonotonicTrack,
  UniqueTrack,
  CounterTrack,
} from './track.js';

export type {
  TrackEntry,
  TrackConfig,
  MonotonicTrackConfig,
  UniqueTrackConfig,
  CounterTrackConfig,
} from './track.js';
````

## File: packages/engine/src/scoring/track.ts
````typescript
export interface TrackEntry {

  value: number;

  points: number;

  isSpecial?: boolean;
}




export interface TrackConfig {

  id: string;

  name?: string;

  maxEntries: number;

  pointsPerEntry?: number[];

  completionBonus?: number;

  allowSpecialEntries?: boolean;
}




export abstract class Track {
  readonly id: string;
  readonly name: string;
  readonly maxEntries: number;
  readonly pointsPerEntry: number[];
  readonly completionBonus: number;
  readonly allowSpecialEntries: boolean;

  protected entries: TrackEntry[] = [];

  constructor(config: TrackConfig) {
    this.id = config.id;
    this.name = config.name ?? config.id;
    this.maxEntries = config.maxEntries;
    this.pointsPerEntry = config.pointsPerEntry ?? new Array(config.maxEntries).fill(0);
    this.completionBonus = config.completionBonus ?? 0;
    this.allowSpecialEntries = config.allowSpecialEntries ?? false;
  }






  abstract canAdd(value: number, isSpecial?: boolean): boolean;





  add(value: number, isSpecial: boolean = false): number {
    if (!this.canAdd(value, isSpecial)) {
      throw new Error(`Cannot add value ${value} to track ${this.id}`);
    }

    const position = this.entries.length;
    const points = this.pointsPerEntry[position] ?? 0;

    this.entries.push({ value, points, isSpecial });
    return points;
  }




  getEntries(): readonly TrackEntry[] {
    return this.entries;
  }




  getLastEntry(): TrackEntry | undefined {
    return this.entries[this.entries.length - 1];
  }




  get length(): number {
    return this.entries.length;
  }




  isComplete(): boolean {
    return this.entries.length >= this.maxEntries;
  }




  isEmpty(): boolean {
    return this.entries.length === 0;
  }




  calculatePoints(): number {
    let total = 0;
    for (const entry of this.entries) {
      total += entry.points;
    }
    if (this.isComplete()) {
      total += this.completionBonus;
    }
    return total;
  }




  getPointsBreakdown(): { entries: number; bonus: number; total: number } {
    const entries = this.entries.reduce((sum, e) => sum + e.points, 0);
    const bonus = this.isComplete() ? this.completionBonus : 0;
    return { entries, bonus, total: entries + bonus };
  }




  clear(): void {
    this.entries = [];
  }




  toJSON(): { id: string; entries: TrackEntry[] } {
    return {
      id: this.id,
      entries: [...this.entries],
    };
  }




  fromJSON(data: { entries: TrackEntry[] }): void {
    this.entries = [...data.entries];
  }
}




export interface MonotonicTrackConfig extends TrackConfig {

  direction: 'increasing' | 'decreasing';

  allowEqual?: boolean;
}






















export class MonotonicTrack extends Track {
  readonly direction: 'increasing' | 'decreasing';
  readonly allowEqual: boolean;

  constructor(config: MonotonicTrackConfig) {
    super(config);
    this.direction = config.direction;
    this.allowEqual = config.allowEqual ?? false;
  }

  canAdd(value: number, isSpecial: boolean = false): boolean {

    if (this.entries.length >= this.maxEntries) {
      return false;
    }


    if (this.entries.length === 0) {
      return true;
    }

    const lastValue = this.entries[this.entries.length - 1].value;


    const allowEqualForThis = this.allowEqual || (isSpecial && this.allowSpecialEntries);

    if (this.direction === 'increasing') {
      return allowEqualForThis ? value >= lastValue : value > lastValue;
    } else {
      return allowEqualForThis ? value <= lastValue : value < lastValue;
    }
  }
}




export interface UniqueTrackConfig extends TrackConfig {

  validRange?: { min: number; max: number };
}














export class UniqueTrack extends Track {
  readonly validRange?: { min: number; max: number };

  constructor(config: UniqueTrackConfig) {
    super(config);
    this.validRange = config.validRange;
  }

  canAdd(value: number, isSpecial: boolean = false): boolean {

    if (this.entries.length >= this.maxEntries) {
      return false;
    }


    if (this.validRange) {
      if (value < this.validRange.min || value > this.validRange.max) {
        return false;
      }
    }


    if (!isSpecial || !this.allowSpecialEntries) {
      if (this.entries.some(e => e.value === value)) {
        return false;
      }
    }

    return true;
  }




  hasValue(value: number): boolean {
    return this.entries.some(e => e.value === value);
  }




  getValues(): Set<number> {
    return new Set(this.entries.map(e => e.value));
  }
}




export interface CounterTrackConfig extends TrackConfig {

  pointsPerCount?: number;
}














export class CounterTrack extends Track {
  readonly pointsPerCount: number;

  constructor(config: CounterTrackConfig) {

    const pointsPerCount = config.pointsPerCount ?? 0;
    super({
      ...config,
      pointsPerEntry: new Array(config.maxEntries).fill(pointsPerCount),
    });
    this.pointsPerCount = pointsPerCount;
  }




  canAdd(_value: number, _isSpecial?: boolean): boolean {
    return this.entries.length < this.maxEntries;
  }




  increment(): number {
    return this.add(this.entries.length + 1);
  }




  get count(): number {
    return this.entries.length;
  }
}
````

## File: packages/engine/src/utils/index.ts
````typescript
export {
  serializeValue,
  deserializeValue,
  serializeAction,
  deserializeAction,
  isSerializedReference,
} from './serializer.js';

export type {
  SerializedReference,
  SerializeOptions,
} from './serializer.js';


export {
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
  computeDiff,
} from './snapshot.js';

export type {
  GameStateSnapshot,
  PlayerStateView,
  StateDiff,
} from './snapshot.js';


export {
  createReplayFile,
  validateReplayFile,
  parseReplayFile,
} from './replay.js';

export type {
  ReplayFile,
} from './replay.js';
````

## File: packages/engine/src/utils/replay.ts
````typescript
import type { SerializedAction } from '../action/types.js';







export interface ReplayFile {

  version: 1;


  gameType: string;


  gameRevision: string;


  seed: string;


  playerCount: number;


  playerNames: string[];


  actions: SerializedAction[];


  outcome: 'complete' | 'aborted';


  winners?: number[];


  timestamp: string;


  metadata?: {

    duration?: number;

    platform?: string;

    custom?: Record<string, unknown>;
  };
}




export function createReplayFile(options: {
  gameType: string;
  gameRevision: string;
  seed: string;
  playerCount: number;
  playerNames: string[];
  actions: SerializedAction[];
  outcome: 'complete' | 'aborted';
  winners?: number[];
  metadata?: ReplayFile['metadata'];
}): ReplayFile {
  return {
    version: 1,
    gameType: options.gameType,
    gameRevision: options.gameRevision,
    seed: options.seed,
    playerCount: options.playerCount,
    playerNames: options.playerNames,
    actions: options.actions,
    outcome: options.outcome,
    winners: options.winners,
    timestamp: new Date().toISOString(),
    metadata: options.metadata,
  };
}




export function validateReplayFile(data: unknown): data is ReplayFile {
  if (typeof data !== 'object' || data === null) {
    return false;
  }

  const replay = data as Record<string, unknown>;

  return (
    replay.version === 1 &&
    typeof replay.gameType === 'string' &&
    typeof replay.gameRevision === 'string' &&
    typeof replay.seed === 'string' &&
    typeof replay.playerCount === 'number' &&
    Array.isArray(replay.playerNames) &&
    Array.isArray(replay.actions) &&
    (replay.outcome === 'complete' || replay.outcome === 'aborted') &&
    typeof replay.timestamp === 'string'
  );
}





export function parseReplayFile(json: string): ReplayFile {
  const data = JSON.parse(json);
  if (!validateReplayFile(data)) {
    throw new Error('Invalid replay file format');
  }
  return data;
}
````

## File: packages/engine/src/utils/snapshot.ts
````typescript
import type { Game } from '../element/game.js';
import type { GameCommand } from '../command/types.js';
import type { SerializedAction } from '../action/types.js';
import type { FlowState } from '../flow/types.js';
import type { ElementJSON } from '../element/types.js';




export interface GameStateSnapshot {

  version: number;


  gameType: string;


  timestamp: number;


  state: ElementJSON & {
    players: Record<string, unknown>[];
    phase: string;
    messages: Array<{ text: string; data?: Record<string, unknown> }>;
    settings: Record<string, unknown>;
  };


  flowState?: FlowState;


  commandHistory: GameCommand[];


  actionHistory: SerializedAction[];


  seed?: string;
}




export interface PlayerStateView {

  player: number;


  state: ElementJSON;


  flowState?: {
    awaitingInput: boolean;
    isMyTurn: boolean;
    availableActions?: string[];
    prompt?: string;
  };


  messages: Array<{ text: string; data?: Record<string, unknown> }>;


  phase: string;


  complete: boolean;


  winners?: number[];
}




export function createSnapshot(
  game: Game,
  gameType: string,
  actionHistory: SerializedAction[] = [],
  seed?: string
): GameStateSnapshot {
  const flowState = game.getFlowState();

  return {
    version: 1,
    gameType,
    timestamp: Date.now(),
    state: game.toJSON() as GameStateSnapshot['state'],
    flowState: flowState ?? undefined,
    commandHistory: [...game.commandHistory],
    actionHistory: [...actionHistory],
    seed,
  };
}




export function createPlayerView(
  game: Game,
  playerPosition: number
): PlayerStateView {
  const flowState = game.getFlowState();
  const currentPlayer = flowState?.currentPlayer;

  return {
    player: playerPosition,
    state: game.toJSONForPlayer(playerPosition),
    flowState: flowState ? {
      awaitingInput: flowState.awaitingInput,
      isMyTurn: currentPlayer === playerPosition,
      availableActions: flowState.awaitingInput && currentPlayer === playerPosition
        ? flowState.availableActions
        : undefined,
      prompt: flowState.awaitingInput && currentPlayer === playerPosition
        ? flowState.prompt
        : undefined,
    } : undefined,
    messages: game.getFormattedMessages().map(text => ({ text })),
    phase: game.phase,
    complete: flowState?.complete ?? false,
    winners: flowState?.complete ? game.getWinners().map(p => p.position) : undefined,
  };
}




export function createAllPlayerViews(game: Game): PlayerStateView[] {
  return game.players.map((_, i) => createPlayerView(game, i));
}




export interface StateDiff {

  changed: Map<number, Partial<ElementJSON>>;

  added: number[];

  removed: number[];

  newCommands: GameCommand[];

  newActions: SerializedAction[];

  flowState?: FlowState;
}




export function computeDiff(
  oldSnapshot: GameStateSnapshot,
  newSnapshot: GameStateSnapshot
): StateDiff {
  const diff: StateDiff = {
    changed: new Map(),
    added: [],
    removed: [],
    newCommands: newSnapshot.commandHistory.slice(oldSnapshot.commandHistory.length),
    newActions: newSnapshot.actionHistory.slice(oldSnapshot.actionHistory.length),
    flowState: newSnapshot.flowState,
  };


  const oldElements = new Map<number, ElementJSON>();
  const newElements = new Map<number, ElementJSON>();

  function collectElements(json: ElementJSON, map: Map<number, ElementJSON>) {
    map.set(json.id, json);
    if (json.children) {
      for (const child of json.children) {
        collectElements(child, map);
      }
    }
  }

  collectElements(oldSnapshot.state, oldElements);
  collectElements(newSnapshot.state, newElements);


  for (const id of newElements.keys()) {
    if (!oldElements.has(id)) {
      diff.added.push(id);
    }
  }

  for (const id of oldElements.keys()) {
    if (!newElements.has(id)) {
      diff.removed.push(id);
    }
  }


  for (const [id, newEl] of newElements) {
    const oldEl = oldElements.get(id);
    if (oldEl && JSON.stringify(oldEl) !== JSON.stringify(newEl)) {
      diff.changed.set(id, newEl);
    }
  }

  return diff;
}
````

## File: packages/engine/ARCHITECTURE.md
````markdown
# BoardSmith Engine Architecture

## Core Concepts

### Actions vs Commands

BoardSmith uses a two-layer architecture for handling player operations:

#### **Actions** (High-Level, Game-Specific)

**Location:** `src/action/`

Actions represent what **players do** in the game from a game design perspective. They are:

- **High-level operations**: "move piece", "draw card", "ask for rank"
- **Game-specific**: Defined by game designers for their particular game
- **Declarative**: Describe *what* players want to do, not *how* to do it
- **User-facing**: Have prompts, selections, and validation for the UI

**Example:**
```typescript
const moveAction = Action.create('move')
  .prompt('Move a piece')
  .chooseElement('from', { prompt: 'Select piece to move' })
  .chooseFrom('to', { prompt: 'Select destination', choices: getValidMoves })
  .execute((args, ctx) => {
    // This execute function generates Commands
    const piece = args.from as Piece;
    const destination = args.to as Space;
    piece.putInto(destination); // â† Generates MoveCommand internally
  });
```

#### **Commands** (Low-Level, Event-Sourced)

**Location:** `src/command/`

Commands represent **low-level state mutations** that modify the game tree. They are:

- **Low-level operations**: `CreateElementCommand`, `MoveCommand`, `SetAttributeCommand`
- **Generic**: Same commands work for any game
- **Imperative**: Direct instructions to modify state
- **Event-sourced**: Tracked, serializable, and replayable
- **Internal**: Not exposed to game designers directly

**Example:**
```typescript
// When piece.putInto(destination) is called, it generates:
{
  type: 'move',
  elementId: piece.id,
  targetId: destination.id,
  position: 'last'
}
```

### Why This Separation?

#### 1. **Separation of Concerns**
- **Actions** handle game logic and player intent
- **Commands** handle state management and persistence

#### 2. **Event Sourcing**
- Commands form an event log that can be:
  - Replayed for debugging
  - Stored for game history
  - Used for undo/redo
  - Validated and sanitized

#### 3. **Flexibility**
- Game designers work with intuitive Actions
- Engine manages state changes via Commands
- UI can be auto-generated from Action metadata

#### 4. **Security**
- Commands are validated before execution
- Players can't directly manipulate state
- All mutations go through the command system

### Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Player selects action in UI                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Action System (High-Level)                          â”‚
â”‚ - Validates selections                              â”‚
â”‚ - Executes game logic                               â”‚
â”‚ - Calls element methods (putInto, create, etc.)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Command System (Low-Level)                          â”‚
â”‚ - Generates MoveCommand, CreateElementCommand, etc.â”‚
â”‚ - Validates against current state                   â”‚
â”‚ - Executes state mutations                          â”‚
â”‚ - Logs for event sourcing                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Game State Updated                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Comparison to Other Patterns

#### Redux/Vuex (Frontend State Management)
- **Actions** = Actions (user intent)
- **Commands** = Mutations (state changes)
- Similar pattern, different domain

#### Event Sourcing (Backend Architecture)
- **Actions** = Commands (user intent)
- **Commands** = Events (things that happened)
- BoardSmith uses imperative commands, not past-tense events

#### CQRS (Command Query Responsibility Segregation)
- **Actions** = Application commands
- **Commands** = Domain events
- Similar layering concept

## When to Use Which?

### Game Designers Use: **Actions**

```typescript
// Define what players can do
const askAction = Action.create('ask')
  .choosePlayer('target')
  .chooseFrom('rank', { choices: ['A', '2', '3', ...] })
  .execute((args, ctx) => {
    // Game logic here
  });
```

### Engine Developers Use: **Commands**

```typescript
// Internal state mutations
executeCommand({
  type: 'move',
  elementId: 42,
  targetId: 17,
});
```

### Element Methods Generate: **Commands**

```typescript
// Game designers call this
piece.putInto(destination);

// Which internally generates this command
{
  type: 'move',
  elementId: piece.id,
  targetId: destination.id,
}
```

## Best Practices

### âœ… Do

- Use Actions for game-specific player operations
- Use element methods (`putInto`, `create`) which generate Commands
- Let the command system handle state mutations
- Keep Action execute functions focused on game logic

### âŒ Don't

- Don't manually create Commands in game code
- Don't bypass the Action system for player operations
- Don't directly mutate element properties (use `setAttribute` if needed)
- Don't mix UI concerns into Action execute functions

## Related Documentation

- **[Action API](src/action/README.md)** - Creating player actions
- **[Command Types](src/command/types.ts)** - Available command types
- **[Element System](src/element/README.md)** - Game element tree structure
- **[Flow System](src/flow/README.md)** - Game flow control

---

**Summary:** Actions are what players *do*. Commands are how the engine *does it*.
````

## File: packages/runtime/src/index.ts
````typescript
export {
  serializeValue,
  deserializeValue,
  serializeAction,
  deserializeAction,
  isSerializedReference,
  type SerializedReference,
  type SerializeOptions,
} from '@boardsmith/engine';


export {
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
  computeDiff,
  type GameStateSnapshot,
  type PlayerStateView,
  type StateDiff,
} from '@boardsmith/engine';


export {
  createReplayFile,
  validateReplayFile,
  parseReplayFile,
  type ReplayFile,
} from '@boardsmith/engine';


export {
  GameRunner,
  type GameRunnerOptions,
  type ActionExecutionResult,
} from './runner.js';
````

## File: docs/actions-and-flow.md
````markdown
# Actions & Flow System

This document covers the Action builder API and the declarative Flow system for controlling game structure.

## Actions

Actions define what players can do during the game. They use a fluent builder pattern.

### Basic Action Structure

```typescript
import { Action, type ActionDefinition } from '@boardsmith/engine';

export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('actionName')
    .prompt('Description shown to player')
    .condition((ctx) => /* when this action is available */)
    .chooseFrom('selection', { /* selection options */ })
    .execute((args, ctx) => {
      // Game logic here
      return { success: true };
    });
}
```

### Selection Methods

#### `chooseFrom<T>` - Choose from a list

```typescript
Action.create('selectRank')
  .chooseFrom<string>('rank', {
    prompt: 'Choose a rank to ask for',
    choices: (ctx) => ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],
  })
```

#### `chooseElement<T>` - Choose a game element

```typescript
Action.create('placeStone')
  .chooseElement<Cell>('cell', {
    prompt: 'Select an empty cell',
    elementClass: Cell,
    filter: (cell, ctx) => cell.isEmpty(),
    display: (cell) => cell.notation,        // Display text
    boardRef: (cell) => ({ id: cell.id }),   // For UI highlighting
  })
```

#### `choosePlayer` - Choose another player

```typescript
Action.create('askPlayer')
  .choosePlayer('target', {
    prompt: 'Who do you want to ask?',
    filter: (player, ctx) => player !== ctx.player,  // Not self
  })
```

#### `chooseNumber` - Enter a number

```typescript
Action.create('bid')
  .chooseNumber('amount', {
    prompt: 'Enter your bid',
    min: 1,
    max: (ctx) => ctx.player.coins,
  })
```

#### `chooseText` - Enter text

```typescript
Action.create('name')
  .chooseText('name', {
    prompt: 'Enter a name',
    maxLength: 20,
  })
```

### Chaining Selections

Actions can have multiple selections that depend on each other:

```typescript
Action.create('move')
  .chooseElement<Piece>('piece', {
    prompt: 'Select a piece to move',
    elementClass: Piece,
    filter: (p, ctx) => p.player === ctx.player,
  })
  .chooseElement<Cell>('destination', {
    prompt: 'Select destination',
    elementClass: Cell,
    // Filter depends on previously selected piece
    filter: (cell, ctx) => {
      const piece = ctx.args.piece as Piece;
      return piece.canMoveTo(cell);
    },
  })
```

### Conditions

Control when actions are available:

```typescript
Action.create('draw')
  .condition((ctx) => {
    // Only available when deck has cards
    return game.deck.count(Card) > 0;
  })
  .execute(...)
```

### Validation

Validate the complete action before execution:

```typescript
Action.create('play')
  .chooseFrom('cards', { choices: getPlayableCards, multi: true })
  .validate((args, ctx) => {
    const cards = args.cards as Card[];
    if (cards.length < 2) {
      return { valid: false, message: 'Must play at least 2 cards' };
    }
    return { valid: true };
  })
  .execute(...)
```

### Execute Function

The execute function performs the actual game logic:

```typescript
.execute((args, ctx) => {
  const player = ctx.player as MyPlayer;
  const card = args.card as Card;

  // Perform game actions (generates commands automatically)
  card.putInto(game.discardPile);
  player.score += card.value;

  // Add game message
  game.message(`${player.name} played ${card.name}`);

  // Return result
  return {
    success: true,
    message: 'Card played successfully',
    data: { cardId: card.id },
  };
});
```

> **Important:** When using `chooseElement`, the `args` contain the **full serialized element object**, not just the ID. To find the element by ID:
> ```typescript
> const elementId = typeof args.piece === 'object' ? (args.piece as any).id : args.piece;
> const piece = game.all(Piece).find(p => p.id === elementId);
> ```
> Also, always use `ctx.game` instead of a closure reference to the game variable in execute functions to avoid stale references during hot-reload.

### Action Options

```typescript
Action.create('move')
  .prompt('Move your piece')
  .notUndoable()                    // Cannot undo this action
  .skipIf((ctx) => /* condition */) // Skip if condition is true
```

### Example: Go Fish Ask Action

From `packages/games/go-fish/rules/src/actions.ts`:

```typescript
export function createAskAction(game: GoFishGame): ActionDefinition {
  return Action.create('ask')
    .prompt('Ask another player for a card')
    .choosePlayer('target', {
      prompt: 'Who do you want to ask?',
      filter: (p, ctx) => p !== ctx.player && p.hand.count(Card) > 0,
    })
    .chooseFrom<string>('rank', {
      prompt: 'What rank do you want?',
      choices: (ctx) => {
        const player = ctx.player as GoFishPlayer;
        const ranks = new Set<string>();
        for (const card of player.hand.all(Card)) {
          ranks.add(card.rank);
        }
        return [...ranks];
      },
    })
    .execute((args, ctx) => {
      const player = ctx.player as GoFishPlayer;
      const target = args.target as GoFishPlayer;
      const rank = args.rank as string;

      const matchingCards = target.hand.all(Card).filter(c => c.rank === rank);

      if (matchingCards.length > 0) {
        for (const card of matchingCards) {
          card.putInto(player.hand);
        }
        game.message(`${player.name} got ${matchingCards.length} ${rank}(s) from ${target.name}!`);
        game.setPlayerGoesAgain(true);
      } else {
        game.message(`${target.name} says "Go Fish!"`);
        game.setPlayerGoesAgain(false);
      }

      return { success: true };
    });
}
```

## Flow System

The Flow system defines game structure using composable nodes.

### Flow Definition

```typescript
import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from '@boardsmith/engine';

export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: /* flow node */,
    isComplete: (ctx) => game.isFinished(),
    getWinners: (ctx) => game.getWinners(),
  };
}
```

### Flow Nodes

#### `sequence` - Run steps in order

```typescript
sequence(
  actionStep({ actions: ['draw'] }),
  actionStep({ actions: ['play'] }),
)
```

#### `loop` - Repeat while condition is true

```typescript
loop({
  name: 'game-loop',
  while: (ctx) => !game.isFinished(),
  maxIterations: 1000,  // Safety limit
  do: /* flow node */,
})
```

#### `repeat` - Fixed number of iterations

```typescript
repeat({
  name: 'deal-cards',
  times: 5,
  do: actionStep({ actions: ['deal'] }),
})
```

#### `eachPlayer` - Iterate over players

```typescript
eachPlayer({
  name: 'player-turns',
  order: TurnOrder.clockwise(),
  filter: (player, ctx) => !player.hasPassed,
  do: /* flow node */,
})
```

#### `forEach` - Iterate over array

```typescript
forEach({
  name: 'score-hands',
  collection: (ctx) => game.players,
  do: (player) => execute({
    do: () => game.scoreHand(player),
  }),
})
```

#### `actionStep` - Wait for player action

```typescript
actionStep({
  name: 'move-step',
  actions: ['move', 'jump'],      // Available actions
  prompt: 'Move or jump a piece',
  skipIf: (ctx) => game.isFinished(),
})
```

#### `simultaneousActionStep` - All players act at once

```typescript
simultaneousActionStep({
  name: 'discard-step',
  actions: ['discard'],
  prompt: 'Choose cards to discard',
})
```

#### `phase` - Named game phase

```typescript
phase('setup', {
  do: sequence(
    execute({ do: () => game.deal() }),
    simultaneousActionStep({ actions: ['discard'] }),
  ),
})
```

#### `switchOn` - Conditional branching

```typescript
switchOn({
  value: (ctx) => game.currentPhase,
  cases: {
    'deal': /* flow node */,
    'play': /* flow node */,
    'score': /* flow node */,
  },
  default: /* flow node */,
})
```

#### `ifThen` - If-else logic

```typescript
ifThen({
  if: (ctx) => game.deck.count(Card) > 0,
  then: actionStep({ actions: ['draw'] }),
  else: execute({ do: () => game.endRound() }),
})
```

#### `execute` - Run code

```typescript
execute({
  name: 'shuffle-deck',
  do: (ctx) => {
    game.deck.shuffle();
    game.message('Deck shuffled!');
  },
})
```

#### `setVar` - Set flow variable

```typescript
setVar({
  name: 'roundNumber',
  value: (ctx) => (ctx.vars.roundNumber ?? 0) + 1,
})
```

### Turn Order

Control player order with `TurnOrder`:

```typescript
eachPlayer({
  order: TurnOrder.roundRobin(),       // Default: 0, 1, 2, ...
  order: TurnOrder.clockwise(),        // Same as roundRobin
  order: TurnOrder.counterClockwise(), // Reverse
  order: TurnOrder.custom((players, ctx) => {
    // Return players in custom order
    return players.sort((a, b) => a.score - b.score);
  }),
})
```

### Flow Variables

Access and set variables during flow:

```typescript
// Set variable
setVar({ name: 'dealer', value: (ctx) => ctx.players[0] })

// Access in conditions
loop({
  while: (ctx) => ctx.vars.roundNumber < 10,
  do: ...
})
```

### Example: Cribbage Flow

Complex multi-phase flow from `packages/games/cribbage/`:

```typescript
export function createCribbageFlow(game: CribbageGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: sequence(
        // Deal phase
        phase('deal', {
          do: execute({ do: () => game.dealHands() }),
        }),

        // Discard phase - all players discard simultaneously
        phase('discard', {
          do: simultaneousActionStep({
            actions: ['discard'],
            prompt: 'Discard 2 cards to the crib',
          }),
        }),

        // Play phase - alternating card play
        phase('play', {
          do: loop({
            while: () => !game.playPhaseComplete(),
            do: eachPlayer({
              do: actionStep({
                actions: ['playCard', 'sayGo'],
                skipIf: (ctx) => !game.canPlay(ctx.player),
              }),
            }),
          }),
        }),

        // Show phase - score hands
        phase('show', {
          do: forEach({
            collection: () => game.getShowOrder(),
            do: (player) => execute({
              do: () => game.scoreHand(player),
            }),
          }),
        }),

        // Rotate dealer
        execute({ do: () => game.rotateDealer() }),
      ),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### Example: Simple Turn-Based Flow (Hex)

Minimal flow from `packages/games/hex/`:

```typescript
export function createHexFlow(game: HexGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      maxIterations: 100,
      do: eachPlayer({
        name: 'player-turns',
        filter: (player) => !game.isFinished(),
        do: actionStep({
          name: 'place-stone',
          actions: ['placeStone'],
          skipIf: () => game.isFinished(),
        }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.winner ? [game.winner] : [],
  };
}
```

## Registering Actions

Actions must be registered in your Game constructor:

```typescript
constructor(options) {
  super(options);
  // ... element setup ...

  this.registerAction(createMoveAction(this));
  this.registerAction(createDrawAction(this));
  this.registerAction(createPlayAction(this));

  this.setFlow(createGameFlow(this));
}
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Elements and state management
- [UI Components](./ui-components.md) - Displaying actions in the UI
- [Game Examples](./game-examples.md) - Real implementations
````

## File: docs/core-concepts.md
````markdown
# Core Concepts

This document explains the fundamental concepts and architecture of BoardSmith.

## Overview

BoardSmith uses a hierarchical element tree to represent game state, with a clear separation between:
- **Actions** (what players do) - high-level, game-specific
- **Commands** (how state changes) - low-level, generic, event-sourced

## Element Tree

Games are represented as a tree of `GameElement` objects:

```
Game (root)
â”œâ”€â”€ Board/Grid/Deck (Spaces - containers)
â”‚   â”œâ”€â”€ Piece/Card (game pieces)
â”‚   â””â”€â”€ More spaces...
â”œâ”€â”€ Player Hands (Spaces)
â””â”€â”€ Pile (removed elements)
```

### Element Types

| Class | Purpose | Example |
|-------|---------|---------|
| `GameElement` | Base class (never instantiate directly) | - |
| `Space` | Container for other elements | Board, pile, zone |
| `Deck` | Stack of cards (shuffleable) | Draw pile, discard |
| `Hand` | Player's private cards | Player's hand |
| `Grid` | Square grid | Chess/checkers board |
| `HexGrid` | Hexagonal grid | Hex game board |
| `Piece` | Physical game piece | Checker, stone |
| `Card` | Playing card | Standard deck card |

### Creating Elements

Elements are created as children of other elements:

```typescript
// In your Game constructor
class MyGame extends Game<MyGame, MyPlayer> {
  constructor(options) {
    super(options);

    // Register element classes (required for serialization)
    this.registerElements([Card, Hand, Deck, Board]);

    // Create elements as children of the game
    this.deck = this.create(Deck, 'deck');
    this.board = this.create(Board, 'board');

    // Create cards inside the deck
    for (const suit of suits) {
      for (const rank of ranks) {
        this.deck.create(Card, `${rank}${suit}`, { suit, rank });
      }
    }
  }
}
```

### Element Operations

```typescript
// Query elements
const card = deck.first(Card);              // First card
const cards = deck.all(Card);               // All cards
const count = deck.count(Card);             // Count cards
const aceOfSpades = deck.first(Card, c => c.rank === 'A' && c.suit === 'S');

// Move elements
card.putInto(hand);                         // Move card to hand
card.putInto(hand, { position: 'first' }); // Put at beginning

// Remove elements
card.remove();                              // Remove from game

// Create elements
const stone = cell.create(Stone, 'stone-1', { player });

// Shuffle (Deck only)
deck.shuffle();

// Element ordering
deck.setOrder('stacking');                  // Last in, first out
```

### Custom Element Classes

Extend base classes to add game-specific properties:

```typescript
// elements.ts
import { Card as BaseCard, Piece as BasePiece } from '@boardsmith/engine';

export class Card extends BaseCard {
  suit!: 'H' | 'D' | 'C' | 'S';
  rank!: string;

  get value(): number {
    const values: Record<string, number> = { 'A': 1, 'J': 11, 'Q': 12, 'K': 13 };
    return values[this.rank] ?? parseInt(this.rank);
  }
}

export class CheckerPiece extends BasePiece {
  player!: CheckersPlayer;
  isKing: boolean = false;

  promote(): void {
    this.isKing = true;
  }
}
```

## Visibility System

Control what each player can see.

### Element Visibility

```typescript
// Make contents visible to everyone
deck.contentsVisible();

// Hide contents from everyone
deck.contentsHidden();

// Only owner can see contents
hand.contentsVisibleToOwner();
```

### Attribute Visibility

Use static `visibleAttributes` to control which attributes are visible:

```typescript
class Card extends BaseCard {
  suit!: Suit;
  rank!: Rank;
  secretValue!: number;  // Hidden from players

  // Only suit and rank are visible in hidden contexts
  static visibleAttributes = ['suit', 'rank'];
}
```

## Actions vs Commands

BoardSmith separates player intent from state mutations.

### Actions (High-Level)

Actions are what players do - game-specific operations with prompts, selections, and validation:

```typescript
const moveAction = Action.create('move')
  .prompt('Move a piece')
  .chooseElement('piece', { filter: p => p.player === ctx.player })
  .chooseElement('destination', { filter: c => c.isEmpty() })
  .execute((args, ctx) => {
    args.piece.putInto(args.destination);  // Generates MoveCommand
  });
```

### Commands (Low-Level)

Commands are generic state mutations that happen automatically when you call element methods:

| Element Method | Generated Command |
|---------------|-------------------|
| `parent.create(Class, name, attrs)` | `CreateElementCommand` |
| `element.putInto(target)` | `MoveCommand` |
| `element.remove()` | `RemoveCommand` |
| `deck.shuffle()` | `ShuffleCommand` |
| `element.setAttribute(key, value)` | `SetAttributeCommand` |
| `element.contentsVisible()` | `SetVisibilityCommand` |

### Why This Matters

1. **Event Sourcing**: Commands form a replayable event log
2. **Undo/Redo**: Actions can be undone by reversing commands
3. **Networking**: Only commands are sent over the network
4. **Security**: Players can't directly manipulate state
5. **Debugging**: Full history of what happened

### Best Practices

```typescript
// DO: Use element methods in action execute functions
.execute((args, ctx) => {
  card.putInto(hand);
  player.score += 10;
});

// DON'T: Try to create commands manually
// DON'T: Bypass actions for player operations
```

## Player System

### Custom Player Classes

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  hand!: Hand;
  score: number = 0;
  abilities: Record<string, number> = { reroll: 1 };

  constructor(position: number, name: string, game: MyGame) {
    super(position, name);
    this.game = game;

    // Create player's hand
    this.hand = game.create(Hand, `hand-${position}`);
    this.hand.player = this;
    this.hand.contentsVisibleToOwner();
  }

  // IMPORTANT: Override toJSON() to include custom properties in network state
  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      score: this.score,
      abilities: this.abilities,
    };
  }
}
```

> **Important**: If your custom Player class has properties that need to be visible to the UI (like `score`, `abilities`, custom stats), you **must** override `toJSON()` to include them. The base `Player.toJSON()` only serializes `position`, `name`, `color`, and `avatar`.

### Player Properties

- `position`: 0-indexed player position
- `name`: Display name
- `game`: Reference to the game instance

### Accessing Players

```typescript
// In game class
this.players                    // All players array
this.players[0]                 // First player
this.currentPlayer              // Player whose turn it is

// In action context
ctx.player                      // Current action's player
```

## Game State Serialization

BoardSmith automatically handles serialization for:
- Network transmission
- State persistence
- Replays

### PlayerCollection Serialization Warning

`game.players` is a `PlayerCollection` (an Array subclass), not a plain Array. This has important implications when working with player data:

```typescript
// âŒ WRONG: Returns a PlayerCollection, not a plain Array
// When JSON.stringify() is called, PlayerCollection.toJSON() re-serializes
// the elements, losing any custom properties
const playerData = game.players.map(p => p.toJSON());

// âœ… CORRECT: Spread to convert to plain Array
const playerData = [...game.players.map(p => p.toJSON())];

// âœ… ALSO CORRECT: Use Array.from()
const playerData = Array.from(game.players.map(p => p.toJSON()));
```

This is a JavaScript quirk: when you call `.map()` on an Array subclass, the result is an instance of the same subclass, not a plain Array. The `PlayerCollection.toJSON()` method then gets called during serialization, which re-processes the already-serialized data.

### Registering Elements

All custom element classes must be registered:

```typescript
this.registerElements([Card, Hand, Deck, Board, Piece]);
```

### State Snapshots

```typescript
// Get complete state snapshot
const snapshot = game.getSnapshot();

// Get player-specific view (with visibility applied)
const playerView = game.getPlayerView(playerPosition);
```

### Player Views

Each player receives a filtered view of the game state:
- Hidden elements show only `visibleAttributes`
- Private zones of other players are hidden
- Server-side information is stripped

## Game Lifecycle

```
1. Constructor
   - Register elements
   - Create initial state
   - Register actions
   - Set flow

2. setup() - Called after constructor
   - Additional initialization

3. start() - Game begins
   - Flow starts executing
   - Players take actions

4. isFinished() returns true
   - Game ends
   - getWinners() called
```

## Example: Hex Game

A minimal but complete example from `packages/games/hex/`:

```typescript
// game.ts
export class HexGame extends Game<HexGame, HexPlayer> {
  board!: Board;
  winner?: HexPlayer;

  constructor(options: HexOptions) {
    super(options);

    this.registerElements([Board, Cell, Stone]);

    // Create hex board
    this.board = this.create(Board, 'board', { boardSize: 7 });
    for (let r = 0; r < 7; r++) {
      for (let q = 0; q < 7; q++) {
        this.board.create(Cell, `cell-${q}-${r}`, { q, r });
      }
    }

    this.registerAction(createPlaceStoneAction(this));
    this.setFlow(createHexFlow(this));
  }

  override isFinished(): boolean {
    return !!this.winner;
  }

  override getWinners(): HexPlayer[] {
    return this.winner ? [this.winner] : [];
  }
}
```

## Related Documentation

- [Actions & Flow](./actions-and-flow.md) - Deep dive on actions and game flow
- [UI Components](./ui-components.md) - Building game UIs
- [Game Examples](./game-examples.md) - Real game implementations
````

## File: docs/game-examples.md
````markdown
# Game Examples & Patterns

This document analyzes the example games in `packages/games/` to demonstrate common patterns and best practices.

## Example Games Overview

| Game | Location | Complexity | Key Patterns |
|------|----------|-----------|--------------|
| Hex | `packages/games/hex/` | Simple | Hex grid, path-finding, simple flow |
| Go Fish | `packages/games/go-fish/` | Medium | Cards, hidden info, conditional turns |
| Checkers | `packages/games/checkers/` | Medium | Square grid, multi-step actions, piece promotion |
| Cribbage | `packages/games/cribbage/` | Complex | Multi-phase, simultaneous actions, complex scoring |

---

## Hex - Simplest Example

**Location**: `packages/games/hex/`

Hex is the simplest example, demonstrating core patterns with minimal complexity.

### Key Features
- Hex grid board
- Simple alternating turns
- Path-finding win condition
- Single action type

### Game Structure

```typescript
// game.ts
export class HexGame extends Game<HexGame, HexPlayer> {
  board!: Board;
  winner?: HexPlayer;

  constructor(options: HexOptions) {
    super(options);

    // Register elements
    this.registerElements([Board, Cell, Stone]);

    // Create hex board
    this.board = this.create(Board, 'board', { boardSize: 7 });
    for (let r = 0; r < 7; r++) {
      for (let q = 0; q < 7; q++) {
        this.board.create(Cell, `cell-${q}-${r}`, { q, r });
      }
    }

    // Single action
    this.registerAction(createPlaceStoneAction(this));
    this.setFlow(createHexFlow(this));
  }
}
```

### Simple Flow

```typescript
// flow.ts
export function createHexFlow(game: HexGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: actionStep({
          actions: ['placeStone'],
          skipIf: () => game.isFinished(),
        }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.winner ? [game.winner] : [],
  };
}
```

### Element with Board Reference

```typescript
// actions.ts
Action.create('placeStone')
  .chooseElement<Cell>('cell', {
    filter: (cell) => cell.isEmpty(),
    boardRef: (cell) => ({
      id: cell.id,
      notation: cell.notation,
    }),
  })
  .execute((args, ctx) => {
    const cell = args.cell as Cell;
    cell.create(Stone, `stone-${player.position}`, { player });

    // Check win condition
    if (game.board.checkWin(player)) {
      game.setWinner(player);
    }
  });
```

### Pattern: Custom Element Classes

```typescript
// elements.ts
export class Cell extends HexCell {
  q!: number;
  r!: number;

  get notation(): string {
    return `${String.fromCharCode(97 + this.q)}${this.r + 1}`;
  }

  isEmpty(): boolean {
    return this.count(Stone) === 0;
  }
}
```

---

## Go Fish - Card Game Patterns

**Location**: `packages/games/go-fish/`

Go Fish demonstrates card game patterns including hidden information and conditional turns.

### Key Features
- Standard deck creation
- Private hands with visibility
- Player interaction (asking)
- Conditional turns (go again if match)
- Book collection

### Hidden Information

```typescript
// game.ts
constructor(options) {
  // Create player hands - hidden from other players
  for (const player of this.players) {
    const hand = this.create(Hand, `hand-${player.position}`);
    hand.player = player;
    hand.contentsVisibleToOwner();  // Only owner sees their cards
  }

  // The pond (draw pile) - hidden
  this.pond = this.create(Pond, 'pond');
  this.pond.contentsHidden();
}
```

### Conditional Turns (Extra Turn Logic)

```typescript
// flow.ts - Turn loop with extra turns
const playerTurn = sequence(
  setVar('extraTurn', false),
  setVar('turnEnded', false),

  loop({
    name: 'turn-loop',
    while: (ctx) => {
      if (ctx.get('turnEnded')) return false;
      // ... other conditions
      return true;
    },
    do: sequence(
      actionStep({ actions: ['ask'] }),
      execute((ctx) => {
        const extraTurn = ctx.lastActionResult?.data?.extraTurn;
        if (!extraTurn) {
          ctx.set('turnEnded', true);
        }
      }),
    ),
  }),
);
```

### Action with Extra Turn Signal

```typescript
// actions.ts
.execute((args, ctx) => {
  const matchingCards = target.hand.all(Card).filter(c => c.rank === rank);

  if (matchingCards.length > 0) {
    for (const card of matchingCards) {
      card.putInto(player.hand);
    }
    // Signal extra turn
    return { success: true, data: { extraTurn: true } };
  } else {
    game.drawFromPond(player);
    return { success: true, data: { extraTurn: false } };
  }
});
```

### Pattern: Book/Set Collection

```typescript
// game.ts
checkForBooks(player: GoFishPlayer): void {
  const hand = this.getPlayerHand(player);
  const cards = hand.all(Card);

  // Count cards by rank
  const rankCounts = new Map<string, Card[]>();
  for (const card of cards) {
    const existing = rankCounts.get(card.rank) || [];
    existing.push(card);
    rankCounts.set(card.rank, existing);
  }

  // Create books for complete sets
  for (const [rank, rankCards] of rankCounts) {
    if (rankCards.length === 4) {
      const book = this.books.create(Book, `book-${rank}`, { rank, player });
      for (const card of rankCards) {
        card.putInto(book);
      }
      player.score++;
    }
  }
}
```

---

## Checkers - Grid & Multi-Step Actions

**Location**: `packages/games/checkers/`

Checkers demonstrates square grids, forced moves, and multi-step actions.

### Key Features
- 8x8 square grid
- Jump chains (multi-step moves)
- Forced jump rule
- Piece promotion (kings)

### Grid Setup

```typescript
// game.ts
constructor(options) {
  this.board = this.create(Board, 'board');
  this.board.contentsVisible();

  // Create 8x8 grid
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const cell = this.board.create(Cell, `cell-${col}-${row}`, {
        col, row,
        isPlayable: (row + col) % 2 === 1,  // Dark squares only
      });
    }
  }

  // Place initial pieces
  this.setupInitialPieces();
}
```

### Multi-Step Action (Jump Chain)

```typescript
// actions.ts - Handling jump chains
Action.create('move')
  .chooseElement<Piece>('piece', {
    filter: (piece, ctx) => {
      const game = ctx.game as CheckersGame;
      // If there's a pending jump, only that piece can continue
      if (game.pendingJumpPiece) {
        return piece === game.pendingJumpPiece;
      }
      return piece.player === ctx.player && game.hasValidMoves(piece);
    },
  })
  .chooseElement<Cell>('destination', {
    filter: (cell, ctx) => {
      const piece = ctx.args.piece as Piece;
      return game.isValidMove(piece, cell);
    },
  })
  .execute((args, ctx) => {
    const piece = args.piece as Piece;
    const dest = args.destination as Cell;

    const isJump = game.isJumpMove(piece, dest);
    piece.putInto(dest);

    if (isJump) {
      game.captureJumpedPiece(piece, dest);

      // Check for additional jumps
      if (game.canContinueJumping(piece)) {
        game.pendingJumpPiece = piece;
        game.setPlayerGoesAgain(true);
      } else {
        game.pendingJumpPiece = null;
      }
    }

    // Check for promotion
    if (game.shouldPromote(piece)) {
      piece.isKing = true;
    }
  });
```

### Forced Move Logic

```typescript
// game.ts
getValidMoves(player: CheckersPlayer): Move[] {
  const pieces = this.board.all(Piece).filter(p => p.player === player);

  // Check for forced jumps
  const jumpMoves = [];
  for (const piece of pieces) {
    jumpMoves.push(...this.getJumpMoves(piece));
  }

  // If jumps available, must take one
  if (jumpMoves.length > 0) {
    return jumpMoves;
  }

  // Otherwise, regular moves
  return pieces.flatMap(p => this.getRegularMoves(p));
}
```

---

## Cribbage - Complex Multi-Phase Game

**Location**: `packages/games/cribbage/`

Cribbage is the most complex example, demonstrating multi-phase flow, simultaneous actions, and complex scoring.

### Key Features
- Multi-phase rounds (deal, discard, play, show)
- Simultaneous actions (both players discard at once)
- Complex scoring logic
- Running count during play
- "Go" mechanics

### Multi-Phase Flow

```typescript
// flow.ts
const playRound = sequence(
  // Initialize round
  execute((ctx) => game.startNewRound()),

  // Discard phase - simultaneous
  phase('discarding', {
    do: simultaneousActionStep({
      actions: ['discard'],
      prompt: 'Discard 2 cards to the crib',
      playerDone: (ctx, player) => {
        const hand = game.getPlayerHand(player);
        return hand.count(Card) <= 4;  // Done when 4 cards left
      },
      allDone: (ctx) => game.allPlayersDiscarded(),
    }),
  }),

  // Store hands before play
  execute(() => game.storeOriginalHands()),

  // Cut starter
  execute(() => game.cutStarterCard()),

  // Play phase - alternating turns
  phase('play', { do: playPhaseSequence }),

  // Scoring phase
  phase('scoring', {
    do: sequence(
      execute(() => game.scoreRoundAndBuildSummary()),
      simultaneousActionStep({
        actions: ['acknowledgeScore'],
        allDone: () => !game.roundSummary.active,
      }),
    ),
  }),

  // Rotate dealer
  execute(() => game.rotateDealer()),
);
```

### Simultaneous Actions

```typescript
// Both players discard at the same time
simultaneousActionStep({
  name: 'simultaneous-discard',
  actions: ['discard'],
  prompt: 'Discard 2 cards to the crib',
  playerDone: (ctx, player) => {
    const hand = game.getPlayerHand(player as CribbagePlayer);
    return hand.count(Card) <= 4;
  },
  allDone: (ctx) => {
    return game.allPlayersDiscarded() || game.isFinished();
  },
});
```

### Phase Lifecycle Hooks

```typescript
// flow.ts
return {
  root: /* ... */,
  isComplete: /* ... */,
  getWinners: /* ... */,

  // Phase lifecycle hooks
  onEnterPhase: (phaseName, ctx) => {
    const game = ctx.game as CribbageGame;
    game.cribbagePhase = phaseName;

    const phaseNames = {
      discarding: 'DISCARD PHASE',
      play: 'PLAY PHASE',
      scoring: 'SCORING PHASE',
    };
    game.message(`=== ${phaseNames[phaseName]} ===`);
  },
};
```

### Complex Play Phase with Go

```typescript
// Play phase loop with "Go" mechanics
loop({
  name: 'play-loop',
  while: () => !game.allCardsPlayed() && !game.isFinished(),
  do: sequence(
    // Check if count needs reset
    execute(() => {
      const currentStuck = currentSaidGo || !currentCanPlay;
      const otherStuck = otherSaidGo || !otherCanPlay;

      if (currentStuck && otherStuck && (hasCards)) {
        // Award "Go" point
        if (game.runningTotal < 31) {
          game.addPoints(lastPlayer, 1, 'Go');
        }
        game.resetCount();
      }
    }),

    // Player plays or says Go
    actionStep({
      player: () => game.getCurrentPlayPlayer(),
      actions: ['playCard', 'sayGo'],
      skipIf: () => playerAlreadySaidGo || !hasCards,
    }),

    // Switch turns
    execute(() => {
      if (!otherSaidGo && otherHasCards) {
        game.switchPlayTurn();
      }
    }),
  ),
});
```

### Scoring System

```typescript
// scoring.ts - Complex scoring calculation
export function scoreHand(cards: Card[], starter: Card, isCrib: boolean): ScoreBreakdown {
  const allFive = [...cards, starter];
  const breakdown: ScoreBreakdown = { fifteens: 0, pairs: 0, runs: 0, flush: 0, nobs: 0 };

  // Score 15s (combinations summing to 15)
  breakdown.fifteens = scoreFifteens(allFive);

  // Score pairs
  breakdown.pairs = scorePairs(allFive);

  // Score runs (sequences)
  breakdown.runs = scoreRuns(allFive);

  // Score flush (requires 4 in hand, or 5 total for crib)
  breakdown.flush = scoreFlush(cards, starter, isCrib);

  // Score nobs (Jack of starter suit)
  breakdown.nobs = scoreNobs(cards, starter);

  return breakdown;
}
```

---

## Common Patterns Summary

### 1. Game Initialization

```typescript
constructor(options) {
  super(options);
  this.registerElements([...]);  // Always register elements
  // Create board/deck
  // Register actions
  this.setFlow(createGameFlow(this));
}
```

### 2. Custom Player Classes

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  hand!: Hand;
  score: number = 0;
  abilities: Record<string, number> = {};

  constructor(position: number, name: string, game: MyGame) {
    super(position, name);
    this.game = game;
    this.hand = game.create(Hand, `hand-${position}`);
    this.hand.player = this;
  }

  // Required to send custom properties to the UI
  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      score: this.score,
      abilities: this.abilities,
    };
  }
}
```

> **Note**: Always override `toJSON()` if you have custom properties that the UI needs to display (scores, abilities, etc.). See [Core Concepts - Serialization](./core-concepts.md#playercollection-serialization-warning) for details.

### 3. Win Condition Checking

```typescript
override isFinished(): boolean {
  return this.winner !== undefined || /* other condition */;
}

override getWinners(): MyPlayer[] {
  if (!this.isFinished()) return [];
  return this.winner ? [this.winner] : [];
}
```

### 4. Action Result Data

```typescript
.execute((args, ctx) => {
  // ... game logic ...
  return {
    success: true,
    message: 'Action completed',
    data: {
      extraTurn: shouldGoAgain,  // Can be read by flow
      customData: 'anything',
    },
  };
});
```

### 5. Flow Variables

```typescript
sequence(
  setVar('roundNumber', 1),
  loop({
    while: (ctx) => ctx.get('roundNumber') <= 10,
    do: sequence(
      /* round logic */,
      execute((ctx) => ctx.set('roundNumber', ctx.get('roundNumber') + 1)),
    ),
  }),
)
```

### 6. Visibility Control

```typescript
// Hidden from everyone
deck.contentsHidden();

// Visible to everyone
board.contentsVisible();

// Only owner sees
hand.contentsVisibleToOwner();
```

## Related Documentation

- [Getting Started](./getting-started.md) - Create your first game
- [Core Concepts](./core-concepts.md) - Element tree, visibility, state
- [Actions & Flow](./actions-and-flow.md) - Action and flow API details
````

## File: docs/README.md
````markdown
# BoardSmith Documentation

This folder contains documentation for the BoardSmith game framework.

## Documents

| Document | Description |
|----------|-------------|
| [Getting Started](./getting-started.md) | CLI setup, project creation, and basic development |
| [Core Concepts](./core-concepts.md) | Element tree, visibility, actions vs commands |
| [Actions & Flow](./actions-and-flow.md) | Action builder API and declarative flow system |
| [Dice & Scoring](./dice-and-scoring.md) | Dice elements, 3D rendering, abilities, and scoring tracks |
| [UI Components](./ui-components.md) | Vue components and composables |
| [AI System](./ai-system.md) | MCTS bot and AI integration |
| [Game Examples](./game-examples.md) | Analysis of example games with patterns |
| [LLM Overview](./llm-overview.md) | Quick-reference for LLMs |

## For LLMs

If you're an AI assistant reading this codebase:

1. **Start with** [`llm-overview.md`](./llm-overview.md) for a comprehensive summary
2. **Simplest example**: `packages/games/hex/` - minimal but complete game
3. **Complex example**: `packages/games/cribbage/` - multi-phase, simultaneous actions

## Generated LLM Context

The repository includes a `repomix.config.json` that generates `llms.txt` - a single file containing the entire relevant codebase optimized for LLM consumption.

To regenerate:
```bash
npx repomix
```

This produces a ~750KB file with:
- All documentation
- Core engine code
- Example game implementations
- CLI tools
- Excludes tests, type declarations, and node_modules

## Quick Links

- **CLI**: `boardsmith init`, `boardsmith dev`, `boardsmith test`
- **Key packages**: `@boardsmith/engine`, `@boardsmith/ui`, `@boardsmith/ai`
- **Example games**: `packages/games/{hex, go-fish, checkers, cribbage}`
````

## File: packages/engine/src/element/game-element.ts
````typescript
import { ElementCollection } from './element-collection.js';
import type {
  ElementClass,
  ElementContext,
  ElementTree,
  ElementJSON,
  ElementFinder,
  ElementAttributes,
  ImageRef,
} from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';
import type { VisibilityState } from '../command/visibility.js';
import { DEFAULT_VISIBILITY, canPlayerSee, resolveVisibility } from '../command/visibility.js';





export class GameElement<G extends Game = any, P extends Player = any> {

  name?: string;


  player?: P;


  row?: number;


  column?: number;






  $image?: ImageRef;






  $images?: Record<string, ImageRef>;


  game!: G;


  _ctx!: ElementContext;


  _t: ElementTree<GameElement>;


  _visibility?: VisibilityState;


  static isGameElement = true;


  static unserializableAttributes = ['_ctx', '_t', 'game', '_visibility'];


  static visibleAttributes: string[] | undefined;

  constructor(ctx: Partial<ElementContext>) {
    this._ctx = ctx as ElementContext;


    if (this._ctx.sequence === undefined) {
      this._ctx.sequence = 0;
    }


    if (!this._ctx.classRegistry) {
      this._ctx.classRegistry = new Map();
    }


    const id = this._ctx.sequence++;
    this._t = {
      children: [],
      id,
      order: 'normal',
    };
  }




  toString(): string {
    return this.name ?? this.constructor.name.replace(/([a-z0-9])([A-Z])/g, '$1 $2');
  }








  get parent(): GameElement | undefined {
    return this._t.parent;
  }




  get children(): ElementCollection<GameElement> {
    return new ElementCollection(...this._t.children);
  }




  isEmpty(): boolean {
    return this._t.children.length === 0;
  }




  isMine(): boolean {
    if (!this._ctx.player) return false;
    return this.player === this._ctx.player;
  }




  branch(): string {
    const path: number[] = [];
    let current: GameElement | undefined = this as GameElement;

    while (current?._t.parent) {
      const parent: GameElement = current._t.parent;
      const index = parent._t.children.indexOf(current);
      path.unshift(index);
      current = parent;
    }

    return path.join('/');
  }




  atBranch(branch: string): GameElement | undefined {
    if (!branch) return this;

    const indices = branch.split('/').map(Number);
    let current: GameElement = this;

    for (const index of indices) {
      const child = current._t.children[index];
      if (!child) return undefined;
      current = child;
    }

    return current;
  }




  atId(id: number): GameElement | undefined {
    if (this._t.id === id) return this;

    for (const child of this._t.children) {
      const found = child.atId(id);
      if (found) return found;
    }

    return undefined;
  }









  create<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T>
  ): T {
    return this.createInternal(elementClass, name, attributes);
  }




  createInternal<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: Record<string, unknown>
  ): T {
    const element = new elementClass(this._ctx);
    element.name = name;
    element.game = this.game;


    if (attributes) {
      Object.assign(element, attributes);
    }


    this.addChild(element);


    const className = elementClass.name;
    if (!this._ctx.classRegistry.has(className)) {
      this._ctx.classRegistry.set(className, elementClass);
    }

    return element;
  }




  createMany<T extends GameElement>(
    count: number,
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T> | ((index: number) => ElementAttributes<T>)
  ): ElementCollection<T> {
    const elements = new ElementCollection<T>();

    for (let i = 0; i < count; i++) {
      const attrs = typeof attributes === 'function' ? attributes(i) : attributes;
      elements.push(this.create(elementClass, name, attrs));
    }

    return elements;
  }




  protected addChild(element: GameElement): void {
    element._t.parent = this;

    if (this._t.order === 'stacking') {
      this._t.children.unshift(element);
    } else {
      this._t.children.push(element);
    }
  }




  protected removeChild(element: GameElement): void {
    const index = this._t.children.indexOf(element);
    if (index !== -1) {
      this._t.children.splice(index, 1);
      element._t.parent = undefined;
    }
  }




  setOrder(order: 'normal' | 'stacking'): void {
    this._t.order = order;
  }








  all<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  all(...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
  all<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const collection = new ElementCollection(...this._t.children);
    return collection.all(classNameOrFinder as ElementClass<F>, ...finders);
  }




  first<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  first(...finders: ElementFinder<GameElement>[]): GameElement | undefined;
  first<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    const collection = new ElementCollection(...this._t.children);
    return collection.first(classNameOrFinder as ElementClass<F>, ...finders);
  }




  firstN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  firstN(n: number, ...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
  firstN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const collection = new ElementCollection(...this._t.children);
    return collection.firstN(n, classNameOrFinder as ElementClass<F>, ...finders);
  }




  last<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined;
  last(...finders: ElementFinder<GameElement>[]): GameElement | undefined;
  last<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): F | undefined {
    const collection = new ElementCollection(...this._t.children);
    return collection.last(classNameOrFinder as ElementClass<F>, ...finders);
  }




  lastN<F extends GameElement>(
    n: number,
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F>;
  lastN(n: number, ...finders: ElementFinder<GameElement>[]): ElementCollection<GameElement>;
  lastN<F extends GameElement>(
    n: number,
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): ElementCollection<F> {
    const collection = new ElementCollection(...this._t.children);
    return collection.lastN(n, classNameOrFinder as ElementClass<F>, ...finders);
  }




  has<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): boolean;
  has(...finders: ElementFinder<GameElement>[]): boolean;
  has<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): boolean {
    const collection = new ElementCollection(...this._t.children);
    return collection.has(classNameOrFinder as ElementClass<F>, ...finders);
  }




  count<F extends GameElement>(
    className: ElementClass<F>,
    ...finders: ElementFinder<F>[]
  ): number;
  count(...finders: ElementFinder<GameElement>[]): number;
  count<F extends GameElement>(
    classNameOrFinder?: ElementClass<F> | ElementFinder<F>,
    ...finders: ElementFinder<F>[]
  ): number {
    return this.all(classNameOrFinder as ElementClass<F>, ...finders).length;
  }








  getEffectiveVisibility(): VisibilityState {

    if (this._visibility?.explicit) {
      return this._visibility;
    }

    return resolveVisibility(this._visibility, this.getParentZoneVisibility());
  }




  protected getParentZoneVisibility(): VisibilityState | undefined {

    const parent = this._t.parent;
    if (!parent) return undefined;


    if ('getZoneVisibility' in parent && typeof parent.getZoneVisibility === 'function') {
      const zoneVis = (parent as any).getZoneVisibility();
      if (zoneVis) return zoneVis;
    }


    return parent.getParentZoneVisibility?.();
  }




  isVisibleTo(player: Player | number): boolean {
    const position = typeof player === 'number' ? player : player.position;
    const visibility = this.getEffectiveVisibility();


    const ownerPosition = this.getEffectiveOwner()?.position;
    return canPlayerSee(visibility, position, ownerPosition);
  }





  getEffectiveOwner(): Player | undefined {
    if (this.player) return this.player;
    return this._t.parent?.getEffectiveOwner();
  }




  isVisible(): boolean {
    if (!this._ctx.player) return true;
    return this.isVisibleTo(this._ctx.player);
  }




  setVisibilityInternal(visibility: VisibilityState): void {
    this._visibility = visibility;
  }




  addVisibleToInternal(players: number[]): void {
    if (!this._visibility) {
      this._visibility = { ...DEFAULT_VISIBILITY, explicit: true };
    }
    this._visibility.addPlayers = Array.from(
      new Set([...(this._visibility.addPlayers ?? []), ...players])
    );
  }








  toJSON(): ElementJSON {
    const className = this.constructor.name;
    const unserializable = new Set(
      (this.constructor as typeof GameElement).unserializableAttributes
    );


    const attributes: Record<string, unknown> = {};
    for (const key of Object.keys(this)) {
      if (!unserializable.has(key) && !key.startsWith('_')) {
        const value = (this as Record<string, unknown>)[key];
        if (value !== undefined) {
          attributes[key] = this.serializeValue(value);
        }
      }
    }

    const json: ElementJSON = {
      className,
      id: this._t.id,
      attributes,
    };

    if (this.name) {
      json.name = this.name;
    }


    if (this._visibility?.explicit) {
      json.visibility = this._visibility;
    }

    if (this._t.children.length > 0) {
      json.children = this._t.children.map((child) => child.toJSON());
    }

    return json;
  }




  protected serializeValue(value: unknown): unknown {
    if (value instanceof GameElement) {

      return { __elementRef: value.branch() };
    }
    if (Array.isArray(value)) {
      return value.map((v) => this.serializeValue(v));
    }
    if (value && typeof value === 'object') {
      const result: Record<string, unknown> = {};
      for (const [k, v] of Object.entries(value)) {
        result[k] = this.serializeValue(v);
      }
      return result;
    }
    return value;
  }




  static fromJSON<T extends GameElement>(
    json: ElementJSON,
    ctx: ElementContext,
    classRegistry: Map<string, ElementClass>
  ): T {
    const ElementClass = classRegistry.get(json.className);
    if (!ElementClass) {
      throw new Error(`Unknown element class: ${json.className}`);
    }

    const element = new ElementClass(ctx);
    element._t.id = json.id;

    if (json.name) {
      element.name = json.name;
    }


    if (json.visibility) {
      element._visibility = json.visibility;
    }


    for (const [key, value] of Object.entries(json.attributes)) {
      (element as unknown as Record<string, unknown>)[key] = value;
    }


    if (json.children) {
      for (const childJson of json.children) {
        const child = GameElement.fromJSON(childJson, ctx, classRegistry);
        child._t.parent = element;
        element._t.children.push(child);
      }
    }

    return element as T;
  }








  get id(): number {
    return this._t.id;
  }
}
````

## File: packages/engine/src/element/hand.ts
````typescript
import { Space } from './space.js';
import type { ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';



















export class Hand<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'hand';

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'hand';


    this.$direction = 'horizontal';
    this.$fan = true;
    this.$fanAngle = 30;
    this.$overlap = 0.5;
    this.$align = 'center';
  }
}
````

## File: packages/engine/src/element/space.ts
````typescript
import { GameElement } from './game-element.js';
import type { ElementClass, ElementAttributes, ElementContext } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';
import type { VisibilityMode, VisibilityState } from '../command/visibility.js';
import { visibilityFromMode } from '../command/visibility.js';




export type ElementEventHandler<T extends GameElement> = {
  callback: (element: T) => void;
  elementClass?: ElementClass;
};




export type LayoutDirection = 'horizontal' | 'vertical';




export type LayoutAlignment = 'start' | 'center' | 'end' | 'stretch';















export class Space<G extends Game = any, P extends Player = any> extends GameElement<G, P> {








  $direction?: LayoutDirection;




  $gap?: string;





  $overlap?: number;





  $fan?: boolean;





  $fanAngle?: number;





  $align?: LayoutAlignment;






  private _eventHandlers: {
    enter: ElementEventHandler<GameElement>[];
    exit: ElementEventHandler<GameElement>[];
  } = { enter: [], exit: [] };


  private _zoneVisibility?: VisibilityState;

  static override unserializableAttributes = [
    ...GameElement.unserializableAttributes,
    '_eventHandlers',
    '_zoneVisibility',
  ];

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);
  }









  setZoneVisibility(mode: VisibilityMode): void {
    this._zoneVisibility = visibilityFromMode(mode);
  }




  getZoneVisibility(): VisibilityState | undefined {
    return this._zoneVisibility;
  }




  contentsVisible(): void {
    this.setZoneVisibility('all');
  }




  contentsVisibleToOwner(): void {
    this.setZoneVisibility('owner');
  }




  contentsHidden(): void {
    this.setZoneVisibility('hidden');
  }




  contentsCountOnly(): void {
    this.setZoneVisibility('count-only');
  }




  addZoneVisibleTo(...players: (P | number)[]): void {
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    if (!this._zoneVisibility) {
      this._zoneVisibility = { mode: 'all', explicit: true };
    }
    this._zoneVisibility.addPlayers = Array.from(
      new Set([...(this._zoneVisibility.addPlayers ?? []), ...positions])
    );
  }




  hideContentsFrom(...players: (P | number)[]): void {
    if (!this._zoneVisibility) {
      this._zoneVisibility = { mode: 'all', explicit: true };
    }
    const positions = players.map((p) => (typeof p === 'number' ? p : p.position));
    this._zoneVisibility.exceptPlayers = Array.from(
      new Set([...(this._zoneVisibility.exceptPlayers ?? []), ...positions])
    );
  }








  onEnter<T extends GameElement>(
    callback: (element: T) => void,
    elementClass?: ElementClass<T>
  ): void {
    this._eventHandlers.enter.push({ callback: callback as (element: GameElement) => void, elementClass });
  }




  onExit<T extends GameElement>(
    callback: (element: T) => void,
    elementClass?: ElementClass<T>
  ): void {
    this._eventHandlers.exit.push({ callback: callback as (element: GameElement) => void, elementClass });
  }




  triggerEvent(type: 'enter' | 'exit', element: GameElement): void {
    for (const handler of this._eventHandlers[type]) {
      if (!handler.elementClass || element instanceof handler.elementClass) {
        handler.callback(element);
      }
    }
  }





  override create<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string,
    attributes?: ElementAttributes<T>
  ): T {
    const element = super.create(elementClass, name, attributes);


    this.triggerEvent('enter', element);

    return element;
  }








  shuffle(): void {
    this.shuffleInternal();
  }




  shuffleInternal(): void {
    const random = this._ctx.random ?? Math.random;


    for (let i = this._t.children.length - 1; i > 0; i--) {
      const j = Math.floor(random() * (i + 1));
      [this._t.children[i], this._t.children[j]] = [
        this._t.children[j],
        this._t.children[i],
      ];
    }
  }








  isSpace(): boolean {
    return true;
  }
}
````

## File: packages/engine/src/element/types.ts
````typescript
import type { GameElement } from './game-element.js';
import type { Game } from './game.js';
import type { Player } from '../player/player.js';
import type { VisibilityState } from '../command/visibility.js';






export type ImageRef =
  | string
  | {

      sprite: string;

      x: number;

      y: number;

      width: number;

      height: number;
    };




export type ElementClass<T extends GameElement = GameElement> = {
  new (ctx: Partial<ElementContext>): T;
  isGameElement: boolean;
};




export type ElementContext = {

  game: Game;

  sequence: number;

  player?: Player;

  classRegistry: Map<string, ElementClass>;

  random: () => number;
};




export type ElementTree<T extends GameElement = GameElement> = {

  children: T[];

  parent?: GameElement;

  id: number;

  order: 'normal' | 'stacking';
};




export type ElementJSON = {
  className: string;
  id: number;
  name?: string;
  attributes: Record<string, unknown>;
  visibility?: VisibilityState;
  children?: ElementJSON[];

  childCount?: number;
};







export type ElementFinder<T extends GameElement = GameElement> =
  | string
  | ((element: T) => boolean)
  | Partial<Record<string, unknown> & { mine?: boolean; empty?: boolean }>;




export type Sorter<T> = keyof T | ((element: T) => number | string);




export type ElementAttributes<T extends GameElement> = Partial<
  Pick<
    T,
    {
      [K in keyof T]: K extends keyof GameElement
        ? never
        : T[K] extends (...args: unknown[]) => unknown
          ? never
          : K;
    }[keyof T]
  > & {
    name?: string;
    player?: Player;
    row?: number;
    column?: number;
  }
>;
````

## File: packages/engine/src/flow/builders.ts
````typescript
import type { Player } from '../player/player.js';
import type {
  FlowNode,
  FlowContext,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  FlowDefinition,
  PhaseConfig,
} from './types.js';












export function sequence(...steps: FlowNode[]): FlowNode {
  return {
    type: 'sequence',
    config: { steps },
  };
}




export function namedSequence(name: string, ...steps: FlowNode[]): FlowNode {
  return {
    type: 'sequence',
    config: { name, steps },
  };
}























export function phase(name: string, config: { do: FlowNode }): FlowNode {
  return {
    type: 'phase',
    config: {
      name,
      do: config.do,
    },
  };
}












export function loop(config: {
  name?: string;
  while?: (context: FlowContext) => boolean;
  maxIterations?: number;
  do: FlowNode;
}): FlowNode {
  return {
    type: 'loop',
    config: {
      name: config.name,
      while: config.while,
      maxIterations: config.maxIterations,
      do: config.do,
    },
  };
}









export function repeat(times: number, body: FlowNode): FlowNode {
  let count = 0;
  return loop({
    while: () => {
      count++;
      return count <= times;
    },
    maxIterations: times,
    do: body,
  });
}











export function eachPlayer(config: {
  name?: string;
  filter?: (player: Player, context: FlowContext) => boolean;
  direction?: 'forward' | 'backward';
  startingPlayer?: (context: FlowContext) => Player;
  do: FlowNode;
}): FlowNode {
  return {
    type: 'each-player',
    config: {
      name: config.name,
      filter: config.filter,
      direction: config.direction,
      startingPlayer: config.startingPlayer,
      do: config.do,
    },
  };
}













export function forEach<T>(config: {
  name?: string;
  collection: T[] | ((context: FlowContext) => T[]);
  as: string;
  do: FlowNode;
}): FlowNode {
  return {
    type: 'for-each',
    config: {
      name: config.name,
      collection: config.collection as unknown[] | ((context: FlowContext) => unknown[]),
      as: config.as,
      do: config.do,
    },
  };
}






















export function actionStep(config: {
  name?: string;
  player?: (context: FlowContext) => Player;
  actions: string[] | ((context: FlowContext) => string[]);
  prompt?: string | ((context: FlowContext) => string);
  repeatUntil?: (context: FlowContext) => boolean;
  skipIf?: (context: FlowContext) => boolean;
  timeout?: number;
  minMoves?: number;
  maxMoves?: number;
}): FlowNode {
  return {
    type: 'action-step',
    config: {
      name: config.name,
      player: config.player,
      actions: config.actions,
      prompt: config.prompt,
      repeatUntil: config.repeatUntil,
      skipIf: config.skipIf,
      timeout: config.timeout,
      minMoves: config.minMoves,
      maxMoves: config.maxMoves,
    },
  };
}












export function playerActions(config: {
  name?: string;
  actions: string[] | ((context: FlowContext) => string[]);
  prompt?: string | ((context: FlowContext) => string);
  repeatUntil?: (context: FlowContext) => boolean;
  skipIf?: (context: FlowContext) => boolean;
}): FlowNode {
  return actionStep({
    name: config.name,
    actions: config.actions,
    prompt: config.prompt,
    repeatUntil: config.repeatUntil,
    skipIf: config.skipIf,
  });
}
















export function simultaneousActionStep(config: {
  name?: string;
  players?: (context: FlowContext) => Player[];
  actions: string[] | ((context: FlowContext, player: Player) => string[]);
  prompt?: string | ((context: FlowContext) => string);
  playerDone?: (context: FlowContext, player: Player) => boolean;
  allDone?: (context: FlowContext) => boolean;
  skipPlayer?: (context: FlowContext, player: Player) => boolean;
  timeout?: number;
}): FlowNode {
  return {
    type: 'simultaneous-action-step',
    config: {
      name: config.name,
      players: config.players,
      actions: config.actions,
      prompt: config.prompt,
      playerDone: config.playerDone,
      allDone: config.allDone,
      skipPlayer: config.skipPlayer,
      timeout: config.timeout,
    },
  };
}
















export function switchOn(config: {
  name?: string;
  on: (context: FlowContext) => unknown;
  cases: Record<string, FlowNode>;
  default?: FlowNode;
}): FlowNode {
  return {
    type: 'switch',
    config: {
      name: config.name,
      on: config.on,
      cases: config.cases,
      default: config.default,
    },
  };
}













export function ifThen(config: {
  name?: string;
  condition: (context: FlowContext) => boolean;
  then: FlowNode;
  else?: FlowNode;
}): FlowNode {
  return {
    type: 'if',
    config: {
      name: config.name,
      condition: config.condition,
      then: config.then,
      else: config.else,
    },
  };
}





































export function defineFlow(config: {
  setup?: (context: FlowContext) => void;
  root: FlowNode;
  isComplete?: (context: FlowContext) => boolean;
  getWinners?: (context: FlowContext) => Player[];
  onEnterPhase?: (phaseName: string, context: FlowContext) => void;
  onExitPhase?: (phaseName: string, context: FlowContext) => void;
}): FlowDefinition {
  return {
    setup: config.setup,
    root: config.root,
    isComplete: config.isComplete,
    getWinners: config.getWinners,
    onEnterPhase: config.onEnterPhase,
    onExitPhase: config.onExitPhase,
  };
}




export function noop(): FlowNode {
  return sequence();
}












export function execute(fn: (context: FlowContext) => void): FlowNode {
  return {
    type: 'execute',
    config: { fn },
  };
}









export function setVar(
  name: string,
  value: unknown | ((context: FlowContext) => unknown)
): FlowNode {
  return execute((ctx) => {
    const resolvedValue = typeof value === 'function' ? (value as Function)(ctx) : value;
    ctx.set(name, resolvedValue);
  });
}
````

## File: packages/engine/src/player/index.ts
````typescript
export { Player, PlayerCollection } from './player.js';

export {
  AbilityManager,
  createAbilityDisplayMap,
} from './abilities.js';

export type {
  Ability,
  AbilityDisplayInfo,
} from './abilities.js';
````

## File: packages/engine/src/utils/serializer.ts
````typescript
import type { Game } from '../element/game.js';
import type { GameElement } from '../element/game-element.js';
import type { Player } from '../player/player.js';
import type { SerializedAction } from '../action/types.js';




export type SerializedReference =
  | { __elementRef: string }
  | { __elementId: number }
  | { __playerRef: number };




export interface SerializeOptions {

  useBranchPaths?: boolean;
}






export function serializeValue(
  value: unknown,
  game: Game,
  options: SerializeOptions = {}
): unknown {
  if (value === null || value === undefined) {
    return value;
  }


  if (value instanceof Object && 'branch' in value && typeof (value as GameElement).branch === 'function') {
    const element = value as GameElement;
    if (options.useBranchPaths) {
      return { __elementRef: element.branch() };
    }
    return { __elementId: element.id };
  }


  if (value instanceof Object && 'position' in value && typeof (value as Player).position === 'number') {
    const player = value as Player;
    return { __playerRef: player.position };
  }


  if (Array.isArray(value)) {
    return value.map(item => serializeValue(item, game, options));
  }


  if (typeof value === 'object' && value !== null) {
    const result: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      result[key] = serializeValue(val, game, options);
    }
    return result;
  }


  return value;
}






export function deserializeValue(
  value: unknown,
  game: Game
): unknown {
  if (value === null || value === undefined) {
    return value;
  }


  if (typeof value === 'object' && value !== null && '__elementRef' in value) {
    const ref = value as { __elementRef: string };
    return game.atBranch(ref.__elementRef);
  }


  if (typeof value === 'object' && value !== null && '__elementId' in value) {
    const ref = value as { __elementId: number };
    return game.first({ id: ref.__elementId } as Record<string, unknown>);
  }


  if (typeof value === 'object' && value !== null && '__playerRef' in value) {
    const ref = value as { __playerRef: number };
    return game.players[ref.__playerRef];
  }


  if (Array.isArray(value)) {
    return value.map(item => deserializeValue(item, game));
  }


  if (typeof value === 'object' && value !== null) {
    const result: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      result[key] = deserializeValue(val, game);
    }
    return result;
  }


  return value;
}




export function serializeAction(
  actionName: string,
  player: Player,
  args: Record<string, unknown>,
  game: Game,
  options: SerializeOptions = {},
  undoable?: boolean
): SerializedAction {
  const serialized: SerializedAction = {
    name: actionName,
    player: player.position,
    args: serializeValue(args, game, options) as Record<string, unknown>,
    timestamp: Date.now(),
  };


  if (undoable === false) {
    serialized.undoable = false;
  }

  return serialized;
}




export function deserializeAction(
  serialized: SerializedAction,
  game: Game
): { actionName: string; player: Player; args: Record<string, unknown> } {
  const player = game.players[serialized.player];
  if (!player) {
    throw new Error(`Player ${serialized.player} not found`);
  }

  return {
    actionName: serialized.name,
    player,
    args: deserializeValue(serialized.args, game) as Record<string, unknown>,
  };
}




export function isSerializedReference(value: unknown): value is SerializedReference {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  return '__elementRef' in value || '__elementId' in value || '__playerRef' in value;
}
````

## File: packages/runtime/src/runner.ts
````typescript
import {
  serializeAction,
  deserializeAction,
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
  type Game,
  type GameOptions,
  type Player,
  type SerializedAction,
  type ActionResult,
  type FlowState,
  type SerializeOptions,
  type GameStateSnapshot,
  type PlayerStateView,
} from '@boardsmith/engine';




export interface GameRunnerOptions<G extends Game> {

  GameClass: new (options: GameOptions) => G;

  gameType: string;

  gameOptions: GameOptions;

  serializeOptions?: SerializeOptions;
}




export interface ActionExecutionResult {

  success: boolean;

  error?: string;

  serializedAction?: SerializedAction;

  flowState?: FlowState;

  playerViews?: PlayerStateView[];
}





export class GameRunner<G extends Game = Game> {

  readonly game: G;


  readonly gameType: string;


  readonly actionHistory: SerializedAction[] = [];


  readonly seed?: string;


  private readonly serializeOptions: SerializeOptions;

  constructor(options: GameRunnerOptions<G>) {
    this.gameType = options.gameType;
    this.seed = options.gameOptions.seed;
    this.serializeOptions = options.serializeOptions ?? { useBranchPaths: true };

    this.game = new options.GameClass(options.gameOptions);
  }




  start(): FlowState {
    return this.game.startFlow();
  }




  performAction(
    actionName: string,
    player: Player | number,
    args: Record<string, unknown>
  ): ActionExecutionResult {
    const playerObj = typeof player === 'number'
      ? this.game.players[player]
      : player;

    if (!playerObj) {
      return {
        success: false,
        error: `Player not found`,
      };
    }

    const playerIndex = playerObj.position;


    if (!this.game.isAwaitingInput()) {
      return {
        success: false,
        error: 'Game is not awaiting input',
      };
    }


    if (!this.game.canPlayerAct(playerIndex)) {
      return {
        success: false,
        error: `Not ${playerObj.name}'s turn`,
      };
    }


    const actionDef = (this.game as any)._actions?.get(actionName);
    const isUndoable = actionDef?.undoable;


    const serializedAction = serializeAction(
      actionName,
      playerObj,
      args,
      this.game,
      this.serializeOptions,
      isUndoable
    );


    let flowState: FlowState;
    try {
      flowState = this.game.continueFlow(actionName, args, playerIndex);
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }


    this.actionHistory.push(serializedAction);

    return {
      success: true,
      serializedAction,
      flowState,
      playerViews: createAllPlayerViews(this.game),
    };
  }




  getFlowState(): FlowState | undefined {
    return this.game.getFlowState() ?? undefined;
  }




  getSnapshot(): GameStateSnapshot {
    return createSnapshot(
      this.game,
      this.gameType,
      this.actionHistory,
      this.seed
    );
  }




  getPlayerView(playerPosition: number): PlayerStateView {
    return createPlayerView(this.game, playerPosition);
  }




  getAllPlayerViews(): PlayerStateView[] {
    return createAllPlayerViews(this.game);
  }




  isComplete(): boolean {
    return this.game.getFlowState()?.complete ?? false;
  }




  getWinners(): Player[] {
    return this.game.getWinners();
  }




  static replay<G extends Game>(
    options: GameRunnerOptions<G>,
    actions: SerializedAction[]
  ): GameRunner<G> {
    const runner = new GameRunner(options);
    runner.start();

    for (const action of actions) {
      const { actionName, player, args } = deserializeAction(action, runner.game);
      const result = runner.performAction(actionName, player, args);

      if (!result.success) {
        throw new Error(`Replay failed at action ${action.name}: ${result.error}`);
      }
    }

    return runner;
  }





  static fromSnapshot<G extends Game>(
    snapshot: GameStateSnapshot,
    GameClass: new (options: GameOptions) => G
  ): GameRunner<G> {
    const runner = new GameRunner({
      GameClass,
      gameType: snapshot.gameType,
      gameOptions: {
        playerCount: snapshot.state.players.length,
        playerNames: snapshot.state.players.map(p => p.name as string),
        seed: snapshot.seed,
      },
    });


    runner.game.replayCommands(snapshot.commandHistory);


    runner.actionHistory.push(...snapshot.actionHistory);


    runner.start();
    for (const action of snapshot.actionHistory) {
      const { actionName, args } = deserializeAction(action, runner.game);
      runner.game.continueFlow(actionName, args);
    }

    return runner;
  }
}
````

## File: docs/llm-overview.md
````markdown
# BoardSmith LLM Overview

This document provides a comprehensive overview of the BoardSmith framework optimized for LLM consumption. Use this to quickly understand the project architecture and key patterns.

## What is BoardSmith?

BoardSmith is a TypeScript framework for building turn-based multiplayer board and card games. It provides:

- **Element-based state management** - Games are trees of typed elements (Board, Deck, Hand, Piece, Card)
- **Declarative flow system** - Define game structure with composable flow nodes
- **Action builder API** - Fluent API for defining player actions with selections and validation
- **Event-sourced commands** - All state mutations are tracked and replayable
- **Automatic UI generation** - AutoUI can render any game without custom components
- **MCTS AI** - Game-agnostic AI opponents using Monte-Carlo Tree Search
- **Multiplayer networking** - WebSocket-based real-time game sessions

## Project Structure

```
BoardSmith/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ engine/       # Core framework (~15k lines)
â”‚   â”œâ”€â”€ runtime/      # Game execution
â”‚   â”œâ”€â”€ session/      # Session management
â”‚   â”œâ”€â”€ ai/           # MCTS bot (~700 lines)
â”‚   â”œâ”€â”€ ui/           # Vue 3 components (~15k lines)
â”‚   â”œâ”€â”€ client/       # Browser networking
â”‚   â”œâ”€â”€ server/       # Platform-agnostic server
â”‚   â”œâ”€â”€ worker/       # Cloudflare Workers runtime
â”‚   â”œâ”€â”€ cli/          # Dev tools
â”‚   â”œâ”€â”€ testing/      # Test utilities
â”‚   â””â”€â”€ games/        # Example games
â”‚       â”œâ”€â”€ hex/      # Simplest example
â”‚       â”œâ”€â”€ go-fish/  # Card game patterns
â”‚       â”œâ”€â”€ checkers/ # Grid + multi-step
â”‚       â””â”€â”€ cribbage/ # Complex multi-phase
â””â”€â”€ docs/             # Documentation
```

## Key Concepts

### 1. Element Tree

Games are represented as a tree of `GameElement` objects:

```
Game (root)
â”œâ”€â”€ Board (Space)
â”‚   â””â”€â”€ Cell (Space) â†’ Piece
â”œâ”€â”€ Deck (Space) â†’ Card, Card, ...
â”œâ”€â”€ Hand (Space) â†’ Card (owner sees)
â””â”€â”€ Pile (removed elements)
```

**Element types**: `Space` (container), `Deck`, `Hand`, `Grid`, `HexGrid`, `Piece`, `Card`

### 2. Actions vs Commands

**Actions** = What players do (high-level, game-specific)
```typescript
Action.create('move')
  .chooseElement('piece', { filter: p => p.player === ctx.player })
  .chooseElement('dest', { filter: c => c.isEmpty() })
  .execute((args) => args.piece.putInto(args.dest));
```

**Commands** = How state changes (low-level, generic, event-sourced)
```typescript
// Generated automatically by element methods
{ type: 'move', elementId: 42, targetId: 17 }
```

### 3. Flow System

Declarative game flow with composable nodes:

```typescript
const flow: FlowDefinition = {
  root: loop({
    while: () => !game.isFinished(),
    do: eachPlayer({
      do: actionStep({ actions: ['move'] }),
    }),
  }),
  isComplete: () => game.isFinished(),
  getWinners: () => game.getWinners(),
};
```

**Flow nodes**: `sequence`, `loop`, `repeat`, `eachPlayer`, `forEach`, `actionStep`, `simultaneousActionStep`, `phase`, `switchOn`, `ifThen`, `execute`, `setVar`

### 4. Visibility System

Control what players can see:

```typescript
deck.contentsHidden();           // Hidden from all
hand.contentsVisibleToOwner();   // Only owner sees
board.contentsVisible();         // Everyone sees
```

## Creating a Game

### 1. Initialize Project

```bash
npx boardsmith init my-game
cd my-game
npm install
boardsmith dev
```

### 2. Define Elements

```typescript
// elements.ts
export class Card extends BaseCard {
  suit!: 'H' | 'D' | 'C' | 'S';
  rank!: string;
}
export class Hand extends BaseHand {}
export class Deck extends BaseDeck {}
```

### 3. Define Actions

```typescript
// actions.ts
export function createPlayAction(game: MyGame): ActionDefinition {
  return Action.create('play')
    .chooseFrom<Card>('card', {
      choices: (ctx) => [...ctx.player.hand.all(Card)],
    })
    .execute((args) => {
      const card = args.card as Card;
      card.remove();
      ctx.player.score += 1;
    });
}
```

### 4. Define Flow

```typescript
// flow.ts
export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: actionStep({ actions: ['play'] }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### 5. Game Class

```typescript
// game.ts
export class MyGame extends Game<MyGame, MyPlayer> {
  deck!: Deck;

  constructor(options: MyGameOptions) {
    super(options);
    this.registerElements([Card, Hand, Deck]);
    this.deck = this.create(Deck, 'deck');
    // ... setup ...
    this.registerAction(createPlayAction(this));
    this.setFlow(createGameFlow(this));
  }

  override isFinished(): boolean {
    return this.deck.count(Card) === 0;
  }
}
```

## Common Patterns

### Conditional Turns (Go Again)

```typescript
.execute((args, ctx) => {
  if (gotMatch) {
    return { success: true, data: { extraTurn: true } };
  }
  return { success: true, data: { extraTurn: false } };
});

// In flow
execute((ctx) => {
  if (!ctx.lastActionResult?.data?.extraTurn) {
    ctx.set('turnEnded', true);
  }
})
```

### Multi-Step Actions (Jump Chains)

```typescript
.execute((args, ctx) => {
  if (canContinueJumping) {
    game.pendingJumpPiece = piece;
    game.setPlayerGoesAgain(true);
  }
});
```

### Simultaneous Actions

```typescript
simultaneousActionStep({
  actions: ['discard'],
  playerDone: (ctx, player) => player.hand.count(Card) <= 4,
  allDone: (ctx) => game.allPlayersDiscarded(),
})
```

### Phase-Based Games

```typescript
sequence(
  phase('deal', { do: execute(() => game.deal()) }),
  phase('discard', { do: simultaneousActionStep({ actions: ['discard'] }) }),
  phase('play', { do: playLoop }),
  phase('score', { do: execute(() => game.score()) }),
)
```

## UI Components

**Core**: `GameShell`, `DebugPanel`, `PlayersPanel`, `GameHistory`

**Helpers**: `Draggable`, `DiceRoller`, `CardFan`, `DeckPile`, `FlyingCardsOverlay`

**Auto-UI**: `AutoUI`, `AutoGameBoard`, `AutoElement`, `ActionPanel`

**Composables**:
- `useBoardInteraction` - Board â†” ActionPanel communication
- `useElementAnimation` - FLIP animations
- `useCardFlip`, `useFlyingCards` - Card animations
- `useGameViewHelpers` - Query game state
- `useGameGrid`, `useHexGrid` - Grid utilities
- `useCardDisplay` - Card formatting

## Dice & Scoring Systems

### Dice Elements

```typescript
// Die extends Piece with sides/value
class MyDie extends Die<MyGame, MyPlayer> {
  color?: 'red' | 'blue';
}

// DicePool is a Space for holding dice
this.shelf = this.create(DicePool, 'shelf');
this.shelf.create(MyDie, 'd6-1', { sides: 6 });
```

### Ability System

```typescript
import { AbilityManager } from '@boardsmith/engine';

type PowerUp = 'reroll' | 'flip' | 'bonus';

class MyPlayer extends Player<MyGame, MyPlayer> {
  abilities = new AbilityManager<PowerUp>();

  constructor() {
    this.abilities.add('reroll', 'starting');
  }
}

// Usage
if (player.abilities.hasUnused('reroll')) {
  player.abilities.use('reroll');
}
```

### Scoring Tracks

```typescript
import { MonotonicTrack, UniqueTrack, CounterTrack } from '@boardsmith/engine';

// Increasing/decreasing sequence tracks
const track = new MonotonicTrack({
  id: 'score',
  direction: 'increasing',  // or 'decreasing'
  maxEntries: 10,
  pointsPerEntry: [0, 1, 3, 6, 11, 16, 23, 30, 40, 50],
});

track.canAdd(15);   // Check if value fits sequence
track.add(15);      // Add value, returns points earned

// Simple counter tracks
const counter = new CounterTrack({
  id: 'bonus',
  maxEntries: 6,
  pointsPerCount: 10,
});

counter.increment();
counter.calculatePoints();  // Returns total points
```

## AI System

```typescript
import { createBot } from '@boardsmith/ai';

const bot = createBot(game, MyGame, 'my-game', 1, [], 'hard');
const move = await bot.play();
```

**Difficulty levels**: `easy` (3 iter), `medium` (5 iter), `hard` (8 iter)

**Custom objectives** for better play:
```typescript
const aiConfig = {
  objectives: (game, playerIndex) => ({
    materialAdvantage: {
      checker: (g, p) => myPieces > oppPieces,
      weight: 0.5,
    },
  }),
};
```

## CLI Commands

```bash
boardsmith init <name>    # Create new game
boardsmith dev            # Start dev server
boardsmith dev --ai 1     # Player 1 is AI
boardsmith test           # Run tests
boardsmith validate       # Validate before publish
boardsmith build          # Production build
boardsmith publish        # Publish to boardsmith.io
```

## Example Games Reference

| Game | File | Key Patterns |
|------|------|--------------|
| Hex | `packages/games/hex/rules/src/` | Simple flow, hex grid, single action |
| Go Fish | `packages/games/go-fish/rules/src/` | Cards, hidden info, conditional turns |
| Checkers | `packages/games/checkers/rules/src/` | Grid, multi-step jumps, promotion |
| Cribbage | `packages/games/cribbage/rules/src/` | Multi-phase, simultaneous, scoring |
| Polyhedral Potions | `packages/games/polyhedral-potions/rules/src/` | Dice, 3D rendering, abilities, scoring tracks |

## Key Files to Understand

1. **Engine core**: `packages/engine/src/`
   - `game.ts` - Game base class
   - `element/` - Element system
   - `action/` - Action builder
   - `flow/` - Flow system
   - `command/` - Command types

2. **Example game**: `packages/games/hex/rules/src/`
   - `game.ts` - Minimal game class
   - `elements.ts` - Custom elements
   - `actions.ts` - Action definitions
   - `flow.ts` - Simple flow

3. **UI**: `packages/ui/src/`
   - `components/GameShell.vue` - Main wrapper
   - `composables/` - Reusable logic

## Architecture Summary

```
User Action â†’ Action System â†’ Commands â†’ State Change
                â†‘                           â†“
            Flow System â†â”€â”€â”€â”€â”€â”€â”€â”€ Game State â†â”€â”€ Serialization
                                     â†“
                              Player Views â†’ UI Render
```

- **Actions** validate and execute player intent
- **Commands** are event-sourced state mutations
- **Flow** controls game structure and turn order
- **State** is an element tree, serializable to JSON
- **Player Views** filter state by visibility rules
- **UI** renders views and submits actions

## Common Pitfalls

### Custom Player Properties Not Showing in UI

If your custom Player class has properties (score, abilities, etc.) that aren't appearing in the UI, you need to override `toJSON()`:

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  score: number = 0;
  abilities: Record<string, number> = { reroll: 1 };

  // REQUIRED: Include custom properties in serialization
  override toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      score: this.score,
      abilities: this.abilities,
    };
  }
}
```

The base `Player.toJSON()` only serializes `position`, `name`, `color`, `avatar`.

### PlayerCollection Array Subclass Gotcha

`game.players` is a `PlayerCollection` (Array subclass). When mapping player data, **always spread to a plain Array**:

```typescript
// âŒ WRONG: map() returns PlayerCollection, which has its own toJSON()
const data = game.players.map(p => p.toJSON());

// âœ… CORRECT: Spread converts to plain Array
const data = [...game.players.map(p => p.toJSON())];
```

This is because JavaScript's `.map()` on an Array subclass returns an instance of the same subclass, and `PlayerCollection.toJSON()` will re-serialize the data, losing custom properties.

### chooseElement Args Are Objects, Not IDs

When using `chooseElement` in actions, the args passed to `execute()` contain the **full serialized element object**, not just the element ID:

```typescript
// âŒ WRONG: args.die is an object, not a number
.chooseElement<Die>('die', { ... })
.execute((args, ctx) => {
  const dieId = args.die as number;  // This is actually an object!
  const die = game.all(Die).find(d => d.id === dieId);  // Never finds it
});

// âœ… CORRECT: Extract the ID from the object
.execute((args, ctx) => {
  const dieId = typeof args.die === 'object' ? (args.die as any).id : args.die as number;
  const die = game.all(Die).find(d => d.id === dieId);
});
```

The args object looks like: `{ die: { className: "Die", id: 3, attributes: {...} } }`

### Action Closures and ctx.game

In action execute functions, always use `ctx.game` instead of a closure reference to the game:

```typescript
// âŒ WRONG: Closure reference can become stale
export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('myAction')
    .execute((args, ctx) => {
      game.doSomething();  // Uses closure - may be stale after hot-reload
    });
}

// âœ… CORRECT: Use ctx.game for the current game instance
export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('myAction')
    .execute((args, ctx) => {
      const currentGame = ctx.game as MyGame;
      currentGame.doSomething();  // Always uses current game
    });
}
```
````

## File: packages/engine/src/action/index.ts
````typescript
export { Action, ActionExecutor } from './action.js';
export type {
  SelectionType,
  Selection,
  BaseSelection,
  ChoiceSelection,
  PlayerSelection,
  ElementSelection,
  TextSelection,
  NumberSelection,
  ActionContext,
  ActionDefinition,
  ActionResult,
  SerializedAction,
  ValidationResult,
  BoardElementRef,
  ChoiceBoardRefs,
  DependentFilter,
} from './types.js';
````

## File: packages/engine/src/action/action.ts
````typescript
import type { GameElement } from '../element/game-element.js';
import type { Player } from '../player/player.js';
import type { Game } from '../element/game.js';
import type {
  ActionDefinition,
  ActionContext,
  ActionResult,
  Selection,
  ChoiceSelection,
  PlayerSelection,
  ElementSelection,
  TextSelection,
  NumberSelection,
  ValidationResult,
  ChoiceBoardRefs,
  DependentFilter,
  BoardElementRef,
} from './types.js';
import type { ElementClass } from '../element/types.js';



























export class Action {
  private definition: ActionDefinition;

  private constructor(name: string) {
    this.definition = {
      name,
      selections: [],
      execute: () => {},
    };
  }




  static create(name: string): Action {
    return new Action(name);
  }




  prompt(prompt: string): this {
    this.definition.prompt = prompt;
    return this;
  }




  condition(fn: (context: ActionContext) => boolean): this {
    this.definition.condition = fn;
    return this;
  }






  notUndoable(): this {
    this.definition.undoable = false;
    return this;
  }




  chooseFrom<T>(
    name: string,
    options: {
      prompt?: string;
      choices: T[] | ((context: ActionContext) => T[]);
      display?: (choice: T) => string;
      skipIfOnlyOne?: boolean;
      optional?: boolean;
      validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;

      boardRefs?: (choice: T, context: ActionContext) => ChoiceBoardRefs;

      filterBy?: DependentFilter;
    }
  ): this {
    const selection: ChoiceSelection<T> = {
      type: 'choice',
      name,
      prompt: options.prompt,
      choices: options.choices,
      display: options.display,
      skipIfOnlyOne: options.skipIfOnlyOne,
      optional: options.optional,
      validate: options.validate,
      boardRefs: options.boardRefs,
      filterBy: options.filterBy,
    };
    this.definition.selections.push(selection as Selection);
    return this;
  }




  choosePlayer(
    name: string,
    options: {
      prompt?: string;
      filter?: (player: Player, context: ActionContext) => boolean;
      skipIfOnlyOne?: boolean;
      optional?: boolean;
      validate?: (value: Player, args: Record<string, unknown>, context: ActionContext) => boolean | string;
      boardRefs?: (player: Player, context: ActionContext) => ChoiceBoardRefs;
    } = {}
  ): this {
    const selection: PlayerSelection = {
      type: 'player',
      name,
      prompt: options.prompt,
      filter: options.filter,
      skipIfOnlyOne: options.skipIfOnlyOne,
      optional: options.optional,
      validate: options.validate,
      boardRefs: options.boardRefs,
    };
    this.definition.selections.push(selection);
    return this;
  }




  chooseElement<T extends GameElement>(
    name: string,
    options: {
      prompt?: string;
      elementClass?: ElementClass<T>;
      from?: GameElement | ((context: ActionContext) => GameElement);
      filter?: (element: GameElement, context: ActionContext) => boolean;
      skipIfOnlyOne?: boolean;
      optional?: boolean;
      validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;

      display?: (element: T, context: ActionContext) => string;

      boardRef?: (element: T, context: ActionContext) => BoardElementRef;
    } = {}
  ): this {
    const selection: ElementSelection<T> = {
      type: 'element',
      name,
      prompt: options.prompt,
      elementClass: options.elementClass,
      from: options.from,
      filter: options.filter,
      skipIfOnlyOne: options.skipIfOnlyOne,
      optional: options.optional,
      validate: options.validate,
      display: options.display as ElementSelection<T>['display'],
      boardRef: options.boardRef as ElementSelection<T>['boardRef'],
    };
    this.definition.selections.push(selection as Selection);
    return this;
  }




  enterText(
    name: string,
    options: {
      prompt?: string;
      pattern?: RegExp;
      minLength?: number;
      maxLength?: number;
      optional?: boolean;
      validate?: (value: string, args: Record<string, unknown>, context: ActionContext) => boolean | string;
    } = {}
  ): this {
    const selection: TextSelection = {
      type: 'text',
      name,
      prompt: options.prompt,
      pattern: options.pattern,
      minLength: options.minLength,
      maxLength: options.maxLength,
      optional: options.optional,
      validate: options.validate,
    };
    this.definition.selections.push(selection);
    return this;
  }




  enterNumber(
    name: string,
    options: {
      prompt?: string;
      min?: number;
      max?: number;
      integer?: boolean;
      optional?: boolean;
      validate?: (value: number, args: Record<string, unknown>, context: ActionContext) => boolean | string;
    } = {}
  ): this {
    const selection: NumberSelection = {
      type: 'number',
      name,
      prompt: options.prompt,
      min: options.min,
      max: options.max,
      integer: options.integer,
      optional: options.optional,
      validate: options.validate,
    };
    this.definition.selections.push(selection);
    return this;
  }




  execute(
    fn: (args: Record<string, unknown>, context: ActionContext) => ActionResult | void
  ): ActionDefinition {
    this.definition.execute = fn;
    return this.definition;
  }




  build(): ActionDefinition {
    return this.definition;
  }
}




export class ActionExecutor {
  private game: Game;

  constructor(game: Game) {
    this.game = game;
  }





  resolveArgs(
    action: ActionDefinition,
    args: Record<string, unknown>
  ): Record<string, unknown> {
    const resolved = { ...args };

    for (const selection of action.selections) {
      const value = args[selection.name];
      if (value === undefined) continue;

      switch (selection.type) {
        case 'player': {

          if (typeof value === 'number') {
            const player = this.game.players[value];
            if (player) {
              resolved[selection.name] = player;
            }
          }
          break;
        }

        case 'element': {

          if (typeof value === 'number') {
            const element = this.game.getElementById(value);
            if (element) {
              resolved[selection.name] = element;
            }
          }
          break;
        }
      }
    }

    return resolved;
  }




  getChoices(
    selection: Selection,
    player: Player,
    args: Record<string, unknown>
  ): unknown[] {
    const context: ActionContext = {
      game: this.game,
      player,
      args,
    };

    switch (selection.type) {
      case 'choice': {
        const choiceSel = selection as ChoiceSelection;
        let choices = typeof choiceSel.choices === 'function'
          ? choiceSel.choices(context)
          : [...choiceSel.choices];


        if (choiceSel.filterBy) {
          const { key, selectionName } = choiceSel.filterBy;
          const previousValue = args[selectionName];

          if (previousValue !== undefined) {


            let filterValue: unknown;
            if (typeof previousValue === 'object' && previousValue !== null) {
              const prevObj = previousValue as Record<string, unknown>;

              filterValue = prevObj[key] !== undefined ? prevObj[key] : prevObj['id'];
            } else {
              filterValue = previousValue;
            }


            choices = choices.filter((choice) => {
              if (typeof choice === 'object' && choice !== null) {
                return (choice as Record<string, unknown>)[key] === filterValue;
              }
              return choice === filterValue;
            });
          }
        }

        return choices;
      }

      case 'player': {
        const playerSel = selection as PlayerSelection;
        let players = [...this.game.players];
        if (playerSel.filter) {
          players = players.filter((p) => playerSel.filter!(p, context));
        }
        return players;
      }

      case 'element': {
        const elementSel = selection as ElementSelection;
        const from =
          typeof elementSel.from === 'function'
            ? elementSel.from(context)
            : elementSel.from ?? this.game;

        let elements: GameElement[];
        if (elementSel.elementClass) {
          elements = [...from.all(elementSel.elementClass)];
        } else {
          elements = [...from.all()];
        }

        if (elementSel.filter) {
          elements = elements.filter((e) => elementSel.filter!(e, context));
        }

        return elements;
      }

      case 'text':
      case 'number':

        return [];

      default:
        return [];
    }
  }




  shouldSkip(
    selection: Selection,
    player: Player,
    args: Record<string, unknown>
  ): { skip: boolean; value?: unknown } {
    if (!selection.skipIfOnlyOne) {
      return { skip: false };
    }

    const choices = this.getChoices(selection, player, args);
    if (choices.length === 1) {
      return { skip: true, value: choices[0] };
    }

    return { skip: false };
  }




  private valuesEqual(a: unknown, b: unknown): boolean {
    if (a === b) return true;
    if (typeof a !== typeof b) return false;
    if (typeof a === 'object' && a !== null && b !== null) {

      return JSON.stringify(a) === JSON.stringify(b);
    }
    return false;
  }




  private choicesContain(choices: unknown[], value: unknown): boolean {
    return choices.some(choice => this.valuesEqual(choice, value));
  }




  validateSelection(
    selection: Selection,
    value: unknown,
    player: Player,
    args: Record<string, unknown>
  ): ValidationResult {
    const errors: string[] = [];
    const context: ActionContext = {
      game: this.game,
      player,
      args,
    };


    if (selection.type === 'choice' || selection.type === 'player' || selection.type === 'element') {
      const choices = this.getChoices(selection, player, args);
      if (!this.choicesContain(choices, value)) {
        errors.push(`Invalid selection for ${selection.name}`);
      }
    }


    switch (selection.type) {
      case 'text': {
        const textSel = selection as TextSelection;
        const str = value as string;
        if (typeof str !== 'string') {
          errors.push(`${selection.name} must be a string`);
        } else {
          if (textSel.minLength !== undefined && str.length < textSel.minLength) {
            errors.push(`${selection.name} must be at least ${textSel.minLength} characters`);
          }
          if (textSel.maxLength !== undefined && str.length > textSel.maxLength) {
            errors.push(`${selection.name} must be at most ${textSel.maxLength} characters`);
          }
          if (textSel.pattern && !textSel.pattern.test(str)) {
            errors.push(`${selection.name} does not match required pattern`);
          }
        }
        break;
      }

      case 'number': {
        const numSel = selection as NumberSelection;
        const num = value as number;
        if (typeof num !== 'number' || isNaN(num)) {
          errors.push(`${selection.name} must be a number`);
        } else {
          if (numSel.min !== undefined && num < numSel.min) {
            errors.push(`${selection.name} must be at least ${numSel.min}`);
          }
          if (numSel.max !== undefined && num > numSel.max) {
            errors.push(`${selection.name} must be at most ${numSel.max}`);
          }
          if (numSel.integer && !Number.isInteger(num)) {
            errors.push(`${selection.name} must be an integer`);
          }
        }
        break;
      }
    }


    if (selection.validate && errors.length === 0) {

      const result = (selection.validate as (v: unknown, a: Record<string, unknown>, c: ActionContext) => boolean | string)(value, args, context);
      if (result !== true) {
        errors.push(typeof result === 'string' ? result : `Invalid ${selection.name}`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }




  validateAction(
    action: ActionDefinition,
    player: Player,
    args: Record<string, unknown>
  ): ValidationResult {
    const allErrors: string[] = [];
    const context: ActionContext = {
      game: this.game,
      player,
      args,
    };


    if (action.condition && !action.condition(context)) {
      return {
        valid: false,
        errors: ['Action is not available'],
      };
    }


    for (const selection of action.selections) {
      const value = args[selection.name];


      if (value === undefined) {
        if (!selection.optional) {
          allErrors.push(`Missing required selection: ${selection.name}`);
        }
        continue;
      }

      const result = this.validateSelection(selection, value, player, args);
      allErrors.push(...result.errors);
    }

    return {
      valid: allErrors.length === 0,
      errors: allErrors,
    };
  }




  executeAction(
    action: ActionDefinition,
    player: Player,
    args: Record<string, unknown>
  ): ActionResult {

    const resolvedArgs = this.resolveArgs(action, args);


    const validation = this.validateAction(action, player, resolvedArgs);
    if (!validation.valid) {
      return {
        success: false,
        error: validation.errors.join('; '),
      };
    }

    const context: ActionContext = {
      game: this.game,
      player,
      args: resolvedArgs,
    };

    try {
      const result = action.execute(resolvedArgs, context);
      return result ?? { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }






  isActionAvailable(action: ActionDefinition, player: Player): boolean {
    const context: ActionContext = {
      game: this.game,
      player,
      args: {},
    };

    if (action.condition && !action.condition(context)) {
      return false;
    }


    return this.hasValidSelectionPath(action.selections, player, {}, 0);
  }




  private getChoiceFilterValue(choice: unknown, key: string): unknown {
    if (typeof choice === 'object' && choice !== null) {
      return (choice as Record<string, unknown>)[key];
    }
    return choice;
  }




  private hasDependentSelection(
    selections: Selection[],
    afterIndex: number,
    selectionName: string
  ): boolean {
    for (let i = afterIndex; i < selections.length; i++) {
      const sel = selections[i];
      if (sel.type === 'choice') {
        const choiceSel = sel as ChoiceSelection;
        if (choiceSel.filterBy?.selectionName === selectionName) {
          return true;
        }
      }
    }
    return false;
  }











  private hasValidSelectionPath(
    selections: Selection[],
    player: Player,
    args: Record<string, unknown>,
    index: number
  ): boolean {

    if (index >= selections.length) {
      return true;
    }

    const selection = selections[index];


    if (selection.optional) {
      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }


    if (selection.type === 'text' || selection.type === 'number') {
      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }



    if (selection.type === 'element' || selection.type === 'player') {
      const choices = this.getChoices(selection, player, args);
      if (choices.length === 0) {
        return false;
      }
      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }



    if (selection.type === 'choice') {
      const choiceSel = selection as ChoiceSelection;
      if (typeof choiceSel.choices === 'function') {
        const choices = this.getChoices(selection, player, args);
        if (choices.length === 0) {
          return false;
        }
        return this.hasValidSelectionPath(selections, player, args, index + 1);
      }
    }


    const choices = this.getChoices(selection, player, args);
    if (choices.length === 0) {
      return false;
    }


    const hasDependent = this.hasDependentSelection(selections, index + 1, selection.name);

    if (!hasDependent) {

      return this.hasValidSelectionPath(selections, player, args, index + 1);
    }



    for (const choice of choices) {

      const newArgs = { ...args, [selection.name]: choice };


      if (this.hasValidSelectionPath(selections, player, newArgs, index + 1)) {
        return true;
      }
    }


    return false;
  }
}
````

## File: packages/engine/src/action/types.ts
````typescript
import type { GameElement } from '../element/game-element.js';
import type { Player } from '../player/player.js';
import type { Game } from '../element/game.js';
import type { ElementClass } from '../element/types.js';




export type SelectionType = 'element' | 'player' | 'choice' | 'text' | 'number';




export interface BaseSelection<T = unknown> {

  name: string;

  prompt?: string;

  skipIfOnlyOne?: boolean;

  optional?: boolean;

  validate?: (value: T, args: Record<string, unknown>, context: ActionContext) => boolean | string;
}




export interface BoardElementRef {
  id?: number;
  name?: string;
  notation?: string;
}




export interface ChoiceBoardRefs {
  sourceRef?: BoardElementRef;
  targetRef?: BoardElementRef;
}




export interface DependentFilter {

  key: string;

  selectionName: string;
}




export interface ChoiceSelection<T = unknown> extends BaseSelection<T> {
  type: 'choice';

  choices: T[] | ((context: ActionContext) => T[]);

  display?: (choice: T) => string;

  boardRefs?: (choice: T, context: ActionContext) => ChoiceBoardRefs;

  filterBy?: DependentFilter;
}




export interface PlayerSelection extends BaseSelection<Player> {
  type: 'player';

  filter?: (player: Player, context: ActionContext) => boolean;

  boardRefs?: (player: Player, context: ActionContext) => ChoiceBoardRefs;
}




export interface ElementSelection<T extends GameElement = GameElement> extends BaseSelection<T> {
  type: 'element';

  filter?: (element: GameElement, context: ActionContext) => boolean;

  elementClass?: ElementClass<T>;

  from?: GameElement | ((context: ActionContext) => GameElement);

  display?: (element: T, context: ActionContext) => string;

  boardRef?: (element: T, context: ActionContext) => BoardElementRef;
}




export interface TextSelection extends BaseSelection<string> {
  type: 'text';

  pattern?: RegExp;

  minLength?: number;

  maxLength?: number;
}




export interface NumberSelection extends BaseSelection<number> {
  type: 'number';

  min?: number;

  max?: number;

  integer?: boolean;
}




export type Selection =
  | ChoiceSelection
  | PlayerSelection
  | ElementSelection
  | TextSelection
  | NumberSelection;




export interface ActionContext {

  game: Game;

  player: Player;

  args: Record<string, unknown>;
}




export interface ActionDefinition {

  name: string;

  prompt?: string;

  selections: Selection[];

  condition?: (context: ActionContext) => boolean;

  execute: (args: Record<string, unknown>, context: ActionContext) => ActionResult | void;






  undoable?: boolean;
}




export interface ActionResult {

  success: boolean;

  error?: string;

  data?: Record<string, unknown>;

  message?: string;
}




export interface SerializedAction {

  name: string;

  player: number;

  args: Record<string, unknown>;

  timestamp?: number;

  undoable?: boolean;
}




export interface ValidationResult {
  valid: boolean;
  errors: string[];
}
````

## File: packages/engine/src/element/deck.ts
````typescript
import { Space } from './space.js';
import { Piece } from './piece.js';
import type { ElementContext, ElementClass } from './types.js';
import type { Player } from '../player/player.js';
import type { Game } from './game.js';























export class Deck<G extends Game = any, P extends Player = any> extends Space<G, P> {




  $type!: 'deck';

  constructor(ctx: Partial<ElementContext>) {
    super(ctx);

    this.$type = 'deck';


    this.setOrder('stacking');


    this.$direction = 'vertical';
    this.$overlap = 0.95;
    this.$align = 'center';
  }





























  drawTo<T extends Piece>(
    destination: Space<G, P>,
    count: number = 1,
    elementClass?: ElementClass<T>
  ): T[] {
    const drawn: T[] = [];
    const cls = elementClass ?? (Piece as unknown as ElementClass<T>);

    for (let i = 0; i < count; i++) {
      const card = this.first(cls);
      if (!card) break;
      card.putInto(destination);
      drawn.push(card);
    }

    return drawn;
  }
}
````

## File: packages/engine/src/flow/engine.ts
````typescript
import type { Game } from '../element/game.js';
import type { Player } from '../player/player.js';
import type { ActionResult } from '../action/types.js';
import type {
  FlowNode,
  FlowContext,
  FlowPosition,
  FlowState,
  FlowStepResult,
  FlowDefinition,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  ExecuteConfig,
  PhaseConfig,
  PlayerAwaitingState,
} from './types.js';




const DEFAULT_MAX_ITERATIONS = 10000;




function createContext<G extends Game>(
  game: G,
  player?: Player,
  variables: Record<string, unknown> = {}
): FlowContext<G> {
  return {
    game,
    player,
    variables,
    set: (name: string, value: unknown) => {
      variables[name] = value;
    },
    get: <T = unknown>(name: string): T | undefined => {
      return variables[name] as T | undefined;
    },
  };
}




interface ExecutionFrame {
  node: FlowNode;
  index: number;
  completed: boolean;
  data?: Record<string, unknown>;
}





export class FlowEngine<G extends Game = Game> {
  private game: G;
  private definition: FlowDefinition;
  private stack: ExecutionFrame[] = [];
  private variables: Record<string, unknown> = {};
  private currentPlayer?: Player;
  private awaitingInput = false;
  private availableActions: string[] = [];
  private prompt?: string;
  private complete = false;
  private lastActionResult?: ActionResult;

  private awaitingPlayers: PlayerAwaitingState[] = [];

  private currentPhase?: string;

  private moveCount = 0;

  private currentActionConfig?: ActionStepConfig;

  constructor(game: G, definition: FlowDefinition) {
    this.game = game;
    this.definition = definition;
  }




  start(): FlowState {

    const context = this.createContext();
    if (this.definition.setup) {
      this.definition.setup(context);
    }


    this.stack = [{ node: this.definition.root, index: 0, completed: false }];
    this.variables = { ...context.variables };
    this.currentPlayer = this.game.players.current;
    this.awaitingInput = false;
    this.complete = false;


    return this.run();
  }







  resume(actionName: string, args: Record<string, unknown>, playerIndex?: number): FlowState {
    if (!this.awaitingInput) {
      throw new Error('Flow is not awaiting input');
    }

    const currentFrame = this.stack[this.stack.length - 1];


    if (currentFrame?.node.type === 'simultaneous-action-step') {
      return this.resumeSimultaneousAction(actionName, args, playerIndex, currentFrame);
    }


    const result = this.game.performAction(actionName, this.currentPlayer!, args);
    this.lastActionResult = result;

    if (!result.success) {

      return this.getState();
    }


    this.awaitingInput = false;


    if (currentFrame?.node.type === 'action-step') {
      const config = currentFrame.node.config as ActionStepConfig;


      const currentMoveCount = (currentFrame.data?.moveCount as number) ?? 0;
      const newMoveCount = currentMoveCount + 1;
      currentFrame.data = { ...currentFrame.data, moveCount: newMoveCount };


      if (config.maxMoves && newMoveCount >= config.maxMoves) {
        currentFrame.completed = true;
        this.currentActionConfig = undefined;
        this.moveCount = 0;
      }

      else if (config.repeatUntil) {
        const minMovesMet = !config.minMoves || newMoveCount >= config.minMoves;
        if (config.repeatUntil(this.createContext()) && minMovesMet) {
          currentFrame.completed = true;
          this.currentActionConfig = undefined;
          this.moveCount = 0;
        }
      }

      else if (!config.minMoves && !config.maxMoves) {
        currentFrame.completed = true;
        this.currentActionConfig = undefined;
        this.moveCount = 0;
      }


    }

    return this.run();
  }




  private resumeSimultaneousAction(
    actionName: string,
    args: Record<string, unknown>,
    playerIndex: number | undefined,
    frame: ExecutionFrame
  ): FlowState {
    const config = frame.node.config as SimultaneousActionStepConfig;


    let actingPlayerIndex = playerIndex;
    if (actingPlayerIndex === undefined) {

      const firstAwaiting = this.awaitingPlayers.find(p => !p.completed && p.availableActions.length > 0);
      if (firstAwaiting) {
        actingPlayerIndex = firstAwaiting.playerIndex;
      }
    }

    if (actingPlayerIndex === undefined) {
      throw new Error('No player specified and no awaiting players found');
    }


    const playerState = this.awaitingPlayers.find(p => p.playerIndex === actingPlayerIndex);
    if (!playerState) {
      throw new Error(`Player ${actingPlayerIndex} is not awaiting action`);
    }
    if (playerState.completed) {
      throw new Error(`Player ${actingPlayerIndex} has already completed their action`);
    }
    if (!playerState.availableActions.includes(actionName)) {
      throw new Error(`Action ${actionName} is not available for player ${actingPlayerIndex}`);
    }


    const player = this.game.players[actingPlayerIndex];
    const result = this.game.performAction(actionName, player as any, args);
    this.lastActionResult = result;

    if (!result.success) {

      return this.getState();
    }


    const context = this.createContext();
    if (config.playerDone) {
      playerState.completed = config.playerDone(context, player);
    }


    if (!playerState.completed) {
      const actions = typeof config.actions === 'function'
        ? config.actions(context, player)
        : config.actions;
      playerState.availableActions = actions.filter((actionName) => {
        const action = this.game.getAction(actionName);
        if (!action) return false;
        return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
      });

      if (playerState.availableActions.length === 0) {
        playerState.completed = true;
      }
    }


    const allDone = config.allDone
      ? config.allDone(context)
      : this.awaitingPlayers.every(p => p.completed);

    if (allDone) {

      this.awaitingInput = false;
      this.awaitingPlayers = [];
      frame.completed = true;
      return this.run();
    }


    return this.getState();
  }




  getState(): FlowState {
    const state: FlowState = {
      position: this.getPosition(),
      complete: this.complete,
      awaitingInput: this.awaitingInput,
      currentPlayer: this.currentPlayer?.position,
      availableActions: this.awaitingInput ? this.availableActions : undefined,
      prompt: this.prompt,
      awaitingPlayers: this.awaitingPlayers.length > 0 ? this.awaitingPlayers : undefined,
      currentPhase: this.currentPhase,
    };


    if (this.currentActionConfig && (this.currentActionConfig.minMoves || this.currentActionConfig.maxMoves)) {
      state.moveCount = this.moveCount;
      if (this.currentActionConfig.maxMoves) {
        state.movesRemaining = this.currentActionConfig.maxMoves - this.moveCount;
      }
      if (this.currentActionConfig.minMoves) {
        state.movesRequired = Math.max(0, this.currentActionConfig.minMoves - this.moveCount);
      }
    }

    return state;
  }




  restore(position: FlowPosition): void {
    this.variables = { ...position.variables };
    this.stack = [];


    let currentNode = this.definition.root;
    for (let i = 0; i < position.path.length; i++) {
      const index = position.path[i];
      const iterationKey = `__iter_${i}`;
      const iteration = position.iterations[iterationKey] ?? 0;

      this.stack.push({
        node: currentNode,
        index,
        completed: false,
        data: { iteration },
      });


      currentNode = this.getChildNode(currentNode, index);
    }


    if (position.playerIndex !== undefined) {
      this.currentPlayer = this.game.players[position.playerIndex];
    }
  }




  isComplete(): boolean {
    return this.complete;
  }




  getWinners(): Player[] {
    if (!this.complete) return [];
    if (this.definition.getWinners) {
      return this.definition.getWinners(this.createContext());
    }
    return [];
  }





  private createContext(): FlowContext<G> {
    const context = createContext(this.game, this.currentPlayer, this.variables);
    context.lastActionResult = this.lastActionResult;
    return context;
  }

  private getPosition(): FlowPosition {
    const path: number[] = [];
    const iterations: Record<string, number> = {};

    for (let i = 0; i < this.stack.length; i++) {
      const frame = this.stack[i];
      path.push(frame.index);
      if (frame.data?.iteration !== undefined) {
        iterations[`__iter_${i}`] = frame.data.iteration as number;
      }
    }

    return {
      path,
      iterations,
      playerIndex: this.currentPlayer?.position,
      variables: { ...this.variables },
    };
  }

  private getChildNode(node: FlowNode, index: number): FlowNode {
    switch (node.type) {
      case 'sequence':
        return node.config.steps[index];
      case 'loop':
      case 'each-player':
      case 'for-each':
      case 'phase':
        return node.config.do;
      case 'if':
        return index === 0 ? node.config.then : (node.config.else ?? node.config.then);
      case 'switch': {
        const cases = Object.values(node.config.cases);
        return cases[index] ?? node.config.default ?? cases[0];
      }
      default:
        return node;
    }
  }




  private run(): FlowState {
    let iterations = 0;

    while (this.stack.length > 0 && !this.awaitingInput && !this.complete) {
      iterations++;
      if (iterations > DEFAULT_MAX_ITERATIONS) {
        throw new Error('Flow exceeded maximum iterations - possible infinite loop');
      }

      const frame = this.stack[this.stack.length - 1];


      if (frame.completed) {
        this.stack.pop();
        continue;
      }

      const result = this.executeNode(frame);

      if (result.awaitingInput) {
        this.awaitingInput = true;
        break;
      }

      if (frame.completed) {
        this.stack.pop();
      }


      if (this.definition.isComplete?.(this.createContext())) {
        this.complete = true;
        break;
      }
    }


    if (this.stack.length === 0 || this.definition.isComplete?.(this.createContext())) {
      this.complete = true;
    }

    return this.getState();
  }




  private executeNode(frame: ExecutionFrame): FlowStepResult {
    const context = this.createContext();

    switch (frame.node.type) {
      case 'sequence':
        return this.executeSequence(frame, frame.node.config, context);
      case 'loop':
        return this.executeLoop(frame, frame.node.config, context);
      case 'each-player':
        return this.executeEachPlayer(frame, frame.node.config, context);
      case 'for-each':
        return this.executeForEach(frame, frame.node.config, context);
      case 'action-step':
        return this.executeActionStep(frame, frame.node.config, context);
      case 'simultaneous-action-step':
        return this.executeSimultaneousActionStep(frame, frame.node.config, context);
      case 'switch':
        return this.executeSwitch(frame, frame.node.config, context);
      case 'if':
        return this.executeIf(frame, frame.node.config, context);
      case 'execute':
        return this.executeExecute(frame, frame.node.config, context);
      case 'phase':
        return this.executePhase(frame, frame.node.config, context);
      default:
        frame.completed = true;
        return { continue: true, awaitingInput: false };
    }
  }

  private executeSequence(
    frame: ExecutionFrame,
    config: SequenceConfig,
    context: FlowContext
  ): FlowStepResult {
    if (frame.index >= config.steps.length) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    const nextStep = config.steps[frame.index];
    this.stack.push({ node: nextStep, index: 0, completed: false });
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeLoop(
    frame: ExecutionFrame,
    config: LoopConfig,
    context: FlowContext
  ): FlowStepResult {
    const iteration = (frame.data?.iteration as number) ?? 0;
    const maxIterations = config.maxIterations ?? DEFAULT_MAX_ITERATIONS;


    if (iteration >= maxIterations) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    if (config.while && !config.while(context)) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    this.stack.push({ node: config.do, index: 0, completed: false });
    frame.data = { ...frame.data, iteration: iteration + 1 };
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeEachPlayer(
    frame: ExecutionFrame,
    config: EachPlayerConfig,
    context: FlowContext
  ): FlowStepResult {

    let players = [...this.game.players];

    if (config.filter) {
      players = players.filter((p) => config.filter!(p, context));
    }

    if (config.direction === 'backward') {
      players.reverse();
    }


    if (frame.data?.playerIndex === undefined) {
      let startIndex = 0;
      if (config.startingPlayer) {
        const startPlayer = config.startingPlayer(context);
        startIndex = players.findIndex((p) => p === startPlayer);
        if (startIndex === -1) startIndex = 0;
      }
      frame.data = { ...frame.data, playerIndex: startIndex, players };
    }

    const playerIndex = frame.data.playerIndex as number;
    const playerList = (frame.data.players as Player[]) ?? players;

    if (playerIndex >= playerList.length) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    this.currentPlayer = playerList[playerIndex];
    this.variables[config.name ?? 'currentPlayer'] = this.currentPlayer;

    this.stack.push({ node: config.do, index: 0, completed: false });
    frame.data = { ...frame.data, playerIndex: playerIndex + 1 };
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeForEach(
    frame: ExecutionFrame,
    config: ForEachConfig,
    context: FlowContext
  ): FlowStepResult {

    const items = typeof config.collection === 'function'
      ? config.collection(context)
      : config.collection;

    const itemIndex = (frame.data?.itemIndex as number) ?? 0;

    if (itemIndex >= items.length) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    this.variables[config.as] = items[itemIndex];

    this.stack.push({ node: config.do, index: 0, completed: false });
    frame.data = { ...frame.data, itemIndex: itemIndex + 1 };
    frame.index++;

    return { continue: true, awaitingInput: false };
  }

  private executeActionStep(
    frame: ExecutionFrame,
    config: ActionStepConfig,
    context: FlowContext
  ): FlowStepResult {

    if (config.skipIf?.(context)) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    if (frame.data?.moveCount === undefined) {
      frame.data = { ...frame.data, moveCount: 0 };
    }
    const moveCount = frame.data.moveCount as number;


    if (config.maxMoves && moveCount >= config.maxMoves) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    const minMovesMet = !config.minMoves || moveCount >= config.minMoves;
    if (this.lastActionResult && config.repeatUntil?.(context) && minMovesMet) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      this.lastActionResult = undefined;
      return { continue: true, awaitingInput: false };
    }


    const player = config.player ? config.player(context) : context.player;
    if (!player) {
      throw new Error('ActionStep requires a player');
    }


    const actions = typeof config.actions === 'function'
      ? config.actions(context)
      : config.actions;


    const available = actions.filter((actionName) => {
      const action = this.game.getAction(actionName);
      if (!action) return false;
      return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
    });


    if (available.length === 0 && minMovesMet) {
      this.currentActionConfig = undefined;
      this.moveCount = 0;
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    if (available.length === 0 && !minMovesMet) {
      throw new Error(`ActionStep requires ${config.minMoves} moves but only ${moveCount} were possible`);
    }


    this.currentActionConfig = config;
    this.moveCount = moveCount;


    this.currentPlayer = player;
    this.availableActions = available;
    this.prompt = typeof config.prompt === 'function' ? config.prompt(context) : config.prompt;


    return {
      continue: false,
      awaitingInput: true,
      availableActions: available,
      currentPlayer: player,
    };
  }

  private executeSimultaneousActionStep(
    frame: ExecutionFrame,
    config: SimultaneousActionStepConfig,
    context: FlowContext
  ): FlowStepResult {

    const players = config.players
      ? config.players(context)
      : [...this.game.players];


    this.awaitingPlayers = [];

    for (const player of players) {

      if (config.skipPlayer?.(context, player)) {
        continue;
      }


      if (config.playerDone?.(context, player)) {
        continue;
      }


      const actions = typeof config.actions === 'function'
        ? config.actions(context, player)
        : config.actions;

      const available = actions.filter((actionName) => {
        const action = this.game.getAction(actionName);
        if (!action) return false;
        return this.game.getAvailableActions(player as any).some((a) => a.name === actionName);
      });


      if (available.length > 0) {
        this.awaitingPlayers.push({
          playerIndex: player.position,
          availableActions: available,
          completed: false,
        });
      }
    }


    if (this.awaitingPlayers.length === 0) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    if (config.allDone?.(context)) {
      this.awaitingPlayers = [];
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }


    this.prompt = typeof config.prompt === 'function' ? config.prompt(context) : config.prompt;


    return {
      continue: false,
      awaitingInput: true,
    };
  }

  private executeSwitch(
    frame: ExecutionFrame,
    config: SwitchConfig,
    context: FlowContext
  ): FlowStepResult {

    if (frame.data?.branchPushed) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    const value = config.on(context);
    const stringValue = String(value);

    const branch = config.cases[stringValue] ?? config.default;
    if (!branch) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    this.stack.push({ node: branch, index: 0, completed: false });
    frame.data = { branchPushed: true };

    return { continue: true, awaitingInput: false };
  }

  private executeIf(
    frame: ExecutionFrame,
    config: IfConfig,
    context: FlowContext
  ): FlowStepResult {

    if (frame.data?.branchPushed) {
      frame.completed = true;
      return { continue: true, awaitingInput: false };
    }

    const condition = config.condition(context);

    if (condition) {
      this.stack.push({ node: config.then, index: 0, completed: false });
      frame.data = { branchPushed: true };
    } else if (config.else) {
      this.stack.push({ node: config.else, index: 0, completed: false });
      frame.data = { branchPushed: true };
    } else {

      frame.completed = true;
    }

    return { continue: true, awaitingInput: false };
  }

  private executeExecute(
    frame: ExecutionFrame,
    config: ExecuteConfig,
    context: FlowContext
  ): FlowStepResult {

    config.fn(context);

    this.variables = { ...context.variables };
    frame.completed = true;
    return { continue: true, awaitingInput: false };
  }

  private executePhase(
    frame: ExecutionFrame,
    config: PhaseConfig,
    context: FlowContext
  ): FlowStepResult {

    if (!frame.data?.entered) {

      const previousPhase = this.currentPhase;
      this.currentPhase = config.name;


      if (this.definition.onEnterPhase) {
        this.definition.onEnterPhase(config.name, context);
      }


      this.stack.push({ node: config.do, index: 0, completed: false });
      frame.data = { entered: true, previousPhase };

      return { continue: true, awaitingInput: false };
    }


    if (this.definition.onExitPhase) {
      this.definition.onExitPhase(config.name, context);
    }


    this.currentPhase = frame.data.previousPhase as string | undefined;
    frame.completed = true;

    return { continue: true, awaitingInput: false };
  }
}
````

## File: packages/engine/src/flow/index.ts
````typescript
export { FlowEngine } from './engine.js';


export {
  sequence,
  namedSequence,
  phase,
  loop,
  repeat,
  eachPlayer,
  forEach,
  actionStep,
  simultaneousActionStep,
  playerActions,
  switchOn,
  ifThen,
  defineFlow,
  noop,
  execute,
  setVar,
} from './builders.js';


export { TurnOrder } from './turn-order.js';
export type { TurnOrderConfig } from './turn-order.js';


export type {
  FlowNodeType,
  FlowStepResult,
  FlowPosition,
  FlowContext,
  FlowNode,
  FlowState,
  FlowDefinition,
  BaseFlowConfig,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  ExecuteConfig,
  PhaseConfig,
  PlayerAwaitingState,
} from './types.js';
````

## File: packages/engine/src/flow/types.ts
````typescript
import type { Game } from '../element/game.js';
import type { Player } from '../player/player.js';
import type { ActionDefinition, ActionResult } from '../action/types.js';




export type FlowNodeType =
  | 'sequence'
  | 'loop'
  | 'each-player'
  | 'for-each'
  | 'action-step'
  | 'simultaneous-action-step'
  | 'switch'
  | 'if'
  | 'execute'
  | 'phase';




export interface FlowStepResult {

  continue: boolean;

  awaitingInput: boolean;

  availableActions?: string[];

  currentPlayer?: Player;

  message?: string;

  data?: Record<string, unknown>;
}




export interface FlowPosition {

  path: number[];

  iterations: Record<string, number>;

  playerIndex?: number;

  itemIndex?: number;

  variables: Record<string, unknown>;
}




export interface FlowContext<G extends Game = Game> {

  game: G;

  player?: Player;

  variables: Record<string, unknown>;

  set: (name: string, value: unknown) => void;

  get: <T = unknown>(name: string) => T | undefined;

  lastActionResult?: ActionResult;
}




export interface BaseFlowConfig {

  name?: string;
}




export interface SequenceConfig extends BaseFlowConfig {

  steps: FlowNode[];
}




export interface LoopConfig extends BaseFlowConfig {

  while?: (context: FlowContext) => boolean;

  maxIterations?: number;

  do: FlowNode;
}




export interface EachPlayerConfig extends BaseFlowConfig {

  filter?: (player: Player, context: FlowContext) => boolean;

  direction?: 'forward' | 'backward';

  startingPlayer?: (context: FlowContext) => Player;

  do: FlowNode;
}




export interface ForEachConfig<T = unknown> extends BaseFlowConfig {

  collection: T[] | ((context: FlowContext) => T[]);

  as: string;

  do: FlowNode;
}




export interface ActionStepConfig extends BaseFlowConfig {

  player?: (context: FlowContext) => Player;

  actions: string[] | ((context: FlowContext) => string[]);

  prompt?: string | ((context: FlowContext) => string);

  repeatUntil?: (context: FlowContext) => boolean;

  skipIf?: (context: FlowContext) => boolean;

  timeout?: number;

  minMoves?: number;

  maxMoves?: number;
}




export interface SimultaneousActionStepConfig extends BaseFlowConfig {

  players?: (context: FlowContext) => Player[];

  actions: string[] | ((context: FlowContext, player: Player) => string[]);

  prompt?: string | ((context: FlowContext) => string);

  playerDone?: (context: FlowContext, player: Player) => boolean;

  allDone?: (context: FlowContext) => boolean;

  skipPlayer?: (context: FlowContext, player: Player) => boolean;

  timeout?: number;
}




export interface SwitchConfig extends BaseFlowConfig {

  on: (context: FlowContext) => unknown;

  cases: Record<string, FlowNode>;

  default?: FlowNode;
}




export interface IfConfig extends BaseFlowConfig {

  condition: (context: FlowContext) => boolean;

  then: FlowNode;

  else?: FlowNode;
}




export interface ExecuteConfig extends BaseFlowConfig {

  fn: (context: FlowContext) => void;
}




export interface PhaseConfig extends BaseFlowConfig {

  name: string;

  do: FlowNode;
}




export type FlowNode =
  | { type: 'sequence'; config: SequenceConfig }
  | { type: 'loop'; config: LoopConfig }
  | { type: 'each-player'; config: EachPlayerConfig }
  | { type: 'for-each'; config: ForEachConfig }
  | { type: 'action-step'; config: ActionStepConfig }
  | { type: 'simultaneous-action-step'; config: SimultaneousActionStepConfig }
  | { type: 'switch'; config: SwitchConfig }
  | { type: 'if'; config: IfConfig }
  | { type: 'execute'; config: ExecuteConfig }
  | { type: 'phase'; config: PhaseConfig };




export interface PlayerAwaitingState {

  playerIndex: number;

  availableActions: string[];

  completed: boolean;
}




export interface FlowState {

  position: FlowPosition;

  complete: boolean;

  awaitingInput: boolean;

  currentPlayer?: number;

  availableActions?: string[];

  prompt?: string;

  awaitingPlayers?: PlayerAwaitingState[];

  currentPhase?: string;

  moveCount?: number;

  movesRemaining?: number;

  movesRequired?: number;
}




export interface FlowDefinition {

  root: FlowNode;

  setup?: (context: FlowContext) => void;

  isComplete?: (context: FlowContext) => boolean;

  getWinners?: (context: FlowContext) => Player[];

  onEnterPhase?: (phaseName: string, context: FlowContext) => void;

  onExitPhase?: (phaseName: string, context: FlowContext) => void;
}
````

## File: packages/engine/src/element/index.ts
````typescript
export { GameElement } from './game-element.js';
export { Space } from './space.js';
export { Piece } from './piece.js';
export { Card } from './card.js';
export { Hand } from './hand.js';
export { Deck } from './deck.js';
export { Die } from './die.js';
export { DicePool } from './dice-pool.js';
export { Grid, GridCell } from './grid.js';
export { HexGrid, HexCell } from './hex-grid.js';
export { Game } from './game.js';
export { ElementCollection } from './element-collection.js';

export type {
  ElementClass,
  ElementContext,
  ElementTree,
  ElementJSON,
  ElementFinder,
  ElementAttributes,
  Sorter,
  ImageRef,
} from './types.js';

export type { GameOptions, GamePhase, PlayerViewFunction } from './game.js';
export type { ElementLayout } from './grid.js';
export type { HexOrientation, HexCoordSystem } from './hex-grid.js';
export type { LayoutDirection, LayoutAlignment } from './space.js';
export type { DieSides } from './die.js';
````

## File: packages/engine/src/element/game.ts
````typescript
import { Space } from './space.js';
import { GameElement } from './game-element.js';
import type { ElementContext, ElementClass, ElementJSON } from './types.js';
import { Player, PlayerCollection } from '../player/player.js';
import type { GameCommand, CommandResult } from '../command/types.js';
import { executeCommand } from '../command/executor.js';
import type { ActionDefinition, ActionResult, SerializedAction } from '../action/types.js';
import { ActionExecutor } from '../action/action.js';
import type { FlowDefinition, FlowState, FlowPosition } from '../flow/types.js';
import { FlowEngine } from '../flow/engine.js';




export type GameOptions = {

  playerCount: number;

  playerNames?: string[];

  seed?: string;
};




export type GamePhase = 'setup' | 'started' | 'finished';











export type PlayerViewFunction<G extends Game = Game> = (
  state: ElementJSON,
  playerPosition: number | null,
  game: G
) => ElementJSON;




function createSeededRandom(seed: string): () => number {

  let h = 0;
  for (let i = 0; i < seed.length; i++) {
    h = Math.imul(31, h) + seed.charCodeAt(i) | 0;
  }

  return function () {
    h |= 0;
    h = h + 0x6D2B79F5 | 0;
    let t = Math.imul(h ^ h >>> 15, 1 | h);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}





export class Game<
  G extends Game = any,
  P extends Player = any
> extends Space<G, P> {




  static playerView?: PlayerViewFunction;


  pile!: GameElement;


  players: PlayerCollection<P> = new PlayerCollection<P>();


  phase: GamePhase = 'setup';


  random: () => number;


  messages: Array<{ text: string; data?: Record<string, unknown> }> = [];


  settings: Record<string, unknown> = {};


  commandHistory: GameCommand[] = [];


  private _actions: Map<string, ActionDefinition> = new Map();


  private _actionExecutor!: ActionExecutor;


  private _flowDefinition?: FlowDefinition;


  private _flowEngine?: FlowEngine;

  static override unserializableAttributes = [
    ...Space.unserializableAttributes,
    'pile',
    'players',
    'random',
    'commandHistory',
    '_actions',
    '_actionExecutor',
    '_flowDefinition',
    '_flowEngine',
  ];

  constructor(options: GameOptions) {

    const seed = options.seed ?? Math.random().toString(36).substring(2);
    const random = createSeededRandom(seed);


    const ctx: Partial<ElementContext> = {
      sequence: 0,
      classRegistry: new Map(),
      random,
    };

    super(ctx);

    this.random = random;
    this.game = this as unknown as G;
    this._ctx.game = this;


    this._ctx.classRegistry.set('Space', Space as unknown as ElementClass);
    this._ctx.classRegistry.set('GameElement', GameElement as unknown as ElementClass);


    this.pile = this.createElement(Space, '__pile__');
    this.pile._t.parent = undefined;


    for (let i = 0; i < options.playerCount; i++) {
      const name = options.playerNames?.[i] ?? `Player ${i + 1}`;
      const player = this.createPlayer(i, name);
      player.game = this as unknown as Game;
      this.players.push(player as P);
    }


    if (this.players.length > 0) {
      this.players.setCurrent(0);
    }


    this._actionExecutor = new ActionExecutor(this);
  }




  protected createPlayer(position: number, name: string): P {
    return new Player(position, name) as P;
  }














  protected registerElements(
    classes: (new (...args: any[]) => GameElement)[]
  ): void {
    for (const cls of classes) {
      const className = cls.name;
      if (!this._ctx.classRegistry.has(className)) {
        this._ctx.classRegistry.set(className, cls as ElementClass);
      }
    }
  }




  protected createElement<T extends GameElement>(
    elementClass: ElementClass<T>,
    name: string
  ): T {
    const element = new elementClass(this._ctx);
    element.name = name;
    element.game = this as unknown as Game;

    const className = elementClass.name;
    if (!this._ctx.classRegistry.has(className)) {
      this._ctx.classRegistry.set(className, elementClass);
    }

    return element;
  }








  getElementById(id: number): GameElement | undefined {

    const found = this.atId(id);
    if (found) return found;


    return this.pile.atId(id);
  }




  getElementClass(className: string): ElementClass | undefined {
    return this._ctx.classRegistry.get(className);
  }








  execute(command: GameCommand): CommandResult {
    const result = executeCommand(this, command);
    if (result.success) {
      this.commandHistory.push(command);
    }
    return result;
  }




  replayCommands(commands: GameCommand[]): void {
    for (const command of commands) {
      const result = executeCommand(this, command);
      if (!result.success) {
        throw new Error(`Failed to replay command: ${result.error}`);
      }
      this.commandHistory.push(command);
    }
  }








  registerAction(action: ActionDefinition): void {
    this._actions.set(action.name, action);
  }




  registerActions(...actions: ActionDefinition[]): void {
    for (const action of actions) {
      this.registerAction(action);
    }
  }




  getAction(name: string): ActionDefinition | undefined {
    return this._actions.get(name);
  }




  getActionNames(): string[] {
    return [...this._actions.keys()];
  }




  getAvailableActions(player: P): ActionDefinition[] {
    const available: ActionDefinition[] = [];
    for (const action of this._actions.values()) {
      if (this._actionExecutor.isActionAvailable(action, player)) {
        available.push(action);
      }
    }
    return available;
  }




  getActionExecutor(): ActionExecutor {
    return this._actionExecutor;
  }




  getSelectionChoices(
    actionName: string,
    selectionName: string,
    player: P,
    args: Record<string, unknown> = {}
  ): unknown[] {
    const action = this._actions.get(actionName);
    if (!action) return [];

    const selection = action.selections.find(s => s.name === selectionName);
    if (!selection) return [];

    return this._actionExecutor.getChoices(selection, player, args);
  }




  performAction(
    actionName: string,
    player: P,
    args: Record<string, unknown>
  ): ActionResult {
    const action = this._actions.get(actionName);
    if (!action) {
      return { success: false, error: `Unknown action: ${actionName}` };
    }

    return this._actionExecutor.executeAction(action, player, args);
  }




  performSerializedAction(serialized: SerializedAction): ActionResult {
    const player = this.players[serialized.player];
    if (!player) {
      return { success: false, error: `Invalid player: ${serialized.player}` };
    }

    return this.performAction(serialized.name, player as P, serialized.args);
  }








  setFlow(definition: FlowDefinition): void {
    this._flowDefinition = definition;
  }




  getFlow(): FlowDefinition | undefined {
    return this._flowDefinition;
  }




  startFlow(): FlowState {
    if (!this._flowDefinition) {
      throw new Error('No flow definition set');
    }

    this._flowEngine = new FlowEngine(this, this._flowDefinition);
    const state = this._flowEngine.start();


    if (this.phase === 'setup') {
      this.phase = 'started';
    }
    if (state.complete) {
      this.phase = 'finished';
    }

    return state;
  }







  continueFlow(actionName: string, args: Record<string, unknown>, playerIndex?: number): FlowState {
    if (!this._flowEngine) {
      throw new Error('Flow not started');
    }

    const state = this._flowEngine.resume(actionName, args, playerIndex);

    if (state.complete) {
      this.phase = 'finished';
      const winners = this._flowEngine.getWinners();
      if (winners.length > 0) {
        this.settings.winners = winners.map(p => p.position);
      }
    }

    return state;
  }




  getFlowState(): FlowState | undefined {
    return this._flowEngine?.getState();
  }




  restoreFlow(position: FlowPosition): void {
    if (!this._flowDefinition) {
      throw new Error('No flow definition set');
    }

    this._flowEngine = new FlowEngine(this, this._flowDefinition);
    this._flowEngine.restore(position);
  }




  isAwaitingInput(): boolean {
    return this._flowEngine?.getState().awaitingInput ?? false;
  }




  getCurrentFlowPlayer(): P | undefined {
    const state = this._flowEngine?.getState();
    if (state?.currentPlayer !== undefined) {
      return this.players[state.currentPlayer];
    }
    return undefined;
  }




  getFlowAvailableActions(): string[] {
    return this._flowEngine?.getState().availableActions ?? [];
  }





  getAwaitingPlayers(): { playerIndex: number; availableActions: string[]; completed: boolean }[] | undefined {
    const state = this._flowEngine?.getState();
    return state?.awaitingPlayers;
  }




  canPlayerAct(playerIndex: number): boolean {
    const state = this._flowEngine?.getState();
    if (!state?.awaitingInput) return false;


    if (state.awaitingPlayers && state.awaitingPlayers.length > 0) {
      const playerState = state.awaitingPlayers.find(p => p.playerIndex === playerIndex);
      return playerState ? !playerState.completed && playerState.availableActions.length > 0 : false;
    }


    return state.currentPlayer === playerIndex;
  }








  start(): void {
    if (this.phase !== 'setup') {
      throw new Error('Game has already started');
    }
    this.phase = 'started';
  }




  finish(winners?: P[]): void {
    this.phase = 'finished';
    if (winners) {
      this.settings.winners = winners.map(p => p.position);
    }
  }




  isFinished(): boolean {
    return this.phase === 'finished';
  }




  getWinners(): P[] {
    const positions = this.settings.winners as number[] | undefined;
    if (!positions) return [];
    return positions.map(pos => this.players[pos]);
  }








  setPlayerContext(player: P | number | undefined): void {
    if (player === undefined) {
      this._ctx.player = undefined;
    } else if (typeof player === 'number') {
      this._ctx.player = this.players[player];
    } else {
      this._ctx.player = player;
    }
  }




  getPlayerContext(): P | undefined {
    return this._ctx.player as P | undefined;
  }








  message(text: string, data?: Record<string, unknown>): void {
    this.addMessageInternal(text, data);
  }




  addMessageInternal(text: string, data?: Record<string, unknown>): void {
    this.messages.push({ text, data });
  }




  getFormattedMessages(): string[] {
    return this.messages.map(({ text, data }) => {
      if (!data) return text;
      let processed = text;
      for (const [key, value] of Object.entries(data)) {
        const replacement = value instanceof GameElement
          ? value.toString()
          : value instanceof Player
            ? value.name
            : String(value);
        processed = processed.replace(new RegExp(`{{${key}}}`, 'g'), replacement);
      }
      return processed;
    });
  }








  override toJSON(): ElementJSON & {
    players: Record<string, unknown>[];
    phase: GamePhase;
    messages: Array<{ text: string; data?: Record<string, unknown> }>;
    settings: Record<string, unknown>;
  } {
    return {
      ...super.toJSON(),
      players: this.players.toJSON(),
      phase: this.phase,
      messages: this.messages,
      settings: this.settings,
    };
  }






  toJSONForPlayer(player: P | number | null): ElementJSON {
    const position = player === null ? null : (typeof player === 'number' ? player : player.position);

    const visibilityPosition = position ?? -1;

    const filterElement = (json: ElementJSON, element: GameElement): ElementJSON | null => {
      const visibility = element.getEffectiveVisibility();



      if (visibility.mode === 'count-only' && !element.isVisibleTo(visibilityPosition)) {
        const systemAttrs: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(json.attributes ?? {})) {
          if (key.startsWith('$')) {
            systemAttrs[key] = value;
          }
        }
        return {
          className: json.className,
          id: json.id,
          name: json.name,
          attributes: systemAttrs,
          childCount: element._t.children.length,
        };
      }


      if (!element.isVisibleTo(visibilityPosition)) {

        return {
          className: json.className,
          id: json.id,
          attributes: { __hidden: true },
        };
      }


      const zoneVisibility = (element as any).getZoneVisibility?.();


      if (zoneVisibility) {
        if (zoneVisibility.mode === 'hidden') {


          const hiddenChildren: ElementJSON[] = [];
          if (json.children) {
            for (const childJson of json.children) {
              const systemAttrs: Record<string, unknown> = { __hidden: true };
              for (const [key, value] of Object.entries(childJson.attributes ?? {})) {
                if (key.startsWith('$')) {
                  systemAttrs[key] = value;
                }
              }
              hiddenChildren.push({
                className: childJson.className,
                id: childJson.id,
                attributes: systemAttrs,
              });
            }
          }
          return {
            ...json,
            children: hiddenChildren.length > 0 ? hiddenChildren : undefined,
            childCount: element._t.children.length,
          };
        } else if (zoneVisibility.mode === 'count-only') {

          return {
            ...json,
            children: undefined,
            childCount: element._t.children.length,
          };
        } else if (zoneVisibility.mode === 'owner' && element.player?.position !== visibilityPosition) {


          const hiddenChildren: ElementJSON[] = [];
          if (json.children) {
            for (const childJson of json.children) {
              const systemAttrs: Record<string, unknown> = { __hidden: true };
              for (const [key, value] of Object.entries(childJson.attributes ?? {})) {
                if (key.startsWith('$')) {
                  systemAttrs[key] = value;
                }
              }
              hiddenChildren.push({
                className: childJson.className,
                id: childJson.id,
                attributes: systemAttrs,
              });
            }
          }
          return {
            ...json,
            children: hiddenChildren.length > 0 ? hiddenChildren : undefined,
          };
        }
      }


      const filteredChildren: ElementJSON[] = [];
      if (json.children) {
        for (let i = 0; i < json.children.length; i++) {
          const childJson = json.children[i];
          const childElement = element._t.children[i];
          const filtered = filterElement(childJson, childElement);
          if (filtered) {
            filteredChildren.push(filtered);
          }
        }
      }

      return {
        ...json,
        children: filteredChildren.length > 0 ? filteredChildren : undefined,
      };
    };

    const fullJson = this.toJSON();
    let filteredState = filterElement(fullJson, this) ?? fullJson;


    const GameClass = this.constructor as typeof Game;
    if (GameClass.playerView) {
      filteredState = GameClass.playerView(filteredState, position, this);
    }

    return filteredState;
  }




  static restoreGame<G extends Game>(
    json: ReturnType<G['toJSON']>,
    GameClass: new (options: GameOptions) => G,
    classRegistry: Map<string, ElementClass>
  ): G {
    const game = new GameClass({
      playerCount: json.players.length,
      playerNames: json.players.map(p => p.name as string),
    });


    for (const [name, cls] of classRegistry) {
      game._ctx.classRegistry.set(name, cls);
    }


    game.phase = json.phase;
    game.messages = json.messages;
    game.settings = json.settings;


    game._t.children = [];
    if (json.children) {
      for (const childJson of json.children) {
        const child = GameElement.fromJSON(childJson, game._ctx, game._ctx.classRegistry);
        child._t.parent = game;
        (child as GameElement).game = game;
        game._t.children.push(child);
      }
    }

    return game;
  }
}
````

## File: packages/engine/src/index.ts
````typescript
export {
  GameElement,
  Space,
  Piece,
  Card,
  Hand,
  Deck,
  Die,
  DicePool,
  Grid,
  GridCell,
  HexGrid,
  HexCell,
  Game,
  ElementCollection,
} from './element/index.js';

export type {
  ElementClass,
  ElementContext,
  ElementTree,
  ElementJSON,
  ElementFinder,
  ElementAttributes,
  Sorter,
  GameOptions,
  GamePhase,
  PlayerViewFunction,
  ElementLayout,
  HexOrientation,
  HexCoordSystem,
  LayoutDirection,
  LayoutAlignment,
  DieSides,
} from './element/index.js';


export {
  Player,
  PlayerCollection,
  AbilityManager,
  createAbilityDisplayMap,
} from './player/index.js';

export type {
  Ability,
  AbilityDisplayInfo,
} from './player/index.js';


export {
  Track,
  MonotonicTrack,
  UniqueTrack,
  CounterTrack,
} from './scoring/index.js';

export type {
  TrackEntry,
  TrackConfig,
  MonotonicTrackConfig,
  UniqueTrackConfig,
  CounterTrackConfig,
} from './scoring/index.js';


export {
  executeCommand,
  canPlayerSee,
  visibilityFromMode,
  resolveVisibility,
  DEFAULT_VISIBILITY,
} from './command/index.js';

export type {
  GameCommand,
  CommandResult,
  BaseCommand,
  CreateElementCommand,
  CreateManyCommand,
  MoveCommand,
  RemoveCommand,
  ShuffleCommand,
  SetAttributeCommand,
  SetVisibilityCommand,
  AddVisibleToCommand,
  SetCurrentPlayerCommand,
  MessageCommand,
  StartGameCommand,
  EndGameCommand,
  SetOrderCommand,
  VisibilityConfig,
  VisibilityMode,
  VisibilityState,
} from './command/index.js';


export { Action, ActionExecutor } from './action/index.js';

export type {
  SelectionType,
  Selection,
  BaseSelection,
  ChoiceSelection,
  PlayerSelection,
  ElementSelection,
  TextSelection,
  NumberSelection,
  ActionContext,
  ActionDefinition,
  ActionResult,
  SerializedAction,
  ValidationResult,
  BoardElementRef,
  ChoiceBoardRefs,
  DependentFilter,
} from './action/index.js';


export {
  FlowEngine,
  sequence,
  namedSequence,
  phase,
  loop,
  repeat,
  eachPlayer,
  forEach,
  actionStep,
  simultaneousActionStep,
  playerActions,
  switchOn,
  ifThen,
  defineFlow,
  noop,
  execute,
  setVar,
  TurnOrder,
} from './flow/index.js';

export type {
  FlowNodeType,
  FlowStepResult,
  FlowPosition,
  FlowContext,
  FlowNode,
  FlowState,
  FlowDefinition,
  BaseFlowConfig,
  SequenceConfig,
  LoopConfig,
  EachPlayerConfig,
  ForEachConfig,
  ActionStepConfig,
  SimultaneousActionStepConfig,
  SwitchConfig,
  IfConfig,
  ExecuteConfig,
  PhaseConfig,
  PlayerAwaitingState,
  TurnOrderConfig,
} from './flow/index.js';


export {
  serializeValue,
  deserializeValue,
  serializeAction,
  deserializeAction,
  isSerializedReference,
  createSnapshot,
  createPlayerView,
  createAllPlayerViews,
  computeDiff,
  createReplayFile,
  validateReplayFile,
  parseReplayFile,
} from './utils/index.js';

export type {
  SerializedReference,
  SerializeOptions,
  GameStateSnapshot,
  PlayerStateView,
  StateDiff,
  ReplayFile,
} from './utils/index.js';


export {
  ExecutionContext,
  ExecutionLimitError,
  withLimits,
  withLimitsAsync,
  guard,
  validateCode,
  DEFAULT_LIMITS,
} from './sandbox/index.js';

export type {
  ExecutionLimits,
} from './sandbox/index.js';
````
