This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/**/*.md, packages/*/README.md, packages/engine/ARCHITECTURE.md, packages/engine/src/**/*.ts, packages/runtime/src/**/*.ts, packages/session/src/**/*.ts, packages/testing/src/**/*.ts, packages/ai/src/**/*.ts
- Files matching these patterns are excluded: node_modules/**, dist/**, **/dist/**, **/*.d.ts, **/*.test.ts, **/*.spec.ts, **/*.bundle.js, pnpm-lock.yaml, .git/**, coverage/**, *.log, packages/games/**, packages/cli/**, packages/server/**, packages/ui/**, packages/worker/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)

# User Provided Header
# BoardSmith - Turn-Based Game Framework

BoardSmith is a TypeScript framework for building multiplayer turn-based board and card games.

## Package Structure

- `@boardsmith/engine` - Core game elements, actions, commands, flow control
- `@boardsmith/runtime` - Game runner, state machine, serialization
- `@boardsmith/session` - Game session management, multiplayer coordination
- `@boardsmith/testing` - Test utilities, debug tools, assertions
- `@boardsmith/ai` - AI player integration

## Quick Reference

- `docs/llm-overview.md` - comprehensive framework summary
- `docs/core-concepts.md` - element tree, actions, commands
- `docs/common-patterns.md` - reusable code patterns
- `docs/common-pitfalls.md` - common mistakes and fixes
- Package README files contain API documentation

# Directory Structure
```
docs/
  api/
    ai-trainer.md
    ai.md
    client.md
    eslint-plugin.md
    index.md
    runtime.md
    server.md
    session.md
    testing.md
    ui.md
    worker.md
  actions-and-flow.md
  ai-system.md
  architecture.md
  common-patterns.md
  common-pitfalls.md
  component-showcase.md
  conditions.md
  core-concepts.md
  custom-ui-guide.md
  dice-and-scoring.md
  element-enrichment.md
  game-examples.md
  getting-started.md
  llm-overview.md
  nomenclature.md
  README.md
  ui-components.md
packages/
  ai/
    README.md
  ai-trainer/
    README.md
  engine/
    ARCHITECTURE.md
    README.md
  session/
    README.md
  testing/
    README.md
```

# Files

## File: docs/architecture.md
````markdown
# BoardSmith Architecture

This document provides an overview of the BoardSmith package architecture and how the components fit together.

## Package Dependency Graph

```
                              ┌─────────────────┐
                              │  eslint-plugin  │  (standalone)
                              └─────────────────┘
                               Sandbox security rules
                               (no-network, no-filesystem,
                                no-timers, no-eval, etc.)

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  ┌─────────┐                                                                │
│  │ engine  │  Core game framework                                           │
│  └────┬────┘  - Element system (Game, Piece, Card, Deck, etc.)              │
│       │       - Action system (builder pattern, selections)                 │
│       │       - Flow system (phases, turns, loops)                          │
│       │       - Command pattern (event sourcing)                            │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────┐                                                                │
│  │ runtime │  Game execution                                                │
│  └────┬────┘  - GameRunner (start, performAction, replay)                   │
│       │       - Action history management                                   │
│       │       - State snapshots                                             │
│       │                                                                     │
│       ├──────────────────┬──────────────────┐                               │
│       ▼                  ▼                  ▼                               │
│  ┌─────────┐        ┌─────────┐        ┌─────────┐                          │
│  │   ai    │        │ session │        │ testing │                          │
│  └────┬────┘        └────┬────┘        └─────────┘                          │
│       │                  │              - Test fixtures                     │
│  MCTS bot                │              - Assertions                        │
│  - createBot()           │              - Random simulation                 │
│  - Difficulty presets    │              - Debug utilities                   │
│       │                  │                                                  │
│       ▼                  │                                                  │
│  ┌────────────┐          │  Game session management                         │
│  │ ai-trainer │          │  - GameSession (create, performAction)           │
│  └────────────┘          │  - Storage adapters                              │
│  - Self-play training    │  - Broadcast adapters                            │
│  - Feature generation    │  - AI controller                                 │
│  - Code generation       │  - Lobby system                                  │
│                          │                                                  │
│                          ├──────────────────┬───────────────────┐           │
│                          ▼                  ▼                   ▼           │
│                     ┌─────────┐        ┌─────────┐         ┌─────────┐      │
│                     │ server  │        │  worker │         │   cli   │      │
│                     └────┬────┘        └────┬────┘         └─────────┘      │
│                          │                  │               - init          │
│                     HTTP/WS core       Cloudflare           - dev           │
│                     - Handlers         Workers              - build         │
│                     - Game stores      - Durable Objects    - test          │
│                     - Matchmaking      - KV storage         - validate      │
│                          │                  │               - train-ai      │
│                          └────────┬─────────┘               - publish       │
│                                   │                                         │
│                                   ▼                                         │
│                              ┌─────────┐                                    │
│                              │ client  │  Browser SDK                       │
│                              └────┬────┘  - MeepleClient (matchmaking)      │
│                                   │       - GameConnection (WebSocket)      │
│                                   │       - Vue composables                 │
│                                   │                                         │
│                                   ▼                                         │
│                              ┌─────────┐                                    │
│                              │   ui    │  Vue 3 components                  │
│                              └─────────┘  - GameShell, ActionPanel          │
│                                           - AutoUI, Die3D                   │
│                                           - 20+ composables                 │
│                                           - Animation system                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Data Flow

### 1. Game Definition → Execution

```
Game Class (rules/game.ts)
    │
    ▼
GameRunner.start()
    │
    ├─► Flow engine executes game flow
    │   - Phases, turns, action steps
    │
    └─► Actions become available
        - Condition checks
        - Selection validation
```

### 2. Action Execution

```
UI Click / Bot Decision
    │
    ▼
actionController.execute(name, args)
    │
    ▼
GameConnection.action()  ──► WebSocket ──► Server/Worker
    │                                           │
    │                                           ▼
    │                                    GameSession.performAction()
    │                                           │
    │                                           ▼
    │                                    GameRunner.performAction()
    │                                           │
    │                                           ▼
    │                                    ActionExecutor.execute()
    │                                           │
    │                                           ▼
    │                                    Commands emitted
    │                                    (MoveCommand, etc.)
    │                                           │
    ◄───────────────────────────────────────────┘
    │                                    State broadcast
    ▼
UI updates via gameView
```

### 3. State Serialization

```
Game Instance (runtime)
    │
    ├─► serialize() ──► GameStateSnapshot (JSON)
    │                        │
    │                        ├─► Storage adapter ──► Database/KV
    │                        │
    │                        └─► Broadcast ──► All connected clients
    │
    └─► playerView(player) ──► PlayerGameState
                                    │
                                    └─► Filtered view for specific player
                                        (hidden cards, fog of war, etc.)
```

## Key Patterns

### Event Sourcing

All game state changes are captured as commands:

```typescript
// Commands are recorded, not state
actionHistory: [
  { action: 'draw', player: 0, args: { count: 3 } },
  { action: 'play', player: 0, args: { card: 42 } },
  // ...
]

// State is reconstructed by replaying commands
GameRunner.replay(actionHistory) → Current State
```

### Visibility Control

Game elements can have visibility restrictions:

```typescript
card.hideFromAll();           // Hidden from everyone
card.showTo(player);          // Visible to specific player
card.showOnlyTo(player);      // Visible ONLY to that player
```

The `playerView()` method filters state based on these visibility rules.

### Platform Adapters

The session package uses adapters for platform-specific concerns:

```
┌─────────────────────────────────────────────────────┐
│                   GameSession                       │
│                                                     │
│  ┌─────────────────┐      ┌─────────────────┐      │
│  │ StorageAdapter  │      │ BroadcastAdapter │      │
│  └────────┬────────┘      └────────┬────────┘      │
└───────────┼─────────────────────────┼───────────────┘
            │                         │
    ┌───────┴───────┐         ┌───────┴───────┐
    │               │         │               │
    ▼               ▼         ▼               ▼
┌────────┐    ┌─────────┐  ┌────────┐   ┌──────────┐
│In-Mem  │    │ SQLite  │  │Express │   │Durable   │
│ Store  │    │ Store   │  │  WS    │   │Object WS │
└────────┘    └─────────┘  └────────┘   └──────────┘
   CLI dev      CLI --persist   CLI dev    Cloudflare
```

## Package Responsibilities

| Package | Responsibility | Key Exports |
|---------|---------------|-------------|
| `engine` | Game rules framework | `Game`, `Action`, `Flow`, elements |
| `runtime` | Game execution | `GameRunner` |
| `session` | Session management | `GameSession`, adapters |
| `server` | HTTP/WS handlers | `GameServerCore`, handlers |
| `worker` | Cloudflare runtime | `createGameWorker`, adapters |
| `client` | Browser SDK | `MeepleClient`, `GameConnection` |
| `ui` | Vue components | `GameShell`, composables |
| `ai` | MCTS bot | `createBot`, `MCTSBot` |
| `ai-trainer` | AI training | `trainAI`, `introspectGame` |
| `cli` | Dev tools | Commands (init, dev, build, etc.) |
| `testing` | Test utilities | `createTestGame`, assertions |
| `eslint-plugin` | Linting rules | Sandbox security rules |

## See Also

- [Getting Started](./getting-started.md) - Quick start guide
- [Core Concepts](./core-concepts.md) - Element system, actions, flow
- [Common Patterns](./common-patterns.md) - Reusable game patterns
````

## File: docs/common-patterns.md
````markdown
# Common Game Patterns

This guide shows reusable patterns that appear across many board games. Use these as starting points for your implementation.

---

## 1. Dealer Rotation

Many card games rotate who deals each round.

### Pattern

```typescript
class MyGame extends Game<MyGame, MyPlayer> {
  dealerPosition: number = 1;  // 1-indexed: player 1 starts as dealer

  /**
   * Get the current dealer
   */
  get dealer(): MyPlayer {
    return this.players.get(this.dealerPosition) as MyPlayer;
  }

  /**
   * Get the player to the dealer's left (usually plays first)
   */
  get playerAfterDealer(): MyPlayer {
    return this.players.nextAfter(this.dealer) as MyPlayer;
  }

  /**
   * Rotate dealer to the next player
   */
  rotateDealer(): void {
    const nextDealer = this.players.nextAfter(this.dealer);
    this.dealerPosition = nextDealer.position;
  }
}
```

### In Flow

```typescript
export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      while: () => !game.isFinished(),
      do: sequence(
        // Deal from current dealer
        execute(() => game.deal()),

        // Play round starting from player after dealer
        eachPlayer({
          startingPlayer: () => game.playerAfterDealer,
          do: actionStep({ actions: ['play'] }),
        }),

        // Rotate dealer for next round
        execute(() => game.rotateDealer()),
      ),
    }),
    // ...
  };
}
```

---

## 2. Simultaneous Actions

All players act at the same time (e.g., revealing cards, placing bids).

### Pattern

```typescript
// In flow
simultaneousActionStep({
  name: 'discard-phase',
  actions: ['discard'],
  prompt: 'Discard 2 cards to the crib',

  // Optional: custom completion check per player
  playerDone: (ctx, player) => {
    const p = player as MyPlayer;
    return p.discarded.count(Card) >= 2;
  },

  // Optional: when all players are done
  allDone: (ctx) => {
    return ctx.game.players.every(p => p.discarded.count(Card) >= 2);
  },
})
```

### Manual Tracking Alternative

For more control, track completion manually:

```typescript
class MyGame extends Game<MyGame, MyPlayer> {
  private completedPlayers: Set<number> = new Set();

  playerCompletedAction(player: MyPlayer): void {
    this.completedPlayers.add(player.position);
  }

  allPlayersCompleted(): boolean {
    return this.completedPlayers.size === this.players.length;
  }

  resetCompletedPlayers(): void {
    this.completedPlayers.clear();
  }
}
```

---

## 3. Multi-Turn Same Player (Go Again)

Player continues their turn under certain conditions.

### Pattern: Using Game State

The simplest pattern is to use a game-level property:

```typescript
class MyGame extends Game<MyGame, MyPlayer> {
  playerGoesAgain: boolean = false;
}

export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: loop({
          name: 'player-turn',
          while: () => game.playerGoesAgain,
          do: sequence(
            // Reset go-again flag
            execute(() => { game.playerGoesAgain = false; }),

            // Player takes action
            actionStep({ actions: ['play'] }),

            // Action can set playerGoesAgain = true to continue
          ),
        }),
      }),
    }),
  };
}

// In action execute:
.execute((args, ctx) => {
  // ... action logic ...

  if (shouldGoAgain) {
    ctx.game.playerGoesAgain = true;
  }

  return { success: true };
});
```

### Alternative: Methods Pattern

For more encapsulation, use methods:

```typescript
class MyGame extends Game<MyGame, MyPlayer> {
  private _playerGoesAgain: boolean = false;

  setPlayerGoesAgain(value: boolean): void {
    this._playerGoesAgain = value;
  }

  shouldPlayerGoAgain(): boolean {
    return this._playerGoesAgain;
  }

  resetPlayerGoesAgain(): void {
    this._playerGoesAgain = false;
  }
}

// In flow
loop({
  while: () => game.shouldPlayerGoAgain(),
  do: sequence(
    execute(() => game.resetPlayerGoesAgain()),
    actionStep({ actions: ['play'] }),
  ),
})
```

---

## 4. Multi-Step Move (e.g., Checkers Captures)

A single turn consists of multiple moves.

### Pattern

```typescript
// In flow - allow multiple captures in one turn
loop({
  name: 'capture-chain',
  while: (ctx) => {
    const piece = ctx.get<Piece>('movingPiece');
    return piece && game.canCapture(piece);
  },
  do: actionStep({
    name: 'continue-capture',
    actions: ['capture'],
  }),
})

// Track the moving piece
.execute((args, ctx) => {
  const piece = args.piece as Piece;

  // First move or continuing?
  if (!ctx.get('movingPiece')) {
    ctx.set('movingPiece', piece);
  }

  // Perform capture
  game.performCapture(piece, args.target);

  // If piece can't capture anymore, clear tracking
  if (!game.canCapture(piece)) {
    ctx.set('movingPiece', null);
  }

  return { success: true };
});
```

---

## 5. Hidden Information

Managing what each player can see.

### Hand Cards (Visible to Owner Only)

```typescript
class MyPlayer extends Player {
  hand!: Hand;
}

class MyGame extends Game<MyGame, MyPlayer> {
  constructor(options: GameOptions) {
    super(options);

    for (const player of this.players) {
      player.hand = this.create(Hand, `hand-${player.position}`);
      player.hand.player = player;
      player.hand.contentsVisibleToOwner();
    }
  }
}
```

### Deck (Hidden Until Drawn)

```typescript
this.deck = this.create(Deck, 'deck');
this.deck.contentsHidden();  // No one sees cards in deck
```

### Revealing Cards

```typescript
// Reveal a single card to all players
card.showToAll();

// Reveal to specific players
card.showOnlyTo(player);      // Only this player can see
card.addVisibleTo(player);    // Add player to visibility list

// Hide again (e.g., after showing)
card.hideFromAll();

// Set visibility mode
card.setVisibility('all');     // Everyone sees
card.setVisibility('owner');   // Only owner sees
card.setVisibility('hidden');  // No one sees
```

---

## 6. Piece Promotion

Pieces that change type (e.g., pawns to queens, checkers to kings).

### Pattern: State Property

```typescript
class CheckerPiece extends Piece {
  isKing: boolean = false;

  /**
   * Promote this piece to a king
   */
  promote(): void {
    this.isKing = true;
    // Optionally update visual
    this.$image = this.player?.color === 'black'
      ? '/pieces/black-king.svg'
      : '/pieces/white-king.svg';
  }

  /**
   * Check if this piece can move backward
   */
  canMoveBackward(): boolean {
    return this.isKing;
  }

  /**
   * Get valid move directions
   */
  getMoveDirections(): Array<{ row: number; col: number }> {
    const forward = this.player?.position === 1 ? -1 : 1;  // Player 1 moves "up"

    if (this.isKing) {
      return [
        { row: forward, col: -1 },
        { row: forward, col: 1 },
        { row: -forward, col: -1 },
        { row: -forward, col: 1 },
      ];
    }

    return [
      { row: forward, col: -1 },
      { row: forward, col: 1 },
    ];
  }
}
```

### Check for Promotion in Move Action

```typescript
.execute((args, ctx) => {
  const piece = args.piece as CheckerPiece;
  const destination = args.destination as Cell;

  // Move the piece
  piece.putInto(destination);

  // Check for promotion (player 1 promotes at row 0, player 2 at row 7)
  const promotionRow = piece.player?.position === 1 ? 0 : 7;
  if (destination.row === promotionRow && !piece.isKing) {
    piece.promote();
    game.message(`${piece} was crowned king!`);
  }

  return { success: true };
});
```

---

## 7. Turn-Based Combat

Resolving combat between game pieces.

### Pattern

```typescript
interface CombatResult {
  attacker: Piece;
  defender: Piece;
  attackerDamage: number;
  defenderDamage: number;
  attackerDestroyed: boolean;
  defenderDestroyed: boolean;
}

class MyGame extends Game<MyGame, MyPlayer> {
  /**
   * Resolve combat between two pieces
   */
  resolveCombat(attacker: Piece, defender: Piece): CombatResult {
    // Roll dice or use stats
    const attackRoll = this.random.d6();
    const defendRoll = this.random.d6();

    const attackerPower = (attacker.attack ?? 0) + attackRoll;
    const defenderPower = (defender.defense ?? 0) + defendRoll;

    const result: CombatResult = {
      attacker,
      defender,
      attackerDamage: 0,
      defenderDamage: 0,
      attackerDestroyed: false,
      defenderDestroyed: false,
    };

    if (attackerPower > defenderPower) {
      // Attacker wins
      result.defenderDamage = attackerPower - defenderPower;
      defender.health -= result.defenderDamage;
      result.defenderDestroyed = defender.health <= 0;
    } else if (defenderPower > attackerPower) {
      // Defender wins
      result.attackerDamage = defenderPower - attackerPower;
      attacker.health -= result.attackerDamage;
      result.attackerDestroyed = attacker.health <= 0;
    }
    // Tie: no damage

    // Remove destroyed pieces
    if (result.attackerDestroyed) attacker.remove();
    if (result.defenderDestroyed) defender.remove();

    return result;
  }
}
```

---

## 8. Resource/Economy System

Managing player resources.

### Pattern

```typescript
class MyPlayer extends Player {
  gold: number = 0;
  wood: number = 0;
  food: number = 0;

  /**
   * Check if player can afford a cost
   */
  canAfford(cost: { gold?: number; wood?: number; food?: number }): boolean {
    if (cost.gold && this.gold < cost.gold) return false;
    if (cost.wood && this.wood < cost.wood) return false;
    if (cost.food && this.food < cost.food) return false;
    return true;
  }

  /**
   * Pay a cost (throws if can't afford)
   */
  pay(cost: { gold?: number; wood?: number; food?: number }): void {
    if (!this.canAfford(cost)) {
      throw new Error('Cannot afford this cost');
    }
    this.gold -= cost.gold ?? 0;
    this.wood -= cost.wood ?? 0;
    this.food -= cost.food ?? 0;
  }

  /**
   * Gain resources
   */
  gain(resources: { gold?: number; wood?: number; food?: number }): void {
    this.gold += resources.gold ?? 0;
    this.wood += resources.wood ?? 0;
    this.food += resources.food ?? 0;
  }
}
```

### In Actions

```typescript
Action.create('build')
  .condition({
    'can afford building cost': (ctx) => {
      const player = ctx.player as MyPlayer;
      return player.canAfford({ wood: 5, gold: 2 });
    },
  })
  .execute((args, ctx) => {
    const player = ctx.player as MyPlayer;
    player.pay({ wood: 5, gold: 2 });

    // Create building...

    return { success: true };
  });
```

---

## 9. Area Control / Majority

Determining who controls a zone based on unit count.

### Pattern

```typescript
class Zone extends Space {
  /**
   * Get the player(s) with the most units in this zone
   */
  getControllers(): Player[] {
    const counts = new Map<Player, number>();

    for (const unit of this.all(Unit)) {
      if (unit.player) {
        counts.set(unit.player, (counts.get(unit.player) ?? 0) + 1);
      }
    }

    if (counts.size === 0) return [];

    const maxCount = Math.max(...counts.values());
    const controllers: Player[] = [];

    for (const [player, count] of counts) {
      if (count === maxCount) {
        controllers.push(player);
      }
    }

    return controllers;
  }

  /**
   * Get the single controller, or null if contested/empty
   */
  getController(): Player | null {
    const controllers = this.getControllers();
    return controllers.length === 1 ? controllers[0] : null;
  }

  /**
   * Check if a player controls this zone
   */
  isControlledBy(player: Player): boolean {
    const controller = this.getController();
    return controller?.position === player.position;
  }
}
```

---

## 10. Victory Point Scoring

Tracking and calculating victory points.

### Pattern

```typescript
interface ScoreBreakdown {
  cards: number;
  territories: number;
  bonuses: number;
  total: number;
}

class MyPlayer extends Player {
  /**
   * Calculate this player's score
   */
  calculateScore(game: MyGame): ScoreBreakdown {
    const cardPoints = this.hand.sum((card) => card.pointValue);

    const territoryPoints = game.zones
      .filter(z => z.isControlledBy(this))
      .reduce((sum, z) => sum + z.pointValue, 0);

    const bonusPoints = this.calculateBonuses(game);

    return {
      cards: cardPoints,
      territories: territoryPoints,
      bonuses: bonusPoints,
      total: cardPoints + territoryPoints + bonusPoints,
    };
  }

  private calculateBonuses(game: MyGame): number {
    let bonus = 0;

    // Longest road bonus
    if (game.hasLongestRoad(this)) {
      bonus += 5;
    }

    // Most cards bonus
    if (game.hasMostCards(this)) {
      bonus += 3;
    }

    return bonus;
  }
}

class MyGame extends Game<MyGame, MyPlayer> {
  override getWinners(): MyPlayer[] {
    const scores = this.players.map(p => ({
      player: p,
      score: p.calculateScore(this),
    }));

    const maxScore = Math.max(...scores.map(s => s.score.total));

    return scores
      .filter(s => s.score.total === maxScore)
      .map(s => s.player);
  }
}
```

---

## 13. Multi-Phase Actions (Action Chaining)

Many complex game actions need to show updated state between phases. Use `followUp` to chain actions together seamlessly.

### Pattern: Explore and Collect

```typescript
// First action: performs exploration and draws items
Action.create('explore')
  .chooseElement('unit', { elementClass: Unit })
  .execute((args, ctx) => {
    const unit = args.unit as Unit;
    const location = unit.location;

    // Draw items to location
    for (let i = 0; i < location.lootCount; i++) {
      const item = ctx.game.drawItem();
      if (item) item.putInto(location.itemsZone);
    }
    location.explored = true;

    // Chain to collect - UI will show drawn items
    return {
      success: true,
      followUp: location.itemsZone.count() > 0
        ? { action: 'collect', args: { unitId: unit.id, locationId: location.id } }
        : undefined,
    };
  });

// Second action: picks from drawn items
Action.create('collect')
  .fromElements<Item>('item', {
    elements: (ctx) => {
      const location = ctx.game.getElementById(ctx.args.locationId);
      return [...location.itemsZone.all(Item)];
    },
    optional: 'Done',
  })
  .execute((args, ctx) => {
    if (args.item) {
      const unit = ctx.game.getElementById(ctx.args.unitId);
      (args.item as Item).putInto(unit.inventoryZone);
    }
    return { success: true };
  });
```

### Key Benefits

1. **State visibility**: UI updates between explore and collect
2. **Context preserved**: unitId and locationId flow automatically
3. **Seamless UX**: feels like one action to the player
4. **Conditional**: only chains if there are items to collect

### When to Use

- After combat: resolve abilities, loot defeated enemies
- After exploration: collect discovered items
- After card play: trigger effects that require choices
- After movement: interact with new location

See [Action Chaining](./actions-and-flow.md#action-chaining-with-followup) for complete documentation.

---

## See Also

- [Common Pitfalls](./common-pitfalls.md) - Mistakes to avoid
- [Actions & Flow](./actions-and-flow.md) - Action and flow details
- [Game Examples](./game-examples.md) - Complete game implementations
````

## File: docs/conditions.md
````markdown
# Conditions

Conditions control when actions are available to players. They use labeled predicates that provide automatic debug tracing.

## Basic Usage

```typescript
Action.create('draw')
  .condition({
    'deck has cards': (ctx) => game.deck.count(Card) > 0,
  })
  .execute(...)
```

The key (`'deck has cards'`) is a human-readable label. When this condition fails, the debug panel shows:

```
Action 'draw' unavailable:
  ✗ deck has cards (FAILED)
```

## Multiple Conditions

All conditions must pass for the action to be available:

```typescript
Action.create('purchase')
  .condition({
    'player can afford cost': (ctx) => ctx.player.gold >= 10,
    'item is available': (ctx) => game.shop.count(Item) > 0,
    'shop is open': (ctx) => game.phase === 'shopping',
  })
  .execute(...)
```

Debug output shows each condition's result:

```
Action 'purchase' unavailable:
  ✓ player can afford cost (passed)
  ✗ item is available (FAILED)
  ✓ shop is open (passed)
```

## Writing Good Labels

Labels should describe **WHY** the condition exists, not **WHAT** it checks:

| Good Label | Bad Label |
|------------|-----------|
| `'player can afford cost'` | `'gold >= 10'` |
| `'in play phase'` | `'phase === play'` |
| `'has cards to discard'` | `'hand.count > 0'` |
| `'target in range'` | `'distance <= 3'` |
| `'is player turn'` | `'currentPlayer === player'` |

Good labels read like natural English and explain intent.

## Complex Conditions

For conditions with complex logic, keep the predicate function readable:

```typescript
.condition({
  'can continue multi-jump': (ctx) => {
    const piece = game.multiJumpPiece;
    if (!piece) return true;  // No multi-jump in progress
    return game.getJumpMoves(piece).length === 0;
  },
})
```

## Examples

### Phase Check

```typescript
.condition({
  'in discarding phase': (ctx) => game.phase === 'discarding',
  'has cards to discard': (ctx) => game.getPlayerHand(ctx.player).count(Card) > 4,
})
```

### Resource Check

```typescript
.condition({
  'can afford building cost': (ctx) => {
    const player = ctx.player as MyPlayer;
    return player.canAfford({ wood: 5, gold: 2 });
  },
})
```

### Game State Check

```typescript
.condition({
  'player can take action': (ctx) => game.canTakeAction(ctx.player as MyPlayer),
})
```

## See Also

- [Actions & Flow](./actions-and-flow.md#conditions) - Conditions in context
- [Common Patterns](./common-patterns.md) - More condition examples
````

## File: docs/game-examples.md
````markdown
# Game Examples & Patterns

This document analyzes the example games in `packages/games/` to demonstrate common patterns and best practices.

## Example Games Overview

| Game | Location | Complexity | Key Patterns |
|------|----------|-----------|--------------|
| Hex | `packages/games/hex/` | Simple | Hex grid, path-finding, simple flow |
| Go Fish | `packages/games/go-fish/` | Medium | Cards, hidden info, conditional turns |
| Checkers | `packages/games/checkers/` | Medium | Square grid, multi-step actions, piece promotion |
| Cribbage | `packages/games/cribbage/` | Complex | Multi-phase, simultaneous actions, complex scoring |

---

## Hex - Simplest Example

**Location**: `packages/games/hex/`

Hex is the simplest example, demonstrating core patterns with minimal complexity.

### Key Features
- Hex grid board
- Simple alternating turns
- Path-finding win condition
- Single action type

### Game Structure

```typescript
// game.ts
export class HexGame extends Game<HexGame, HexPlayer> {
  board!: Board;
  winner?: HexPlayer;

  constructor(options: HexOptions) {
    super(options);

    // Register elements
    this.registerElements([Board, Cell, Stone]);

    // Create hex board
    this.board = this.create(Board, 'board', { boardSize: 7 });
    for (let r = 0; r < 7; r++) {
      for (let q = 0; q < 7; q++) {
        this.board.create(Cell, `cell-${q}-${r}`, { q, r });
      }
    }

    // Single action
    this.registerAction(createPlaceStoneAction(this));
    this.setFlow(createHexFlow(this));
  }
}
```

### Simple Flow

```typescript
// flow.ts
export function createHexFlow(game: HexGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: actionStep({
          actions: ['placeStone'],
          skipIf: () => game.isFinished(),
        }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.winner ? [game.winner] : [],
  };
}
```

### Element with Board Reference

```typescript
// actions.ts
Action.create('placeStone')
  .chooseElement<Cell>('cell', {
    filter: (cell) => cell.isEmpty(),
    boardRef: (cell) => ({
      id: cell.id,
      notation: cell.notation,
    }),
  })
  .execute((args, ctx) => {
    const cell = args.cell as Cell;
    cell.create(Stone, `stone-${player.position}`, { player });

    // Check win condition
    if (game.board.checkWin(player)) {
      game.setWinner(player);
    }
  });
```

### Pattern: Custom Element Classes

```typescript
// elements.ts
export class Cell extends HexCell {
  q!: number;
  r!: number;

  get notation(): string {
    return `${String.fromCharCode(97 + this.q)}${this.r + 1}`;
  }

  isEmpty(): boolean {
    return this.count(Stone) === 0;
  }
}
```

---

## Go Fish - Card Game Patterns

**Location**: `packages/games/go-fish/`

Go Fish demonstrates card game patterns including hidden information and conditional turns.

### Key Features
- Standard deck creation
- Private hands with visibility
- Player interaction (asking)
- Conditional turns (go again if match)
- Book collection

### Hidden Information

```typescript
// game.ts
constructor(options) {
  // Create player hands - hidden from other players
  for (const player of this.players) {
    const hand = this.create(Hand, `hand-${player.position}`);
    hand.player = player;
    hand.contentsVisibleToOwner();  // Only owner sees their cards
  }

  // The pond (draw pile) - hidden
  this.pond = this.create(Pond, 'pond');
  this.pond.contentsHidden();
}
```

### Conditional Turns (Extra Turn Logic)

```typescript
// flow.ts - Turn loop with extra turns
const playerTurn = sequence(
  setVar('extraTurn', false),
  setVar('turnEnded', false),

  loop({
    name: 'turn-loop',
    while: (ctx) => {
      if (ctx.get('turnEnded')) return false;
      // ... other conditions
      return true;
    },
    do: sequence(
      actionStep({ actions: ['ask'] }),
      execute((ctx) => {
        const extraTurn = ctx.lastActionResult?.data?.extraTurn;
        if (!extraTurn) {
          ctx.set('turnEnded', true);
        }
      }),
    ),
  }),
);
```

### Action with Extra Turn Signal

```typescript
// actions.ts
.execute((args, ctx) => {
  const matchingCards = target.hand.all(Card).filter(c => c.rank === rank);

  if (matchingCards.length > 0) {
    for (const card of matchingCards) {
      card.putInto(player.hand);
    }
    // Signal extra turn
    return { success: true, data: { extraTurn: true } };
  } else {
    game.drawFromPond(player);
    return { success: true, data: { extraTurn: false } };
  }
});
```

### Pattern: Book/Set Collection

```typescript
// game.ts
checkForBooks(player: GoFishPlayer): void {
  const hand = this.getPlayerHand(player);
  const cards = hand.all(Card);

  // Count cards by rank
  const rankCounts = new Map<string, Card[]>();
  for (const card of cards) {
    const existing = rankCounts.get(card.rank) || [];
    existing.push(card);
    rankCounts.set(card.rank, existing);
  }

  // Create books for complete sets
  for (const [rank, rankCards] of rankCounts) {
    if (rankCards.length === 4) {
      const book = this.books.create(Book, `book-${rank}`, { rank, player });
      for (const card of rankCards) {
        card.putInto(book);
      }
      player.score++;
    }
  }
}
```

---

## Checkers - Grid & Multi-Step Actions

**Location**: `packages/games/checkers/`

Checkers demonstrates square grids, forced moves, and multi-step actions.

### Key Features
- 8x8 square grid
- Jump chains (multi-step moves)
- Forced jump rule
- Piece promotion (kings)

### Grid Setup

```typescript
// game.ts
constructor(options) {
  this.board = this.create(Board, 'board');
  this.board.contentsVisible();

  // Create 8x8 grid
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const cell = this.board.create(Cell, `cell-${col}-${row}`, {
        col, row,
        isPlayable: (row + col) % 2 === 1,  // Dark squares only
      });
    }
  }

  // Place initial pieces
  this.setupInitialPieces();
}
```

### Multi-Step Action (Jump Chain)

```typescript
// actions.ts - Handling jump chains
Action.create('move')
  .chooseElement<Piece>('piece', {
    filter: (piece, ctx) => {
      const game = ctx.game as CheckersGame;
      // If there's a pending jump, only that piece can continue
      if (game.pendingJumpPiece) {
        return piece === game.pendingJumpPiece;
      }
      return piece.player === ctx.player && game.hasValidMoves(piece);
    },
  })
  .chooseElement<Cell>('destination', {
    filter: (cell, ctx) => {
      const piece = ctx.args.piece as Piece;
      return game.isValidMove(piece, cell);
    },
  })
  .execute((args, ctx) => {
    const piece = args.piece as Piece;
    const dest = args.destination as Cell;

    const isJump = game.isJumpMove(piece, dest);
    piece.putInto(dest);

    if (isJump) {
      game.captureJumpedPiece(piece, dest);

      // Check for additional jumps
      if (game.canContinueJumping(piece)) {
        game.pendingJumpPiece = piece;
        game.setPlayerGoesAgain(true);
      } else {
        game.pendingJumpPiece = null;
      }
    }

    // Check for promotion
    if (game.shouldPromote(piece)) {
      piece.isKing = true;
    }
  });
```

### Forced Move Logic

```typescript
// game.ts
getValidMoves(player: CheckersPlayer): Move[] {
  const pieces = this.board.all(Piece).filter(p => p.player === player);

  // Check for forced jumps
  const jumpMoves = [];
  for (const piece of pieces) {
    jumpMoves.push(...this.getJumpMoves(piece));
  }

  // If jumps available, must take one
  if (jumpMoves.length > 0) {
    return jumpMoves;
  }

  // Otherwise, regular moves
  return pieces.flatMap(p => this.getRegularMoves(p));
}
```

---

## Cribbage - Complex Multi-Phase Game

**Location**: `packages/games/cribbage/`

Cribbage is the most complex example, demonstrating multi-phase flow, simultaneous actions, and complex scoring.

### Key Features
- Multi-phase rounds (deal, discard, play, show)
- Simultaneous actions (both players discard at once)
- Complex scoring logic
- Running count during play
- "Go" mechanics

### Multi-Phase Flow

```typescript
// flow.ts
const playRound = sequence(
  // Initialize round
  execute((ctx) => game.startNewRound()),

  // Discard phase - simultaneous
  phase('discarding', {
    do: simultaneousActionStep({
      actions: ['discard'],
      prompt: 'Discard 2 cards to the crib',
      playerDone: (ctx, player) => {
        const hand = game.getPlayerHand(player);
        return hand.count(Card) <= 4;  // Done when 4 cards left
      },
      allDone: (ctx) => game.allPlayersDiscarded(),
    }),
  }),

  // Store hands before play
  execute(() => game.storeOriginalHands()),

  // Cut starter
  execute(() => game.cutStarterCard()),

  // Play phase - alternating turns
  phase('play', { do: playPhaseSequence }),

  // Scoring phase
  phase('scoring', {
    do: sequence(
      execute(() => game.scoreRoundAndBuildSummary()),
      simultaneousActionStep({
        actions: ['acknowledgeScore'],
        allDone: () => !game.roundSummary.active,
      }),
    ),
  }),

  // Rotate dealer
  execute(() => game.rotateDealer()),
);
```

### Simultaneous Actions

```typescript
// Both players discard at the same time
simultaneousActionStep({
  name: 'simultaneous-discard',
  actions: ['discard'],
  prompt: 'Discard 2 cards to the crib',
  playerDone: (ctx, player) => {
    const hand = game.getPlayerHand(player as CribbagePlayer);
    return hand.count(Card) <= 4;
  },
  allDone: (ctx) => {
    return game.allPlayersDiscarded() || game.isFinished();
  },
});
```

### Phase Lifecycle Hooks

```typescript
// flow.ts
return {
  root: /* ... */,
  isComplete: /* ... */,
  getWinners: /* ... */,

  // Phase lifecycle hooks
  onEnterPhase: (phaseName, ctx) => {
    const game = ctx.game as CribbageGame;
    game.cribbagePhase = phaseName;

    const phaseNames = {
      discarding: 'DISCARD PHASE',
      play: 'PLAY PHASE',
      scoring: 'SCORING PHASE',
    };
    game.message(`=== ${phaseNames[phaseName]} ===`);
  },
};
```

### Complex Play Phase with Go

```typescript
// Play phase loop with "Go" mechanics
loop({
  name: 'play-loop',
  while: () => !game.allCardsPlayed() && !game.isFinished(),
  do: sequence(
    // Check if count needs reset
    execute(() => {
      const currentStuck = currentSaidGo || !currentCanPlay;
      const otherStuck = otherSaidGo || !otherCanPlay;

      if (currentStuck && otherStuck && (hasCards)) {
        // Award "Go" point
        if (game.runningTotal < 31) {
          game.addPoints(lastPlayer, 1, 'Go');
        }
        game.resetCount();
      }
    }),

    // Player plays or says Go
    actionStep({
      player: () => game.getCurrentPlayPlayer(),
      actions: ['playCard', 'sayGo'],
      skipIf: () => playerAlreadySaidGo || !hasCards,
    }),

    // Switch turns
    execute(() => {
      if (!otherSaidGo && otherHasCards) {
        game.switchPlayTurn();
      }
    }),
  ),
});
```

### Scoring System

```typescript
// scoring.ts - Complex scoring calculation
export function scoreHand(cards: Card[], starter: Card, isCrib: boolean): ScoreBreakdown {
  const allFive = [...cards, starter];
  const breakdown: ScoreBreakdown = { fifteens: 0, pairs: 0, runs: 0, flush: 0, nobs: 0 };

  // Score 15s (combinations summing to 15)
  breakdown.fifteens = scoreFifteens(allFive);

  // Score pairs
  breakdown.pairs = scorePairs(allFive);

  // Score runs (sequences)
  breakdown.runs = scoreRuns(allFive);

  // Score flush (requires 4 in hand, or 5 total for crib)
  breakdown.flush = scoreFlush(cards, starter, isCrib);

  // Score nobs (Jack of starter suit)
  breakdown.nobs = scoreNobs(cards, starter);

  return breakdown;
}
```

---

## Common Patterns Summary

### 1. Game Initialization

```typescript
constructor(options) {
  super(options);
  this.registerElements([...]);  // Always register elements
  // Create board/deck
  // Register actions
  this.setFlow(createGameFlow(this));
}
```

### 2. Custom Player Classes

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  hand!: Hand;
  score: number = 0;  // Auto-serialized
  abilities: Record<string, number> = {};  // Auto-serialized

  constructor(position: number, name: string, game: MyGame) {
    super(position, name);
    this.game = game;
    this.hand = game.create(Hand, `hand-${position}`);
    this.hand.player = this;
  }
  // No toJSON override needed - simple properties are auto-serialized
}
```

> **Note**: Simple properties (numbers, strings, plain objects) are auto-serialized. Only override `toJSON()` when using classes with their own `toJSON()` methods (like `AbilityManager`).

### 3. Win Condition Checking

```typescript
override isFinished(): boolean {
  return this.winner !== undefined || /* other condition */;
}

override getWinners(): MyPlayer[] {
  if (!this.isFinished()) return [];
  return this.winner ? [this.winner] : [];
}
```

### 4. Action Result Data

```typescript
.execute((args, ctx) => {
  // ... game logic ...
  return {
    success: true,
    message: 'Action completed',
    data: {
      extraTurn: shouldGoAgain,  // Can be read by flow
      customData: 'anything',
    },
  };
});
```

### 5. Flow Variables

```typescript
sequence(
  setVar('roundNumber', 1),
  loop({
    while: (ctx) => ctx.get('roundNumber') <= 10,
    do: sequence(
      /* round logic */,
      execute((ctx) => ctx.set('roundNumber', ctx.get('roundNumber') + 1)),
    ),
  }),
)
```

### 6. Visibility Control

```typescript
// Hidden from everyone
deck.contentsHidden();

// Visible to everyone
board.contentsVisible();

// Only owner sees
hand.contentsVisibleToOwner();
```

## Related Documentation

- [Getting Started](./getting-started.md) - Create your first game
- [Core Concepts](./core-concepts.md) - Element tree, visibility, state
- [Actions & Flow](./actions-and-flow.md) - Action and flow API details
````

## File: packages/ai/README.md
````markdown
# @boardsmith/ai

MCTS (Monte Carlo Tree Search) AI bot for BoardSmith games. Provides generic AI opponents that work with any game.

## Installation

```bash
npm install @boardsmith/ai
```

## Quick Start

```typescript
import { createBot } from '@boardsmith/ai';
import { CheckersGame, gameDefinition } from './my-game';

// Create a bot for player 1
const bot = createBot(
  game,
  CheckersGame,
  'checkers',
  1,  // player index
  actionHistory,
  'hard'  // difficulty
);

// Get the bot's move
const move = await bot.play();
console.log(move.action, move.args);

// Apply the move
await session.performAction(move.action, 1, move.args);
```

## Difficulty Levels

| Level | Iterations | Timeout | Description |
|-------|------------|---------|-------------|
| `easy` | 3 | 1s | Quick, makes mistakes |
| `medium` | 5 | 1.5s | Balanced play |
| `hard` | 8 | 2s | Strong play |

You can also pass a custom iteration count:

```typescript
const bot = createBot(game, GameClass, 'my-game', 1, history, 15);
```

## Custom Objectives

For smarter AI, define objectives that give partial credit during playouts:

```typescript
import { createBot, AIConfig } from '@boardsmith/ai';

const aiConfig: AIConfig = {
  objectives: (game, playerIndex) => ({
    'material advantage': {
      checker: (g, p) => {
        const myPieces = g.board.all(Piece).filter(p => p.owner === p);
        const theirPieces = g.board.all(Piece).filter(p => p.owner !== p);
        return myPieces.length > theirPieces.length;
      },
      weight: 0.5,  // 0-1, how important this objective is
    },
    'center control': {
      checker: (g, p) => g.centerSquares.some(s => s.piece?.owner === p),
      weight: 0.3,
    },
  }),
};

const bot = createBot(game, GameClass, 'my-game', 1, history, 'hard', aiConfig);
```

## API Reference

### createBot()

```typescript
function createBot<G extends Game>(
  game: G,
  GameClass: GameClass<G>,
  gameType: string,
  playerIndex: number,
  actionHistory?: SerializedAction[],
  difficulty?: DifficultyLevel | number,
  aiConfig?: AIConfig
): MCTSBot<G>
```

### MCTSBot

```typescript
class MCTSBot<G extends Game> {
  /** Get the best move found by MCTS */
  async play(): Promise<BotMove>;
}
```

### Types

```typescript
interface BotMove {
  action: string;
  args: Record<string, unknown>;
}

interface BotConfig {
  iterations: number;      // MCTS iterations (default: 100)
  playoutDepth: number;    // Max depth before evaluating (default: 5)
  seed?: string;           // Random seed for reproducibility
  async?: boolean;         // Yield to event loop (default: true)
  timeout?: number;        // Max time in ms (default: 2000)
}

interface AIConfig {
  objectives?: (game: Game, playerIndex: number) => Record<string, Objective>;
}

interface Objective {
  checker: (game: Game, playerIndex: number) => boolean;
  weight: number;  // Positive = good for player, negative = bad
}
```

## Integration with Session

The `@boardsmith/session` package has built-in AI controller support:

```typescript
import { GameSession, AIController } from '@boardsmith/session';

const ai = new AIController({
  level: 'medium',
  players: [1],  // AI controls player 1
});

// In your game loop
if (ai.isAIPlayer(currentPlayer)) {
  const move = await ai.getMove(session);
  await session.performAction(move.action, move.player, move.args);
}
```

## CLI Integration

Use AI players in local development:

```bash
# Player 1 is AI with hard difficulty
npx boardsmith dev --ai 1 --ai-level hard

# Multiple AI players
npx boardsmith dev --ai 0 2 --ai-level medium
```

## See Also

- [@boardsmith/session](../session/README.md) - Game session with AI controller
- [@boardsmith/ai-trainer](../ai-trainer/README.md) - Train custom AI through self-play
````

## File: packages/ai-trainer/README.md
````markdown
# @boardsmith/ai-trainer

Automatic AI training for BoardSmith games through self-play simulation. Generates optimized `ai.ts` files with learned objectives.

## AI Generation Tiers

BoardSmith provides three tiers of AI generation, each suited for different needs:

### Tier 1: Zero-Config Heuristics (Automatic)

When no `ai.ts` file exists, the MCTS bot uses built-in heuristics based on game structure. This provides reasonable AI behavior out of the box with zero configuration.

**Best for:** Rapid prototyping, simple games, getting started quickly.

### Tier 2: Self-Play Training (`boardsmith train-ai`)

Automated training through self-play simulation. The trainer introspects your game, generates candidate features, runs simulations, and learns which features correlate with winning.

```bash
npx boardsmith train-ai
```

**Best for:** Production-quality AI, games where patterns can be learned from outcomes.

### Tier 3: LLM-Assisted Generation (`/generate-ai`)

Interactive AI generation using Claude Code. The LLM analyzes your game rules, asks strategic questions, and generates custom evaluation functions based on game-specific understanding.

```
/generate-ai
```

**Best for:** Complex strategy games, games requiring domain knowledge, fine-tuned behavior.

Install Claude Code slash commands with:
```bash
npx boardsmith claude install
```

## Installation

```bash
npm install @boardsmith/ai-trainer
```

## Quick Start

The easiest way to train AI is via the CLI:

```bash
npx boardsmith train-ai
```

This will:
1. Introspect your game structure
2. Generate candidate features
3. Run self-play simulations
4. Analyze which features correlate with winning
5. Generate an `ai.ts` file with learned objectives

## Programmatic Usage

```typescript
import { ParallelTrainer } from '@boardsmith/ai-trainer';
import { gameDefinition } from './my-game';

const trainer = new ParallelTrainer(
  gameDefinition.gameClass,
  'my-game',
  '/path/to/compiled/game.js', // Required for worker threads
  {
    gamesPerIteration: 200,
    iterations: 5,
  }
);

const result = await trainer.train();

console.log('Learned objectives:', result.objectives);
console.log('Action preferences:', result.actionPreferences);
```

## Training Pipeline

### 1. Introspection

Analyze game structure to understand elements, actions, and complexity:

```typescript
import { introspectGame, printGameStructure } from '@boardsmith/ai-trainer';

const structure = introspectGame(gameDefinition);
printGameStructure(structure);

// Output:
// Game: Checkers
// Players: 2
// Element Types: Piece (24), Board (1), Cell (64)
// Actions: move, jump, endTurn
// Estimated complexity: medium
```

### 2. Feature Generation

Generate candidate features that might predict winning:

```typescript
import { generateCandidateFeatures, printFeatures } from '@boardsmith/ai-trainer';

const features = generateCandidateFeatures(structure);
printFeatures(features);

// Output:
// Position Features:
//   - pieces_in_center: Count of pieces in center squares
//   - pieces_advanced: Count of pieces past midline
// Material Features:
//   - piece_count: Total pieces owned
//   - piece_advantage: My pieces - opponent pieces
```

### 3. Simulation

Run self-play games and collect data:

```typescript
import { runSimulations } from '@boardsmith/ai-trainer';

const results = await runSimulations(gameDefinition, {
  games: 200,
  features,
  mctsIterations: 3,
  onProgress: (current, total) => console.log(`${current}/${total}`),
});

console.log(`Completed ${results.gamesPlayed} games`);
console.log(`Average game length: ${results.averageTurns} turns`);
```

### 4. Analysis

Determine which features correlate with winning:

```typescript
import { analyzeFeatures, selectTopFeatures } from '@boardsmith/ai-trainer';

const analysis = analyzeFeatures(results.gameData, features);
const topFeatures = selectTopFeatures(analysis, { maxFeatures: 5 });

for (const feature of topFeatures) {
  console.log(`${feature.name}: correlation ${feature.correlation.toFixed(3)}`);
}
```

### 5. Code Generation

Generate the `ai.ts` file:

```typescript
import { generateAICode } from '@boardsmith/ai-trainer';

const code = generateAICode({
  objectives: topFeatures.map(f => ({
    name: f.name,
    weight: correlationToWeight(f.correlation),
    checker: f.checker,
  })),
  actionPreferences: analysis.actionPreferences,
});

fs.writeFileSync('rules/ai.ts', code);
```

## Incremental Training

Start from an existing `ai.ts` file and improve it:

```typescript
import { ParallelTrainer } from '@boardsmith/ai-trainer';

// Train with existing AI file as starting point
const trainer = new ParallelTrainer(
  gameDefinition.gameClass,
  'my-game',
  '/path/to/compiled/game.js',
  {
    existingAIPath: 'rules/ai.ts', // Will parse and build upon existing objectives
    iterations: 3,
  }
);

const result = await trainer.train();
```

## Feature Templates

Built-in feature templates for common patterns:

```typescript
import { FEATURE_TEMPLATES } from '@boardsmith/ai-trainer';

// Available templates:
// - position_control: Center, corners, edges
// - material_count: Piece counts and advantages
// - mobility: Available moves
// - threats: Attack and defense positions
// - progress: Advancement toward goals
```

## API Reference

### ParallelTrainer

```typescript
class ParallelTrainer {
  constructor(
    GameClass: GameClass,
    gameType: string,
    gameModulePath: string,  // Path to compiled .js file (required for workers)
    config?: ParallelTrainingConfig
  )

  train(): Promise<TrainingResult>
}

interface ParallelTrainingConfig {
  gamesPerIteration?: number;  // Default: 200
  iterations?: number;         // Default: 5
  mctsIterations?: number;     // Default: 15
  workerCount?: number;        // Default: CPU cores - 1
  existingAIPath?: string;     // Path to existing ai.ts to build upon
  evolve?: boolean;            // Enable evolutionary weight optimization
  evolutionGenerations?: number; // Default: 5
  evolutionLambda?: number;    // Population size, default: 20
  onProgress?: (progress: TrainingProgress) => void;
}

interface TrainingResult {
  objectives: LearnedObjective[];
  actionPreferences: LearnedActionPreference[];
  metadata: {
    gamesPlayed: number;
    totalStates: number;
    finalWinRate: number;
  };
}
```

### introspectGame()

```typescript
function introspectGame(gameDefinition: GameDefinition): GameStructure

interface GameStructure {
  gameName: string;
  playerCount: { min: number; max: number };
  elementTypes: ElementTypeInfo[];
  actions: string[];
  spatialInfo: SpatialInfo;
  complexity: GameComplexity;
}
```

## Parallel Training

Training always uses parallel mode with worker threads for maximum performance:

```bash
npx boardsmith train-ai --workers 8  # Use 8 workers (default: CPU cores - 1)
```

This distributes game simulations and evolution benchmarks across multiple CPU cores.

### Performance

Parallel training achieves significant speedup on multi-core systems:

| Workers  | Time (50 games) | CPU Usage | Speedup |
|----------|-----------------|-----------|---------|
| 1        | 171s            | ~100%     | 1x      |
| 11       | 21s             | ~970%     | 8.3x    |

*Benchmark: Go Fish game on Apple M3 Pro (12 cores)*

### How It Works

1. The main process generates game seeds and distributes work to workers
2. Each worker runs simulations independently with its own game instance
3. Results are aggregated for feature analysis
4. Evolution benchmarks also run in parallel across workers
5. Same seed produces identical aggregate results regardless of worker count (deterministic)

## CLI Options

```bash
npx boardsmith train-ai [options]

Options:
  -g, --games <count>       Games per iteration (default: 200)
  -i, --iterations <count>  Training iterations (default: 5)
  -o, --output <path>       Output path for ai.ts
  -m, --mcts <iterations>   MCTS iterations per move (default: 15)
  --fresh                   Ignore existing ai.ts and start fresh
  --workers <count>         Number of worker threads (default: CPU cores - 1)
  --evolve                  Enable evolutionary weight optimization
  --generations <count>     Evolution generations (default: 5)
  --population <count>      Evolution population size (default: 20)
  -v, --verbose             Show detailed progress
```

## See Also

- [@boardsmith/ai](../ai/README.md) - MCTS bot that uses trained objectives
- [Common Patterns](../../docs/common-patterns.md) - AI integration patterns
````

## File: packages/engine/ARCHITECTURE.md
````markdown
# BoardSmith Engine Architecture

## Core Concepts

### Actions vs Commands

BoardSmith uses a two-layer architecture for handling player operations:

#### **Actions** (High-Level, Game-Specific)

**Location:** `src/action/`

Actions represent what **players do** in the game from a game design perspective. They are:

- **High-level operations**: "move piece", "draw card", "ask for rank"
- **Game-specific**: Defined by game designers for their particular game
- **Declarative**: Describe *what* players want to do, not *how* to do it
- **User-facing**: Have prompts, selections, and validation for the UI

**Example:**
```typescript
const moveAction = Action.create('move')
  .prompt('Move a piece')
  .chooseElement('from', { prompt: 'Select piece to move' })
  .chooseFrom('to', { prompt: 'Select destination', choices: getValidMoves })
  .execute((args, ctx) => {
    // This execute function generates Commands
    const piece = args.from as Piece;
    const destination = args.to as Space;
    piece.putInto(destination); // ← Generates MoveCommand internally
  });
```

#### **Commands** (Low-Level, Event-Sourced)

**Location:** `src/command/`

Commands represent **low-level state mutations** that modify the game tree. They are:

- **Low-level operations**: `CreateElementCommand`, `MoveCommand`, `SetAttributeCommand`
- **Generic**: Same commands work for any game
- **Imperative**: Direct instructions to modify state
- **Event-sourced**: Tracked, serializable, and replayable
- **Internal**: Not exposed to game designers directly

**Example:**
```typescript
// When piece.putInto(destination) is called, it generates:
{
  type: 'move',
  elementId: piece.id,
  targetId: destination.id,
  position: 'last'
}
```

### Why This Separation?

#### 1. **Separation of Concerns**
- **Actions** handle game logic and player intent
- **Commands** handle state management and persistence

#### 2. **Event Sourcing**
- Commands form an event log that can be:
  - Replayed for debugging
  - Stored for game history
  - Used for undo/redo
  - Validated and sanitized

#### 3. **Flexibility**
- Game designers work with intuitive Actions
- Engine manages state changes via Commands
- UI can be auto-generated from Action metadata

#### 4. **Security**
- Commands are validated before execution
- Players can't directly manipulate state
- All mutations go through the command system

### Flow Diagram

```
┌─────────────────────────────────────────────────────┐
│ Player selects action in UI                        │
└─────────────────┬───────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────┐
│ Action System (High-Level)                          │
│ - Validates selections                              │
│ - Executes game logic                               │
│ - Calls element methods (putInto, create, etc.)    │
└─────────────────┬───────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────┐
│ Command System (Low-Level)                          │
│ - Generates MoveCommand, CreateElementCommand, etc.│
│ - Validates against current state                   │
│ - Executes state mutations                          │
│ - Logs for event sourcing                           │
└─────────────────┬───────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────┐
│ Game State Updated                                  │
└─────────────────────────────────────────────────────┘
```

### Comparison to Other Patterns

#### Redux/Vuex (Frontend State Management)
- **Actions** = Actions (user intent)
- **Commands** = Mutations (state changes)
- Similar pattern, different domain

#### Event Sourcing (Backend Architecture)
- **Actions** = Commands (user intent)
- **Commands** = Events (things that happened)
- BoardSmith uses imperative commands, not past-tense events

#### CQRS (Command Query Responsibility Segregation)
- **Actions** = Application commands
- **Commands** = Domain events
- Similar layering concept

## When to Use Which?

### Game Designers Use: **Actions**

```typescript
// Define what players can do
const askAction = Action.create('ask')
  .chooseFrom('target', { choices: (ctx) => game.playerChoices({ excludeSelf: true, currentPlayer: ctx.player }) })
  .chooseFrom('rank', { choices: ['A', '2', '3', ...] })
  .execute((args, ctx) => {
    // Game logic here
  });
```

### Engine Developers Use: **Commands**

```typescript
// Internal state mutations
executeCommand({
  type: 'move',
  elementId: 42,
  targetId: 17,
});
```

### Element Methods Generate: **Commands**

```typescript
// Game designers call this
piece.putInto(destination);

// Which internally generates this command
{
  type: 'move',
  elementId: piece.id,
  targetId: destination.id,
}
```

## Best Practices

### ✅ Do

- Use Actions for game-specific player operations
- Use element methods (`putInto`, `create`) which generate Commands
- Let the command system handle state mutations
- Keep Action execute functions focused on game logic

### ❌ Don't

- Don't manually create Commands in game code
- Don't bypass the Action system for player operations
- Don't directly mutate element properties (use `setAttribute` if needed)
- Don't mix UI concerns into Action execute functions

## Related Documentation

- **[Action API](src/action/README.md)** - Creating player actions
- **[Command Types](src/command/types.ts)** - Available command types
- **[Element System](src/element/README.md)** - Game element tree structure
- **[Flow System](src/flow/README.md)** - Game flow control

---

**Summary:** Actions are what players *do*. Commands are how the engine *does it*.
````

## File: packages/engine/README.md
````markdown
# @boardsmith/engine

Core game engine for BoardSmith. Provides the element system, actions, flow control, and command execution.

## Installation

```bash
npm install @boardsmith/engine
```

## Core Concepts

### Element System

Build your game state as a tree of elements:

```typescript
import { Game, Card, Deck, Hand, Space, Piece } from '@boardsmith/engine';

class MyGame extends Game {
  deck: Deck<PlayingCard>;
  players: PlayerCollection<MyPlayer>;

  constructor(options: GameOptions) {
    super(options);

    // Register custom element classes for serialization
    this.registerElements([PlayingCard, MyPlayer]);

    // Create element tree
    this.deck = this.create(Deck, 'deck');
    this.deck.createMany(52, PlayingCard, 'card', (i) => ({
      suit: ['hearts', 'diamonds', 'clubs', 'spades'][Math.floor(i / 13)],
      rank: (i % 13) + 1,
    }));
  }
}
```

### Element Types

| Type | Description |
|------|-------------|
| `Game` | Root element, contains all game state |
| `Space` | Container for other elements (board regions, zones) |
| `Piece` | Movable game pieces |
| `Card` | Card elements with flip states |
| `Deck` | Ordered stack of cards with shuffle/draw |
| `Hand` | Player's hand of cards |
| `Die` | Rollable die with configurable sides |
| `DicePool` | Collection of dice |
| `Grid` | 2D grid of cells |
| `HexGrid` | Hexagonal grid |

### Element Comparison

**Important**: Always compare elements by ID, not reference:

```typescript
// WRONG - may fail due to serialization
if (myCards.includes(selectedCard)) { ... }

// CORRECT - compare by ID
if (myCards.some(c => c.id === selectedCard.id)) { ... }

// CORRECT - use built-in helpers
if (selectedCard.equals(otherCard)) { ... }
if (myCards.contains(selectedCard)) { ... }
```

## Actions

Define player actions with the Action builder:

```typescript
import { Action } from '@boardsmith/engine';

const playCard = Action.create<MyGame>('playCard')
  .chooseElement<PlayingCard>('card', {
    prompt: 'Choose a card to play',
    from: (ctx) => ctx.player.hand.all(PlayingCard),
    filter: (card, ctx) => card.isPlayable(),
  })
  .execute((args, ctx) => {
    const card = args.card as PlayingCard;
    card.moveTo(ctx.game.discardPile);
    ctx.player.score += card.value;
  });
```

### Selection Types

- `chooseElement<T>()` - Select a game element
- `chooseFrom()` - Select from a list of choices
- `chooseNumber()` - Select a number in a range
- `chooseText()` - Free text input

### Multi-Step Selections

When filters depend on previous selections, handle the undefined case:

```typescript
Action.create('move')
  .chooseElement<Piece>('piece', { ... })
  .chooseElement<Cell>('destination', {
    filter: (cell, ctx) => {
      const piece = ctx.args?.piece as Piece | undefined;
      if (!piece) {
        // Availability check - return true if ANY piece can reach this cell
        return getAllPieces(ctx).some(p => p.canMoveTo(cell));
      }
      // Actual selection - filter based on selected piece
      return piece.canMoveTo(cell);
    }
  })
```

Or use the `dependentFilter` helper:

```typescript
import { dependentFilter } from '@boardsmith/engine';

.chooseElement<Cell>('destination', {
  filter: dependentFilter({
    dependsOn: 'piece',
    whenUndefined: (cell, ctx) => getAllPieces(ctx).some(p => p.canMoveTo(cell)),
    whenSelected: (cell, piece, ctx) => piece.canMoveTo(cell),
  })
})
```

## Flow Control

Define game structure with flow nodes:

```typescript
import {
  defineFlow, sequence, phase, loop, eachPlayer,
  actionStep, execute, TurnOrder
} from '@boardsmith/engine';

export const flow = defineFlow(
  sequence(
    phase('setup', {
      do: execute((ctx) => {
        ctx.game.deck.shuffle();
        for (const player of ctx.game.players) {
          ctx.game.deck.deal(player.hand, 5);
        }
      }),
    }),

    phase('play', {
      do: loop({
        while: (ctx) => !ctx.game.isGameOver(),
        maxIterations: 1000,
        do: eachPlayer({
          ...TurnOrder.DEFAULT,
          do: actionStep({ actions: ['playCard', 'draw', 'pass'] }),
        }),
      }),
    }),

    execute((ctx) => ctx.game.declareWinner()),
  )
);
```

### Flow Nodes

| Node | Description |
|------|-------------|
| `sequence()` | Execute nodes in order |
| `phase()` | Named game phase |
| `loop()` | Repeat while condition is true |
| `repeat()` | Repeat a fixed number of times |
| `turnLoop()` | Simplified action loop with auto game.isFinished() check |
| `eachPlayer()` | Iterate through players |
| `forEach()` | Iterate through elements |
| `actionStep()` | Wait for player action |
| `simultaneousActionStep()` | All players act at once |
| `switchOn()` | Branch based on value |
| `ifThen()` | Conditional execution |
| `execute()` | Run code immediately |

### turnLoop

A simplified loop for turn-based action sequences. Automatically checks `game.isFinished()` and reduces boilerplate for common turn loop patterns:

```typescript
// Instead of this verbose pattern:
loop({
  while: (ctx) => {
    if (ctx.game.isFinished()) return false;
    const player = ctx.player as MyPlayer;
    return player.actionsRemaining > 0;
  },
  maxIterations: 30,
  do: actionStep({ actions: ['move', 'attack', 'endTurn'] }),
})

// Use turnLoop:
turnLoop({
  actions: ['move', 'attack', 'endTurn'],
  while: (ctx) => (ctx.player as MyPlayer).actionsRemaining > 0,
  maxIterations: 30,
})
```

### Turn Order

Use `TurnOrder` presets for common patterns:

```typescript
eachPlayer({
  ...TurnOrder.LEFT_OF_DEALER(ctx => ctx.game.dealerPosition),
  ...TurnOrder.SKIP_IF(player => player.hasFolded),
  do: actionStep({ actions: ['bet', 'fold'] }),
})
```

## Commands

The engine uses event sourcing. All state changes go through commands:

```typescript
// In action execute:
ctx.game.deck.shuffle();  // Generates ShuffleCommand
card.moveTo(player.hand); // Generates MoveCommand
card.flip();              // Generates SetAttributeCommand
```

Commands are automatically generated and can be replayed for undo/redo.

## Visibility

Control what players can see:

```typescript
// Card is visible only to its owner
card.showOnlyTo(player);

// Card is visible to everyone
card.showToAll();

// Card is hidden from everyone
card.hide();
```

## API Reference

### Game

```typescript
class Game extends GameElement {
  players: PlayerCollection;
  phase?: string;
  finished: boolean;

  registerElements(classes: ElementClass[]): void;
  getElementById(id: number): GameElement | undefined;
  atBranch(path: string): GameElement | undefined;
  finish(winners?: Player[]): void;
}
```

### GameElement

```typescript
class GameElement {
  id: number;            // Unique identifier
  name: string;          // Element name
  game: Game;            // Root game reference
  parent?: GameElement;  // Parent in tree

  create<T>(Class, name, attrs?): T;
  createMany<T>(count, Class, name, attrs?): ElementCollection<T>;
  all<T>(Class?): ElementCollection<T>;
  first<T>(Class?): T | undefined;
  count(Class?): number;

  moveTo(destination: GameElement): void;
  remove(): void;

  equals(other: GameElement): boolean;
  hasId(id: number): boolean;
}
```

### ElementCollection

```typescript
class ElementCollection<T> extends Array<T> {
  first(): T | undefined;
  last(): T | undefined;
  random(): T | undefined;
  shuffle(): this;

  contains(element: GameElement): boolean;
  findById(id: number): T | undefined;
  hasId(id: number): boolean;
  indexOfElement(element: GameElement): number;
}
```

## Debugging Actions

When an action isn't appearing in `availableActions` and you can't figure out why, use `debugActionAvailability()`:

```typescript
const debug = game.debugActionAvailability('equipItem', player);
console.log(debug.reason);
// "Selection 'equipment' has no valid choices (Depends on 'actingMerc' - no valid combinations found)"

// For detailed breakdown:
console.log('Condition passed:', debug.details.conditionPassed);
for (const sel of debug.details.selections) {
  const status = sel.passed ? '✓' : '✗';
  console.log(`${status} ${sel.name}: ${sel.choices} choices`);
  if (sel.note) console.log(`    ${sel.note}`);
}
```

Common issues this helps diagnose:
- **Condition returns false**: Check your action's `condition` function
- **Selection has no choices**: The `from` or `filter` eliminated all options
- **Dependent selection fails**: When using `dependsOn`, no combination of previous selections leads to valid choices

To debug all actions at once:

```typescript
const allDebug = game.debugAllActions(player);
const unavailable = allDebug.filter(d => !d.available);
for (const d of unavailable) {
  console.log(`${d.actionName}: ${d.reason}`);
}
```

## See Also

- [Getting Started Guide](../../docs/getting-started.md)
- [Common Pitfalls](../../docs/common-pitfalls.md)
- [Common Patterns](../../docs/common-patterns.md)
- [Actions & Flow](../../docs/actions-and-flow.md)
````

## File: packages/session/README.md
````markdown
# @boardsmith/session

Game session management for BoardSmith. Handles game lifecycle, state synchronization, action processing, and AI players.

## Installation

```bash
npm install @boardsmith/session
```

## Overview

The session package provides a unified API for managing game sessions across different platforms (local development, Cloudflare Workers, etc.) while keeping game designers isolated from implementation details.

## Quick Start

```typescript
import { GameSession, generateGameId } from '@boardsmith/session';
import { CheckersGame, gameDefinition } from './my-game';

// Create a new game session
const session = await GameSession.create({
  gameType: 'checkers',
  GameClass: CheckersGame,
  playerCount: 2,
  playerNames: ['Alice', 'Bob'],
  seed: 12345,  // Optional: for reproducible games
});

// Get state for a specific player
const playerState = session.getState(0);  // Alice's view

// Perform an action
const result = await session.performAction('move', 0, {
  piece: pieceId,
  destination: cellId,
});

if (result.success) {
  console.log('Move successful!');
} else {
  console.log(`Error: ${result.error}`);
}
```

## GameSession

The main class for managing a game instance.

### Creation

```typescript
// Create a new game
const session = await GameSession.create({
  gameType: 'my-game',
  GameClass: MyGame,
  playerCount: 4,
  playerNames: ['Alice', 'Bob', 'Carol', 'Dave'],
  gameOptions: { variant: 'advanced' },
  seed: Date.now(),  // Optional random seed
  storage: myStorageAdapter,  // Optional persistence
});

// Restore from saved state
const session = await GameSession.restore(
  gameDefinition,
  storedState,
  { storage: myStorageAdapter }
);
```

### Getting State

```typescript
// Get state for a specific player (with hidden info filtered)
const playerState = session.getState(playerPosition);

interface PlayerGameState {
  game: any;              // Serialized game state (player's view)
  flowState: FlowState;   // Current flow state
  playerNames: string[];  // All player names
  playerPosition: number; // This player's position
  finished: boolean;      // Is game over
  winners?: number[];     // Winning player positions
}
```

### Performing Actions

```typescript
const result = await session.performAction(
  'playCard',      // Action name
  0,               // Player position
  { card: cardId } // Action arguments
);

interface ActionResult {
  success: boolean;
  error?: string;
  state?: PlayerGameState;
  pendingAction?: PendingActionInfo;
}
```

### Undo

```typescript
// Undo to turn start
const result = await session.undoToTurnStart(playerPosition);

// Undo last action (with limits)
const result = await session.undo(playerPosition);

interface UndoResult {
  success: boolean;
  error?: string;
  actionsUndone?: number;
}
```

### History and Replay

```typescript
// Get state at a specific action index (for time travel)
const historicalState = session.getStateAtAction(actionIndex);

// Rewind game to an action and continue from there
const result = await session.rewindToAction(actionIndex);

// Get action history
const history = session.getActionHistory();
```

## Storage Adapters

Persist game state with storage adapters:

```typescript
interface StorageAdapter {
  save(state: StoredGameState): Promise<void>;
  load(): Promise<StoredGameState | null>;
}

// Example: SQLite adapter
class SqliteStorage implements StorageAdapter {
  constructor(private db: Database, private gameId: string) {}

  async save(state: StoredGameState): Promise<void> {
    this.db.run(
      'INSERT OR REPLACE INTO games (id, state) VALUES (?, ?)',
      [this.gameId, JSON.stringify(state)]
    );
  }

  async load(): Promise<StoredGameState | null> {
    const row = this.db.get('SELECT state FROM games WHERE id = ?', [this.gameId]);
    return row ? JSON.parse(row.state) : null;
  }
}
```

## Broadcast Adapters

Notify connected clients of state changes:

```typescript
interface BroadcastAdapter<TSession extends SessionInfo> {
  addSession(session: TSession): void;
  removeSession(session: TSession): void;
  getSessions(): TSession[];
  send(session: TSession, message: unknown): void;
  broadcast(message: unknown): void;
}

interface SessionInfo {
  playerPosition: number;
  isSpectator: boolean;
  playerId?: string;
}
```

## AI Controller

Built-in AI player support using Monte Carlo Tree Search:

```typescript
import { AIController } from '@boardsmith/session';

const ai = new AIController({
  level: 'medium',  // 'easy' | 'medium' | 'hard' | 'expert' or iteration count
  players: [1, 3],  // AI-controlled player positions
});

// Check if current player is AI
if (ai.isAIPlayer(currentPlayerPosition)) {
  const move = await ai.getMove(session);
  await session.performAction(move.action, move.player, move.args);
}
```

### AI Levels

| Level | Iterations | Description |
|-------|------------|-------------|
| easy | 100 | Quick, makes mistakes |
| medium | 500 | Balanced play |
| hard | 1500 | Strong play |
| expert | 5000 | Very strong, slower |

## Lobby System

Manage pre-game player setup:

```typescript
// Lobby is integrated into GameSession
const lobby = session.lobby;

// Claim a position
await session.claimPosition(playerId, playerPosition);

// Update player name
await session.updatePlayerName(playerId, 'New Name');

// Check if ready to start
if (lobby.canStart()) {
  await session.startGame();
}

interface LobbyState {
  slots: LobbySlot[];
  minPlayers: number;
  maxPlayers: number;
  isStarted: boolean;
}

interface LobbySlot {
  position: number;
  status: 'open' | 'claimed' | 'ai' | 'locked';
  playerId?: string;
  playerName?: string;
  isConnected: boolean;
}
```

## Player Options

Configure per-player settings:

```typescript
interface PlayerOptionDefinition {
  id: string;
  type: 'standard' | 'exclusive';
  choices: { id: string; label: string }[];
  defaultValue: string;
}

// Standard option: each player picks independently
const colorOption: StandardPlayerOption = {
  id: 'color',
  type: 'standard',
  choices: [
    { id: 'red', label: 'Red' },
    { id: 'blue', label: 'Blue' },
    { id: 'green', label: 'Green' },
  ],
  defaultValue: 'red',
};

// Exclusive option: first-come-first-served
const factionOption: ExclusivePlayerOption = {
  id: 'faction',
  type: 'exclusive',
  choices: [
    { id: 'empire', label: 'Empire' },
    { id: 'rebels', label: 'Rebels' },
  ],
  defaultValue: 'empire',
};
```

### Color Options

Built-in color picker:

```typescript
import { createColorOption, STANDARD_PLAYER_COLORS } from '@boardsmith/session';

const colorOption = createColorOption({
  defaultColors: ['red', 'blue', 'green', 'yellow'],
});

// Available colors
console.log(STANDARD_PLAYER_COLORS);
// ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'cyan', ...]
```

## Utility Functions

### generateGameId

Create unique game identifiers:

```typescript
import { generateGameId } from '@boardsmith/session';

const gameId = generateGameId();  // e.g., 'abc123xyz'
```

### buildPlayerState

Create player-specific state view:

```typescript
import { buildPlayerState } from '@boardsmith/session';

const playerView = buildPlayerState(
  gameRunner,
  playerNames,
  playerPosition,
  { includeActionMetadata: true }
);
```

### isPlayersTurn

Check if it's a player's turn:

```typescript
import { isPlayersTurn } from '@boardsmith/session';

const canAct = isPlayersTurn(flowState, playerPosition);
```

## Type Definitions

### GameDefinition

```typescript
interface GameDefinition {
  gameType: string;
  displayName?: string;
  gameClass: GameClass;
  flow: FlowNode;
  actions: Record<string, Action>;
  minPlayers: number;
  maxPlayers: number;
  playerOptions?: PlayerOptionDefinition[];
  gameOptions?: GameOptionDefinition[];
  presets?: GamePreset[];
}
```

### StoredGameState

```typescript
interface StoredGameState {
  gameType: string;
  playerCount: number;
  playerNames: string[];
  seed: number;
  gameOptions?: Record<string, unknown>;
  playerConfigs?: PlayerConfig[];
  actionHistory: SerializedAction[];
  version: number;
}
```

### WebSocketMessage

```typescript
type WebSocketMessage =
  | { type: 'action'; action: string; args: unknown }
  | { type: 'undo' }
  | { type: 'undoToTurnStart' }
  | { type: 'ping' };
```

## Error Handling

```typescript
const result = await session.performAction('move', 0, args);

if (!result.success) {
  switch (result.error) {
    case 'Not your turn':
      // Handle wrong player
      break;
    case 'Action not available':
      // Handle invalid action
      break;
    case 'Invalid selection':
      // Handle invalid arguments
      break;
    default:
      console.error('Unknown error:', result.error);
  }
}
```

## Best Practices

1. **Use storage adapters** for game persistence
2. **Implement broadcast adapters** for multiplayer
3. **Set random seeds** for reproducible games
4. **Check isPlayersTurn** before allowing actions
5. **Handle pending actions** for multi-step selections
6. **Use lobby system** for proper game setup

## See Also

- [Getting Started](../../docs/getting-started.md)
- [@boardsmith/engine](../engine/README.md) - Core game engine
- [@boardsmith/server](../server/README.md) - HTTP/WebSocket server
````

## File: packages/testing/README.md
````markdown
# @boardsmith/testing

Testing utilities for BoardSmith games. Provides helpers for simulating games, asserting state, and debugging issues.

## Installation

```bash
npm install --save-dev @boardsmith/testing
```

## Quick Start

```typescript
import { createTestGame, simulateAction, assertFlowState } from '@boardsmith/testing';
import { gameDefinition } from './game';

describe('MyGame', () => {
  it('should deal cards to all players', async () => {
    const testGame = await createTestGame(gameDefinition, {
      playerCount: 2,
      seed: 12345,
    });

    // Verify initial state
    assertFlowState(testGame, { phase: 'setup' });

    // Each player should have 5 cards
    for (const player of testGame.game.players) {
      expect(player.hand.count()).toBe(5);
    }
  });
});
```

## Test Game Setup

### createTestGame

Create a game instance for testing:

```typescript
const testGame = await createTestGame(gameDefinition, {
  playerCount: 3,
  playerNames: ['Alice', 'Bob', 'Carol'],
  seed: 42,  // Optional: deterministic randomness
  gameOptions: { variant: 'advanced' },
});
```

### TestGame Object

```typescript
interface TestGame {
  game: Game;           // The game instance
  runner: GameRunner;   // Flow/action runner
  session: GameSession; // Full session (for state access)
}
```

## Simulating Actions

### simulateAction

Execute a single action:

```typescript
import { simulateAction, assertActionSucceeds } from '@boardsmith/testing';

const result = await simulateAction(testGame, 'playCard', {
  card: testGame.game.players[0].hand.first(),
});

// Or assert it succeeds
await assertActionSucceeds(testGame, 'playCard', { card: someCard });
```

### simulateActions

Execute multiple actions in sequence:

```typescript
import { simulateActions } from '@boardsmith/testing';

await simulateActions(testGame, [
  { name: 'draw', args: {} },
  { name: 'playCard', args: { card: firstCard } },
  { name: 'endTurn', args: {} },
]);
```

### assertActionFails

Verify an action cannot be taken:

```typescript
import { assertActionFails } from '@boardsmith/testing';

// Ensure player can't play a card they don't have
await assertActionFails(testGame, 'playCard', {
  card: otherPlayerCard,
});
```

## Assertions

### assertFlowState

Check the current flow state:

```typescript
import { assertFlowState } from '@boardsmith/testing';

assertFlowState(testGame, {
  phase: 'playing',
  currentPlayer: 0,  // Player position
  actions: ['play', 'draw', 'pass'],  // Available actions
});
```

### assertPlayerHas

Check elements in player zones:

```typescript
import { assertPlayerHas } from '@boardsmith/testing';

assertPlayerHas(testGame, 0, 'hand', { count: 5 });
assertPlayerHas(testGame, 0, 'hand', { element: specificCard });
assertPlayerHas(testGame, 0, 'board', { elementType: Piece, count: 3 });
```

### assertElementCount

Check element counts globally:

```typescript
import { assertElementCount } from '@boardsmith/testing';

assertElementCount(testGame, Card, 52);
assertElementCount(testGame, Piece, { min: 1, max: 10 });
```

### assertGameFinished

Verify game completion:

```typescript
import { assertGameFinished } from '@boardsmith/testing';

assertGameFinished(testGame, {
  winner: testGame.game.players[0],
});

// Or just check it's finished
assertGameFinished(testGame);
```

### assertActionAvailable / assertActionNotAvailable

Check action availability:

```typescript
import { assertActionAvailable, assertActionNotAvailable } from '@boardsmith/testing';

assertActionAvailable(testGame, 0, 'draw');  // Player 0 can draw
assertActionNotAvailable(testGame, 1, 'draw');  // Player 1 cannot
```

## Fixtures and Scenarios

### ScenarioBuilder

Build game scenarios fluently:

```typescript
import { scenario } from '@boardsmith/testing';

const testGame = await scenario(gameDefinition)
  .withPlayers(3)
  .withSeed(42)
  .setup((game) => {
    // Custom setup
    game.deck.shuffle();
    game.players[0].hand.createMany(3, Card, 'card', { suit: 'hearts' });
  })
  .build();
```

### quickGame

Create a game and advance to a specific state:

```typescript
import { quickGame } from '@boardsmith/testing';

const testGame = await quickGame(gameDefinition, {
  players: 2,
  advanceTo: 'playing',  // Phase name or predicate
});
```

### playSequence

Play a sequence of actions:

```typescript
import { playSequence } from '@boardsmith/testing';

const { testGame, results } = await playSequence(gameDefinition, [
  { player: 0, action: 'draw' },
  { player: 0, action: 'playCard', args: { cardIndex: 0 } },
  { player: 1, action: 'draw' },
]);
```

### playUntil

Play random actions until a condition:

```typescript
import { playUntil } from '@boardsmith/testing';

const testGame = await playUntil(
  gameDefinition,
  (game) => game.phase === 'endgame',
  { maxActions: 100 }
);
```

### createMultiple

Create multiple elements easily:

```typescript
import { createMultiple } from '@boardsmith/testing';

// In scenario setup:
createMultiple(player.hand, Card, 5, (i) => ({
  suit: 'hearts',
  rank: i + 1,
}));
```

## Debug Utilities

### toDebugString

Get a human-readable game state:

```typescript
import { toDebugString } from '@boardsmith/testing';

console.log(toDebugString(testGame.game));
// Game: MyGame
// Phase: playing
// Current Player: Alice (position 0)
//
// Players:
//   [0] Alice: hand(5), score=10
//   [1] Bob: hand(4), score=15
//
// Elements:
//   Deck (id=1): 32 children
//   DiscardPile (id=2): 10 children
```

### debugActionAvailability (Recommended)

The engine provides a built-in method for debugging action availability with human-readable explanations:

```typescript
// Using the engine's built-in method (recommended)
const debug = testGame.game.debugActionAvailability('move', player);
console.log(debug.reason);
// "Selection 'destination' has no valid choices (Depends on 'piece' - no valid combinations found)"

for (const sel of debug.details.selections) {
  const status = sel.passed ? '✓' : '✗';
  console.log(`${status} ${sel.name}: ${sel.choices} choices`);
  if (sel.note) console.log(`    ${sel.note}`);
}
// ✓ piece: 3 choices
//     3 valid choices
// ✗ destination: 0 choices
//     Depends on 'piece' - no valid combinations found

// Debug all actions at once
const allDebug = testGame.game.debugAllActions(player);
for (const d of allDebug.filter(d => !d.available)) {
  console.log(`${d.actionName}: ${d.reason}`);
}
```

### traceAction

Legacy testing utility for action debugging (prefer `game.debugActionAvailability()` above):

```typescript
import { traceAction } from '@boardsmith/testing';

const trace = traceAction(testGame.game, 'move', player);
console.log(trace.reason);
// "No valid elements for selection 'destination'"

for (const detail of trace.details) {
  console.log(`${detail.step}: ${detail.passed ? '✓' : '✗'} ${detail.info}`);
}
// Lookup: ✓ Found action 'move'
// Condition: ✓ Condition returned true
// Selection 'piece': ✓ 3 valid elements (5 before filter)
// Selection 'destination': ✗ 0 valid elements (24 before filter)
```

### visualizeFlow

Print the flow structure:

```typescript
import { visualizeFlow } from '@boardsmith/testing';

console.log(visualizeFlow(gameDefinition.flow));
// sequence "main"
//   ├─ phase "setup"
//   │  └─ execute
//   ├─ loop (while: ...)
//   │  └─ eachPlayer
//   │     └─ action-step [play, draw, pass]
//   └─ execute
```

### logAvailableActions

Show all actions and their status:

```typescript
import { logAvailableActions } from '@boardsmith/testing';

console.log(logAvailableActions(testGame.game));
// Available actions for Alice:
//   ✓ playCard - Action available
//   ✓ draw - Action available
//   ✗ attack - No valid elements for selection 'target'
//   ✗ rest - Action condition returned false
```

### diffSnapshots

Compare game states before/after:

```typescript
import { diffSnapshots } from '@boardsmith/testing';

const before = JSON.stringify(getSnapshot(testGame.game));
await simulateAction(testGame, 'move', args);
const after = JSON.stringify(getSnapshot(testGame.game));

console.log(diffSnapshots(before, after));
// Changes:
//   players[0].position: 3 → 5
//   board.cells[5].occupant: null → {id: 42}
```

### debugFlowState

Get detailed info about current flow position:

```typescript
import { debugFlowState } from '@boardsmith/testing';

const flowState = debugFlowState(testGame);
console.log(flowState.description);
// "In phase 'playing', waiting for Player 0 to choose: [play, draw, pass]"

console.log(flowState.nodeStack);
// ["sequence 'main'", "loop 'rounds'", "eachPlayer", "actionStep"]

console.log(flowState.currentPhase);      // "playing"
console.log(flowState.currentPlayer);      // 0
console.log(flowState.availableActions);   // ["play", "draw", "pass"]
console.log(flowState.awaitingInput);      // true
```

### visualizeFlowWithPosition

Show flow structure with current position highlighted:

```typescript
import { visualizeFlowWithPosition } from '@boardsmith/testing';

console.log(visualizeFlowWithPosition(gameDefinition.flow, testGame));
// sequence "main"
//   ├─ phase "setup"
//   ├─ loop "rounds"
//   │  ├─ eachPlayer
//   │  │  └─ actionStep [play, draw, pass] ← CURRENT
//   │  └─ execute
//   └─ phase "endgame"
```

## Random Simulation

### simulateRandomGames

Run random games for stress testing:

```typescript
import { simulateRandomGames } from '@boardsmith/testing';

const results = await simulateRandomGames(gameDefinition, {
  count: 100,
  maxActionsPerGame: 500,
  playerCount: 4,
});

console.log(`Completed: ${results.completed}/${results.total}`);
console.log(`Avg actions: ${results.averageActions}`);
console.log(`Errors: ${results.errors.length}`);
```

## Best Practices

1. **Use deterministic seeds** for reproducible tests
2. **Test edge cases** with specific scenarios
3. **Use assertions** instead of manual checks
4. **Use traceAction** to debug failing action tests
5. **Run random simulations** to catch edge cases

## API Reference

### Test Game Creation

```typescript
function createTestGame(definition, options): Promise<TestGame>;
function scenario(definition): ScenarioBuilder;
function quickGame(definition, options): Promise<TestGame>;
```

### Action Simulation

```typescript
function simulateAction(testGame, name, args): Promise<SimulateActionResult>;
function simulateActions(testGame, actions): Promise<SimulateActionResult[]>;
function assertActionSucceeds(testGame, name, args): Promise<void>;
function assertActionFails(testGame, name, args): Promise<void>;
```

### Assertions

```typescript
function assertFlowState(testGame, expected): void;
function assertPlayerHas(testGame, playerIndex, zone, criteria): void;
function assertElementCount(testGame, elementClass, count): void;
function assertGameFinished(testGame, options?): void;
function assertActionAvailable(testGame, playerIndex, actionName, options?): void;
function assertActionNotAvailable(testGame, playerIndex, actionName, options?): void;
```

### Debug Utilities

```typescript
function toDebugString(game, options?): string;
function traceAction(game, actionName, player?): ActionTraceResult;
function visualizeFlow(flow): string;
function visualizeFlowWithPosition(flow, testGame?): string;
function debugFlowState(testGame): FlowStateDebug;
function logAvailableActions(game, player?): string;
function diffSnapshots(before, after): string;
```
````

## File: docs/api/ai-trainer.md
````markdown
# boardsmith/ai-trainer

> Tools for training and improving AI weights.

## When to Use

Import from `boardsmith/ai-trainer` when you want to train AI weights for your game, analyze game features, or generate AI code. This package provides parallel training infrastructure for evolving optimal AI strategies.

## Usage

```typescript
import {
  ParallelTrainer,
  WeightEvolver,
  introspectGame,
  generateCandidateFeatures,
  generateAICode,
} from 'boardsmith/ai-trainer';
```

## Exports

### Training

- `ParallelTrainer` - Multi-threaded AI training
- `WeightEvolver` - Evolve optimal weights
- `DEFAULT_TRAINING_CONFIG` - Default training configuration

### Introspection

- `introspectGame()` - Analyze game structure
- `createIntrospectionGame()` - Create game for analysis
- `printGameStructure()` - Print game structure
- `estimateComplexity()` - Estimate game complexity

### Feature Generation

- `generateCandidateFeatures()` - Generate potential AI features
- `filterFeaturesByCategory()` - Filter features by category
- `getFeatureSummary()` - Get feature summary
- `printFeatures()` - Print features

### Feature Templates

- `FEATURE_TEMPLATES` - Built-in feature templates

### Simulation

- `runSimulations()` - Run game simulations
- `simulateSingleGame()` - Simulate one game
- `serializeGameStructure()` - Serialize for workers
- `deserializeGameStructure()` - Deserialize from workers

### Parallel Simulation

- `runParallelSimulations()` - Run simulations in parallel

### Benchmarking

- `runParallelBenchmarks()` - Benchmark AI performance
- `benchmarkAI()` - Run AI benchmark

### Analysis

- `analyzeFeatures()` - Analyze feature effectiveness
- `analyzeActions()` - Analyze action patterns
- `selectTopFeatures()` - Select best features
- `correlationToWeight()` - Convert correlation to weight
- `printAnalysisSummary()` - Print analysis results

### Code Generation

- `generateAICode()` - Generate AI TypeScript code
- `updateAIWeights()` - Update weights in existing AI file

### AI File Parsing

- `parseExistingAI()` - Parse existing AI file
- `parsedToLearned()` - Convert parsed to learned format
- `mergeObjectives()` - Merge objective sets
- `getCumulativeStats()` - Get cumulative statistics

### Evolution Utilities

- `createSeededRandom()` - Create seeded random
- `mutateWeights()` - Mutate weight values
- `crossoverWeights()` - Crossover two weight sets
- `selectBest()` - Select best individuals
- `generateOffspring()` - Generate offspring

### Types

- `GameClass` - Game class constructor
- `GameStructure` - Analyzed game structure
- `ElementTypeInfo` - Element type information
- `PlayerTypeInfo` - Player type information
- `SpatialInfo` - Spatial relationship info
- `CandidateFeature` - Candidate feature
- `StateSnapshot` - State snapshot
- `GameData` - Game data for analysis
- `FeatureStats` - Feature statistics
- `ActionStats` - Action statistics
- `LearnedObjective` - Learned AI objective
- `LearnedActionPreference` - Action preference
- `TrainingResult` - Training result
- `TrainingConfig` - Training configuration
- `TrainingProgress` - Training progress
- `ParallelTrainingConfig` - Parallel training config
- `WeightEvolverConfig` - Weight evolver config
- `WeightEvolutionResult` - Evolution result
- `BenchmarkConfig` - Benchmark configuration
- `BenchmarkResult` - Benchmark result
- `PlayerConfig` - Player configuration
- `SimulationOptions` - Simulation options
- `SimulationResults` - Simulation results
- `ParallelSimulatorOptions` - Parallel simulation options
- `ParallelBenchmarkOptions` - Parallel benchmark options
- `IndividualFitness` - Individual fitness score
- `CodeGeneratorOptions` - Code generator options
- `UpdateWeightsOptions` - Update weights options
- `ParsedAIFile` - Parsed AI file
- `ParsedObjective` - Parsed objective
- `FeatureTemplate` - Feature template

## Examples

### Quick Weight Evolution

```typescript
import { WeightEvolver } from 'boardsmith/ai-trainer';
import { MyGame } from './game';

const evolver = new WeightEvolver({
  GameClass: MyGame,
  gameType: 'my-game',
  populationSize: 20,
  generations: 50,
  gamesPerEvaluation: 10,
});

const result = await evolver.evolve((progress) => {
  console.log(`Gen ${progress.generation}: best fitness ${progress.bestFitness}`);
});

console.log('Best weights:', result.bestWeights);
console.log('Final fitness:', result.fitness);
```

### Full Training Pipeline

```typescript
import {
  introspectGame,
  generateCandidateFeatures,
  runParallelSimulations,
  analyzeFeatures,
  selectTopFeatures,
  generateAICode,
} from 'boardsmith/ai-trainer';
import { MyGame } from './game';

// 1. Analyze game structure
const structure = introspectGame(MyGame);
console.log(`Found ${structure.elementTypes.length} element types`);

// 2. Generate candidate features
const features = generateCandidateFeatures(structure);
console.log(`Generated ${features.length} candidate features`);

// 3. Run simulations to gather data
const simResults = await runParallelSimulations({
  GameClass: MyGame,
  gameType: 'my-game',
  gameCount: 1000,
  workers: 4,
});

// 4. Analyze feature correlations
const analysis = analyzeFeatures(simResults.gameData, features);

// 5. Select top performing features
const topFeatures = selectTopFeatures(analysis, 10);

// 6. Generate AI code
const aiCode = generateAICode({
  features: topFeatures,
  gameType: 'my-game',
});

// Write to file
writeFileSync('./src/ai.ts', aiCode);
```

### Updating Existing AI

```typescript
import { parseExistingAI, updateAIWeights } from 'boardsmith/ai-trainer';
import { readFileSync, writeFileSync } from 'fs';

// Parse existing AI file
const content = readFileSync('./src/ai.ts', 'utf-8');
const parsed = parseExistingAI(content);

console.log(`Found ${parsed.objectives.length} objectives`);

// Update weights based on new training
const newWeights = { 'piece-count': 0.15, 'board-control': 0.25 };

const updated = updateAIWeights({
  content,
  weights: newWeights,
});

writeFileSync('./src/ai.ts', updated);
```

### Parallel Training

```typescript
import { ParallelTrainer } from 'boardsmith/ai-trainer';
import { MyGame } from './game';

const trainer = new ParallelTrainer({
  GameClass: MyGame,
  gameType: 'my-game',
  workers: 8,
  gamesPerGeneration: 100,
  generations: 100,
  populationSize: 50,
});

trainer.on('generation', (gen, stats) => {
  console.log(`Generation ${gen}:`);
  console.log(`  Best: ${stats.bestFitness}`);
  console.log(`  Average: ${stats.averageFitness}`);
});

const result = await trainer.train();
```

### Benchmarking AI Versions

```typescript
import { benchmarkAI } from 'boardsmith/ai-trainer';
import { MyGame } from './game';

const results = await benchmarkAI({
  GameClass: MyGame,
  gameType: 'my-game',
  players: [
    { type: 'ai', config: oldAI, name: 'Old AI' },
    { type: 'ai', config: newAI, name: 'New AI' },
  ],
  games: 100,
});

console.log('Results:');
console.log(`  Old AI wins: ${results.winRates[0] * 100}%`);
console.log(`  New AI wins: ${results.winRates[1] * 100}%`);
console.log(`  Average game length: ${results.averageLength} moves`);
```

### Game Introspection

```typescript
import { introspectGame, printGameStructure, estimateComplexity } from 'boardsmith/ai-trainer';
import { ChessGame } from './game';

const structure = introspectGame(ChessGame);

printGameStructure(structure);
// Game: ChessGame
// Elements:
//   - Board (Grid 8x8)
//   - Piece (King, Queen, Rook, Bishop, Knight, Pawn)
// Actions:
//   - move: Select piece, select destination
//   - castle: Select side
// ...

const complexity = estimateComplexity(structure);
console.log(`Branching factor: ~${complexity.branchingFactor}`);
console.log(`State space: ~10^${complexity.stateSpaceExponent}`);
```

## See Also

- [AI System Guide](../ai-system.md) - AI system overview
- [boardsmith/ai](./ai.md) - Using trained AI in games
````

## File: docs/api/ai.md
````markdown
# boardsmith/ai

> MCTS-based AI opponents for board games.

## When to Use

Import from `boardsmith/ai` when adding AI opponents to your game. This package provides a Monte Carlo Tree Search (MCTS) bot that can play any BoardSmith game with configurable difficulty levels.

## Usage

```typescript
import { createBot, MCTSBot, parseAILevel, DIFFICULTY_PRESETS } from 'boardsmith/ai';
```

## Exports

### Factory Functions

- `createBot()` - Create an MCTS bot for a game
- `parseAILevel()` - Parse difficulty from string (for CLI)

### Classes

- `MCTSBot` - MCTS-based game AI

### Configuration

- `DIFFICULTY_PRESETS` - Preset difficulty configurations
- `DEFAULT_CONFIG` - Default bot configuration

### Types

- `BotConfig` - Bot configuration options
- `BotMove` - Bot move result
- `AIConfig` - AI configuration for session
- `Objective` - AI objective definition
- `ThreatResponse` - Threat response configuration
- `DifficultyLevel` - Difficulty preset names

## Examples

### Basic AI Opponent

```typescript
import { createBot } from 'boardsmith/ai';
import { CheckersGame } from './game';

// Create a game
const game = new CheckersGame({
  playerCount: 2,
  playerNames: ['Human', 'AI'],
});

// Create an AI bot for player 1 (medium difficulty)
const bot = createBot(
  game,
  CheckersGame,
  'checkers',
  1, // player index
  [], // action history
  'medium',
);

// Get the AI's move
const move = await bot.play();

if (move) {
  console.log(`AI plays: ${move.action}`, move.args);
  // Execute the move in your game
}
```

### Difficulty Levels

```typescript
import { createBot, DIFFICULTY_PRESETS } from 'boardsmith/ai';

// Easy - quick moves, less thinking
const easyBot = createBot(game, GameClass, 'game', 1, [], 'easy');

// Medium - balanced
const mediumBot = createBot(game, GameClass, 'game', 1, [], 'medium');

// Hard - more iterations, smarter play
const hardBot = createBot(game, GameClass, 'game', 1, [], 'hard');

// Custom - specify exact iteration count
const customBot = createBot(game, GameClass, 'game', 1, [], 5000);

// Available presets
console.log(DIFFICULTY_PRESETS);
// {
//   easy: { iterations: 100, explorationConstant: 1.414 },
//   medium: { iterations: 500, explorationConstant: 1.414 },
//   hard: { iterations: 2000, explorationConstant: 1.414 },
// }
```

### With AI Configuration

```typescript
import { createBot } from 'boardsmith/ai';
import type { AIConfig } from 'boardsmith/ai';

// Define custom AI objectives
const aiConfig: AIConfig = {
  objectives: [
    {
      name: 'control-center',
      description: 'Control the center of the board',
      feature: (game, player) => {
        const centerPieces = game.board.center.all(Piece, { player });
        return centerPieces.length * 0.1;
      },
      weight: 0.3,
    },
    {
      name: 'piece-advantage',
      description: 'Have more pieces than opponent',
      feature: (game, player) => {
        const myPieces = game.all(Piece, { player }).length;
        const theirPieces = game.all(Piece, { player: 1 - player }).length;
        return (myPieces - theirPieces) * 0.05;
      },
      weight: 0.5,
    },
  ],
};

const bot = createBot(
  game,
  CheckersGame,
  'checkers',
  1,
  actionHistory,
  'hard',
  aiConfig,
);
```

### Parsing CLI Arguments

```typescript
import { parseAILevel } from 'boardsmith/ai';

// From command line arguments
const levelArg = process.argv[2] || 'medium';
const difficulty = parseAILevel(levelArg);

// Accepts preset names or numbers
parseAILevel('easy'); // 'easy'
parseAILevel('medium'); // 'medium'
parseAILevel('hard'); // 'hard'
parseAILevel('1000'); // 1000 (custom iteration count)
parseAILevel('invalid'); // 'medium' (default fallback)
```

### Using MCTSBot Directly

```typescript
import { MCTSBot } from 'boardsmith/ai';

const bot = new MCTSBot(
  game,
  CheckersGame,
  'checkers',
  1,
  actionHistory,
  {
    iterations: 1000,
    explorationConstant: 1.5,
    timeLimit: 5000, // 5 second time limit
  },
);

// Get move with statistics
const move = await bot.play();
console.log(`Selected: ${move.action}`);
console.log(`Win rate: ${move.winRate}`);
console.log(`Simulations: ${move.simulations}`);
```

## How MCTS Works

The bot uses Monte Carlo Tree Search to evaluate moves:

1. **Selection** - Traverse the game tree using UCB1 to balance exploration/exploitation
2. **Expansion** - Add new game states to the tree
3. **Simulation** - Play random games to completion
4. **Backpropagation** - Update win statistics back up the tree

The bot automatically handles:

- All valid moves for the current player
- Multi-step actions with selections
- Game state cloning for simulations
- Undo/redo for efficient tree traversal

## See Also

- [AI System Guide](../ai-system.md) - Detailed AI system documentation
- [boardsmith/ai-trainer](./ai-trainer.md) - Train and improve AI weights
- [boardsmith/session](./session.md) - Using AI with GameSession
````

## File: docs/api/client.md
````markdown
# boardsmith/client

> Browser SDK for multiplayer games.

## When to Use

Import from `boardsmith/client` when building the browser-side client for multiplayer games. This package provides WebSocket connectivity, state synchronization, and audio services.

## Usage

```typescript
import { MeepleClient, GameConnection, audioService } from 'boardsmith/client';
```

## Exports

### Classes

- `MeepleClient` - Main client for connecting to game servers
- `GameConnection` - Active connection to a game

### Audio

- `audioService` - Audio playback service

### Types

- `MeepleClientConfig` - Client configuration
- `GameConnectionConfig` - Connection configuration
- `FindMatchOptions` - Matchmaking options
- `MatchmakingResult` - Matchmaking result
- `MatchmakingStatus` - Matchmaking status enum
- `FlowState` - Game flow state
- `PlayerState` - Player-specific state
- `GameState` - Combined game state
- `ConnectionStatus` - Connection status enum
- `ActionResult` - Action execution result
- `StateChangeCallback` - State change handler
- `ErrorCallback` - Error handler
- `ConnectionCallback` - Connection status handler
- `CreateGameRequest` - Create game request
- `CreateGameResponse` - Create game response
- `ApiResponse` - Generic API response
- `LobbyState` - Lobby state
- `SlotStatus` - Lobby slot status
- `LobbySlot` - Lobby slot data
- `LobbyInfo` - Lobby information
- `ClaimPositionRequest` - Claim position request
- `ClaimPositionResponse` - Claim position response
- `AudioServiceOptions` - Audio service options

## Examples

### Basic Client Usage

```typescript
import { MeepleClient } from 'boardsmith/client';

// Create client
const client = new MeepleClient({
  baseUrl: 'https://game.example.com',
});

// Create a new game
const { gameId } = await client.createGame({
  gameType: 'go-fish',
  playerCount: 3,
  playerNames: ['Alice', 'Bob', 'Charlie'],
});

// Connect to the game
const connection = client.connect(gameId, {
  playerPosition: 0,
});

// Subscribe to state changes
connection.onStateChange((state) => {
  console.log('Game state updated:', state);
  console.log('Current player:', state.flowState.currentPlayer);
  console.log('Is my turn:', state.flowState.currentPlayer === 0);
});

// Perform an action when it's your turn
await connection.action('ask', {
  target: 1,
  rank: '7',
});
```

### Matchmaking

```typescript
import { MeepleClient } from 'boardsmith/client';

const client = new MeepleClient({
  baseUrl: 'https://game.example.com',
});

// Find a match
const match = await client.findMatch('go-fish', {
  playerCount: 4,
  playerId: 'user-123',
  playerName: 'Alice',
});

if (match.status === 'matched') {
  // Matched with other players!
  const connection = client.connect(match.gameId!, {
    playerPosition: match.playerPosition!,
    playerId: 'user-123',
  });
} else if (match.status === 'waiting') {
  // Waiting for more players
  console.log(`Position ${match.position} in queue`);

  // Poll for match status
  const status = await client.matchmakingStatus('user-123');
  if (status.status === 'matched') {
    // Now matched!
  }
}

// Cancel matchmaking
await client.leaveMatchmaking('user-123');
```

### Connection Event Handling

```typescript
import { MeepleClient } from 'boardsmith/client';

const client = new MeepleClient({ baseUrl: 'https://game.example.com' });
const connection = client.connect(gameId, { playerPosition: 0 });

// State changes
connection.onStateChange((state) => {
  updateUI(state);
});

// Connection status
connection.onConnect(() => {
  console.log('Connected to game');
});

connection.onDisconnect(() => {
  console.log('Disconnected from game');
  showReconnectButton();
});

// Errors
connection.onError((error) => {
  console.error('Game error:', error);
  showErrorMessage(error.message);
});

// Action results
connection.onActionResult((result) => {
  if (!result.success) {
    showActionError(result.error);
  }
});
```

### Performing Actions

```typescript
// Simple action
await connection.action('draw');

// Action with arguments
await connection.action('play', {
  card: 'card-123',
  target: 'space-456',
});

// Action with error handling
try {
  const result = await connection.action('move', {
    from: 'a1',
    to: 'b2',
  });

  if (!result.success) {
    console.error('Move failed:', result.error);
  }
} catch (error) {
  console.error('Connection error:', error);
}
```

### Game History and Replay

```typescript
// Get action history
const history = await connection.getHistory();
console.log(`${history.actionHistory.length} actions played`);

// Get state at specific action
const pastState = await connection.getStateAt(10, 0);

// Get state diff between two points
const diff = await connection.getStateDiff(5, 10, 0);
```

### Lobby Management

```typescript
const client = new MeepleClient({ baseUrl: 'https://game.example.com' });

// Create game with lobby
const { gameId } = await client.createGame({
  gameType: 'go-fish',
  playerCount: 4,
  withLobby: true,
});

// Connect as spectator to lobby
const connection = client.connect(gameId, {
  playerId: 'user-123',
  spectator: true,
});

// Claim a position
await connection.claimPosition({
  position: 0,
  playerId: 'user-123',
  name: 'Alice',
});

// Update name
await connection.updateName({
  playerId: 'user-123',
  name: 'Alice the Great',
});

// Set ready status
await connection.setReady({
  playerId: 'user-123',
  ready: true,
});

// Listen for lobby updates
connection.onLobbyUpdate((lobby) => {
  console.log('Lobby state:', lobby.state);
  console.log('Slots:', lobby.slots);
});
```

### Audio Service

```typescript
import { audioService } from 'boardsmith/client';

// Configure audio
audioService.configure({
  basePath: '/sounds',
  enabled: true,
  volume: 0.8,
});

// Play sounds
audioService.play('card-play');
audioService.play('piece-capture');
audioService.play('victory');

// Toggle mute
audioService.mute();
audioService.unmute();

// Adjust volume
audioService.setVolume(0.5);
```

### Undo and Restart

```typescript
// Undo last move (if allowed)
const undoResult = await connection.undo(0);

if (!undoResult.success) {
  console.log('Cannot undo:', undoResult.error);
}

// Restart game
await connection.restart();
```

### Spectator Mode

```typescript
const connection = client.connect(gameId, {
  spectator: true,
});

// Spectators receive state updates but cannot perform actions
connection.onStateChange((state) => {
  // Watch the game
  renderGameBoard(state);
});

// This will fail for spectators
try {
  await connection.action('move', { from: 'a1', to: 'b2' });
} catch (error) {
  console.log('Spectators cannot perform actions');
}
```

## See Also

- [boardsmith/server](./server.md) - Server-side implementation
- [boardsmith/session](./session.md) - Session management
- [UI Components Guide](../ui-components.md) - Building game UIs
````

## File: docs/api/eslint-plugin.md
````markdown
# boardsmith/eslint-plugin

> ESLint rules for game code determinism.

## When to Use

Import from `boardsmith/eslint-plugin` when linting game rule code to ensure determinism. Board games must produce the same results given the same inputs, so this plugin catches common sources of non-determinism.

## Usage

```javascript
// eslint.config.js
import boardsmithPlugin from 'boardsmith/eslint-plugin';

export default [
  {
    files: ['src/games/**/*.ts'],
    plugins: {
      boardsmith: boardsmithPlugin,
    },
    rules: {
      'boardsmith/no-network': 'error',
      'boardsmith/no-filesystem': 'error',
      'boardsmith/no-timers': 'error',
      'boardsmith/no-nondeterministic': 'error',
      'boardsmith/no-eval': 'error',
    },
  },
];
```

## Exports

### Default Export

- `default` - ESLint plugin with rules and configs

### Named Exports

- `rules` - Individual rules object
- `configs` - Configuration presets

## Rules

### no-network

Disallows network access in game code.

**Why:** Network calls are inherently non-deterministic (latency, failures, different responses).

```typescript
// Bad
fetch('/api/data'); // Error: Network access is not allowed
new XMLHttpRequest(); // Error: Network access is not allowed
new WebSocket('ws://...'); // Error: Network access is not allowed

// Good
// Use game state and actions instead
this.draw(1);
```

### no-filesystem

Disallows filesystem access in game code.

**Why:** File contents can change between runs, breaking determinism.

```typescript
// Bad
import fs from 'fs';
fs.readFileSync('data.json'); // Error: Filesystem access is not allowed

// Good
// Define data in code or load at initialization
const CARD_DATA = [
  { rank: 'A', suit: 'hearts' },
  // ...
];
```

### no-timers

Disallows timers and time-based code in game logic.

**Why:** Time varies between runs. Game state should advance through actions, not time.

```typescript
// Bad
setTimeout(() => doThing(), 1000); // Error: Timers are not allowed
Date.now(); // Error: Current time is not allowed
new Date(); // Error: Current time is not allowed

// Good
// Use flow control for timing
sequence(
  actionStep({ name: 'play' }),
  execute(() => this.nextPhase()),
);
```

### no-nondeterministic

Disallows `Math.random()` and similar non-deterministic functions.

**Why:** Random results vary between runs. Use the seeded random provided by BoardSmith.

```typescript
// Bad
Math.random(); // Error: Use game's seeded random instead
crypto.getRandomValues(); // Error: Non-deterministic

// Good
// Use game's random (automatically seeded)
this.deck.shuffle(); // Uses seeded random internally
this.die.roll(); // Uses seeded random internally

// For custom random needs
const value = this.random(); // Returns seeded random 0-1
```

### no-eval

Disallows `eval()` and `Function()` constructor.

**Why:** Dynamic code execution is a security risk and breaks static analysis.

```typescript
// Bad
eval('doSomething()'); // Error: eval is not allowed
new Function('return x + y'); // Error: Function constructor is not allowed

// Good
// Define logic statically
function doSomething() {
  // ...
}
```

## Configuration Presets

### recommended

Enables all rules at error level.

```javascript
// eslint.config.js
import boardsmithPlugin from 'boardsmith/eslint-plugin';

export default [
  {
    files: ['src/games/**/*.ts'],
    ...boardsmithPlugin.configs.recommended,
  },
];
```

Equivalent to:

```javascript
{
  plugins: ['boardsmith'],
  rules: {
    'boardsmith/no-network': 'error',
    'boardsmith/no-filesystem': 'error',
    'boardsmith/no-timers': 'error',
    'boardsmith/no-nondeterministic': 'error',
    'boardsmith/no-eval': 'error',
  },
}
```

## Examples

### Full ESLint Configuration

```javascript
// eslint.config.js
import tseslint from 'typescript-eslint';
import boardsmithPlugin from 'boardsmith/eslint-plugin';

export default tseslint.config(
  // Base TypeScript config
  ...tseslint.configs.recommended,

  // Game code - strict determinism
  {
    files: ['src/games/**/game.ts', 'src/games/**/rules/**/*.ts'],
    plugins: {
      boardsmith: boardsmithPlugin,
    },
    rules: {
      'boardsmith/no-network': 'error',
      'boardsmith/no-filesystem': 'error',
      'boardsmith/no-timers': 'error',
      'boardsmith/no-nondeterministic': 'error',
      'boardsmith/no-eval': 'error',
    },
  },

  // UI code - less strict
  {
    files: ['src/games/**/ui/**/*.ts', 'src/games/**/ui/**/*.vue'],
    plugins: {
      boardsmith: boardsmithPlugin,
    },
    rules: {
      // UI can use timers for animations
      'boardsmith/no-timers': 'off',
      // But still no network/random in UI
      'boardsmith/no-network': 'error',
      'boardsmith/no-nondeterministic': 'error',
    },
  },
);
```

### Disabling Rules

```typescript
// Temporarily disable for a line
// eslint-disable-next-line boardsmith/no-timers
const now = Date.now(); // For logging only, not game logic

// Disable for a block
/* eslint-disable boardsmith/no-network */
// This code runs in UI, not game logic
await fetch('/api/leaderboard');
/* eslint-enable boardsmith/no-network */
```

### Common Patterns

```typescript
// BAD: Non-deterministic shuffle
cards.sort(() => Math.random() - 0.5);

// GOOD: Use deck's shuffle method
this.deck.shuffle();

// BAD: Random player selection
const firstPlayer = Math.floor(Math.random() * playerCount);

// GOOD: Use game's random
const firstPlayer = Math.floor(this.random() * playerCount);

// BAD: Time-based seed
const seed = Date.now().toString();

// GOOD: Use provided seed
// (GameSession provides deterministic seed automatically)

// BAD: Fetch card images
const cardImage = await fetch(`/cards/${card.id}.png`);

// GOOD: Reference static assets
const cardImage = `/cards/${card.id}.png`; // URL only, no fetch
```

## See Also

- [Common Pitfalls](../common-pitfalls.md) - Avoiding determinism issues
- [boardsmith](./index.md) - Core engine with seeded random
````

## File: docs/api/index.md
````markdown
# boardsmith

> Core game engine - elements, actions, flow, and commands.

## When to Use

Import from `boardsmith` when building game logic. This is the root export containing all element classes (Game, Card, Piece, etc.), action definitions, flow control, and the command system for event sourcing.

## Usage

```typescript
import {
  Game,
  GameElement,
  Space,
  Piece,
  Card,
  Hand,
  Deck,
  Player,
  Action,
  FlowEngine,
  sequence,
  actionStep,
} from 'boardsmith';
```

## Exports

### Element Classes

- `GameElement` - Base class for all game elements
- `Space` - Container for pieces and cards
- `Piece` - Game piece that can move between spaces
- `Card` - Playing card with visibility rules
- `Hand` - Player's hand of cards
- `Deck` - Stack of cards with shuffle support
- `Die` - Single die with configurable sides
- `DicePool` - Collection of dice for rolling
- `Grid` - Rectangular grid of spaces
- `GridCell` - Individual cell in a Grid
- `HexGrid` - Hexagonal grid layout
- `HexCell` - Individual cell in a HexGrid
- `Game` - Base class for game definitions
- `ElementCollection` - Queryable collection of elements
- `PersistentMap` - Map that survives serialization

### Player System

- `Player` - Base class for player state
- `AbilityManager` - Manages player abilities and resources

### Scoring System

- `Track` - Base scoring track
- `MonotonicTrack` - Track that only increases/decreases
- `UniqueTrack` - Track with unique values
- `CounterTrack` - Simple numeric counter

### Command System

- `executeCommand()` - Execute a game command
- `undoCommand()` - Undo a command
- `createInverseCommand()` - Create inverse for undo
- `canPlayerSee()` - Check visibility for player
- `visibilityFromMode()` - Convert mode to visibility state
- `resolveVisibility()` - Resolve visibility configuration
- `DEFAULT_VISIBILITY` - Default visibility settings

### Action System

- `Action` - Define player actions with selections
- `ActionExecutor` - Execute actions with validation
- `evaluateCondition()` - Evaluate action conditions

### Filter Helpers

- `dependentFilter()` - Filter based on previous selections
- `adjacentToSelection()` - Filter to adjacent elements
- `excludeAlreadySelected()` - Exclude previously selected
- `allOf()` - Combine filters with AND
- `anyOf()` - Combine filters with OR
- `not()` - Negate a filter

### Action State

- `actionTempState()` - Persist state between choices and execute

### Flow System

- `FlowEngine` - Run game flow definitions
- `sequence()` - Execute steps in sequence
- `namedSequence()` - Named sequence for debugging
- `phase()` - Define a game phase
- `loop()` - Loop until condition
- `repeat()` - Repeat N times
- `eachPlayer()` - Execute for each player
- `forEach()` - Execute for each item
- `actionStep()` - Wait for player action
- `simultaneousActionStep()` - Wait for all players
- `playerActions()` - Define available actions
- `switchOn()` - Branch based on value
- `ifThen()` - Conditional execution
- `defineFlow()` - Define reusable flow
- `noop()` - No operation
- `execute()` - Execute function
- `setVar()` - Set flow variable
- `turnLoop()` - Standard turn-based loop
- `TurnOrder` - Turn order utilities

### Utilities

- `serializeValue()` - Serialize game values
- `deserializeValue()` - Deserialize game values
- `serializeAction()` - Serialize an action
- `deserializeAction()` - Deserialize an action
- `isSerializedReference()` - Check if value is reference
- `createSnapshot()` - Create game state snapshot
- `createPlayerView()` - Create player-specific view
- `createAllPlayerViews()` - Create all player views
- `createReplayFile()` - Create replay file format
- `validateReplayFile()` - Validate replay file
- `parseReplayFile()` - Parse replay file
- `resolveElementArg()` - Resolve element argument
- `isResolvedElement()` - Check if element is resolved
- `captureDevState()` - Capture state for HMR
- `restoreDevState()` - Restore state after HMR
- `validateDevSnapshot()` - Validate dev snapshot
- `formatValidationErrors()` - Format validation errors
- `validateFlowPosition()` - Validate flow position
- `formatFlowRecovery()` - Format flow recovery info
- `getSnapshotElementCount()` - Count elements in snapshot
- `createTrackedRandom()` - Create deterministic random
- `getRandomCallCount()` - Get random call count
- `resetRandomCallCounter()` - Reset random counter
- `createCheckpoint()` - Create HMR checkpoint
- `restoreFromCheckpoint()` - Restore from checkpoint

### Sandbox

- `ExecutionContext` - Execution context with limits
- `ExecutionLimitError` - Error for exceeded limits
- `withLimits()` - Run with execution limits
- `withLimitsAsync()` - Run async with limits
- `guard()` - Guard execution
- `validateCode()` - Validate code safety
- `DEFAULT_LIMITS` - Default execution limits

### Types

- `ElementClass` - Element class constructor
- `ElementContext` - Element context data
- `ElementTree` - Element tree structure
- `ElementJSON` - Serialized element
- `ElementFinder` - Element query function
- `ElementAttributes` - Element attributes
- `Sorter` - Sort comparison function
- `GameOptions` - Game constructor options
- `GamePhase` - Game phase enum
- `PlayerViewFunction` - Player view function
- `ElementLayout` - Layout configuration
- `HexOrientation` - Hex grid orientation
- `HexCoordSystem` - Hex coordinate system
- `LayoutDirection` - Layout direction
- `LayoutAlignment` - Layout alignment
- `DieSides` - Die sides configuration
- `Ability` - Player ability type
- `TrackEntry` - Track entry type
- `TrackConfig` - Track configuration
- `GameCommand` - Command type union
- `CommandResult` - Command execution result
- `SelectionType` - Selection type enum
- `Selection` - Selection definition
- `ActionContext` - Action execution context
- `ActionDefinition` - Action definition
- `ActionResult` - Action execution result
- `FlowNodeType` - Flow node type enum
- `FlowStepResult` - Flow step result
- `FlowPosition` - Flow position
- `FlowContext` - Flow context
- `FlowNode` - Flow node
- `FlowState` - Flow state
- `FlowDefinition` - Flow definition
- `ExecutionLimits` - Execution limit config

## Examples

### Defining a Game

```typescript
import { Game, Player, Space, Piece, Action } from 'boardsmith';

class MyGame extends Game<MyGame, MyPlayer> {
  board!: Space<MyGame, MyPlayer>;

  defineElements() {
    this.board = this.create(Space, 'board');

    for (let i = 0; i < 4; i++) {
      this.board.create(Piece, 'token', { color: i });
    }
  }

  defineActions() {
    this.defineAction('move', {
      prompt: 'Select a token to move',
      select: {
        type: 'element',
        from: this.board.all(Piece),
      },
      execute: ({ selected }) => {
        // Move logic
      },
    });
  }
}
```

### Using Flow Control

```typescript
import { sequence, eachPlayer, actionStep, loop } from 'boardsmith';

const gameFlow = sequence(
  // Setup phase
  execute(() => game.deal()),

  // Main game loop
  loop(
    eachPlayer({
      do: actionStep({ name: 'play' }),
    }),
    // Continue until game ends
    () => !game.isOver(),
  ),
);
```

## See Also

- [Getting Started](../getting-started.md)
- [Core Concepts](../core-concepts.md)
- [Actions and Flow](../actions-and-flow.md)
````

## File: docs/api/runtime.md
````markdown
# boardsmith/runtime

> Game runner and serialization utilities.

## When to Use

Import from `boardsmith/runtime` when you need low-level game execution, serialization for network transfer, or replay functionality. This package is used internally by both client and server packages.

## Usage

```typescript
import {
  GameRunner,
  serializeAction,
  deserializeAction,
  createSnapshot,
  createPlayerView,
} from 'boardsmith/runtime';
```

## Exports

### Game Runner

- `GameRunner` - Execute game instances with action handling

### Serialization

- `serializeValue()` - Serialize game values for transfer
- `deserializeValue()` - Deserialize game values
- `serializeAction()` - Serialize an action with arguments
- `deserializeAction()` - Deserialize an action
- `isSerializedReference()` - Check if value is an element reference

### State Snapshots

- `createSnapshot()` - Create a full game state snapshot
- `createPlayerView()` - Create player-specific state view
- `createAllPlayerViews()` - Create views for all players

### Replay

- `createReplayFile()` - Create a replay file from game history
- `validateReplayFile()` - Validate replay file format
- `parseReplayFile()` - Parse replay file content

### Types

- `GameRunnerOptions` - Runner configuration
- `ActionExecutionResult` - Action execution result
- `SerializedReference` - Serialized element reference
- `SerializeOptions` - Serialization options
- `GameStateSnapshot` - Full game state snapshot
- `PlayerStateView` - Player-specific view
- `ReplayFile` - Replay file format

## Examples

### Using GameRunner

```typescript
import { GameRunner } from 'boardsmith/runtime';
import { MyGame } from './game';

// Create a game runner
const runner = new GameRunner({
  GameClass: MyGame,
  gameType: 'my-game',
  playerCount: 2,
  playerNames: ['Alice', 'Bob'],
});

// Get current state
const snapshot = runner.getSnapshot();
console.log('Current player:', snapshot.flowState.currentPlayer);

// Execute an action
const result = runner.executeAction({
  action: 'move',
  player: 0,
  args: { from: 'a1', to: 'b2' },
});

if (result.success) {
  console.log('Move executed');
  console.log('New state:', result.snapshot);
} else {
  console.error('Move failed:', result.error);
}
```

### Serializing Actions for Network

```typescript
import { serializeAction, deserializeAction } from 'boardsmith/runtime';

// On the client
const action = {
  action: 'play',
  player: 0,
  args: {
    card: cardElement, // GameElement reference
    target: spaceElement,
  },
};

// Serialize for network transfer
const serialized = serializeAction(action, game);
// { action: 'play', player: 0, args: { card: { _ref: 'card-123' }, target: { _ref: 'space-456' } } }

// Send over WebSocket
ws.send(JSON.stringify(serialized));

// On the server
const received = JSON.parse(message);
const deserialized = deserializeAction(received, game);
// { action: 'play', player: 0, args: { card: <Card element>, target: <Space element> } }
```

### Creating Player Views

```typescript
import { createSnapshot, createPlayerView, createAllPlayerViews } from 'boardsmith/runtime';

// Create full snapshot (includes all hidden information)
const fullSnapshot = createSnapshot(game);

// Create view for specific player (respects visibility)
const player0View = createPlayerView(game, 0);
// Player 0 can see their own hand but not opponent's

// Create views for all players at once
const allViews = createAllPlayerViews(game);
// { 0: player0View, 1: player1View, ... }

// Views hide information the player shouldn't see
console.log(player0View.elements);
// Cards in opponent's hand show as { type: 'card', faceDown: true }
```

### Working with Replays

```typescript
import { createReplayFile, validateReplayFile, parseReplayFile } from 'boardsmith/runtime';

// Create a replay file from completed game
const replay = createReplayFile({
  gameType: 'checkers',
  playerCount: 2,
  playerNames: ['Alice', 'Bob'],
  actionHistory: session.getHistory().actionHistory,
  initialSeed: session.getSeed(),
  result: {
    winner: 0,
    reason: 'checkmate',
  },
});

// Save to file
const replayJson = JSON.stringify(replay, null, 2);
fs.writeFileSync('game-replay.json', replayJson);

// Later, load and validate
const loaded = JSON.parse(fs.readFileSync('game-replay.json', 'utf-8'));
const validation = validateReplayFile(loaded);

if (validation.valid) {
  const parsed = parseReplayFile(loaded);
  console.log(`Replay: ${parsed.playerNames.join(' vs ')}`);
  console.log(`Actions: ${parsed.actionHistory.length}`);
  console.log(`Winner: ${parsed.result.winner}`);
} else {
  console.error('Invalid replay:', validation.errors);
}
```

### Serialization Details

```typescript
import { serializeValue, deserializeValue, isSerializedReference } from 'boardsmith/runtime';

// Serialize various value types
serializeValue(42); // 42
serializeValue('hello'); // 'hello'
serializeValue(true); // true
serializeValue(null); // null
serializeValue([1, 2, 3]); // [1, 2, 3]
serializeValue({ x: 1, y: 2 }); // { x: 1, y: 2 }

// GameElements become references
serializeValue(cardElement, game);
// { _ref: 'card-123' }

// Check for references
isSerializedReference({ _ref: 'card-123' }); // true
isSerializedReference({ x: 1 }); // false

// Deserialize back
const card = deserializeValue({ _ref: 'card-123' }, game);
// Returns the actual Card element
```

### Runner with Action History

```typescript
import { GameRunner } from 'boardsmith/runtime';

const runner = new GameRunner({
  GameClass: MyGame,
  gameType: 'my-game',
  playerCount: 2,
  playerNames: ['Alice', 'Bob'],
  seed: 'deterministic-seed',
});

// Execute a series of actions
runner.executeAction({ action: 'draw', player: 0, args: {} });
runner.executeAction({ action: 'play', player: 0, args: { card: 'card-1' } });
runner.executeAction({ action: 'draw', player: 1, args: {} });

// Get action history
const history = runner.getActionHistory();
console.log(`${history.length} actions played`);

// Replay to a specific point
const stateAtAction2 = runner.getStateAt(2);
```

## See Also

- [boardsmith/session](./session.md) - Higher-level session management
- [boardsmith/server](./server.md) - Server implementation
- [boardsmith](./index.md) - Core game engine
````

## File: docs/api/server.md
````markdown
# boardsmith/server

> Platform-agnostic game server core.

## When to Use

Import from `boardsmith/server` when building self-hosted game servers. This package provides HTTP/WebSocket handlers, storage adapters, and matchmaking that works with both Node.js and edge runtimes.

## Usage

```typescript
import {
  GameServerCore,
  InMemoryGameStore,
  SqliteGameStore,
  handleCreateGame,
  handleAction,
} from 'boardsmith/server';
```

## Exports

### Core

- `GameServerCore` - Main server class

### Storage Implementations

- `InMemoryGameStore` - In-memory game storage
- `SimpleGameRegistry` - Simple game registry
- `InMemoryMatchmakingStore` - In-memory matchmaking
- `SqliteGameStore` - SQLite game storage
- `SqliteStorageAdapter` - SQLite storage adapter
- `initSqliteSchema()` - Initialize SQLite schema

### Request Handlers

- `handleCreateGame()` - Handle game creation
- `handleGetGame()` - Handle get game state
- `handleAction()` - Handle action execution
- `handleGetHistory()` - Handle get action history
- `handleGetStateAt()` - Handle get state at action index
- `handleGetStateDiff()` - Handle get state diff
- `handleUndo()` - Handle undo request
- `handleRestart()` - Handle game restart
- `handleHealth()` - Handle health check
- `handleRewind()` - Handle rewind to action

### Matchmaking Handlers

- `handleMatchmakingJoin()` - Handle join matchmaking
- `handleMatchmakingStatus()` - Handle matchmaking status check
- `handleMatchmakingLeave()` - Handle leave matchmaking

### Types

- `ServerRequest` - Server request type
- `ServerResponse` - Server response type
- `GameServerCoreOptions` - Server options
- `CreateGameOptions` - Create game options
- `CreateGameResult` - Create game result
- `GameStore` - Game storage interface
- `GameRegistry` - Game registry interface
- `MatchmakingStore` - Matchmaking storage interface
- `QueueEntry` - Matchmaking queue entry
- `MatchInfo` - Match information
- `WaitingInfo` - Waiting information
- `MatchmakingRequest` - Matchmaking request
- `WebSocketAdapter` - WebSocket adapter interface
- `WebSocketSession` - WebSocket session
- `GameSessionWithBroadcaster` - Session with broadcaster
- `BroadcasterFactory` - Broadcaster factory function
- `GameDefinition` - Game definition
- `GameClass` - Game class type
- `GameConfig` - Game configuration
- `StoredGameState` - Stored game state
- `PlayerGameState` - Player game state
- `SessionInfo` - Session information
- `AIConfig` - AI configuration
- `BroadcastAdapter` - Broadcast adapter
- `StorageAdapter` - Storage adapter
- `CreateGameRequest` - Create game request
- `ActionRequest` - Action request
- `WebSocketMessage` - WebSocket message

## Examples

### Basic Express Server

```typescript
import express from 'express';
import { GameServerCore, InMemoryGameStore, SimpleGameRegistry } from 'boardsmith/server';
import { GoFishGame } from './games/go-fish/game';

const app = express();
app.use(express.json());

// Set up game registry
const registry = new SimpleGameRegistry();
registry.set({
  gameType: 'go-fish',
  gameClass: GoFishGame,
  minPlayers: 2,
  maxPlayers: 6,
});

// Set up server
const server = new GameServerCore({
  gameRegistry: registry,
  gameStore: new InMemoryGameStore(),
});

// REST endpoints
app.post('/games', async (req, res) => {
  const result = await server.createGame(req.body);
  res.status(result.success ? 201 : 400).json(result);
});

app.get('/games/:id', async (req, res) => {
  const player = parseInt(req.query.player as string) || 0;
  const result = await server.getGame(req.params.id, player);
  res.json(result);
});

app.post('/games/:id/action', async (req, res) => {
  const result = await server.performAction(req.params.id, req.body);
  res.json(result);
});

app.listen(3000);
```

### With SQLite Persistence

```typescript
import { GameServerCore, SqliteGameStore, SimpleGameRegistry } from 'boardsmith/server';
import Database from 'better-sqlite3';

// Initialize SQLite
const db = new Database('./games.db');
const gameStore = new SqliteGameStore(db);

const server = new GameServerCore({
  gameRegistry: registry,
  gameStore: gameStore,
});

// Games now persist across restarts
```

### WebSocket Support

```typescript
import { WebSocketServer } from 'ws';
import { GameServerCore, InMemoryGameStore } from 'boardsmith/server';

const wss = new WebSocketServer({ port: 8080 });
const server = new GameServerCore({
  gameRegistry: registry,
  gameStore: new InMemoryGameStore(),
});

wss.on('connection', (ws, req) => {
  const gameId = new URL(req.url!, 'http://localhost').searchParams.get('gameId');
  const player = parseInt(new URL(req.url!, 'http://localhost').searchParams.get('player') || '0');

  // Register connection for broadcasts
  server.registerConnection(gameId!, {
    playerPosition: player,
    send: (msg) => ws.send(JSON.stringify(msg)),
  });

  ws.on('message', async (data) => {
    const message = JSON.parse(data.toString());

    if (message.type === 'action') {
      const result = await server.performAction(gameId!, {
        action: message.action,
        player: player,
        args: message.args,
      });

      ws.send(JSON.stringify({ type: 'actionResult', ...result }));
    }
  });

  ws.on('close', () => {
    server.unregisterConnection(gameId!, player);
  });
});
```

### Using Individual Handlers

```typescript
import {
  handleCreateGame,
  handleGetGame,
  handleAction,
  InMemoryGameStore,
  SimpleGameRegistry,
} from 'boardsmith/server';

const gameStore = new InMemoryGameStore();
const registry = new SimpleGameRegistry();
registry.set(gameDefinition);

// In your request handler
async function createGame(req: Request): Promise<Response> {
  const body = await req.json();

  const result = await handleCreateGame(gameStore, registry, body);

  return new Response(JSON.stringify(result.body), {
    status: result.status,
    headers: { 'Content-Type': 'application/json' },
  });
}
```

### Matchmaking

```typescript
import {
  InMemoryMatchmakingStore,
  handleMatchmakingJoin,
  handleMatchmakingStatus,
  handleMatchmakingLeave,
} from 'boardsmith/server';

const matchmaking = new InMemoryMatchmakingStore();

app.post('/matchmaking/join', async (req, res) => {
  const result = await handleMatchmakingJoin(
    matchmaking,
    registry,
    req.body,
    async (gameType, playerCount, playerNames, playerIds) => {
      // Create game when match is found
      const game = await server.createGame({
        gameType,
        playerCount,
        playerNames,
        playerIds,
      });
      return game.gameId!;
    },
  );
  res.status(result.status).json(result.body);
});

app.get('/matchmaking/status', async (req, res) => {
  const result = await handleMatchmakingStatus(matchmaking, req.query.playerId as string);
  res.status(result.status).json(result.body);
});

app.post('/matchmaking/leave', async (req, res) => {
  const result = await handleMatchmakingLeave(matchmaking, req.body.playerId);
  res.status(result.status).json(result.body);
});
```

### Custom Storage Adapter

```typescript
import type { GameStore, StoredGameState } from 'boardsmith/server';

class RedisGameStore implements GameStore {
  constructor(private redis: Redis) {}

  async get(gameId: string): Promise<StoredGameState | null> {
    const data = await this.redis.get(`game:${gameId}`);
    return data ? JSON.parse(data) : null;
  }

  async set(gameId: string, state: StoredGameState): Promise<void> {
    await this.redis.set(`game:${gameId}`, JSON.stringify(state));
  }

  async delete(gameId: string): Promise<void> {
    await this.redis.del(`game:${gameId}`);
  }

  async list(): Promise<string[]> {
    const keys = await this.redis.keys('game:*');
    return keys.map((k) => k.replace('game:', ''));
  }
}
```

### Multiple Game Types

```typescript
import { SimpleGameRegistry } from 'boardsmith/server';
import { GoFishGame } from './games/go-fish/game';
import { CheckersGame } from './games/checkers/game';
import { TicTacToeGame } from './games/tic-tac-toe/game';

const registry = new SimpleGameRegistry();

registry.set({
  gameType: 'go-fish',
  gameClass: GoFishGame,
  minPlayers: 2,
  maxPlayers: 6,
});

registry.set({
  gameType: 'checkers',
  gameClass: CheckersGame,
  minPlayers: 2,
  maxPlayers: 2,
});

registry.set({
  gameType: 'tic-tac-toe',
  gameClass: TicTacToeGame,
  minPlayers: 2,
  maxPlayers: 2,
});

// Server automatically handles all game types
```

## See Also

- [boardsmith/client](./client.md) - Browser client SDK
- [boardsmith/worker](./worker.md) - Cloudflare Workers deployment
- [boardsmith/session](./session.md) - Session management
````

## File: docs/api/session.md
````markdown
# boardsmith/session

> Game session management for local and multiplayer games.

## When to Use

Import from `boardsmith/session` when managing game sessions, handling AI opponents, or building multiplayer infrastructure. This package provides a unified API for game state management across different platforms.

## Usage

```typescript
import {
  GameSession,
  AIController,
  CheckpointManager,
  generateGameId,
  type GameDefinition,
  type StorageAdapter,
} from 'boardsmith/session';
```

## Exports

### Core Classes

- `GameSession` - Main session manager for game state
- `AIController` - Manages AI player turns
- `CheckpointManager` - Manages state checkpoints for HMR

### Utilities

- `generateGameId()` - Generate unique game ID
- `isPlayersTurn()` - Check if it's a player's turn
- `buildPlayerState()` - Build player-specific state view

### Player Colors

- `STANDARD_PLAYER_COLORS` - Full color palette
- `DEFAULT_PLAYER_COLORS` - Default 6 player colors
- `createColorOption()` - Create color selection option

### Error Handling

- `ErrorCode` - Error code enum for session errors

### Types

- `GameClass` - Game class constructor type
- `GameDefinition` - Game definition with metadata
- `GameConfig` - Game configuration options
- `StoredGameState` - Persisted game state
- `PlayerGameState` - Player-specific state view
- `SessionInfo` - Session metadata
- `StateUpdate` - State update message
- `AIConfig` - AI player configuration
- `StorageAdapter` - Storage backend interface
- `BroadcastAdapter` - WebSocket broadcast interface
- `CreateGameRequest` - Create game request
- `ActionRequest` - Action request message
- `WebSocketMessage` - WebSocket message type
- `PlayerOptionDefinition` - Player option definition
- `StandardPlayerOption` - Standard player option
- `ExclusivePlayerOption` - Exclusive player option
- `PlayerConfig` - Player configuration
- `GamePreset` - Game preset definition
- `GameOptionDefinition` - Game option definition
- `NumberOption` - Numeric option
- `SelectOption` - Selection option
- `BooleanOption` - Boolean option
- `LobbyState` - Lobby state enum
- `SlotStatus` - Slot status enum
- `LobbySlot` - Lobby slot data
- `LobbyInfo` - Lobby information
- `LobbyUpdate` - Lobby update message
- `ClaimPositionRequest` - Claim position request
- `ClaimPositionResponse` - Claim position response
- `UpdateNameRequest` - Update name request
- `GameSessionOptions` - Session constructor options
- `ActionResult` - Action execution result
- `UndoResult` - Undo operation result
- `CheckpointManagerOptions` - Checkpoint manager options
- `ColorChoice` - Color choice option
- `ColorOptionDefinition` - Color option definition

## Examples

### Creating a Local Game Session

```typescript
import { GameSession } from 'boardsmith/session';
import { MyGame } from './game';

// Create a new game session
const session = GameSession.create({
  gameType: 'my-game',
  GameClass: MyGame,
  playerCount: 2,
  playerNames: ['Alice', 'Bob'],
});

// Get state for a specific player
const { flowState, state } = session.getState(0);
console.log('Current player:', flowState.currentPlayer);
console.log('Available actions:', flowState.actions);

// Perform an action
const result = await session.performAction('move', 0, {
  from: 'a1',
  to: 'b2',
});

if (result.success) {
  console.log('Move successful!');
} else {
  console.error('Move failed:', result.error);
}
```

### Adding AI Opponents

```typescript
import { GameSession } from 'boardsmith/session';
import { MyGame } from './game';

const session = GameSession.create({
  gameType: 'my-game',
  GameClass: MyGame,
  playerCount: 2,
  playerNames: ['Human', 'Bot'],
  aiConfig: {
    players: [1], // Player 1 is AI
    level: 'hard',
  },
});

// AI moves are handled automatically when it's the AI's turn
const result = await session.performAction('move', 0, { from: 'a1', to: 'b2' });
// After the human moves, AI will automatically play
```

### Implementing Storage Adapter

```typescript
import type { StorageAdapter, StoredGameState } from 'boardsmith/session';

class LocalStorageAdapter implements StorageAdapter {
  constructor(private gameId: string) {}

  async save(state: StoredGameState): Promise<void> {
    localStorage.setItem(`game:${this.gameId}`, JSON.stringify(state));
  }

  async load(): Promise<StoredGameState | null> {
    const data = localStorage.getItem(`game:${this.gameId}`);
    return data ? JSON.parse(data) : null;
  }
}

const session = GameSession.create({
  gameType: 'my-game',
  GameClass: MyGame,
  playerCount: 2,
  playerNames: ['Alice', 'Bob'],
  storage: new LocalStorageAdapter('game-123'),
});
```

### Restoring a Saved Game

```typescript
import { GameSession } from 'boardsmith/session';
import { MyGame } from './game';

// Load stored state
const storedState = await storage.load();

if (storedState) {
  // Restore from saved state
  const session = GameSession.restore(storedState, MyGame, storage);

  // Continue playing
  const { flowState, state } = session.getState(0);
}
```

### Multiplayer with Broadcast

```typescript
import type { BroadcastAdapter, SessionInfo } from 'boardsmith/session';

class WebSocketBroadcaster implements BroadcastAdapter<SessionInfo> {
  constructor(private connections: Map<number, WebSocket>) {}

  getSessions(): SessionInfo[] {
    return Array.from(this.connections.keys()).map((pos) => ({
      playerPosition: pos,
      isSpectator: false,
    }));
  }

  send(session: SessionInfo, message: unknown): void {
    const ws = this.connections.get(session.playerPosition);
    ws?.send(JSON.stringify(message));
  }
}

// Set up broadcasting
session.setBroadcaster(new WebSocketBroadcaster(connections));

// State updates are now automatically broadcast to all players
```

## See Also

- [boardsmith/server](./server.md) - Server-side game hosting
- [boardsmith/client](./client.md) - Browser client SDK
- [boardsmith/ai](./ai.md) - AI opponent system
````

## File: docs/api/testing.md
````markdown
# boardsmith/testing

> Test utilities for BoardSmith games.

## When to Use

Import from `boardsmith/testing` when writing tests for your game logic. This package provides utilities for creating test games, simulating actions, making assertions, and debugging game state.

## Usage

```typescript
import {
  createTestGame,
  simulateAction,
  assertFlowState,
  assertActionSucceeds,
  toDebugString,
} from 'boardsmith/testing';
```

## Exports

### Test Game Creation

- `TestGame` - Test game wrapper class
- `createTestGame()` - Create a test game instance

### Action Simulation

- `simulateAction()` - Simulate a single action
- `simulateActions()` - Simulate multiple actions
- `assertActionSucceeds()` - Assert action succeeds
- `assertActionFails()` - Assert action fails

### Random Simulation

- `simulateRandomGames()` - Run random game simulations for completeness testing

### Assertions

- `assertFlowState()` - Assert flow state matches expected
- `assertPlayerHas()` - Assert player has specific elements
- `assertElementCount()` - Assert element count
- `assertGameFinished()` - Assert game is finished
- `assertActionAvailable()` - Assert action is available
- `assertActionNotAvailable()` - Assert action is not available

### Fixtures and Scenarios

- `ScenarioBuilder` - Build test scenarios fluently
- `scenario()` - Create a scenario builder
- `quickGame()` - Create a quick game setup
- `playSequence()` - Play a sequence of actions
- `playUntil()` - Play until condition is met
- `createMultiple()` - Create multiple test games

### Debug Utilities

- `toDebugString()` - Convert game state to debug string
- `traceAction()` - Trace action execution
- `visualizeFlow()` - Visualize flow definition
- `visualizeFlowWithPosition()` - Visualize with current position
- `debugFlowState()` - Debug flow state
- `logAvailableActions()` - Log available actions
- `diffSnapshots()` - Diff two state snapshots

### Types

- `TestGameOptions` - Test game creation options
- `SimulateActionResult` - Action simulation result
- `SimulateRandomGamesOptions` - Random simulation options
- `SingleGameResult` - Single game simulation result
- `SimulationResults` - Aggregated simulation results
- `ExpectedFlowState` - Expected flow state
- `FlowStateAssertionResult` - Assertion result
- `DebugStringOptions` - Debug string options
- `ActionTraceResult` - Action trace result
- `ActionTraceDetail` - Action trace detail
- `FlowStateDebug` - Flow state debug info

## Examples

### Basic Test

```typescript
import { describe, test, expect } from 'vitest';
import { createTestGame, assertFlowState, assertActionSucceeds } from 'boardsmith/testing';
import { GoFishGame } from '../src/game';

describe('Go Fish', () => {
  test('player can ask for a card', () => {
    const game = createTestGame(GoFishGame, { playerCount: 2 });

    // Verify initial state
    assertFlowState(game, {
      currentPlayer: 0,
      actions: ['ask'],
    });

    // Perform an action
    assertActionSucceeds(game, 0, 'ask', {
      target: 1,
      rank: '7',
    });
  });
});
```

### Simulating Actions

```typescript
import { createTestGame, simulateAction } from 'boardsmith/testing';

const game = createTestGame(CheckersGame, { playerCount: 2 });

// Simulate a move
const result = simulateAction(game, 0, 'move', {
  from: 'a3',
  to: 'b4',
});

expect(result.success).toBe(true);
expect(result.state.board.children).toHaveLength(24);
```

### Using Scenario Builder

```typescript
import { scenario } from 'boardsmith/testing';

test('capturing a piece', () => {
  const game = scenario(CheckersGame)
    .withPlayers(2)
    .setup((g) => {
      // Set up specific board position
      g.board.at(2, 2).create(Piece, 'checker', { player: 0 });
      g.board.at(3, 3).create(Piece, 'checker', { player: 1 });
    })
    .build();

  // Test capturing
  assertActionSucceeds(game, 0, 'move', {
    from: { row: 2, col: 2 },
    to: { row: 4, col: 4 },
  });

  // Verify piece was captured
  assertElementCount(game, Piece, 1);
});
```

### Random Game Simulation

```typescript
import { simulateRandomGames } from 'boardsmith/testing';

test('game always terminates', async () => {
  const results = await simulateRandomGames(MyGame, {
    playerCount: 2,
    gameCount: 100,
    maxActions: 1000,
  });

  expect(results.completed).toBe(100);
  expect(results.stuck).toBe(0);
  expect(results.errors).toHaveLength(0);

  console.log(`Average game length: ${results.averageActions} actions`);
  console.log(`Win rates: ${JSON.stringify(results.winRates)}`);
});
```

### Debugging Test Failures

```typescript
import { createTestGame, toDebugString, traceAction, visualizeFlow } from 'boardsmith/testing';

const game = createTestGame(MyGame, { playerCount: 2 });

// Print current game state
console.log(toDebugString(game));
// Output:
// Game: MyGame
// Phase: playing
// Current Player: 0
// Board:
//   - Space "a1": Piece(white)
//   - Space "a2": empty
//   ...

// Trace why an action fails
const trace = traceAction(game, 0, 'move', { from: 'a1', to: 'c3' });
console.log(trace);
// Output:
// Action: move
// Player: 0
// Args: { from: "a1", to: "c3" }
// Status: FAILED
// Reason: Target space is not adjacent
// Conditions evaluated:
//   - isValidPiece: true
//   - isAdjacent: false (c3 is 2 squares away)

// Visualize game flow
console.log(visualizeFlow(game));
// Output:
// sequence
// ├── setup
// ├── loop (until: game.isOver())
// │   └── eachPlayer
// │       └── actionStep [current] -> "move"
// └── scoring
```

### Testing Edge Cases

```typescript
import { createTestGame, playUntil, assertGameFinished } from 'boardsmith/testing';

test('game handles draw correctly', () => {
  const game = createTestGame(TicTacToeGame, { playerCount: 2 });

  // Play until board is full (draw scenario)
  playUntil(game, (g) => g.board.all(Piece).length === 9);

  assertGameFinished(game, {
    winner: null, // Draw
    reason: 'board-full',
  });
});
```

## See Also

- [Common Pitfalls](../common-pitfalls.md) - Common issues and solutions
- [boardsmith](./index.md) - Core game engine
````

## File: docs/api/ui.md
````markdown
# boardsmith/ui

> Vue components and composables for game UI.

## When to Use

Import from `boardsmith/ui` when building the visual interface for your game. This includes shell components, automatic UI generation, drag-and-drop, animations, and board interaction composables.

## Usage

```typescript
import {
  GameShell,
  AutoUI,
  ActionPanel,
  useBoardInteraction,
  useAutoAnimations,
  useDragDrop,
} from 'boardsmith/ui';
```

## Exports

### Core Components

- `GameShell` - Main game container with header, panels, and layout
- `DebugPanel` - Developer debug tools
- `GameHeader` - Game title and player info
- `GameHistory` - Action history display
- `GameLobby` - Pre-game lobby for multiplayer
- `HamburgerMenu` - Mobile menu
- `PlayersPanel` - Player list and scores
- `WaitingRoom` - Waiting for players screen
- `Toast` - Toast notification component

### Helper Components

- `FlyingCardsOverlay` - Overlay for card animations
- `ZoomPreviewOverlay` - Card/die zoom preview

### 3D Dice

- `Die3D` - Three.js 3D die component
- `DIE_ANIMATION_CONTEXT_KEY` - Context key for die animations
- `createDieAnimationContext()` - Create die animation context

### Auto-UI Components

- `AutoUI` - Automatic game UI from state
- `AutoGameBoard` - Automatic board rendering
- `AutoElement` - Automatic element rendering
- `ActionPanel` - Action selection panel

### Composables

#### Board Interaction

- `useBoardInteraction()` - Core board interaction state and actions
- `createBoardInteraction()` - Create board interaction instance
- `provideBoardInteraction()` - Provide to component tree

#### Toast Notifications

- `useToast()` - Toast notification composable

#### Drag and Drop

- `useDragDrop()` - Drag and drop for game elements

#### Animations

- `useElementAnimation()` - Element animation utilities
- `prefersReducedMotion()` - Check reduced motion preference
- `useFlyingCards()` - Card flying animations
- `useAutoFlyingElements()` - Automatic element flying
- `useAutoFLIP()` - Automatic FLIP animations
- `useAutoFlyToStat()` - Fly elements to stat displays
- `useAutoAnimations()` - Unified animation system
- `useFlyOnAppear()` - Animate new elements
- `useActionAnimations()` - Action-triggered animations
- `useZoomPreview()` - Card/die zoom preview
- `usePlayerStatAnimation()` - Player stat animations
- `getPlayerStatElement()` - Get player stat element
- `flyToPlayerStat()` - Fly to player stat

#### Game View Helpers

- `useGameViewHelpers()` - Common view helpers
- `findElementById()` - Find element by ID
- `findElement()` - Find single element
- `findElements()` - Find multiple elements
- `findChildByAttribute()` - Find child by attribute
- `findElementByAttribute()` - Find by attribute
- `findAllByAttribute()` - Find all by attribute
- `getElementId()` - Get element ID
- `findPlayerHand()` - Find player's hand
- `findAllHands()` - Find all hands
- `getElementCount()` - Get element count
- `getCards()` - Get cards from container
- `getFirstCard()` - Get first card
- `getCardData()` - Get card display data
- `getElementOwner()` - Get element owner
- `isOwnedByPlayer()` - Check ownership
- `isMyElement()` - Check if current player's
- `isOpponentElement()` - Check if opponent's

#### Grid Utilities

- `useGameGrid()` - Grid game utilities
- `toAlgebraicNotation()` - Convert to chess notation
- `fromAlgebraicNotation()` - Parse chess notation

#### Hex Grid Utilities

- `useHexGrid()` - Hex grid utilities
- `hexToPixel()` - Convert hex to pixel coords
- `getHexPolygonPoints()` - Get hex polygon SVG points
- `calculateHexDistance()` - Calculate hex distance

#### Card Display

- `useCardDisplay()` - Card display utilities
- `getSuitSymbol()` - Get suit symbol
- `getSuitColor()` - Get suit color
- `getRankName()` - Get rank name
- `getCardPointValue()` - Get card point value
- `isRedSuit()` - Check if red suit
- `isBlackSuit()` - Check if black suit

#### Change Tracking

- `useElementChangeTracker()` - Track element changes
- `useCountTracker()` - Track count changes

#### FLIP Animations

- `useFLIPAnimation()` - Manual FLIP animations
- `createFLIPSnapshot()` - Create FLIP snapshot

#### Action Controller

- `useActionController()` - Action handling for custom UIs
- `injectActionController()` - Inject action controller
- `ACTION_CONTROLLER_KEY` - Injection key
- `injectSelectionStepFn()` - Inject selection step function
- `injectBoardInteraction()` - Inject board interaction
- `actionNeedsWizardMode()` - Check if action needs wizard

### Theming

- `applyTheme()` - Apply theme to game
- `getTheme()` - Get current theme
- `themeCSS()` - Generate theme CSS

### Player Colors

- `STANDARD_PLAYER_COLORS` - Standard color palette
- `DEFAULT_PLAYER_COLORS` - Default player colors

### Types

- `BoardInteraction` - Board interaction interface
- `BoardInteractionState` - Interaction state
- `BoardInteractionActions` - Interaction actions
- `ElementRef` - Element reference
- `HighlightableChoice` - Highlightable choice
- `DragProps` - Drag properties
- `DropProps` - Drop properties
- `UseDragDropReturn` - Drag-drop return type
- `AnimationOptions` - Animation options
- `FlyingCard` - Flying card data
- `HexOrientation` - Hex orientation type
- `HexGridOptions` - Hex grid options
- `ThemeConfig` - Theme configuration
- `ColorChoice` - Color choice option

## Examples

### Basic Game Shell

```vue
<script setup lang="ts">
import { GameShell, ActionPanel, useBoardInteraction } from 'boardsmith/ui';

const { state, flowState, performAction } = useBoardInteraction();
</script>

<template>
  <GameShell>
    <template #board>
      <!-- Your custom board rendering -->
      <div class="board">
        <div v-for="piece in state.board.children" :key="piece.id">
          {{ piece.type }}
        </div>
      </div>
    </template>

    <template #actions>
      <ActionPanel />
    </template>
  </GameShell>
</template>
```

### Drag and Drop

```vue
<script setup lang="ts">
import { useDragDrop } from 'boardsmith/ui';

const { drag, drop } = useDragDrop({
  canDrag: (el) => el.type === 'card' && el.owner === currentPlayer,
  canDrop: (dragEl, dropEl) => dropEl.type === 'space',
  onDrop: (dragEl, dropEl) => {
    performAction('play', { card: dragEl.id, target: dropEl.id });
  },
});
</script>

<template>
  <div v-for="card in hand.children" :key="card.id" v-bind="drag(card)">
    {{ card.rank }} of {{ card.suit }}
  </div>

  <div v-for="space in board.children" :key="space.id" v-bind="drop(space)">
    <!-- Drop zone -->
  </div>
</template>
```

### Auto Animations

```vue
<script setup lang="ts">
import { useAutoAnimations } from 'boardsmith/ui';

useAutoAnimations({
  containers: [
    { selector: '.hand', from: 'deck' },
    { selector: '.discard', from: 'hand' },
  ],
  flyToStats: [
    { selector: '.score', stat: 'score' },
  ],
});
</script>
```

## CSS Assets

```typescript
// Drag-drop styles
import 'boardsmith/ui/animation/drag-drop.css';

// Card flip animation styles
import 'boardsmith/ui/animation/card-flip.css';
```

## See Also

- [UI Components Guide](../ui-components.md)
- [Custom UI Guide](../custom-ui-guide.md)
- [Component Showcase](../component-showcase.md)
````

## File: docs/api/worker.md
````markdown
# boardsmith/worker

> Cloudflare Workers game deployment.

## When to Use

Import from `boardsmith/worker` when deploying games to Cloudflare Workers. This package provides Durable Objects for game state persistence and WebSocket connections, plus KV-based matchmaking.

## Usage

```typescript
import {
  createGameWorker,
  createGameStateDurableObject,
  buildRegistries,
} from 'boardsmith/worker';
```

## Exports

### Factory Functions

- `createGameWorker()` - Create a Worker fetch handler
- `createGameStateDurableObject()` - Create a Durable Object class
- `buildRegistries()` - Build registries from game definitions

### Types

- `GameRegistry` - Map of game type to game class
- `GameConfigRegistry` - Map of game type to config
- `Env` - Worker environment bindings
- `CreateGameRequest` - Create game request
- `ActionRequest` - Action request
- `MatchmakingRequest` - Matchmaking request
- `GameResponse` - Game operation response
- `WebSocketMessage` - WebSocket message type
- `WebSocketSession` - WebSocket session info
- `WorkerConfig` - Worker configuration
- `GameClass` - Game class type
- `GameDefinition` - Game definition
- `GameConfig` - Game configuration
- `StoredGameState` - Stored game state
- `PlayerGameState` - Player game state
- `AIConfig` - AI configuration

## Examples

### Basic Worker Setup

```typescript
// src/worker.ts
import { createGameWorker, createGameStateDurableObject, buildRegistries } from 'boardsmith/worker';
import { GoFishGame, goFishDefinition } from './games/go-fish/game';

// Build registries from game definitions
const { gameRegistry, gameConfigRegistry } = buildRegistries([goFishDefinition]);

// Export Durable Object class
export const GameState = createGameStateDurableObject(gameRegistry);

// Export Worker
export default createGameWorker({
  gameRegistry,
  gameConfigRegistry,
});
```

### wrangler.toml Configuration

```toml
name = "my-game-server"
main = "src/worker.ts"
compatibility_date = "2024-01-01"

[vars]
ENVIRONMENT = "production"

[[durable_objects.bindings]]
name = "GAME_STATE"
class_name = "GameState"

[[migrations]]
tag = "v1"
new_classes = ["GameState"]

[[kv_namespaces]]
binding = "MATCHMAKING"
id = "your-kv-namespace-id"
```

### Game Definition

```typescript
// games/go-fish/game.ts
import { Game, Player, Card, Hand, Deck } from 'boardsmith';
import type { GameDefinition } from 'boardsmith/worker';

export class GoFishGame extends Game<GoFishGame, GoFishPlayer> {
  deck!: Deck<GoFishGame, GoFishPlayer>;

  defineElements() {
    this.deck = this.create(Deck, 'deck');
    // ... setup cards
  }

  defineActions() {
    this.defineAction('ask', {
      prompt: 'Ask a player for a rank',
      // ... action definition
    });
  }
}

export const goFishDefinition: GameDefinition = {
  gameType: 'go-fish',
  gameClass: GoFishGame,
  minPlayers: 2,
  maxPlayers: 6,
};
```

### Multiple Games

```typescript
import { buildRegistries, createGameWorker, createGameStateDurableObject } from 'boardsmith/worker';
import { goFishDefinition } from './games/go-fish/game';
import { checkersDefinition } from './games/checkers/game';
import { ticTacToeDefinition } from './games/tic-tac-toe/game';

const { gameRegistry, gameConfigRegistry } = buildRegistries([
  goFishDefinition,
  checkersDefinition,
  ticTacToeDefinition,
]);

export const GameState = createGameStateDurableObject(gameRegistry);

export default createGameWorker({
  gameRegistry,
  gameConfigRegistry,
});
```

### API Routes

The worker automatically handles these routes:

```
POST /games                    - Create a new game
GET  /games/:id                - Get game state
GET  /games/:id (WebSocket)    - Connect via WebSocket
POST /games/:id/action         - Perform an action
GET  /games/:id/history        - Get action history
GET  /games/:id/state-at/:n    - Get state at action N
GET  /games/:id/state-diff/:from/:to - Get state diff
POST /games/:id/undo           - Undo last action
POST /games/:id/restart        - Restart game

POST /matchmaking/join         - Join matchmaking queue
GET  /matchmaking/status       - Check matchmaking status
POST /matchmaking/leave        - Leave matchmaking queue

GET  /health                   - Health check
```

### Creating a Game

```typescript
// From client
const response = await fetch('https://your-worker.workers.dev/games', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    gameType: 'go-fish',
    playerCount: 3,
    playerNames: ['Alice', 'Bob', 'Charlie'],
    aiPlayers: [2], // Player 2 is AI
    aiLevel: 'medium',
  }),
});

const { gameId } = await response.json();
```

### WebSocket Connection

```typescript
// Connect to game
const ws = new WebSocket(`wss://your-worker.workers.dev/games/${gameId}?player=0`);

ws.onmessage = (event) => {
  const message = JSON.parse(event.data);

  switch (message.type) {
    case 'state':
      // Initial state or update
      updateUI(message.state, message.flowState);
      break;

    case 'actionResult':
      // Response to action
      if (!message.success) {
        showError(message.error);
      }
      break;

    case 'error':
      showError(message.error);
      break;
  }
};

// Perform an action
ws.send(
  JSON.stringify({
    type: 'action',
    action: 'ask',
    args: { target: 1, rank: '7' },
    requestId: 'unique-id-123',
  }),
);
```

### With Lobby System

```typescript
// Create game with lobby
const { gameId } = await fetch('/games', {
  method: 'POST',
  body: JSON.stringify({
    gameType: 'go-fish',
    playerCount: 4,
    withLobby: true,
  }),
}).then((r) => r.json());

// Connect with playerId
const ws = new WebSocket(`wss://example.com/games/${gameId}?playerId=user-123`);

// Claim a position
await fetch(`/games/${gameId}/claim-position`, {
  method: 'POST',
  body: JSON.stringify({
    position: 0,
    playerId: 'user-123',
    name: 'Alice',
  }),
});

// Set ready
await fetch(`/games/${gameId}/set-ready`, {
  method: 'POST',
  body: JSON.stringify({
    playerId: 'user-123',
    ready: true,
  }),
});
```

### Matchmaking

```typescript
// Join matchmaking
const result = await fetch('/matchmaking/join', {
  method: 'POST',
  body: JSON.stringify({
    gameType: 'go-fish',
    playerCount: 4,
    playerId: 'user-123',
    playerName: 'Alice',
  }),
}).then((r) => r.json());

if (result.status === 'matched') {
  // Game created!
  const ws = new WebSocket(
    `wss://example.com/games/${result.gameId}?player=${result.playerPosition}`,
  );
} else if (result.status === 'waiting') {
  // Poll for status
  const poll = setInterval(async () => {
    const status = await fetch(`/matchmaking/status?playerId=user-123`).then((r) => r.json());

    if (status.status === 'matched') {
      clearInterval(poll);
      // Connect to game
    }
  }, 1000);
}
```

### Environment Variables

```typescript
interface Env {
  GAME_STATE: DurableObjectNamespace; // Required: Durable Object binding
  MATCHMAKING: KVNamespace; // Required: KV for matchmaking
  ENVIRONMENT: string; // Optional: 'development' | 'production'
}
```

## See Also

- [boardsmith/server](./server.md) - Node.js server implementation
- [boardsmith/client](./client.md) - Browser client SDK
- [Cloudflare Workers Docs](https://developers.cloudflare.com/workers/)
````

## File: docs/actions-and-flow.md
````markdown
# Actions & Flow System

This document covers the Action builder API and the declarative Flow system for controlling game structure.

## Actions

Actions define what players can do during the game. They use a fluent builder pattern.

### Basic Action Structure

```typescript
import { Action, type ActionDefinition } from 'boardsmith';

export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('actionName')
    .prompt('Description shown to player')
    .condition({
      'player has enough resources': (ctx) => ctx.player.gold >= 5,
    })
    .chooseFrom('selection', { /* selection options */ })
    .execute((args, ctx) => {
      // Game logic here
      return { success: true };
    });
}
```

### Selection Methods

#### `chooseFrom<T>` - Choose from a list

```typescript
Action.create('selectRank')
  .chooseFrom<string>('rank', {
    prompt: 'Choose a rank to ask for',
    choices: (ctx) => ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],
  })
```

#### On-Demand Choices

Choices are always evaluated on-demand when the player needs to make a selection. This means the `choices` callback runs at the moment the player is presented with the selection, not when the action metadata is built.

**This enables:**
- Choice computation with side effects (e.g., drawing cards from a deck)
- Choices that depend on the current game state
- Manipulating state (like decks) right before showing choices

> ⚠️ **CRITICAL: Module-Level Variables Don't Work**
>
> The `choices()` and `execute()` callbacks run in **different contexts**. Module-level variables (Maps, arrays, objects outside the action) will NOT persist between them:
>
> ```typescript
> // ❌ WRONG - This will NOT work!
> const drawnCache = new Map<string, Equipment>();
>
> Action.create('armsDealer')
>   .chooseFrom('equipment', {
>     choices: (ctx) => {
>       const equipment = deck.draw();
>       drawnCache.set('drawn', equipment);  // Set in choices...
>       return [equipment];
>     },
>   })
>   .execute((args, ctx) => {
>     const equipment = drawnCache.get('drawn');  // ...empty in execute!
>   });
> ```
>
> **Use `actionTempState()` instead** (see below).

#### Using `actionTempState()` for Temp State

The `actionTempState()` helper provides a clean API for storing state between `choices()` and `execute()`:

```typescript
import { Action, actionTempState } from 'boardsmith';

Action.create('armsDealer')
  .chooseFrom('equipment', {
    choices: (ctx) => {
      const temp = actionTempState(ctx, 'armsDealer');
      const equipment = ctx.game.equipmentDeck.draw();
      temp.set('drawnEquipment', equipment.id);
      return [equipment, { value: 'skip', label: 'Skip (add to stash)' }];
    },
  })
  .execute((args, ctx) => {
    const temp = actionTempState(ctx, 'armsDealer');
    const equipmentId = temp.get<number>('drawnEquipment');
    const equipment = ctx.game.getElementById(equipmentId) as Equipment;
    temp.clear();  // Always clean up!

    if (args.equipment === 'skip') {
      sector.addToStash(equipment);
    } else {
      // Equip to merc...
    }
  });
```

**API:**
- `temp.set(key, value)` - Store a value
- `temp.get<T>(key)` - Retrieve a value (typed)
- `temp.clear()` - Remove all temp state for this action/player

The helper automatically namespaces by action name and player, so multiple players or actions won't conflict.

#### Full On-Demand Choices Example

```typescript
Action.create('hireFirstMerc')
  .prompt('Choose a MERC to hire')
  .condition({
    'player has no team yet': (ctx) => ctx.player.team.length === 0,
  })
  .chooseFrom('merc', {
    choices: (ctx) => {
      const temp = actionTempState(ctx, 'hireFirstMerc');
      const drawn = ctx.game.mercDeck.drawCards(3);
      temp.set('drawnIds', drawn.map(m => m.id));
      return drawn;
    },
    display: (merc) => merc.displayName,
  })
  .execute((args, ctx) => {
    const temp = actionTempState(ctx, 'hireFirstMerc');
    const merc = args.merc;
    ctx.player.team.push(merc);

    // Return unused mercs to deck
    const drawnIds = temp.get<number[]>('drawnIds') ?? [];
    for (const id of drawnIds) {
      if (id !== merc.id) {
        const card = ctx.game.getElementById(id);
        if (card) ctx.game.mercDeck.addToBottom(card);
      }
    }

    temp.clear();
    return { success: true };
  });
```

**How it works:**
1. Player sees "Hire First MERC" button
2. Player clicks button
3. Server evaluates choices callback NOW (draws 3 cards, stores IDs)
4. UI receives choices and shows selection dropdown
5. Player picks one, `execute()` runs with temp state available

> **Important: UI Sync Limitation**
>
> State changes made in `choices()` or `elements()` callbacks happen **server-side only**. The client's `gameView` is NOT updated until the entire action completes (after `execute()` runs).
>
> This means:
> - The UI won't show the drawn cards, updated counts, or state changes immediately
> - Custom game boards must read from `game.settings` to see mid-action state
> - If your UI needs to reflect state changes before selection, consider splitting into two actions in your flow
>
> **Example: Two-Action Pattern for UI Updates**
> ```typescript
> // flow.ts - Split exploration into two actions
> phase('explore', {
>   do: sequence(
>     actionStep({ actions: ['explore'] }),       // Draws equipment, updates state
>     actionStep({ actions: ['collectLoot'] }),   // UI now shows updated state
>   ),
> })
> ```
> This pattern ensures the UI sees the exploration results before the player picks equipment.

#### `chooseElement<T>` - Choose a game element

```typescript
Action.create('placeStone')
  .chooseElement<Cell>('cell', {
    prompt: 'Select an empty cell',
    elementClass: Cell,
    filter: (cell, ctx) => cell.isEmpty(),
    display: (cell) => cell.notation,        // Display text
    boardRef: (cell) => ({ id: cell.id }),   // For UI highlighting
  })
```

#### `fromElements<T>` - Select from a list of elements (Recommended for Custom UIs)

**This is the preferred method when building custom game UIs.** It uses element IDs as values, making it seamless for custom components to send selections.

```typescript
Action.create('attack')
  .fromElements<Unit>('target', {
    prompt: 'Choose a target',
    elements: (ctx) => ctx.game.combat.validTargets,
    display: (unit, ctx, allUnits) => unit.name,  // Optional: custom display
    boardRef: (unit) => ({ id: unit.id }),
  })
  .execute((args, ctx) => {
    // args.target is the resolved Element object (not an ID!)
    const target = args.target as Unit;
    target.takeDamage(10);
    return { success: true };
  });
```

**Why use `fromElements` instead of `chooseFrom`?**

| Feature | `chooseFrom` | `fromElements` |
|---------|-------------|----------------|
| Value type | String (manual) | Element ID (automatic) |
| Custom UI sends | `"Militia #1"` (must match exactly) | `42` (element ID) |
| Display names | Manual | Auto-disambiguated |
| Execute receives | Raw value | Resolved Element |

**Custom UI integration:**

```typescript
// In your custom Vue component:
function attackTarget(targetId: number) {
  // Just send the element ID - it works!
  props.action('attack', { target: targetId });
}
```

**Auto-disambiguation:**
When multiple elements share the same name, display names are automatically suffixed:
- "Militia" (if unique)
- "Militia #1", "Militia #2" (if duplicates exist)

**Multi-select:**

```typescript
.fromElements<Unit>('targets', {
  elements: (ctx) => ctx.game.combat.validTargets,
  multiSelect: { min: 1, max: 3 },  // Select 1-3 targets
})
.execute((args) => {
  // args.targets is an array of Element objects
  const targets = args.targets as Unit[];
  targets.forEach(t => t.takeDamage(5));
});
```

**Optional selections:**

Allow players to skip a selection. Use `optional: true` for a "Skip" button, or provide a string for custom button text:

```typescript
.fromElements<Equipment>('item', {
  elements: (ctx) => ctx.loot.all(Equipment),
  optional: true,           // Shows "Skip" button
})

.fromElements<Equipment>('item', {
  elements: (ctx) => ctx.loot.all(Equipment),
  optional: 'Done',         // Shows "Done" button instead of "Skip"
})
```

#### `playerChoices` - Choose a player with chooseFrom

Use the `playerChoices()` helper on your Game class to generate player choices for use with `chooseFrom`:

```typescript
Action.create('askPlayer')
  .chooseFrom('target', {
    prompt: 'Who do you want to ask?',
    choices: (ctx) => game.playerChoices({ excludeSelf: true, currentPlayer: ctx.player }),
  })
  .execute((args, ctx) => {
    // playerChoices returns { value: position; display: string } objects
    // Position values are 1-indexed
    const choice = args.target as { value: number; display: string };
    const targetPlayer = game.players.get(choice.value)!;
    // ...
  });
```

The `playerChoices()` helper supports:
- `excludeSelf: true` - Filter out the current player
- `currentPlayer` - Required when using excludeSelf
- `filter: (player) => boolean` - Custom filter function

#### `enterNumber` - Enter a number

```typescript
Action.create('bid')
  .enterNumber('amount', {
    prompt: 'Enter your bid',
    min: 1,
    max: (ctx) => ctx.player.coins,
  })
```

#### `enterText` - Enter text

```typescript
Action.create('name')
  .enterText('name', {
    prompt: 'Enter a name',
    maxLength: 20,
  })
```

### Chaining Selections with `dependsOn`

When selection B depends on selection A's value, use the `dependsOn` option:

```typescript
Action.create('dropEquipment')
  .fromElements('merc', {
    elements: () => [...game.all(Merc)],
  })
  .fromElements('equipment', {
    dependsOn: 'merc',  // Tells framework B depends on A
    elements: (ctx) => {
      const merc = ctx.args.merc as Merc;
      return [...merc.equipment.all(Equipment)];
    },
  })
```

**What `dependsOn` does:**
- During availability check, the framework automatically iterates through all choices for A
- For each A choice, it checks if B would have valid choices
- Action is available if at least one A choice leads to valid B choices
- No crashes, no manual undefined handling needed!

Works with all selection types:

```typescript
// With chooseElement
Action.create('move')
  .chooseElement<Piece>('piece', {
    elementClass: Piece,
    filter: (p, ctx) => p.player === ctx.player,
  })
  .chooseElement<Cell>('destination', {
    dependsOn: 'piece',
    from: (ctx) => ctx.args.piece as Piece,
    elementClass: Cell,
  })

// With chooseFrom
Action.create('selectItem')
  .chooseFrom('category', { choices: ['weapons', 'armor'] })
  .chooseFrom('item', {
    dependsOn: 'category',
    choices: (ctx) => getItemsForCategory(ctx.args.category as string),
  })
```

> **Alternative: Manual Undefined Handling**
>
> For complex cases where you need custom availability logic, you can handle `undefined` manually instead of using `dependsOn`:
>
> ```typescript
> filter: (cell, ctx) => {
>   const piece = ctx.args?.piece as Piece | undefined;
>
>   if (!piece) {
>     // Availability check - no piece selected yet
>     // Return true if this cell would be valid for ANY movable piece
>     return getMovablePieces(ctx.player).some(p => p.canMoveTo(cell));
>   }
>
>   // Actual selection - piece is selected
>   return piece.canMoveTo(cell);
> }
> ```
>
> See [Common Pitfalls](./common-pitfalls.md#2-dependent-selections-selection-b-depends-on-selection-a) for more details.

### Conditions

Control when actions are available using labeled conditions:

```typescript
Action.create('draw')
  .condition({
    'deck has cards': (ctx) => game.deck.count(Card) > 0,
  })
  .execute(...)

// Multiple conditions are AND'd together
Action.create('purchase')
  .condition({
    'player can afford cost': (ctx) => ctx.player.gold >= 10,
    'item is available': (ctx) => game.shop.count(Item) > 0,
  })
  .execute(...)
```

Each key is a human-readable label that appears in debug output when the condition fails. This makes it easy to understand why an action isn't available.

**Labels should describe WHY** the condition exists, not just what it checks:
- Good: `'player can afford cost'`, `'in play phase'`, `'has cards to discard'`
- Bad: `'gold >= 10'`, `'phase === play'`, `'hand.count > 0'`

### Validation

Validate the complete action before execution:

```typescript
Action.create('play')
  .chooseFrom('cards', { choices: getPlayableCards, multi: true })
  .validate((args, ctx) => {
    const cards = args.cards as Card[];
    if (cards.length < 2) {
      return { valid: false, message: 'Must play at least 2 cards' };
    }
    return { valid: true };
  })
  .execute(...)
```

### Execute Function

The execute function performs the actual game logic:

```typescript
.execute((args, ctx) => {
  const player = ctx.player as MyPlayer;
  const card = args.card as Card;

  // Perform game actions (generates commands automatically)
  card.putInto(game.discardPile);
  player.score += card.value;

  // Add game message
  game.message(`${player.name} played ${card.name}`);

  // Return result
  return {
    success: true,
    message: 'Card played successfully',
    data: { cardId: card.id },
  };
});
```

> **Important:** When using `chooseElement`, the `args` contain the **full serialized element object**, not just the ID. To find the element by ID:
> ```typescript
> const elementId = typeof args.piece === 'object' ? (args.piece as any).id : args.piece;
> const piece = game.all(Piece).find(p => p.id === elementId);
> ```
> Also, always use `ctx.game` instead of a closure reference to the game variable in execute functions to avoid stale references during hot-reload.

### Action Options

```typescript
Action.create('move')
  .prompt('Move your piece')
  .notUndoable()                    // Cannot undo this action
  .skipIf((ctx) => /* condition */) // Skip if condition is true
```

---

## Action Chaining with `followUp`

Action chaining allows one action to automatically trigger another action with pre-filled context. This is essential for multi-phase game interactions where:
- The UI needs to show updated state between phases
- Context (which piece, which location) should flow between phases
- The user experience should feel seamless

### Basic Usage

Return a `followUp` object from your execute function:

```typescript
Action.create('explore')
  .chooseElement('merc', {
    prompt: 'Select MERC to explore',
    elementClass: Merc,
  })
  .execute((args, ctx) => {
    const merc = args.merc as Merc;
    const sector = merc.getCurrentSector();

    // Draw equipment to the sector's stash
    for (let i = 0; i < sector.lootCount; i++) {
      const equipment = ctx.game.drawEquipment();
      if (equipment) equipment.putInto(sector.stashZone);
    }
    sector.explored = true;
    merc.useAction(1);

    ctx.game.message(`${merc.name} explored ${sector.name}`);

    // Chain to collect action - UI will see the drawn equipment
    return {
      success: true,
      followUp: {
        action: 'collectEquipment',
        args: {
          mercId: merc.id,
          sectorId: sector.id,
        },
      },
    };
  });

// The follow-up action receives pre-filled args
Action.create('collectEquipment')
  .fromElements<Equipment>('equipment', {
    prompt: 'Select equipment to take',
    elements: (ctx) => {
      // UI shows updated state - stash has the drawn equipment
      const sector = ctx.game.getElementById(ctx.args.sectorId) as Sector;
      return [...sector.stashZone.all(Equipment)];
    },
    optional: 'Done taking equipment',
  })
  .execute((args, ctx) => {
    if (args.equipment) {
      const merc = ctx.game.getElementById(ctx.args.mercId) as Merc;
      (args.equipment as Equipment).putInto(merc.inventoryZone);
      ctx.game.message(`Took ${(args.equipment as Equipment).name}`);
    }
    return { success: true };
  });
```

### Conditional Chaining

Only chain to follow-up when a condition is met:

```typescript
.execute((args, ctx) => {
  const sector = performExploration(args, ctx);

  return {
    success: true,
    // Only chain if there's equipment to collect
    followUp: sector.stashZone.count() > 0
      ? { action: 'collectEquipment', args: { sectorId: sector.id } }
      : undefined,
  };
})
```

### How It Works

1. **First action executes** - state changes (drawing equipment, marking explored)
2. **State syncs to client** - UI receives updated gameView with new state
3. **Follow-up auto-starts** - client automatically begins the follow-up action
4. **Args pre-filled** - follow-up action starts with provided args already set
5. **User continues** - from user's perspective, it's one seamless interaction

### When to Use Action Chaining

Use `followUp` when:
- An action modifies state that the next action's choices depend on
- You need the UI to reflect changes before the player makes their next selection
- Context (which piece, which location, etc.) should flow to the next action
- The follow-up is optional or conditional

Don't use `followUp` when:
- Selections don't depend on state changes from previous selections
- A single action with multiple selections is sufficient
- The follow-up is mandatory and unconditional (consider putting both in the same action)

### Displaying followUp Args

When followUp args are displayed in the action panel (as chips showing context), plain IDs like `mercId: 51` display as "51" which isn't user-friendly.

**Option 1: Pass objects with name/display properties**

```typescript
return {
  success: true,
  followUp: {
    action: 'collectEquipment',
    args: {
      // Plain ID - displays as "51" ❌
      // mercId: merc.id,

      // Object with name - displays as "Bronson" ✓
      mercId: { id: merc.id, name: merc.mercName },
      sectorId: { id: sector.id, name: sector.sectorName },
    },
  },
};
```

The UI extracts the `name` (or `display`) property automatically. Your follow-up action's helpers should handle both formats:

```typescript
function getMerc(ctx: ActionContext): Merc {
  const arg = ctx.args.mercId;
  // Handle both plain ID and object format
  const id = typeof arg === 'object' && arg !== null ? (arg as { id: number }).id : arg;
  return ctx.game.first(Merc, m => m.id === id)!;
}
```

**Option 2: Use the display option (recommended)**

For cleaner separation of value and display:

```typescript
return {
  success: true,
  followUp: {
    action: 'collectEquipment',
    args: {
      mercId: merc.id,
      sectorId: sector.id,
    },
    display: {
      mercId: merc.mercName,      // "Bronson"
      sectorId: sector.sectorName, // "Diamond Industry"
    },
  },
};
```

This keeps the args as plain IDs (no helper changes needed) while providing display strings for the UI.

### Example: Attack with Damage Resolution

```typescript
Action.create('attack')
  .chooseElement('attacker', { elementClass: Unit })
  .chooseElement('target', { elementClass: Unit })
  .execute((args, ctx) => {
    const attacker = args.attacker as Unit;
    const target = args.target as Unit;

    const damage = calculateDamage(attacker, target);
    target.takeDamage(damage);

    // If target has a defensive ability, chain to resolution
    return {
      success: true,
      followUp: target.hasDefensiveAbility()
        ? { action: 'resolveDefense', args: { targetId: target.id, damage } }
        : undefined,
    };
  });
```

---

### Example: Go Fish Ask Action

From `packages/games/go-fish/rules/src/actions.ts`:

```typescript
export function createAskAction(game: GoFishGame): ActionDefinition {
  return Action.create('ask')
    .prompt('Ask another player for a card')
    .chooseFrom('target', {
      prompt: 'Who do you want to ask?',
      choices: (ctx) => game.playerChoices({ excludeSelf: true, currentPlayer: ctx.player }),
      boardRefs: (choice: { value: number; display: string }, ctx) => {
        const targetPlayer = game.players.get(choice.value) as GoFishPlayer;
        return { targetRef: { id: game.getPlayerHand(targetPlayer).id } };
      },
    })
    .chooseFrom<string>('rank', {
      prompt: 'What rank do you want?',
      choices: (ctx) => game.getPlayerRanks(ctx.player as GoFishPlayer),
      display: (rank) => {
        const names: Record<string, string> = {
          'A': 'Aces', '2': 'Twos', '3': 'Threes', '4': 'Fours',
          '5': 'Fives', '6': 'Sixes', '7': 'Sevens', '8': 'Eights',
          '9': 'Nines', '10': 'Tens', 'J': 'Jacks', 'Q': 'Queens', 'K': 'Kings'
        };
        return names[rank] ?? rank;
      },
    })
    .execute((args, ctx) => {
      const player = ctx.player as GoFishPlayer;
      const targetChoice = args.target as { value: number; display: string };
      const target = game.players.get(targetChoice.value) as GoFishPlayer;
      const rank = args.rank as string;

      const matchingCards = game.getCardsOfRank(target, rank);

      if (matchingCards.length > 0) {
        for (const card of matchingCards) {
          card.putInto(game.getPlayerHand(player));
        }
        game.message(`${player.name} got ${matchingCards.length} ${rank}(s) from ${target.name}!`);
        // Player gets another turn when they receive cards
      } else {
        game.message(`${target.name} says "Go Fish!"`);
        // Player draws from pond
      }

      return { success: true };
    });
}
```

## Flow System

The Flow system defines game structure using composable nodes.

### Flow Definition

```typescript
import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from 'boardsmith';

export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: /* flow node */,
    isComplete: (ctx) => game.isFinished(),
    getWinners: (ctx) => game.getWinners(),
  };
}
```

### Flow Nodes

#### `sequence` - Run steps in order

```typescript
sequence(
  actionStep({ actions: ['draw'] }),
  actionStep({ actions: ['play'] }),
)
```

#### `loop` - Repeat while condition is true

```typescript
loop({
  name: 'game-loop',
  while: (ctx) => !game.isFinished(),
  maxIterations: 1000,  // Safety limit
  do: /* flow node */,
})
```

#### `repeat` - Fixed number of iterations

```typescript
repeat({
  name: 'deal-cards',
  times: 5,
  do: actionStep({ actions: ['deal'] }),
})
```

#### `eachPlayer` - Iterate over players

```typescript
eachPlayer({
  name: 'player-turns',
  order: TurnOrder.clockwise(),
  filter: (player, ctx) => !player.hasPassed,
  do: /* flow node */,
})
```

#### `forEach` - Iterate over array

```typescript
forEach({
  name: 'score-hands',
  collection: (ctx) => ctx.game.players,
  as: 'player',  // Variable name to access current item
  do: execute((ctx) => {
    const player = ctx.get('player');
    game.scoreHand(player);
  }),
})
```

#### `actionStep` - Wait for player action

```typescript
actionStep({
  name: 'move-step',
  actions: ['move', 'jump'],      // Available actions
  prompt: 'Move or jump a piece',
  skipIf: (ctx) => game.isFinished(),
})
```

#### `simultaneousActionStep` - All players act at once

```typescript
simultaneousActionStep({
  name: 'discard-step',
  actions: ['discard'],
  prompt: 'Choose cards to discard',
})
```

#### `phase` - Named game phase

```typescript
phase('setup', {
  do: sequence(
    execute({ do: () => game.deal() }),
    simultaneousActionStep({ actions: ['discard'] }),
  ),
})
```

#### `switchOn` - Conditional branching

```typescript
switchOn({
  value: (ctx) => game.currentPhase,
  cases: {
    'deal': /* flow node */,
    'play': /* flow node */,
    'score': /* flow node */,
  },
  default: /* flow node */,
})
```

#### `ifThen` - If-else logic

```typescript
ifThen({
  if: (ctx) => ctx.game.deck.count(Card) > 0,
  then: actionStep({ actions: ['draw'] }),
  else: execute((ctx) => ctx.game.endRound()),
})
```

#### `execute` - Run code

```typescript
execute((ctx) => {
  ctx.game.deck.shuffle();
  ctx.game.message('Deck shuffled!');
})
```

#### `setVar` - Set flow variable

```typescript
setVar('roundNumber', (ctx) => (ctx.get('roundNumber') ?? 0) + 1)
```

### Turn Order

Control player order with `TurnOrder` presets. Use the spread operator to apply them:

```typescript
import { TurnOrder } from 'boardsmith';

// Default round-robin from player 1
eachPlayer({
  ...TurnOrder.DEFAULT,
  do: actionStep({ actions: ['play'] }),
})

// Available presets (player positions are 1-indexed):
TurnOrder.DEFAULT           // Standard round-robin from player 1
TurnOrder.REVERSE           // Round-robin backward
TurnOrder.CONTINUE          // Continue from current player
TurnOrder.ACTIVE_ONLY       // Only non-eliminated players
TurnOrder.START_FROM(n)     // Start from position n (1-indexed)
TurnOrder.ONLY([1, 3])      // Specific players only (positions 1 and 3)
TurnOrder.LEFT_OF_DEALER()  // Common for card games (reads ctx.get('dealer'))
TurnOrder.SKIP_IF(fn)       // Skip players based on condition
TurnOrder.combine(...)      // Combine multiple configs

// Example with dealer rotation
eachPlayer({
  ...TurnOrder.LEFT_OF_DEALER(),
  do: actionStep({ actions: ['playCard'] }),
})
```

### Flow Variables

Access and set variables during flow:

```typescript
// Set variable (player positions are 1-indexed)
setVar('dealer', (ctx) => ctx.game.players.get(1))

// Access in conditions
loop({
  while: (ctx) => ctx.get('roundNumber') < 10,
  do: /* flow node */,
})
```

### Example: Cribbage Flow

Complex multi-phase flow from `packages/games/cribbage/`:

```typescript
export function createCribbageFlow(game: CribbageGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: sequence(
        // Deal phase
        phase('deal', {
          do: execute(() => game.dealHands()),
        }),

        // Discard phase - all players discard simultaneously
        phase('discard', {
          do: simultaneousActionStep({
            actions: ['discard'],
            prompt: 'Discard 2 cards to the crib',
          }),
        }),

        // Play phase - alternating card play
        phase('play', {
          do: loop({
            while: () => !game.playPhaseComplete(),
            do: eachPlayer({
              do: actionStep({
                actions: ['playCard', 'sayGo'],
                skipIf: (ctx) => !game.canPlay(ctx.player),
              }),
            }),
          }),
        }),

        // Show phase - score hands
        phase('show', {
          do: forEach({
            collection: () => game.getShowOrder(),
            as: 'player',
            do: execute((ctx) => game.scoreHand(ctx.get('player'))),
          }),
        }),

        // Rotate dealer
        execute(() => game.rotateDealer()),
      ),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### Example: Simple Turn-Based Flow (Hex)

Minimal flow from `packages/games/hex/`:

```typescript
export function createHexFlow(game: HexGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      maxIterations: 100,
      do: eachPlayer({
        name: 'player-turns',
        filter: (player) => !game.isFinished(),
        do: actionStep({
          name: 'place-stone',
          actions: ['placeStone'],
          skipIf: () => game.isFinished(),
        }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.winner ? [game.winner] : [],
  };
}
```

## Registering Actions

Actions must be registered in your Game constructor:

```typescript
constructor(options) {
  super(options);
  // ... element setup ...

  this.registerAction(createMoveAction(this));
  this.registerAction(createDrawAction(this));
  this.registerAction(createPlayAction(this));

  this.setFlow(createGameFlow(this));
}
```

## Custom UI Integration

### Sending Actions from Custom Components

When building a custom game board in Vue, you can send actions using the `action` prop:

```vue
<script setup lang="ts">
const props = defineProps<{
  gameView: GameView;
  action: (name: string, args: Record<string, unknown>) => Promise<{ success: boolean }>;
}>();

function attackTarget(targetId: number) {
  props.action('attack', { target: targetId });
}
</script>
```

### Smart Value Resolution

BoardSmith automatically resolves values in `chooseFrom` selections. When you send an action, these formats are accepted:

1. **Exact choice value** (original behavior)
2. **Element ID** (if choice references an element with that ID)
3. **Display string** (case-insensitive match to choice display)

This means custom UIs can send element IDs even for `chooseFrom` selections:

```typescript
// Action definition using chooseFrom
.chooseFrom('target', {
  choices: (ctx) => game.validTargets,  // Returns element objects
  display: (target) => target.name,
})

// Custom UI can send the element ID directly
props.action('attack', { target: target.id });  // Works!
```

### Detailed Validation Errors

When validation fails, you get helpful error messages:

```typescript
// Error response includes valid choices:
{
  success: false,
  error: 'Invalid selection for "target": "invalid-value". Valid choices: [Militia #1, Militia #2, genesis]'
}
```

### Best Practices

1. **Prefer `fromElements` for new code** - It's designed for custom UIs
2. **Use element IDs, not string values** - IDs are stable; display strings can change
3. **Check `actionMetadata` for valid choices** - It includes element IDs for reference

```typescript
// actionMetadata structure for fromElements (single-select):
{
  selections: [{
    name: 'target',
    type: 'element',  // Single-select uses 'element' type
    validElements: [
      { id: 42, display: 'Militia #1', ref: { id: 42 } },
      { id: 43, display: 'Militia #2', ref: { id: 43 } },
    ]
  }]
}

// actionMetadata structure for fromElements (multi-select):
{
  selections: [{
    name: 'targets',
    type: 'elements',  // Multi-select uses 'elements' type
    multiSelect: { min: 1, max: 3 },
    validElements: [
      { id: 42, display: 'Militia #1', ref: { id: 42 } },
      { id: 43, display: 'Militia #2', ref: { id: 43 } },
    ]
  }]
}
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Elements and state management
- [UI Components](./ui-components.md) - Displaying actions in the UI
- [Game Examples](./game-examples.md) - Real implementations
````

## File: docs/ai-system.md
````markdown
# AI System

BoardSmith includes a game-agnostic AI system using Monte-Carlo Tree Search (MCTS). The AI works with any game without game-specific tuning.

## Overview

The `boardsmith/ai` package provides:
- **MCTSBot**: MCTS-based AI player
- **Difficulty presets**: easy, medium, hard
- **Custom objectives**: Guide AI behavior for specific games

## How MCTS Works

Monte-Carlo Tree Search builds a game tree by repeatedly:

1. **SELECT**: Walk down the tree using UCT (Upper Confidence Bound for Trees) to balance exploration vs exploitation
2. **EXPAND**: Try one unexplored action from a leaf node
3. **PLAYOUT**: Random moves until game ends (or depth limit)
4. **BACKPROPAGATE**: Update win counts back up the tree

After many iterations, the bot chooses the most-visited child of the root (robust choice).

## Basic Usage

### Using the CLI

The easiest way to add AI players is via the CLI:

```bash
# Player 1 is AI (medium difficulty)
boardsmith dev --ai 1

# Players 0 and 2 are AI
boardsmith dev --ai 0 2

# Set difficulty level
boardsmith dev --ai 1 --ai-level hard

# Custom iteration count
boardsmith dev --ai 1 --ai-level 50
```

### Difficulty Levels

| Level | Iterations | Playout Depth | Timeout |
|-------|-----------|---------------|---------|
| easy | 3 | 3 | 1000ms |
| medium | 5 | 4 | 1500ms |
| hard | 8 | 5 | 2000ms |

Note: Iterations are kept low because game operations can be slow (~18ms per move). The timeout ensures responsive behavior.

### Programmatic Usage

```typescript
import { createBot, parseAILevel } from 'boardsmith/ai';
import { MyGame } from './game.js';

// Create a bot for player 1
const bot = createBot(
  game,                    // Game instance
  MyGame,                  // Game class constructor
  'my-game',               // Game type identifier
  1,                       // Player index (0-based)
  actionHistory,           // History of actions taken so far
  'hard'                   // Difficulty level or iteration count
);

// Get the bot's move
const move = await bot.play();
console.log(`Bot plays: ${move.action}`, move.args);

// Execute the move
game.continueFlow(move.action, move.args, 1);
```

## Custom Objectives

For games where win/loss isn't sufficient guidance, you can define objectives that give the AI partial credit during playouts.

### Defining Objectives

```typescript
import type { AIConfig, Game } from 'boardsmith/ai';

const aiConfig: AIConfig = {
  objectives: (game: Game, playerIndex: number) => ({
    // Positive weight = good for the player
    controlCenter: {
      checker: (g, p) => {
        const center = g.board.cells.filter(c => c.isCentral);
        const playerPieces = center.filter(c => c.piece?.player?.position === p);
        return playerPieces.length >= 2;
      },
      weight: 0.3,
    },

    // Negative weight = bad for the player
    exposedKing: {
      checker: (g, p) => {
        const king = g.players.get(p)!.king;
        return king.isExposed();
      },
      weight: -0.5,
    },

    // Material advantage
    materialAdvantage: {
      checker: (g, p) => {
        const myPieces = g.pieces.filter(pc => pc.player?.position === p);
        const oppPieces = g.pieces.filter(pc => pc.player?.position !== p);
        return myPieces.length > oppPieces.length;
      },
      weight: 0.4,
    },
  }),
};

// Use with createBot
const bot = createBot(game, MyGame, 'my-game', 1, [], 'medium', aiConfig);
```

### Objective Evaluation

During playouts that don't reach a terminal state:
- If total objective score > 0: returns 0.6 (slightly favorable)
- If total objective score < 0: returns 0.4 (slightly unfavorable)
- If total objective score = 0: returns 0.5 (neutral)

Terminal states always use actual win/loss (1.0/0.0).

## Example: Checkers AI

From `packages/games/checkers/rules/src/ai.ts`:

```typescript
import type { AIConfig, Game } from 'boardsmith/ai';

export const checkersAIConfig: AIConfig = {
  objectives: (game: Game, playerIndex: number) => ({
    // Having more pieces is good
    morePieces: {
      checker: (g, p) => {
        const myPieces = countPieces(g, p);
        const oppPieces = countPieces(g, 1 - p);
        return myPieces > oppPieces;
      },
      weight: 0.5,
    },

    // Having kings is good
    hasKings: {
      checker: (g, p) => {
        const myKings = countKings(g, p);
        return myKings > 0;
      },
      weight: 0.3,
    },

    // Controlling the center is good
    centerControl: {
      checker: (g, p) => {
        const centerCells = getCenterCells(g);
        const myPiecesInCenter = centerCells.filter(
          c => c.piece?.player?.position === p
        );
        return myPiecesInCenter.length >= 2;
      },
      weight: 0.2,
    },
  }),
};
```

## Integration with GameSession

The `boardsmith/session` package integrates AI automatically:

```typescript
import { GameSession } from 'boardsmith/session';
import { MyGame } from './game.js';
import { myGameAIConfig } from './ai.js';

const session = new GameSession({
  gameClass: MyGame,
  gameType: 'my-game',
  playerCount: 2,
  aiPlayers: [1],           // Player 1 is AI
  aiLevel: 'hard',
  aiConfig: myGameAIConfig,  // Optional custom objectives
});

// AI will automatically play when it's player 1's turn
session.start();
```

## BotConfig Options

```typescript
interface BotConfig {
  /** Number of MCTS iterations (higher = stronger but slower). Default: 100 */
  iterations: number;

  /** Maximum playout depth before evaluating position. Default: 5 */
  playoutDepth: number;

  /** Random seed for reproducible behavior */
  seed?: string;

  /** Run async to yield to event loop (prevents UI freezing). Default: true */
  async?: boolean;

  /** Maximum time in milliseconds before returning best move found. Default: 2000 */
  timeout?: number;
}
```

## Performance Considerations

1. **Iteration count**: More iterations = better play, but slower. The default presets are tuned for responsiveness.

2. **Playout depth**: Deeper playouts give more accurate evaluations but take longer. 3-5 is usually sufficient.

3. **Timeout**: The timeout ensures the bot always returns within a reasonable time, even if iterations haven't completed.

4. **Branching factor**: Games with many possible moves per turn will have fewer iterations explored per move. The bot samples up to 20 choices per selection to limit combinatorial explosion.

5. **Game complexity**: Simple games (Hex, Checkers) work well. Complex games (Cribbage with many scoring possibilities) may need custom objectives.

## Limitations

- **No learning**: The AI doesn't learn from past games. Each game starts fresh.
- **Text/number inputs**: The AI can't handle actions that require text or number input (it can only choose from discrete options).
- **Determinism**: With a seed, the bot is deterministic. Without a seed, it uses `Math.random()`.

## API Reference

### createBot()

```typescript
function createBot<G extends Game>(
  game: G,
  GameClass: new (options: GameOptions) => G,
  gameType: string,
  playerIndex: number,
  actionHistory?: SerializedAction[],
  difficulty?: DifficultyLevel | number,
  aiConfig?: AIConfig
): MCTSBot<G>
```

### MCTSBot.play()

```typescript
async play(): Promise<BotMove>
```

Returns the best move found after running MCTS iterations.

### parseAILevel()

```typescript
function parseAILevel(level: string): DifficultyLevel | number
```

Parse an AI level string (e.g., from CLI arguments).

## Related Documentation

- [Core Concepts](./core-concepts.md) - Understanding game state
- [Actions & Flow](./actions-and-flow.md) - How actions work
- [Game Examples](./game-examples.md) - Games with AI implementations
````

## File: docs/common-pitfalls.md
````markdown
# Common Pitfalls in BoardSmith

This guide documents common mistakes that cause hard-to-debug issues. Read this before starting your game implementation.

---

## 1. Object Reference Comparison (CRITICAL)

### The Problem

BoardSmith's `chooseElement` and element queries return **new object instances** each time. This means JavaScript's default equality checks will fail:

```typescript
// WRONG - This will ALWAYS be false!
const myCards = player.hand.all(Card);
const selectedCard = args.card as Card;
if (myCards.includes(selectedCard)) {
  // This code will NEVER run
}

// WRONG - Same problem
if (myCards.indexOf(selectedCard) !== -1) { ... }

// WRONG - Direct comparison fails too
if (card1 === card2) { ... }
```

### The Solution

Always compare elements by their `id` property:

```typescript
// CORRECT - Compare by ID
const myCards = player.hand.all(Card);
const selectedCard = args.card as Card;
if (myCards.some(c => c.id === selectedCard.id)) {
  // This works!
}

// CORRECT - Use the equals() helper
if (card1.equals(card2)) { ... }

// CORRECT - Use contains() on collections
if (myCards.contains(selectedCard)) { ... }

// CORRECT - Find by ID
const found = myCards.find(c => c.id === selectedCard.id);
```

### Why This Happens

BoardSmith serializes and deserializes game state for:
- Network synchronization between players
- Action replay and undo
- AI decision making
- State snapshots

Each deserialization creates new object instances with the same data but different memory addresses.

---

## 2. Dependent Selections (Selection B depends on Selection A)

### The Problem

When selection B depends on selection A's value, the filter/elements function for B can't access A during the availability check because A hasn't been selected yet:

```typescript
// WRONG - crashes when merc is undefined during availability check
Action.create('dropEquipment')
  .fromElements('merc', { elements: () => [...game.all(Merc)] })
  .fromElements('equipment', {
    elements: (ctx) => {
      const merc = ctx.args.merc as Merc;  // undefined during availability!
      return [...merc.equipment.all(Equipment)];  // CRASH!
    }
  })
```

### The Solution: Use `dependsOn`

Add `dependsOn` to tell the framework that selection B depends on selection A. The framework will automatically verify the action is available by checking if ANY choice for A leads to valid choices for B:

```typescript
// CORRECT - use dependsOn for automatic handling
Action.create('dropEquipment')
  .fromElements('merc', { elements: () => [...game.all(Merc)] })
  .fromElements('equipment', {
    dependsOn: 'merc',  // Framework handles availability check!
    elements: (ctx) => {
      const merc = ctx.args.merc as Merc;
      return [...merc.equipment.all(Equipment)];
    }
  })
```

**How it works:**
- During availability check, the framework iterates through all mercs
- For each merc, it checks if the equipment selection would have choices
- Action is available if at least one merc has equipment
- No crashes, no manual undefined handling needed!

This works with all selection types:

```typescript
// With chooseElement
.chooseElement('destination', {
  dependsOn: 'piece',
  from: (ctx) => ctx.args.piece as Piece,
  elementClass: Cell,
})

// With chooseFrom
.chooseFrom('item', {
  dependsOn: 'category',
  choices: (ctx) => getItemsForCategory(ctx.args.category as string),
})
```

### Alternative: Manual Undefined Handling

For complex cases where you need custom availability logic, you can still handle `undefined` manually:

```typescript
// Manual approach - handle undefined explicitly
.chooseElement<Sector>('destination', {
  filter: (sector, ctx) => {
    const selectedSquad = ctx.args?.squad as Squad | undefined;

    if (!selectedSquad) {
      // Availability check - return true if valid for ANY squad
      return movableSquads.some(squad =>
        isAdjacent(squad.sectorId, sector.id)
      );
    }

    // Actual selection - filter based on selected squad
    return isAdjacent(selectedSquad.sectorId, sector.id);
  }
})
```

### When to Use Which

| Use `dependsOn` when... | Use manual handling when... |
|------------------------|----------------------------|
| Simple dependency (B's choices come from A) | Complex availability logic needed |
| Standard patterns (select container, then contents) | Need to filter A's choices based on B's existence |
| Want automatic framework handling | Need custom "any possible path" logic |

---

## 3. Dead/Removed Elements in Collections

### The Problem

Element queries like `all()`, `first()`, etc. return **all matching elements**, including those that are logically "dead" or removed from play:

```typescript
// WRONG - includes dead pieces
const pieces = player.board.all(Piece);
const canMove = pieces.every(p => p.canMove);  // False if any dead piece exists

// WRONG - dead element with 0 actions breaks the check
const mercs = squad.all(Merc);
const allHaveActions = mercs.every(m => m.actionsRemaining >= 1);  // Always false!
```

### The Solution

Filter out dead/inactive elements explicitly:

```typescript
// CORRECT - filter to living pieces
const livingPieces = player.board.all(Piece).filter(p => !p.isDead);
const canMove = livingPieces.every(p => p.canMove);

// CORRECT - create a helper method
class Squad extends Space {
  getLivingMercs(): MercCard[] {
    return this.all(MercCard).filter(m => !m.isDead);
  }
}

// Then use it consistently
const mercs = squad.getLivingMercs();
const allHaveActions = mercs.every(m => m.actionsRemaining >= 1);
```

### Best Practice

Create helper methods for common filtered queries in your element classes:
- `getLivingPieces()`
- `getActiveCards()`
- `getAvailableSlots()`

This prevents the filter from being forgotten in different parts of your code.

---

## 4. Action Cost Placement

### The Problem

If you place action cost logic inside a `repeat.onEach` callback, the cost is charged **per item selected**, not once per action:

```typescript
// WRONG - charges 1 action for EACH equipment piece selected
Action.create('equip')
  .chooseElement<Equipment>('equipment', {
    repeat: { max: 3 },
    onEach: (equipment, ctx) => {
      merc.useAction(1);  // Called 3 times if player selects 3 items!
    }
  })
  .execute((args) => { ... });
```

### The Solution

Place action costs in the `execute` block, which runs once:

```typescript
// CORRECT - charges once in execute
Action.create('equip')
  .chooseElement<Equipment>('equipment', {
    repeat: { max: 3 }
  })
  .execute((args, ctx) => {
    // Charge action cost once
    merc.useAction(1);

    // Process all selected equipment
    const items = args.equipment as Equipment[];
    for (const item of items) {
      merc.equip(item);
    }
  });
```

---

## 5. Player Data Serialization

### The Problem

Custom data on Player objects may not serialize correctly, especially complex objects or element references:

```typescript
// PROBLEMATIC - element references on player
class MyPlayer extends Player {
  selectedCard?: Card;  // May not survive serialization
  squadRefs: Squad[] = [];  // Array of element refs is tricky
}
```

### The Solution

Store element references by ID or use game-level storage:

```typescript
// CORRECT - store IDs instead of references
class MyPlayer extends Player {
  selectedCardId?: number;
  squadIds: number[] = [];

  getSelectedCard(): Card | undefined {
    if (!this.selectedCardId) return undefined;
    return this.game.getElementById(this.selectedCardId) as Card;
  }
}

// ALTERNATIVE - use game-level maps
class MyGame extends Game {
  playerSelections: Map<number, number> = new Map();  // playerId -> cardId
}
```

---

## 6. Flow Loop Conditions

### The Problem

Flow loops with stale condition checks can cause infinite loops:

```typescript
// WRONG - condition may never become true
loop({
  while: () => !game.isFinished(),  // If isFinished() never returns true...
  do: actionStep({ actions: ['play'] })
})
```

### The Solution

Ensure your loop conditions will eventually become false:

```typescript
// CORRECT - use maxIterations as safety net
loop({
  while: () => !game.isFinished(),
  maxIterations: 1000,  // Prevents infinite loop
  do: actionStep({ actions: ['play'] })
})

// CORRECT - condition references mutable state
loop({
  while: (ctx) => {
    const player = ctx.player;
    return player.actionsRemaining > 0;  // Will decrease each iteration
  },
  do: actionStep({ actions: ['play'] })
})
```

---

## 6.5. followUp Chains Don't Count Against Loop Iterations

### How It Works

When using `followUp` to chain actions within a `loop`, only the **final action in the chain** counts as a move/iteration. This allows patterns like recursive impact resolution:

```typescript
// Player turn loop - maxIterations: 30 prevents runaway loops
loop({
  maxIterations: 30,
  while: (ctx) => !ctx.game.isFinished(),
  do: actionStep({
    actions: ['explore', 'attack', 'endTurn'],
  }),
})

// Explore action that can trigger long followUp chains
Action.create('explore')
  .execute((args, ctx) => {
    const impacts = detectImpacts();  // Could return 5, 10, 20+ impacts

    if (impacts.length > 0) {
      return {
        success: true,
        followUp: {
          action: 'applyImpact',
          args: { impactIndex: 0, allImpacts: impacts }
        }
      };
    }
    return { success: true };
  });

// Recursive impact resolution - chains to itself
Action.create('applyImpact')
  .execute((args, ctx) => {
    applyImpact(args.allImpacts[args.impactIndex]);

    const nextIndex = args.impactIndex + 1;
    if (nextIndex < args.allImpacts.length) {
      return {
        success: true,
        followUp: {
          action: 'applyImpact',
          args: { impactIndex: nextIndex, allImpacts: args.allImpacts }
        }
      };
    }
    // Chain complete - NOW counts as 1 move
    return { success: true };
  });
```

In this example, if `explore` triggers 20 impact followUps, they all count as **1 loop iteration**, not 20. This is the intended behavior.

### Why This Matters

Without this behavior, recursive `followUp` patterns would quickly exhaust `maxIterations`:
- Player explores → triggers 20 impacts
- Each impact was counting as 1 iteration
- maxIterations: 30 would be reached after 1-2 player turns
- The game would end prematurely or require absurdly high maxIterations

### The Rule

A `loop` iteration is only incremented when an action completes **without returning a followUp**. This means:
- `action → followUp → followUp → done` = 1 iteration
- `action → done` = 1 iteration
- `action → followUp (chain of 100) → done` = 1 iteration

---

## 7. Element Class Registration

### The Problem

Forgetting to register custom element classes causes deserialization failures:

```typescript
// WRONG - MyCard not registered
class MyGame extends Game {
  constructor() {
    this.deck = this.create(Deck, 'deck');
    this.deck.create(MyCard, 'card', { value: 1 });  // Works initially...
    // But fails on reload/restore!
  }
}
```

### The Solution

Always register custom element classes in your Game constructor:

```typescript
// CORRECT - register all custom classes
class MyGame extends Game {
  constructor() {
    super(options);

    // Register ALL custom element classes
    this.registerElements([MyCard, MyDeck, MyPiece, MyBoard]);

    // Now create elements
    this.deck = this.create(Deck, 'deck');
    // ...
  }
}
```

---

## 8. Side Effects in Choice Callbacks

### The Problem

Choice callbacks in `chooseFrom` are evaluated when building action metadata, **before the player acts**. This causes issues when your choices have side effects:

```typescript
// WRONG - Draws cards every time action metadata is built!
Action.create('hireFirstMerc')
  .chooseFrom('merc', {
    choices: (ctx) => {
      // This runs on EVERY state update, not when player clicks
      const drawn = ctx.game.mercDeck.drawCards(3);  // Side effect!
      return drawn;
    },
  })
```

This causes:
- Cards drawn before player intends to act
- Cards drawn multiple times during the same turn
- Deck state corruption

### The Solution

Choices are now always evaluated on-demand when the player needs to make the selection. This is the default behavior - no special configuration needed:

```typescript
// CORRECT - Choices evaluated when player clicks
Action.create('hireFirstMerc')
  .chooseFrom('merc', {
    choices: (ctx) => {
      // This runs when player needs to make the selection
      const drawn = ctx.game.mercDeck.drawCards(3);
      return drawn;
    },
  })
```

See [On-Demand Choices](./actions-and-flow.md#on-demand-choices) in the Actions & Flow documentation for full details.

---

## 8.5. Module-Level Caching Doesn't Work (CRITICAL)

### The Problem

You try to cache data in a module-level variable to share between `choices()` and `execute()`, but the data is missing when `execute()` runs:

```typescript
// ❌ WRONG - Module-level caching will NOT work!
const drawnEquipmentCache = new Map<string, Equipment>();

Action.create('armsDealer')
  .chooseFrom('equipment', {
    choices: (ctx) => {
      const equipment = ctx.game.equipmentDeck.draw();
      drawnEquipmentCache.set(`player_${ctx.player.position}`, equipment);  // Set here...
      return [equipment, { value: 'skip', label: 'Skip' }];
    },
  })
  .execute((args, ctx) => {
    const key = `player_${ctx.player.position}`;
    const equipment = drawnEquipmentCache.get(key);  // ...undefined here!
    console.log('Equipment from cache:', equipment);  // "NONE"
  });
```

### Why This Happens

The `choices()` and `execute()` callbacks run in **different contexts**:
- `choices()` runs when building the UI/validating
- `execute()` runs when the player submits their choice
- With network play, these may be completely different server instances

Module-level variables don't survive across these boundaries.

### The Solution: Use `actionTempState()`

```typescript
import { Action, actionTempState } from 'boardsmith';

Action.create('armsDealer')
  .chooseFrom('equipment', {
    choices: (ctx) => {
      const temp = actionTempState(ctx, 'armsDealer');
      const equipment = ctx.game.equipmentDeck.draw();
      temp.set('drawnEquipment', equipment.id);  // Store in game state
      return [equipment, { value: 'skip', label: 'Skip' }];
    },
  })
  .execute((args, ctx) => {
    const temp = actionTempState(ctx, 'armsDealer');
    const equipmentId = temp.get<number>('drawnEquipment');  // ✓ Works!
    const equipment = ctx.game.getElementById(equipmentId) as Equipment;
    temp.clear();  // Always clean up

    if (args.equipment === 'skip') {
      sector.addToStash(equipment);
    } else {
      // Equip to merc...
    }
  });
```

**Key points:**
- `actionTempState()` stores data in `game.settings` which persists correctly
- Automatically namespaced by action name and player
- Always call `temp.clear()` in `execute()` to clean up

See [Using actionTempState()](./actions-and-flow.md#using-actiontempstate-for-temp-state) for full documentation.

---

## 9. Element Storage: Arrays vs Children (CRITICAL)

### The Problem

Storing game elements in property arrays throws an error because elements cannot be serialized to JSON:

```typescript
// ERROR - Will throw at runtime
class Sector extends Space {
  stash: Equipment[] = [];  // Throws: "Element arrays cannot be auto-synced"

  addToStash(equipment: Equipment): void {
    this.stash.push(equipment);  // Error thrown here
  }
}
```

BoardSmith detects element arrays and throws a clear error with guidance:
```
Element arrays cannot be auto-synced: game.stash contains a GameElement.
Use element children instead:
  // Instead of: game.stash = []
  // Use: stashZone = this.create(Space, 'stashZone')
  //      stashZone.create(Equipment, 'item')
  //      Access via: this.stashZone.all(Equipment)
```

### Primitive Arrays Work Automatically

Simple data arrays (numbers, strings, objects) **automatically survive HMR** without any special handling:

```typescript
// WORKS - Primitive arrays auto-sync to settings
class MyGame extends Game {
  scores: number[] = [];           // Auto-synced, survives HMR
  history: string[] = [];          // Auto-synced, survives HMR
  roundData: { round: number }[] = [];  // Auto-synced, survives HMR

  recordScore(score: number): void {
    this.scores.push(score);       // Automatically persisted
  }
}
```

All array mutations (push, pop, splice, sort, etc.) and reassignments are tracked automatically.

### The Solution for Element Arrays

Store elements as **children** in the element tree, not as property arrays:

```typescript
// CORRECT - Elements as children serialize fully
class Sector extends Space {
  // Create a child Space to hold stash items
  stashZone!: Space;

  setupStash(): void {
    this.stashZone = this.create(Space, 'stash');
    this.stashZone.contentsHidden();  // Optional: hide from other players
  }

  addToStash(equipment: Equipment): void {
    equipment.putInto(this.stashZone);  // Moves element in tree
  }

  getStash(): Equipment[] {
    return [...this.stashZone.all(Equipment)];
  }

  get stashCount(): number {
    return this.stashZone.count(Equipment);
  }
}
```

Now equipment serializes with all attributes because it's part of the element tree.

### When to Use Each Pattern

| Pattern | Use For | Example |
|---------|---------|---------|
| **Element children** | Game pieces that need UI display | Cards in hand, pieces on board, equipment in stash |
| **Property arrays** | Simple data (auto-syncs to HMR) | `scores: number[]`, `history: string[]`, `roundData: object[]` |
| **ID arrays** | References you'll look up later | `selectedCardIds: number[]` then use `getElementById()` |

> **Note:** Property arrays automatically sync to `game.settings` and survive HMR. You don't need to manually use `game.settings.myArray` anymore - just declare a regular array property.

### Migration Example

If you have existing code with array storage:

```typescript
// Before (broken)
class Player extends BasePlayer {
  inventory: Equipment[] = [];

  addItem(item: Equipment): void {
    this.inventory.push(item);
  }
}

// After (correct)
class Player extends BasePlayer {
  inventoryZone!: Space;

  setupInventory(game: Game): void {
    this.inventoryZone = game.create(Space, `inventory-${this.position}`);
    this.inventoryZone.player = this;
    this.inventoryZone.contentsVisibleToOwner();
  }

  addItem(item: Equipment): void {
    item.putInto(this.inventoryZone);
  }

  get inventory(): Equipment[] {
    return [...this.inventoryZone.all(Equipment)];
  }
}
```

---

## 10. followUp Args Auto-Resolution

### The Problem

When using `followUp` to chain actions with pre-filled args, the server **automatically resolves numeric IDs to elements** before calling your callbacks. Your code may expect an ID but receive an element:

```typescript
// In explore action execute():
return {
  success: true,
  followUp: {
    action: 'collectEquipment',
    args: { mercId: merc.id, sectorId: sector.id }  // Passing numeric IDs
  }
};

// In collectEquipment filter() - WRONG assumption:
filter: (element, ctx) => {
  // ctx.args.sectorId is NOT a number - it's the resolved Sector element!
  const sector = game.getElementById(ctx.args.sectorId);  // FAILS - already an object
  return element.container === sector;
}
```

### The Solution

Use the `resolveElementArg()` helper to handle both cases:

```typescript
import { resolveElementArg } from 'boardsmith';

// In collectEquipment filter():
filter: (element, ctx) => {
  const sector = resolveElementArg<Sector>(game, ctx.args.sectorId);
  if (!sector) return false;
  return element.container === sector;
}
```

Or handle both cases manually:

```typescript
function getSector(ctx: any): Sector | undefined {
  const sectorArg = ctx.args?.sectorId;
  if (typeof sectorArg === 'number') {
    return game.getElementById(sectorArg) as Sector | undefined;
  } else if (sectorArg && typeof sectorArg === 'object' && 'id' in sectorArg) {
    return sectorArg as Sector;
  }
  return undefined;
}
```

### Why This Happens

The server resolves numeric args to elements so that most action callbacks "just work" with element objects. However, if your code explicitly calls `getElementById()` on an already-resolved element, it fails.

---

## 11. Computed Getters Not Serialized

### The Problem

Computed getters on element classes are **not included in serialization**. The UI only receives the raw serialized properties:

```typescript
// Server-side element class
class Sector extends Space {
  get stash(): Equipment[] {
    return [...this.stashZone.all(Equipment)];  // Computed from children
  }
}

// UI code - WRONG:
const stash = getAttr(sectorElement, 'stash', []);  // Returns [] - not serialized!
```

The UI receives the raw element tree, not computed properties.

### The Solution

In UI code, query the element tree directly instead of expecting computed properties:

```typescript
// UI code - CORRECT:
function getStashFromSector(sectorElement: any): Equipment[] {
  // Find the stash zone child
  const stashZone = sectorElement.children?.find((c: any) =>
    c.className === 'Space' && getAttr(c, 'name', '') === 'stash'
  );

  if (!stashZone?.children) return [];

  // Get equipment from the zone
  return stashZone.children
    .filter((e: any) => e.className === 'Equipment')
    .map((e: any) => ({
      id: e.id,
      name: getAttr(e, 'equipmentName', 'Unknown'),
      type: getAttr(e, 'equipmentType', 'item'),
    }));
}
```

### Best Practices

1. **Design for serialization**: Store data as element children or explicit properties, not computed getters
2. **UI mirrors structure**: Write UI code that queries the same element tree structure as the server
3. **Use attributes**: Store frequently-accessed values as actual attributes, not computed

### Example: Exposing Computed Data

If you need a computed value available to the UI, store it as an attribute:

```typescript
// Server-side
class Sector extends Space {
  updateStashCount(): void {
    // Store as explicit attribute for UI access
    this.stashCount = this.stashZone.count(Equipment);
  }

  addToStash(equipment: Equipment): void {
    equipment.putInto(this.stashZone);
    this.updateStashCount();  // Keep attribute in sync
  }
}

// UI can now access directly
const count = getAttr(sectorElement, 'stashCount', 0);
```

---

## 12. Debugging "Why Isn't My Action Available?"

### The Problem

Your action isn't appearing in `availableActions` and you can't figure out why. The game silently excludes it with no explanation.

### The Solution: Use `debugActionAvailability()`

The engine provides a built-in debugging method that explains exactly why an action is or isn't available:

```typescript
// In your game code or browser console:
const debug = game.debugActionAvailability('equipItem', player);
console.log(debug.reason);
// "Selection 'equipment' has no valid choices (Depends on 'actingMerc' - no valid combinations found)"

// For detailed breakdown:
console.log('Condition passed:', debug.details.conditionPassed);
for (const sel of debug.details.selections) {
  const status = sel.passed ? '✓' : '✗';
  console.log(`${status} ${sel.name}: ${sel.choices} choices`);
  if (sel.note) console.log(`    ${sel.note}`);
}
// ✓ actingMerc: 3 choices
//     3 valid choices
// ✗ equipment: 0 choices
//     Depends on 'actingMerc' - no valid combinations found
```

### Common Issues and What to Look For

| `debug.reason` says... | Check this... |
|------------------------|---------------|
| "Condition returned false" | Your action's `condition` function. Use `ConditionTracer` for details. |
| "Selection 'X' has no valid choices" | The `from`, `filter`, or `elements` for that selection. |
| "Depends on 'Y' - no valid combinations" | All choices for Y lead to empty choices for X. Maybe Y has the wrong elements? |
| "Filter eliminated all choices" | Your `filter` function is too restrictive. |
| "Action 'X' does not exist" | Typo in action name or action not registered. |

### Debug All Actions At Once

```typescript
const allDebug = game.debugAllActions(player);
const unavailable = allDebug.filter(d => !d.available);
for (const d of unavailable) {
  console.log(`${d.actionName}: ${d.reason}`);
}
```

### In Tests

```typescript
import { createTestGame } from 'boardsmith/testing';

const testGame = await createTestGame(gameDefinition, { playerCount: 2 });

// Debug why action isn't available
const debug = testGame.game.debugActionAvailability('attack', testGame.game.players.get(1)!);
expect(debug.available).toBe(true);
// If it fails, debug.reason tells you why
```

---

## 13. Client-Side vs Server-Side Element Access

### The Problem

On the **server side** (engine), you access elements via methods like `first()`, `all()`, and properties:
```typescript
// Server-side - returns GameElement with ._t.id
const weapon = merc.first(Equipment, e => e.equippedSlot === 'weapon');
console.log(weapon?.id); // 42 (numeric ID from _t.id)
```

On the **client side** (UI), you access elements via the serialized `gameView` tree:
```typescript
// Client-side - gameView has { id, className, attributes, children }
const weapon = merc.children?.find(c =>
  c.className === 'Equipment' && c.attributes?.equippedSlot === 'weapon'
);
console.log(weapon?.id); // 42 (numeric ID at top level)
```

### Common Mistake: Accessing Attributes Instead of Children

```typescript
// WRONG - Accessing an attribute that might store element DATA (not the element)
const slot = merc.attributes.weaponSlot;
// Returns: { equipmentId: "45-caliber...", ... } - plain object, NO id!

// CORRECT - Find in children array
const slot = merc.children?.find(c =>
  c.attributes?.equippedSlot === 'weapon'
);
// Returns: { id: 42, className: 'Equipment', attributes: {...} }
```

### The Symptom

If you see:
- `element.id` is `undefined`
- Object has game-specific attributes like `equipmentId` (string) instead of numeric `id`
- Element has no `className` property

You're likely looking at an **attribute object**, not a proper element from the tree.

### Visibility Can Hide Children

If an element belongs to an opponent, its children may be hidden:
```typescript
// Hidden child elements appear with __hidden flag and may have negative IDs
{
  id: -5001,  // Negative = hidden placeholder
  className: 'Equipment',
  attributes: { __hidden: true }
}
```

Check for `__hidden` when iterating children:
```typescript
const visibleEquipment = merc.children?.filter(c =>
  c.className === 'Equipment' && !c.attributes?.__hidden
);
```

### Debugging Checklist

1. **Server-side**: Use `element._t.children` to see actual children
2. **Client-side**: Use `element.children` from gameView
3. **Check visibility**: Look for `__hidden: true` in attributes
4. **Verify IDs**: Real elements have positive numeric `id`, hidden placeholders have negative `id`

---

## 14. Action Availability = Conditions AND Flow (CRITICAL)

### The Problem

Your action passes all its conditions (shown as available in the debug panel), but it doesn't appear in `availableActions` in the UI. You've verified the condition logic, checked your selections, and everything looks correct - but the action is silently excluded.

```typescript
// Debug panel shows:
// ✓ move - conditionResult: true, selections: [{ name: 'piece', choiceCount: 5 }]
//
// But in your game UI:
// availableActions = ['endTurn']  // Where's 'move'??
```

### The Root Cause

BoardSmith has **two layers** of action availability:

1. **Action conditions** - Does the action's `condition()` pass? Do all selections have valid choices?
2. **Flow restrictions** - Is the action listed in the current `actionStep({ actions: [...] })`?

An action must pass BOTH to appear in `availableActions`. The debug panel's "Actions" tab shows all actions that pass layer 1, but doesn't show layer 2 restrictions.

### The Solution

Check your flow definition - the action must be listed in the `actionStep({ actions: [...] })`:

```typescript
// WRONG - 'move' not in flow's action list
actionStep({
  name: 'player-turn',
  actions: ['endTurn'],  // Only endTurn is allowed!
})

// CORRECT - include all actions you want available
actionStep({
  name: 'player-turn',
  actions: ['move', 'attack', 'useAbility', 'endTurn'],
})
```

### Use the Debug Panel's Flow Context

The debug panel now shows flow context information:

```
⚡ FLOW CONTEXT
Phase: playerTurn
Current player: 0 [Your turn]
Flow allows: endTurn

✓ AVAILABLE (1)
  endTurn

🚫 FLOW-RESTRICTED (3)
  These actions pass their conditions but are not allowed by the current flow step.
  move          [would be available]
  attack        [would be available]
  useAbility    [would be available]
```

The **Flow-Restricted** section shows exactly which actions are being blocked by the flow.

### Common Scenarios

#### 1. Renamed/Consolidated Actions
After refactoring, the flow references old action names:

```typescript
// Old code had separate actions
actions: ['dictatorMove', 'dictatorAttack']

// After consolidation, actions are unified
// But flow still references old names!
game.defineAction('move', ...)  // 'dictatorMove' no longer exists
```

**Fix:** Update flow to use new action names. The engine now warns about unknown actions:
```
[BoardSmith] Flow step 'player-turn' references unknown action 'dictatorMove'.
Did you forget to register it with game.defineAction('dictatorMove', ...)?
```

#### 2. Dynamic Action Lists
Use a function for conditional action lists:

```typescript
actionStep({
  name: 'merc-action',
  actions: (ctx) => {
    const baseActions = ['move', 'attack', 'endTurn'];
    const player = ctx.player as MyPlayer;

    // Only add special actions if player has capabilities
    if (player.hasTactics) baseActions.push('playTactics');
    if (player.canReinforce) baseActions.push('reinforce');

    return baseActions;
  },
})
```

#### 3. Phase-Based Actions
Different phases allow different actions:

```typescript
const combatPhase = phase('combat', {
  do: actionStep({
    actions: ['attack', 'defend', 'retreat'],
  }),
});

const buildPhase = phase('build', {
  do: actionStep({
    actions: ['construct', 'recruit', 'upgrade'],
  }),
});
```

### Why This Design?

The flow-based restriction is intentional - it enforces game structure:

- **Phases**: Only certain actions make sense during specific phases
- **Sequences**: Ensure players complete steps in order (draft → play → score)
- **Turn structure**: Separate "main actions" from "free actions"

Without flow restrictions, any action could be taken at any time, breaking game rules.

### Debugging Checklist

1. **Open debug panel → Actions tab** - Check the Flow Context section
2. **Look at "Flow allows"** - Is your action listed?
3. **Check "Flow-Restricted" section** - Is your action there?
4. **If flow-restricted**: Update your flow's `actionStep({ actions: [...] })` to include it
5. **If not even in conditions-passed**: Use `game.debugActionAvailability()` to find why

---

## 15. Using followUp Args in prompt/filter

### The Problem

When using `followUp` to chain actions, the args passed in `followUp.args` need to be available in `prompt` and `filter` functions. A common pattern is filtering choices based on a context element:

```typescript
Action.create('collectEquipment')
  .chooseElement('equipment', {
    prompt: (ctx) => {
      // You want ctx.args.sectorId to show "Select from Sector X"
      const sector = ctx.game.getElementById(ctx.args?.sectorId);
      return `Select from ${sector?.name}`;
    },
    filter: (element, ctx) => {
      // You want ctx.args.sectorId to filter to only this sector's items
      const sector = ctx.game.getElementById(ctx.args?.sectorId);
      return sector?.stash.contains(element);
    },
  })
  .execute((args, ctx) => {
    // Process the selection...
    if (moreItemsAvailable) {
      return {
        followUp: {
          action: 'collectEquipment',
          args: { sectorId: ctx.args.sectorId }  // Pass element or ID
        }
      };
    }
  });
```

### The Solution

This pattern works correctly in BoardSmith. When you return `followUp.args`:

1. **Elements are automatically resolved everywhere**: Whether you pass an element or an ID, the server resolves it to the actual Element when:
   - Evaluating `prompt` and `filter` functions
   - Calling the `execute` function (in both `args` and `ctx.args`)
2. **Consistent args**: The same resolved `ctx.args` is available in prompt, filter, and execute

### Best Practices for followUp Args

1. **Pass elements directly** - the framework handles serialization automatically:

```typescript
return {
  followUp: {
    action: 'collectEquipment',
    args: { sectorId: sector }  // Element gets serialized/deserialized automatically
  }
};
```

2. **Access directly via ctx.args** - already resolved to Elements:

```typescript
prompt: (ctx) => {
  // ctx.args.sectorId is the resolved Element
  return `Select from ${ctx.args.sectorId?.name}`;
},
filter: (element, ctx) => {
  // Same - ctx.args.sectorId is the Element
  return ctx.args.sectorId?.stash.contains(element);
},
execute: (args, ctx) => {
  // args.sectorId is also the resolved Element (not just in ctx.args)
  const sector = args.sectorId;
  sector.stash.remove(args.equipment);
}
```

### Why This Works

BoardSmith automatically resolves element references throughout the action lifecycle:

1. **Action returns followUp**: Elements in `followUp.args` get JSON-serialized (keeping their `id`)
2. **Client stores and sends back**: Args are sent to server for choices and execution
3. **Server resolves everywhere**:
   - In `getSelectionChoices`: Resolves args before evaluating `prompt`, `filter`, `elements()`
   - In `executeAction`: Resolves ALL args (selection args AND followUp args) before calling `execute`
4. **Consistent element access**: `ctx.args.sectorId` is the same Element in prompt, filter, and execute

---

## 16. Element Count Explosion During followUp Chains

### The Problem

After many followUp iterations (e.g., 20+), your element queries suddenly return far more elements than expected:

```typescript
// Expected: ~200 Equipment elements
// Actual: 15,698 Equipment elements after 20 followUp iterations!
const equipment = [...game.all(Equipment)];
```

### Diagnosis

BoardSmith provides development mode warnings and debug methods:

1. **Automatic warning in development mode**: When element count doubles unexpectedly, you'll see:

```
[BoardSmith] Element count explosion detected for 'equipment'!
  Previous count: 200
  Current count: 15698 (78.5x increase)
  Element class: Equipment
  Total elements in game tree: 15700
  Element sequence counter: 15700
  ...
```

2. **Use `debugElementTree()` for detailed diagnostics**:

```typescript
const treeInfo = game.debugElementTree();
console.log(treeInfo.summary);
// "Total: 15698 elements in tree, 12 in pile, sequence at 15710"

console.log(treeInfo.byClass);
// { Equipment: 15690, Sector: 5, Player: 2, Space: 3 }

if (treeInfo.issues.length > 0) {
  console.log('Issues:', treeInfo.issues);
  // Any circular references or duplicate IDs detected
}
```

### Common Causes

1. **Action execute handler creating elements**:

```typescript
// WRONG - creates elements on every iteration!
.execute((args, ctx) => {
  // This creates a new Equipment every time the action runs
  const newItem = sector.create(Equipment, 'Item', { ... });

  return {
    followUp: { action: 'sameAction', args: { ... } }
  };
})
```

2. **Setup code running on every action** (HMR issue):

```typescript
// WRONG - if this runs on hot reload, it creates duplicates
game.all(Sector).forEach(sector => {
  sector.create(Equipment, 'Loot1');  // Runs again on HMR!
});
```

### The Solution

1. **Check your execute handler** - make sure you're not creating elements unintentionally

2. **Guard against duplicate creation**:

```typescript
// CORRECT - check before creating
if (!sector.first(Equipment, { name: 'Loot1' })) {
  sector.create(Equipment, 'Loot1');
}
```

3. **Use `debugElementTree()` in your game to track element growth**:

```typescript
// Add this to your game for debugging
this.registerDebug('Element Tree', () => this.debugElementTree());
```

4. **Check the sequence counter** - if it's much higher than element count, elements are being created and removed (normal but worth investigating)

### Key Diagnostic Values

| Metric | Meaning |
|--------|---------|
| `totalInTree` | Current elements in game tree (should be stable) |
| `sequenceCounter` | Total elements ever created (always increases) |
| `byClass` | Breakdown by element type (find which class is exploding) |
| `issues` | Circular references or duplicate IDs (tree corruption) |

---

## 17. Loop Exit with Pending Async State

### The Problem

Your flow loop's `while` condition only checks action availability, but doesn't account for async game state (like combat) that needs resolution:

```typescript
// WRONG - Exits when actions are depleted, even if combat is pending
loop({
  while: (ctx) => {
    const player = ctx.player as MercPlayer;
    return player.team.some(m => m.actionsRemaining > 0);
  },
  do: actionStep({ actions: ['move', 'attack', 'endTurn'] })
})
```

**What happens:**
1. Player uses their last action to attack
2. Attack triggers combat that requires target selection
3. Loop's `while` returns `false` (no actions left)
4. Loop exits before combat is resolved
5. Combat state is orphaned or cleared by the next game phase

### The Solution

Use `stateAwareLoop()` to automatically check for pending state before exiting:

```typescript
import { stateAwareLoop } from 'boardsmith';

stateAwareLoop({
  name: 'combat-action-loop',
  actions: ['move', 'attack', 'endTurn'],
  while: (ctx) => {
    const player = ctx.player as MercPlayer;
    return player.team.some(m => m.actionsRemaining > 0);
  },
  pendingStates: (ctx) => [
    (ctx.game as MercGame).activeCombat,    // Keep looping while combat pending
    (ctx.game as MercGame).pendingCombat,   // Keep looping while combat about to start
  ],
})
```

**How it works:**
- `pendingStates` returns an array of values to check
- If ANY are truthy, the loop continues even if `while` returns false
- This ensures async state (combat, animations, etc.) resolves before the loop exits

### Alternative: Manual Check

You can also add checks directly in a regular `loop`:

```typescript
loop({
  while: (ctx) => {
    const game = ctx.game as MercGame;

    // Always stop if game is finished
    if (game.isFinished()) return false;

    // Keep looping while combat needs resolution
    if (game.activeCombat) return true;
    if (game.pendingCombat) return true;

    // Then check normal action availability
    const player = ctx.player as MercPlayer;
    return player.team.some(m => m.actionsRemaining > 0);
  },
  do: actionStep({ actions: ['move', 'attack', 'endTurn'] })
})
```

### The Pattern

Any loop that can trigger async state changes should check for that state:

```typescript
// Template for async-state-aware loops
loop({
  while: (ctx) => {
    // 1. Check game completion
    if (ctx.game.isFinished()) return false;

    // 2. Check for pending async state (combat, animations, etc.)
    if (hasPendingAsyncState(ctx)) return true;

    // 3. Check normal loop condition (action availability, etc.)
    return normalLoopCondition(ctx);
  },
  do: ...
})
```

---

## 18. Passing Choice Objects to fill() Instead of Values

### The Problem

You get choices from `getChoices()` and pass the entire choice object to `fill()`, but the action behaves unexpectedly or fails:

```typescript
// WRONG - passing the choice object
const choices = actionController.getChoices(currentSelection);
const selectedChoice = choices.find(c => c.value === sectorId);
await actionController.fill(selection.name, selectedChoice);  // ❌
// selectedChoice = { value: 142, display: "Wilderness" }
```

### The Solution

Pass `choice.value`, not the choice object:

```typescript
// CORRECT - pass just the value
await actionController.fill(selection.name, selectedChoice.value);  // ✓
// passes 142
```

### Why This Matters

`getChoices()` returns `{ value, display }` objects for UI rendering:
- `value`: What the server expects (element ID, choice value, etc.)
- `display`: Human-readable label for buttons/lists

The `fill()` function expects the raw value, not the wrapper object.

### Pit of Success

As of v0.8, BoardSmith automatically unwraps choice objects passed to `fill()` and shows a dev warning. However, passing `choice.value` directly is clearer and recommended.

---

## 19. Drag-Drop Not Working with ActionPanel

### The Problem

You've set up drag-drop using `useDragDrop`, but when you drag an element, nothing happens - no drop targets highlight, and dropping doesn't execute the action.

### Check the Console for Warnings

In development mode, BoardSmith warns you when a drag starts but no matching action is found:

```
[BoardSmith] Drag started for element {"id":42} but no matching action found.

For drag-drop to work automatically, your action needs one of these patterns:
1. Element -> Choice with filterBy: .fromElements('piece', {...}).chooseFrom('dest', { filterBy: { key: 'pieceId' } })
2. Element -> Element: .fromElements('source', {...}).fromElements('target', {...})

Current action: none
Available actions: move, attack, endTurn
```

### Required Action Patterns

For ActionPanel's automatic drag-drop to work, your action must follow one of these patterns:

**Pattern 1: Element -> Choice with filterBy**
```typescript
Action.create('moveCard')
  .fromElements('card', {
    elements: (ctx) => [...ctx.game.all(Card)],
  })
  .chooseFrom('destination', {
    choices: buildDestinationChoices(),  // Returns { value, targetRef }
    filterBy: { key: 'cardId' },  // Filter destinations by the selected card
  })
```

**Pattern 2: Element -> Element**
```typescript
Action.create('assignToSquad')
  .fromElements('combatant', {
    elements: (ctx) => [...ctx.game.all(Combatant)],
  })
  .fromElements('targetSquad', {
    elements: (ctx) => [...ctx.game.all(Squad)],
  })
```

### Common Mistakes

1. **Action not available**: The action must be in `availableActions` for drag-drop to work. Check that:
   - The action is listed in your flow's `actionStep({ actions: [...] })`
   - The action's conditions pass

2. **Wrong selection type**: Using `chooseFrom` without `filterBy` doesn't work for automatic drag-drop. The framework needs to know how to filter destinations based on the dragged element.

3. **Missing targetRef**: For `chooseFrom` with `filterBy`, each choice needs a `targetRef` property that identifies the drop target element:
   ```typescript
   choices: zones.map(zone => ({
     value: { zoneId: zone.id, cardId: selectedCard.id },
     display: zone.name,
     targetRef: { name: zone.name },  // Required for drop target identification
   }))
   ```

4. **Element ref mismatch**: The `dragProps` ref must match what the action's `fromElements` returns:
   ```typescript
   // If your action uses element IDs:
   dragProps({ id: card.id })  // ✓
   dragProps({ name: card.name })  // ✗ Won't match

   // If your action returns elements by name:
   dragProps({ name: piece.name })  // ✓
   ```

### Debugging Checklist

1. **Open browser console** - Look for `[BoardSmith] Drag started...` warnings
2. **Check action availability** - Is the action in `availableActions`?
3. **Verify action pattern** - Does it use one of the supported patterns?
4. **Check element refs** - Do `dragProps` refs match what `fromElements` returns?
5. **Inspect choices** - For `chooseFrom`, do choices have `targetRef`?

### Using the Pit-of-Success API

If drag-drop isn't working with the automatic ActionPanel integration, you can use the simpler `drag()` and `drop()` helpers which give you more control:

```vue
<script setup>
import { useDragDrop } from 'boardsmith/ui';
import 'boardsmith/ui/animation/drag-drop.css';

const { drag, drop } = useDragDrop();

const canDragCard = (cardId) =>
  currentAction.value === 'moveCard' &&
  currentSelection.value?.name === 'card' &&
  isCardSelectable(cardId);
</script>

<template>
  <div
    v-for="card in cards"
    v-bind="drag({ id: card.id }, { when: canDragCard(card.id) }).props"
    :class="drag({ id: card.id }, { when: canDragCard(card.id) }).classes"
  />
</template>
```

See [useDragDrop documentation](./ui-components.md#usedragdrop) for full details.

---

## 20. Mixing Dice Randomization Methods

### The Problem

Using multiple randomization approaches in the same action creates confusion and bugs:

```typescript
// WRONG - three different approaches mixed!
game.die.roll();  // Method 1: roll() generates random value
const rolled = Math.floor(Math.random() * 6) + 1;  // Method 2: separate random
game.die.setValue(rolled);  // Method 3: overwrite with different value
```

This causes:
- The die shows one value, then immediately changes to another
- `Math.random()` breaks determinism and replay
- The animation from `roll()` shows a different value than what ends up displayed

### The Solution

Use ONE approach:

```typescript
// CORRECT - roll() handles everything
const rolled = game.die.roll();  // Returns value, triggers animation
game.message(`Rolled ${rolled}!`);
```

### When to Use Each

| Method | Use Case |
|--------|----------|
| `die.roll()` | Normal dice rolling (random value + animation) |
| `die.setValue(n)` | Abilities that set specific values ("flip to opposite", "set to max") |
| `game.random()` | Non-dice randomness (shuffle order, random events) |

**Never use `Math.random()`** - it breaks determinism and replay.

### Symptoms of This Bug

- Die shows one value briefly, then shows another
- Die animation doesn't match final value
- Game replay shows different dice results
- "Rolled X" message doesn't match displayed die

---

## Quick Reference

| Pitfall | Wrong | Right |
|---------|-------|-------|
| Element comparison | `array.includes(element)` | `array.some(e => e.id === element.id)` |
| Element equality | `el1 === el2` | `el1.equals(el2)` |
| Multi-step filter | `args.previous.prop` | `args?.previous?.prop` with fallback |
| Dead elements | `squad.all(Merc)` | `squad.getLivingMercs()` |
| Action costs | In `onEach` callback | In `execute` block |
| Element refs on Player | `selectedCard: Card` | `selectedCardId: number` |
| Loop safety | No `maxIterations` | Always set `maxIterations` |
| Class registration | Forget to register | `registerElements([...])` |
| Side effects in choices | N/A (no longer an issue) | Choices always evaluated on-demand |
| **Module-level caching** | `const cache = new Map()` | `actionTempState(ctx, 'action')` |
| **Element storage** | `stash: Equipment[] = []` | `stashZone.all(Equipment)` |
| **Action debugging** | Guessing why action unavailable | `game.debugActionAvailability(name, player)` |
| **Client-side elements** | `element.attributes.slot` | `element.children?.find(...)` |
| **Flow restrictions** | Action passes conditions but not in UI | Check flow's `actionStep({ actions: [...] })` |
| **followUp args in filter** | `ctx.args.sectorId` undefined in filter/prompt | Args are resolved - use `ctx.args.sectorId` |
| **Element count explosion** | Elements mysteriously multiply | `game.debugElementTree()` to diagnose |
| **Loop exit with pending state** | Loop checks only actions remaining | Use `stateAwareLoop()` with `pendingStates` |
| **execute() vs start()** | `execute('retreat', {})` without params | `start('retreat')` for wizard mode |
| **Choice objects in fill()** | `fill(name, choiceObject)` | `fill(name, choiceObject.value)` |
| **Drag-drop not working** | No matching action for drag | Use element→element or element→choice with filterBy |
| **Mixing dice randomization** | `die.roll()` then `die.setValue(Math.random())` | Use only `die.roll()` for normal rolling |

---

## See Also

- [Core Concepts](./core-concepts.md) - Element tree structure
- [Actions & Flow](./actions-and-flow.md) - Action and flow patterns
- [Common Patterns](./common-patterns.md) - Reusable game patterns
````

## File: docs/core-concepts.md
````markdown
# Core Concepts

This document explains the fundamental concepts and architecture of BoardSmith.

## Overview

BoardSmith uses a hierarchical element tree to represent game state, with a clear separation between:
- **Actions** (what players do) - high-level, game-specific
- **Commands** (how state changes) - low-level, generic, event-sourced

## Element Tree

Games are represented as a tree of `GameElement` objects:

```
Game (root)
├── Board/Grid/Deck (Spaces - containers)
│   ├── Piece/Card (game pieces)
│   └── More spaces...
├── Player Hands (Spaces)
└── Pile (removed elements)
```

### Element Types

| Class | Purpose | Example |
|-------|---------|---------|
| `GameElement` | Base class (never instantiate directly) | - |
| `Space` | Container for other elements | Board, pile, zone |
| `Deck` | Stack of cards (shuffleable) | Draw pile, discard |
| `Hand` | Player's private cards | Player's hand |
| `Grid` | Square grid | Chess/checkers board |
| `HexGrid` | Hexagonal grid | Hex game board |
| `Piece` | Physical game piece | Checker, stone |
| `Card` | Playing card | Standard deck card |

### Creating Elements

Elements are created as children of other elements:

```typescript
// In your Game constructor
class MyGame extends Game<MyGame, MyPlayer> {
  constructor(options) {
    super(options);

    // Register element classes (required for serialization)
    this.registerElements([Card, Hand, Deck, Board]);

    // Create elements as children of the game
    this.deck = this.create(Deck, 'deck');
    this.board = this.create(Board, 'board');

    // Create cards inside the deck
    for (const suit of suits) {
      for (const rank of ranks) {
        this.deck.create(Card, `${rank}${suit}`, { suit, rank });
      }
    }
  }
}
```

### Element Operations

```typescript
// Query elements
const card = deck.first(Card);              // First card
const cards = deck.all(Card);               // All cards
const count = deck.count(Card);             // Count cards
const aceOfSpades = deck.first(Card, c => c.rank === 'A' && c.suit === 'S');

// Move elements
card.putInto(hand);                         // Move card to hand
card.putInto(hand, { position: 'first' }); // Put at beginning

// Remove elements
card.remove();                              // Remove from game

// Create elements
const stone = cell.create(Stone, 'stone-1', { player });

// Shuffle (Deck only)
deck.shuffle();

// Element ordering
deck.setOrder('stacking');                  // Last in, first out
```

### Custom Element Classes

Extend base classes to add game-specific properties:

```typescript
// elements.ts
import { Card as BaseCard, Piece as BasePiece } from 'boardsmith';

export class Card extends BaseCard {
  suit!: 'H' | 'D' | 'C' | 'S';
  rank!: string;

  get value(): number {
    const values: Record<string, number> = { 'A': 1, 'J': 11, 'Q': 12, 'K': 13 };
    return values[this.rank] ?? parseInt(this.rank);
  }
}

export class CheckerPiece extends BasePiece {
  player!: CheckersPlayer;
  isKing: boolean = false;

  promote(): void {
    this.isKing = true;
  }
}
```

## Visibility System

Control what each player can see.

### Element Visibility

```typescript
// Make contents visible to everyone
deck.contentsVisible();

// Hide contents from everyone
deck.contentsHidden();

// Only owner can see contents
hand.contentsVisibleToOwner();
```

### Attribute Visibility

Use static `visibleAttributes` to control which attributes are visible:

```typescript
class Card extends BaseCard {
  suit!: Suit;
  rank!: Rank;
  secretValue!: number;  // Hidden from players

  // Only suit and rank are visible in hidden contexts
  static visibleAttributes = ['suit', 'rank'];
}
```

## Actions vs Commands

BoardSmith separates player intent from state mutations.

### Actions (High-Level)

Actions are what players do - game-specific operations with prompts, selections, and validation:

```typescript
const moveAction = Action.create('move')
  .prompt('Move a piece')
  .chooseElement('piece', { filter: p => p.player === ctx.player })
  .chooseElement('destination', { filter: c => c.isEmpty() })
  .execute((args, ctx) => {
    args.piece.putInto(args.destination);  // Generates MoveCommand
  });
```

### Commands (Low-Level)

Commands are generic state mutations that happen automatically when you call element methods:

| Element Method | Generated Command |
|---------------|-------------------|
| `parent.create(Class, name, attrs)` | `CreateElementCommand` |
| `element.putInto(target)` | `MoveCommand` |
| `element.remove()` | `RemoveCommand` |
| `deck.shuffle()` | `ShuffleCommand` |
| `element.setAttribute(key, value)` | `SetAttributeCommand` |
| `element.contentsVisible()` | `SetVisibilityCommand` |

### Why This Matters

1. **Event Sourcing**: Commands form a replayable event log
2. **Undo/Redo**: Actions can be undone by reversing commands
3. **Networking**: Only commands are sent over the network
4. **Security**: Players can't directly manipulate state
5. **Debugging**: Full history of what happened

### Best Practices

```typescript
// DO: Use element methods in action execute functions
.execute((args, ctx) => {
  card.putInto(hand);
  player.score += 10;
});

// DON'T: Try to create commands manually
// DON'T: Bypass actions for player operations
```

## Player System

### Custom Player Classes

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  hand!: Hand;
  score: number = 0;  // Auto-serialized to gameView
  abilities: Record<string, number> = { reroll: 1 };  // Auto-serialized

  constructor(position: number, name: string, game: MyGame) {
    super(position, name);
    this.game = game;

    // Create player's hand
    this.hand = game.create(Hand, `hand-${position}`);
    this.hand.player = this;
    this.hand.contentsVisibleToOwner();
  }
}
```

> **Auto-serialization**: Public properties (like `score`, `abilities`) are automatically included in the game view sent to the UI. You do NOT need to override `toJSON()` for simple properties. Properties starting with `_` are private and not serialized.

### Player Properties

- `position`: 1-indexed player position (Player 1 = position 1)
- `name`: Display name
- `game`: Reference to the game instance

### Accessing Players

```typescript
// In game class
this.players                    // PlayerCollection
this.players.get(1)             // First player (1-indexed)
this.players.get(2)             // Second player
this.players.current            // Player whose turn it is
this.players.all()              // Array of all players

// In action context
ctx.player                      // Current action's player
ctx.game.players.current        // Current player from game
```

## Game State Serialization

BoardSmith automatically handles serialization for:
- Network transmission
- State persistence
- Replays

### PlayerCollection Serialization Warning

`game.players` is a `PlayerCollection` (an Array subclass), not a plain Array. This has important implications when working with player data:

```typescript
// ❌ WRONG: Returns a PlayerCollection, not a plain Array
// When JSON.stringify() is called, PlayerCollection.toJSON() re-serializes
// the elements, losing any custom properties
const playerData = game.players.map(p => p.toJSON());

// ✅ CORRECT: Spread to convert to plain Array
const playerData = [...game.players.map(p => p.toJSON())];

// ✅ ALSO CORRECT: Use Array.from()
const playerData = Array.from(game.players.map(p => p.toJSON()));
```

This is a JavaScript quirk: when you call `.map()` on an Array subclass, the result is an instance of the same subclass, not a plain Array. The `PlayerCollection.toJSON()` method then gets called during serialization, which re-processes the already-serialized data.

### Registering Elements

All custom element classes must be registered:

```typescript
this.registerElements([Card, Hand, Deck, Board, Piece]);
```

### State Snapshots

Use utility functions from `boardsmith` for state snapshots:

```typescript
import { createSnapshot, createPlayerView } from 'boardsmith';

// Get complete state snapshot
const snapshot = createSnapshot(game, 'my-game');

// Get player-specific view (with visibility applied)
const playerView = createPlayerView(game, playerPosition);
```

### Player Views

Each player receives a filtered view of the game state:
- Hidden elements show only `visibleAttributes`
- Private zones of other players are hidden
- Server-side information is stripped

## Game Lifecycle

```
1. Constructor
   - Register elements
   - Create initial state
   - Register actions
   - Set flow

2. setup() - Called after constructor
   - Additional initialization

3. start() - Game begins
   - Flow starts executing
   - Players take actions

4. isFinished() returns true
   - Game ends
   - getWinners() called
```

## Game Definition Metadata

Games export a `gameDefinition` object that describes the game to the framework. This metadata enables:
- Dynamic lobby UI generation
- Game options configuration
- Per-player settings (colors, roles)
- Quick-start presets

### Basic Structure

```typescript
// index.ts
export const gameDefinition = {
  gameClass: MyGame,
  gameType: 'my-game',
  displayName: 'My Game',
  minPlayers: 2,
  maxPlayers: 4,
  ai: {
    objectives: getMyGameObjectives,  // Optional AI support
  },
  gameOptions: { /* ... */ },         // Optional game-level options
  playerOptions: { /* ... */ },       // Optional per-player options
  presets: [ /* ... */ ],             // Optional quick-start presets
};
```

### Game Options

Game-level configuration options that appear in the lobby.

```typescript
gameOptions: {
  boardSize: {
    type: 'number',
    label: 'Board Size',
    description: 'Number of hexes per side',
    min: 5,
    max: 19,
    step: 1,
    default: 11,
  },
  targetScore: {
    type: 'number',
    label: 'Target Score',
    description: 'Points needed to win',
    min: 31,
    max: 121,
    default: 121,
  },
  variant: {
    type: 'select',
    label: 'Game Variant',
    choices: [
      { value: 'standard', label: 'Standard' },
      { value: 'speed', label: 'Speed Mode' },
    ],
    default: 'standard',
  },
  allowUndo: {
    type: 'boolean',
    label: 'Allow Undo',
    default: true,
  },
}
```

### Player Options

Per-player settings that appear for each player slot in the lobby.

```typescript
import { createColorOption } from 'boardsmith/session';

playerOptions: {
  // Standard color picker (8 colors)
  color: createColorOption(),

  // Custom color picker
  color: createColorOption([
    { value: '#ff0000', label: 'Red Team' },
    { value: '#0000ff', label: 'Blue Team' },
  ], 'Team'),

  // Role selector (for symmetric options)
  role: {
    type: 'select',
    label: 'Role',
    choices: [
      { value: 'attacker', label: 'Attacker' },
      { value: 'defender', label: 'Defender' },
    ],
    default: 'attacker',
  },
}
```

### Exclusive Player Options

For asymmetric games where exactly one player must have a specific role (e.g., 1 Dictator vs many Rebels), use the `exclusive` type. This renders as a radio button on each player row.

```typescript
playerOptions: {
  isDictator: {
    type: 'exclusive',
    label: 'Dictator',
    description: 'Select which player is the dictator',
    default: 'last',  // 'first', 'last', or player index number
  },
}
```

### Presets

Quick-start configurations for common game setups.

```typescript
presets: [
  {
    name: 'Quick Game',
    description: '7x7 board',
    options: { boardSize: 7 },
    players: [
      { color: '#e74c3c' },
      { color: '#3498db' },
    ],
  },
  {
    name: 'vs AI',
    description: 'Play against AI',
    options: { boardSize: 9 },
    players: [
      { isAI: false, color: '#e74c3c' },
      { isAI: true, aiLevel: 'medium', color: '#3498db' },
    ],
  },
]
```

### Receiving Options in Game Constructor

Options are passed to your game constructor via `CreateGameRequest`:

```typescript
export interface CreateGameRequest {
  gameType: string;
  playerCount: number;
  playerNames?: string[];
  gameOptions?: Record<string, unknown>;    // From gameOptions
  playerConfigs?: PlayerConfig[];           // From playerOptions
  aiPlayers?: number[];
  aiLevel?: string;
}

// In your game
class MyGame extends Game<MyGame, MyPlayer> {
  constructor(options: MyGameOptions) {
    super(options);

    // Access game options
    const boardSize = options.boardSize ?? 11;

    // Access player configs (players are 1-indexed)
    for (const player of this.players) {
      const config = options.playerConfigs?.[player.position - 1];  // configs array is 0-indexed
      if (config?.color) {
        player.color = config.color;
      }
    }
  }
}
```

## Example: Hex Game

A minimal but complete example from `packages/games/hex/`:

```typescript
// game.ts
export class HexGame extends Game<HexGame, HexPlayer> {
  board!: Board;
  winner?: HexPlayer;

  constructor(options: HexOptions) {
    super(options);

    this.registerElements([Board, Cell, Stone]);

    // Create hex board
    this.board = this.create(Board, 'board', { boardSize: 7 });
    for (let r = 0; r < 7; r++) {
      for (let q = 0; q < 7; q++) {
        this.board.create(Cell, `cell-${q}-${r}`, { q, r });
      }
    }

    this.registerAction(createPlaceStoneAction(this));
    this.setFlow(createHexFlow(this));
  }

  override isFinished(): boolean {
    return !!this.winner;
  }

  override getWinners(): HexPlayer[] {
    return this.winner ? [this.winner] : [];
  }
}
```

## Related Documentation

- [Actions & Flow](./actions-and-flow.md) - Deep dive on actions and game flow
- [UI Components](./ui-components.md) - Building game UIs
- [Game Examples](./game-examples.md) - Real game implementations
````

## File: docs/custom-ui-guide.md
````markdown
# Building Custom Game UIs

This guide walks you through building a custom game UI from scratch. It covers the complete flow from understanding game data to executing actions and debugging issues.

## Overview

BoardSmith UIs receive game state as a serialized element tree (`gameView`) and execute actions through the `actionController`. The key concepts are:

1. **gameView** - Serialized game state (read-only, from server)
2. **actionController** - Execute actions and manage wizard mode
3. **validElements** - Which elements can be selected for the current action
4. **boardInteraction** - Highlight/select elements on the board

## Step 1: Understanding gameView Structure

The `gameView` is a tree of serialized game elements. Each element has:

```typescript
interface GameViewElement {
  id: number;              // Unique ID - use this for action args!
  className: string;       // Element class (e.g., 'Card', 'Piece')
  name?: string;           // Optional name
  attributes: {            // Your custom properties
    rank?: string;
    suit?: string;
    health?: number;
    // ...
  };
  children?: GameViewElement[];  // Child elements
  childCount?: number;           // For hidden containers
}
```

**Critical:** The `id` is at the top level, NOT in `attributes`:

```typescript
// Correct
const cardId = card.id;  // ✓

// Wrong - common mistake!
const cardId = card.attributes.id;  // ✗ undefined
```

## Step 2: Finding Elements

Use the helper functions from `boardsmith/ui`:

```typescript
import {
  findElement,
  findElements,
  findElementById,
  findPlayerHand,
  findChildByAttribute,
  findElementByAttribute,
  getElementId,
} from 'boardsmith/ui';

// Find by type (uses $type attribute)
const deck = findElement(gameView, { type: 'deck' });

// Find by name
const board = findElement(gameView, { name: 'mainBoard' });

// Find player's hand
const myHand = findPlayerHand(gameView, playerPosition);

// Find by ID (recursive search)
const card = findElementById(gameView, cardId);

// Find by attribute value
const merc = findChildByAttribute(squad, 'mercName', 'Jake');
const sector = findElementByAttribute(gameView, 'sectorId', 'alpha-3');
```

### Common Pattern: Extracting Data for Display

```vue
<script setup lang="ts">
import { computed } from 'vue';
import { findPlayerHand, findElement } from 'boardsmith/ui';

const props = defineProps<{
  gameView: any;
  playerPosition: number;
}>();

// Extract hand cards
const myCards = computed(() => {
  const hand = findPlayerHand(props.gameView, props.playerPosition);
  if (!hand?.children) return [];

  return hand.children.map(card => ({
    id: card.id,
    rank: card.attributes?.rank,
    suit: card.attributes?.suit,
  }));
});

// Extract board state
const boardPieces = computed(() => {
  const board = findElement(props.gameView, { type: 'board' });
  if (!board?.children) return [];

  return board.children.filter(c => c.className === 'Piece');
});
</script>
```

## Step 3: Executing Actions

The `actionController` provides two patterns for executing actions:

### Pattern A: Direct Execution

Use when you have all required values:

```typescript
// No selections needed
await actionController.execute('endTurn');

// All selections provided
await actionController.execute('move', {
  piece: clickedPiece.id,      // Use numeric IDs
  destination: clickedCell.id,
});

// The result tells you if it succeeded
const result = await actionController.execute('play', { card: cardId });
if (!result.success) {
  console.error(result.error);
}
```

### Pattern B: Wizard Mode

Use when the user needs to make selections through the ActionPanel:

```typescript
// Start wizard mode - ActionPanel shows selection UI
actionController.start('attack');

// Pre-fill the first selection
actionController.start('move', {
  args: { piece: pieceId }
});

// Pre-fill a later selection (auto-applied when that step activates)
actionController.start('dropEquipment', {
  args: { merc: mercId },
  prefill: { equipment: equipmentId },
});
```

**When to use which:**

| Scenario | Use |
|----------|-----|
| No selections (endTurn, pass) | `execute()` |
| All values known from board click | `execute()` |
| User picks from ActionPanel | `start()` |
| Pre-fill first selection, user picks rest | `start()` with `args` |
| Dependent selection needs prefill | `start()` with `prefill` |

### The `args` vs `prefill` Difference

- **args**: Applied immediately when `start()` is called
- **prefill**: Applied later when that selection step becomes active

Use `prefill` for dependent selections where the choice isn't available until a prior selection is made.

### Common Pattern: Button → Board Selection

A common pattern in custom UIs is a button that triggers an action requiring the user to select an element on the game board. For example, a "Retreat" button that requires selecting a destination sector.

**The Wrong Way (easy mistake):**
```typescript
// CombatPanel.vue
function handleRetreat() {
  // WRONG: execute() without the required 'retreatSector' parameter
  // The action needs wizard mode to let the user select a sector!
  await actionController.execute('retreat', {});  // ❌ Fails silently
}
```

**The Right Way:**
```typescript
// CombatPanel.vue
function handleRetreat() {
  // Start wizard mode - BoardSmith will enable sector selection
  actionController.start('retreat');  // ✓
}
```

After calling `start()`, BoardSmith:
1. Enters "wizard mode" for the action
2. Fetches valid choices from the server
3. Populates `validElements` with selectable elements
4. Enables `isSelectableElement()` for those elements on the board
5. Waits for user to click a valid element
6. Auto-completes the action when selection is made

**In your board component**, highlight selectable elements:
```vue
<template>
  <div
    v-for="sector in sectors"
    :key="sector.id"
    :class="{ selectable: boardInteraction?.isSelectableElement(sector) }"
    @click="onSectorClick(sector)"
  >
    {{ sector.name }}
  </div>
</template>

<script setup lang="ts">
import { useBoardInteraction } from 'boardsmith/ui';

const boardInteraction = useBoardInteraction();

function onSectorClick(sector: { id: number }) {
  if (boardInteraction?.isSelectableElement(sector)) {
    boardInteraction.triggerElementSelect(sector);
  }
}
</script>
```

### Detecting When to Use Wizard Mode

Use the `actionNeedsWizardMode()` helper to check programmatically:

```typescript
import { actionNeedsWizardMode } from 'boardsmith/ui';

const meta = actionController.getActionMetadata('retreat');
const check = actionNeedsWizardMode(meta, {});

if (check.needed) {
  console.log(check.reason);
  // "Selection 'retreatSector' requires element selection from the game board"
  actionController.start('retreat');
} else {
  actionController.execute('retreat', {});
}
```

> **Dev Mode Warning**: In development mode, BoardSmith automatically warns when you call `execute()` on an action that likely needs wizard mode. Check your browser console for helpful messages.

## Step 4: Handling Element Selections

When an action uses `fromElements()` or `chooseElement()`, the `actionController` provides `validElements` - a reactive computed of which elements can be selected:

```vue
<script setup lang="ts">
import type { UseActionControllerReturn } from 'boardsmith/ui';

const props = defineProps<{
  actionController: UseActionControllerReturn;
}>();

// Reactive! Updates automatically when:
// - Current selection changes
// - Choices are fetched from server
// - gameView updates
const selectableCards = computed(() => {
  const { currentSelection, validElements } = props.actionController;

  if (currentSelection.value?.type !== 'element') return [];

  return validElements.value.map(ve => ({
    id: ve.id,
    display: ve.display,
    // Full element data is included:
    image: ve.element?.attributes?.image,
    rank: ve.element?.attributes?.rank,
  }));
});
</script>
```

### Highlighting Selectable Elements

```vue
<template>
  <div
    v-for="card in myCards"
    :key="card.id"
    class="card"
    :class="{
      'selectable': isSelectable(card.id),
      'selected': isSelected(card.id),
    }"
    @click="onCardClick(card)"
  >
    {{ card.rank }}{{ card.suit }}
  </div>
</template>

<script setup lang="ts">
function isSelectable(cardId: number): boolean {
  return props.actionController.validElements.value
    .some(ve => ve.id === cardId);
}

function isSelected(cardId: number): boolean {
  const currentArgs = props.actionController.currentArgs.value;
  return currentArgs.card === cardId;
}

async function onCardClick(card: { id: number }) {
  if (!isSelectable(card.id)) return;

  // Fill the selection (always await - it returns a Promise)
  await props.actionController.fill('card', card.id);
}
</script>
```

### Understanding getChoices() Return Values

When building custom UIs, you'll often need to get the available choices for a selection. The `getChoices()` method returns choices in a consistent format:

```typescript
Array<{ value: unknown; display: string }>
```

**Important:** The `value` property contains what you should pass to `fill()`:
- For element selections: `value` is the numeric element ID
- For choice selections: `value` is the choice value (string, object, etc.)

```typescript
// Getting choices for the current selection
const choices = actionController.getChoices(currentSelection);

// CORRECT - pass choice.value to fill()
const selectedChoice = choices.find(c => c.value === userSelectedId);
await actionController.fill(currentSelection.name, selectedChoice.value);

// WRONG - don't pass the whole choice object
await actionController.fill(currentSelection.name, selectedChoice); // ❌
```

The `display` property is the human-readable label for rendering in your UI (buttons, lists, etc.).

**Note:** If you do accidentally pass a choice object to `fill()`, BoardSmith will auto-unwrap it in development mode and show a warning. However, passing `choice.value` directly is clearer and recommended.

## Step 5: Using boardInteraction

For bidirectional interaction between the board and ActionPanel:

```typescript
import { useBoardInteraction } from 'boardsmith/ui';

const boardInteraction = useBoardInteraction();

// Check if element is highlighted (hovering in ActionPanel)
boardInteraction.isHighlighted(element)

// Check if element is currently selected
boardInteraction.isSelected(element)

// Check if element is a valid selection target
boardInteraction.isSelectableElement(element)

// Trigger selection from board click
boardInteraction.triggerElementSelect(element)

// Check current action state
boardInteraction.currentAction        // 'move' | null
boardInteraction.currentSelectionName // 'destination' | null
```

### Complete Board Integration Example

```vue
<template>
  <div class="board">
    <div
      v-for="piece in pieces"
      :key="piece.id"
      class="piece"
      :class="{
        highlighted: boardInteraction?.isHighlighted(piece),
        selected: boardInteraction?.isSelected(piece),
        selectable: boardInteraction?.isSelectableElement(piece),
      }"
      @click="onPieceClick(piece)"
      @mouseenter="onPieceHover(piece)"
      @mouseleave="onPieceLeave"
    >
      {{ piece.name }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { useBoardInteraction, type UseActionControllerReturn } from 'boardsmith/ui';

const props = defineProps<{
  actionController: UseActionControllerReturn;
  availableActions: string[];
}>();

const boardInteraction = useBoardInteraction();

function onPieceClick(piece: any) {
  // If in wizard mode and piece is selectable, trigger selection
  if (boardInteraction?.isSelectableElement(piece)) {
    boardInteraction.triggerElementSelect(piece);
    return;
  }

  // Otherwise start a new action if available
  if (props.availableActions.includes('move')) {
    props.actionController.start('move', { args: { piece: piece.id } });
  }
}
</script>
```

## Step 6: Handling Dependent Selections

When selection B depends on selection A (e.g., "select merc, then select their equipment"):

### Engine Side (for reference)

```typescript
Action.create('dropEquipment')
  .fromElements('merc', { elements: () => [...game.all(Merc)] })
  .fromElements('equipment', {
    dependsOn: 'merc',  // Tells framework this depends on merc
    elements: (ctx) => {
      const merc = ctx.args.merc as Merc;
      return [...merc.equipment.all(Equipment)];
    }
  })
```

### UI Side: Using prefill

```typescript
// User clicks on a piece of equipment on a merc
function onEquipmentClick(merc: any, equipment: any) {
  // Start the action with both values
  actionController.start('dropEquipment', {
    args: { merc: merc.id },
    prefill: { equipment: equipment.id },  // Auto-fills when equipment step activates
  });
}
```

### UI Side: Watching for Dependent Changes

```typescript
import { watch } from 'vue';

// When merc selection changes, equipment choices update automatically
watch(
  () => actionController.validElements.value,
  (newElements) => {
    console.log('Available equipment:', newElements.map(e => e.display));
  }
);
```

### Loading State for Dependent Choices

When a selection depends on a previous one, choices are fetched from the server. Show a loading indicator while fetching:

```vue
<template>
  <div class="selection-panel">
    <!-- Loading spinner while fetching choices -->
    <div v-if="actionController.isLoadingChoices.value" class="loading">
      Loading options...
    </div>

    <!-- Show choices when loaded -->
    <div v-else-if="actionController.validElements.value.length">
      <div
        v-for="el in actionController.validElements.value"
        :key="el.id"
        @click="selectElement(el)"
      >
        {{ el.display }}
      </div>
    </div>

    <!-- Empty state -->
    <div v-else class="empty">
      No options available
    </div>
  </div>
</template>
```

## Step 7: Reacting to Action Context

Sometimes UI panels need to react to action state. For example, showing a detail panel when an action targets a specific element.

### Accessing Current Action Args

The `actionController.currentArgs` ref contains all args for the in-progress action, including followUp context:

```typescript
import { computed } from 'vue';

// Get sector ID from current action (if any)
const actionContextSectorId = computed(() => {
  const args = actionController.currentArgs.value;
  if (!args?.sectorId) return null;

  // Handle both plain ID and {id, name} object formats
  const sectorId = args.sectorId;
  if (typeof sectorId === 'object' && sectorId !== null) {
    return (sectorId as { id: number }).id;
  }
  return sectorId as number;
});
```

### Example: Auto-Opening a Detail Panel

When a sector-related action starts (either from ActionPanel or via followUp), automatically show the sector's detail panel:

```vue
<script setup lang="ts">
import { computed, ref } from 'vue';
import type { UseActionControllerReturn } from 'boardsmith/ui';

const props = defineProps<{
  actionController: UseActionControllerReturn;
  sectors: Array<{ id: number; name: string }>;
}>();

// Sector selected by clicking on map
const selectedSectorId = ref<number | null>(null);

// Sector from action context (e.g., followUp.args.sectorId)
const actionContextSectorId = computed(() => {
  const args = props.actionController.currentArgs.value;
  if (!args?.sectorId) return null;

  // Handle both plain ID and {id, name} object formats
  const sectorId = args.sectorId;
  if (typeof sectorId === 'object' && sectorId !== null) {
    return (sectorId as { id: number }).id;
  }
  return sectorId as number;
});

// Show panel if either source has a sector
const activeSectorId = computed(() =>
  selectedSectorId.value ?? actionContextSectorId.value
);

const activeSector = computed(() =>
  props.sectors.find(s => s.id === activeSectorId.value)
);
</script>

<template>
  <div class="game-layout">
    <GameMap
      :sectors="sectors"
      @sector-click="selectedSectorId = $event"
    />

    <!-- Panel shows for clicked sector OR action context sector -->
    <SectorPanel
      v-if="activeSector"
      :sector="activeSector"
      @close="selectedSectorId = null"
    />
  </div>
</template>
```

### Watching for Action Changes

To run side effects when actions start or complete:

```typescript
import { watch } from 'vue';

// React when action starts
watch(
  () => actionController.currentAction.value,
  (newAction, oldAction) => {
    if (newAction && !oldAction) {
      console.log('Action started:', newAction);
      console.log('Initial args:', actionController.currentArgs.value);
    }
    if (!newAction && oldAction) {
      console.log('Action completed/cancelled:', oldAction);
    }
  }
);

// React to specific arg changes
watch(
  () => actionController.currentArgs.value?.targetId,
  (targetId) => {
    if (targetId) {
      highlightElement(targetId);
    }
  }
);
```

## Debugging

### Why Isn't My Action Available?

Use `debugActionAvailability()` in the game code or browser console:

```typescript
// In game rules (server-side)
const debug = game.debugActionAvailability('attack', player);
console.log(debug.reason);
// "Selection 'target' has no valid choices"

// For detailed breakdown
for (const sel of debug.details.selections) {
  console.log(`${sel.name}: ${sel.choices} choices - ${sel.note || 'OK'}`);
}
```

### Why Isn't My Action Executing?

1. **Check actionController.error:**
   ```typescript
   watch(() => actionController.lastError.value, (error) => {
     if (error) console.error('Action failed:', error);
   });
   ```

2. **Log action args before execution:**
   ```typescript
   async function executeAction(name: string, args: Record<string, unknown>) {
     console.log('[Action]', name, JSON.stringify(args, null, 2));
     await actionController.execute(name, args);
   }
   ```

3. **Check Network tab** for WebSocket messages or API calls

### Common Mistakes

| Symptom | Cause | Fix |
|---------|-------|-----|
| Action not in availableActions | Condition failed or no valid selections | Use `debugActionAvailability()` |
| "Invalid selection" error | Passed wrong value type | Check you're passing element ID (number) not object |
| Element not found in gameView | ID mismatch or element moved | Use `findElementById()` to verify |
| validElements is empty | Choices not fetched yet | Check `isLoadingChoices`, wait for fetch |
| Selection not applying | Wrote to actionArgs directly | Use `actionController.fill()` instead |
| Spurious values in followUp args | Custom UI writing to actionArgs | See warning in console, use `fill()` |

### ID vs Object Confusion

A common source of bugs is confusing element IDs with element objects:

```typescript
// Element from gameView
const card = findPlayerHand(gameView, 0)?.children?.[0];

// This is the element object
console.log(card);           // { id: 42, className: 'Card', attributes: {...} }

// This is what actions need
console.log(card.id);        // 42

// Correct - pass the ID
await actionController.execute('play', { card: card.id });

// Wrong - don't pass the object
await actionController.execute('play', { card: card });
```

## Complete Example: Card Game Board

```vue
<script setup lang="ts">
import { computed, ref } from 'vue';
import {
  useBoardInteraction,
  findPlayerHand,
  findElement,
  type UseActionControllerReturn,
} from 'boardsmith/ui';

const props = defineProps<{
  gameView: any;
  playerPosition: number;
  isMyTurn: boolean;
  availableActions: string[];
  actionController: UseActionControllerReturn;
}>();

const boardInteraction = useBoardInteraction();

// Extract game state
const myHand = computed(() => {
  const hand = findPlayerHand(props.gameView, props.playerPosition);
  return hand?.children || [];
});

const discardPile = computed(() => {
  const pile = findElement(props.gameView, { type: 'discard' });
  return pile?.children || [];
});

const topDiscard = computed(() => discardPile.value[discardPile.value.length - 1]);

// Card interaction
function isCardPlayable(cardId: number): boolean {
  if (!props.isMyTurn) return false;
  if (!props.availableActions.includes('play')) return false;

  // If in wizard mode, check validElements
  const { currentSelection, validElements } = props.actionController;
  if (currentSelection.value?.name === 'card') {
    return validElements.value.some(ve => ve.id === cardId);
  }

  return true;
}

async function onCardClick(card: any) {
  if (!isCardPlayable(card.id)) return;

  // If in wizard mode, fill the selection
  if (boardInteraction?.isSelectableElement(card)) {
    boardInteraction.triggerElementSelect(card);
    return;
  }

  // Otherwise execute directly
  await props.actionController.execute('play', { card: card.id });
}

async function drawCard() {
  if (!props.availableActions.includes('draw')) return;
  await props.actionController.execute('draw');
}
</script>

<template>
  <div class="card-game-board">
    <!-- Discard pile -->
    <div class="discard-pile" @click="drawCard">
      <div v-if="topDiscard" class="card">
        {{ topDiscard.attributes?.rank }}{{ topDiscard.attributes?.suit }}
      </div>
      <div v-else class="empty">Empty</div>
    </div>

    <!-- Hand -->
    <div class="hand">
      <div
        v-for="card in myHand"
        :key="card.id"
        class="card"
        :class="{
          playable: isCardPlayable(card.id),
          highlighted: boardInteraction?.isHighlighted(card),
          selected: boardInteraction?.isSelected(card),
        }"
        @click="onCardClick(card)"
      >
        {{ card.attributes?.rank }}{{ card.attributes?.suit }}
      </div>
    </div>

    <!-- Error display -->
    <div v-if="actionController.lastError.value" class="error">
      {{ actionController.lastError.value }}
    </div>
  </div>
</template>

<style scoped>
.card {
  cursor: pointer;
  transition: transform 0.2s;
}

.card.playable {
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
}

.card.highlighted {
  transform: translateY(-8px);
  box-shadow: 0 0 12px rgba(255, 255, 0, 0.8);
}

.card.selected {
  transform: translateY(-12px);
  box-shadow: 0 0 16px rgba(0, 128, 255, 1);
}

.error {
  position: fixed;
  top: 1rem;
  left: 50%;
  transform: translateX(-50%);
  background: #e74c3c;
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 4px;
}
</style>
```

## Next Steps

- [UI Components Reference](./ui-components.md) - Full API documentation
- [Common Pitfalls](./common-pitfalls.md) - Avoid common mistakes
- [Actions & Flow](./actions-and-flow.md) - How actions work server-side
- [Element Enrichment](./element-enrichment.md) - Advanced validElements usage
````

## File: docs/dice-and-scoring.md
````markdown
# Dice & Scoring Systems

BoardSmith provides comprehensive support for dice games and roll-and-write style scoring. This document covers the engine's dice elements, 3D dice rendering, ability management, and scoring track systems.

## Dice Elements

### Die

The base `Die` class extends `Piece` with dice-specific properties:

```typescript
import { Die } from 'boardsmith';

class MyDie extends Die<MyGame, MyPlayer> {
  // Inherited properties:
  // sides: number - Number of faces (4, 6, 8, 10, 12, 20)
  // value: number - Current face value

  // Add custom properties
  color?: 'red' | 'blue' | 'green';
}
```

#### Die Sides

The engine supports standard polyhedral dice:

| Type | Geometry | Values |
|------|----------|--------|
| D4 | Tetrahedron | 1-4 |
| D6 | Cube | 1-6 |
| D8 | Octahedron | 1-8 |
| D10 | Trapezohedron | 0-9 or 1-10 |
| D12 | Dodecahedron | 1-12 |
| D20 | Icosahedron | 1-20 |

### DicePool

A `DicePool` is a `Space` designed to hold multiple dice:

```typescript
import { DicePool, Die } from 'boardsmith';

class MyGame extends Game<MyGame, MyPlayer> {
  shelf!: DicePool;

  constructor(options: GameOptions) {
    super(options);

    this.registerElements([DicePool, MyDie]);

    // Create the dice pool
    this.shelf = this.create(DicePool, 'shelf');

    // Create dice inside the pool
    this.shelf.create(MyDie, 'd6-1', { sides: 6 });
    this.shelf.create(MyDie, 'd6-2', { sides: 6 });
    this.shelf.create(MyDie, 'd8-1', { sides: 8 });
  }
}
```

### Rolling Dice

Use the `roll()` method to roll dice. It:
- Uses `game.random()` internally (seeded, reproducible)
- Increments `rollCount` to trigger UI animations
- Returns the rolled value

```typescript
const rollAction = Action.create('roll')
  .prompt('Roll all dice')
  .execute((args, ctx) => {
    const dice = ctx.game.shelf.all(MyDie);
    let total = 0;
    for (const die of dice) {
      const rolled = die.roll();  // Returns value, triggers animation
      total += rolled;
    }
    ctx.game.message(`Rolled ${total}!`);
    return { success: true };
  });
```

For a single die:
```typescript
const die = ctx.game.shelf.first(Die);
const rolled = die.roll();  // Returns 1-6 for d6
ctx.game.message(`You rolled a ${rolled}!`);
```

### Common Mistakes

#### Mistake 1: Calling roll() but ignoring the return value

```typescript
// WRONG - value is lost, you can't know what was rolled
die.roll();
game.message(`Rolled... something?`);

// CORRECT - capture the returned value
const rolled = die.roll();
game.message(`Rolled ${rolled}!`);
```

#### Mistake 2: Using Math.random() instead of roll()

```typescript
// WRONG - not seeded, breaks replay and determinism
const value = Math.floor(Math.random() * 6) + 1;
die.setValue(value);

// CORRECT - roll() is seeded and returns the value
const value = die.roll();
```

#### Mistake 3: Calling both roll() and setValue()

```typescript
// WRONG - roll() already set a value, then you overwrite it
// This causes the die to briefly show one value, then change
die.roll();
die.setValue(someOtherValue);

// CORRECT - use one or the other based on intent
const rolled = die.roll();  // For normal random rolling

// OR for abilities that set specific values:
die.setValue(6);  // "Set die to maximum"
die.setValue(die.getOpposite());  // "Flip to opposite face"
```

#### Die Methods

| Method | Description |
|--------|-------------|
| `roll()` | Roll and return value (uses seeded random, triggers animation) |
| `setValue(n)` | Set to specific value (for abilities like "flip to opposite") |
| `getOpposite()` | Get the opposite face value |

#### Important: Never use Math.random()

```typescript
// WRONG - breaks determinism and replay!
die.value = Math.floor(Math.random() * die.sides) + 1;

// CORRECT - use the roll() method
const rolled = die.roll();
```

For other randomness needs (not dice), use `game.random()`:
```typescript
// Seeded random 0-1 (like Math.random but reproducible)
const randomIndex = Math.floor(game.random() * array.length);
```

## 3D Dice UI

The `boardsmith/ui` package includes a WebGL-based 3D dice renderer that displays accurate polyhedral geometry with smooth roll animations.

### Die3D Component

```vue
<script setup lang="ts">
import { Die3D } from 'boardsmith/ui';

const props = defineProps<{
  die: {
    id: string;
    sides: number;
    value: number;
  };
}>();
</script>

<template>
  <Die3D
    :die-id="die.id"
    :sides="die.sides"
    :value="die.value"
    :size="80"
    style="--die-color: #2196F3"
  />
</template>
```

#### Props

| Prop | Type | Description |
|------|------|-------------|
| `dieId` | `string` | Unique identifier for the die |
| `sides` | `4 \| 6 \| 8 \| 10 \| 12 \| 20` | Number of faces |
| `value` | `number` | Current face value to display |
| `size` | `number` | Size in pixels (default: 60) |

#### CSS Custom Properties

Style dice using CSS variables:

```css
.my-die {
  --die-color: #FF5722;           /* Face color */
  --die-pip-color: #FFFFFF;       /* Number/pip color */
  --die-edge-color: #333333;      /* Edge color */
}
```

### Roll Animations

The Die3D component animates when `rollCount` changes. The `roll()` method automatically increments this, so animations happen automatically when you call `die.roll()`.

Pass `rollCount` to the Die3D component:

```vue
<Die3D
  :die-id="die.id"
  :sides="die.attributes.sides"
  :value="die.attributes.value"
  :roll-count="die.attributes.rollCount"
  :size="80"
/>
```

The animation is triggered by changes to `rollCount`, not `value`. This ensures:
- Rolling to the same value still animates
- Setting a value directly (like for abilities) doesn't animate

### Zoom Preview

Enable Alt+hover zoom by adding `data-die-preview` attribute:

```vue
<template>
  <div
    class="die-slot"
    :data-die-preview="JSON.stringify({ sides: die.sides, value: die.value })"
  >
    <Die3D :die-id="die.id" :sides="die.sides" :value="die.value" />
  </div>
</template>
```

The zoom preview provides a larger, centered view of the die for accessibility.

## Ability System

The `AbilityManager` provides a reusable system for games where players earn and use special abilities/powers. Common in dice games with unlockable abilities.

### Basic Usage

```typescript
import { AbilityManager, Player } from 'boardsmith';

// Define your ability types
type MyAbility = 'reroll' | 'flip' | 'bonus' | 'skip';

class MyPlayer extends Player<MyGame, MyPlayer> {
  abilities = new AbilityManager<MyAbility>();

  constructor(position: number, name: string) {
    super(position, name);
    // Give each player a starting ability
    this.abilities.add('reroll', 'starting');
  }

  // Override needed for AbilityManager because it has its own toJSON() method
  override toJSON() {
    const json = super.toJSON();
    json.attributes.abilities = this.abilities.toJSON();
    return json;
  }
}
```

### AbilityManager API

```typescript
const abilities = new AbilityManager<MyAbility>();

// Adding abilities
abilities.add('reroll');                    // Add an ability
abilities.add('reroll', 'from-track');      // With source description

// Checking abilities
abilities.hasUnused('reroll');              // Has unused ability?
abilities.has('reroll');                    // Has any (used or unused)?
abilities.countUnused('reroll');            // Count unused of type
abilities.countAllUnused();                 // Total unused count

// Using abilities
if (abilities.hasUnused('reroll')) {
  abilities.use('reroll');                  // Marks one as used
}

// Querying
abilities.getAll();                         // All abilities
abilities.getUnused();                      // Only unused
abilities.getUsed();                        // Only used
abilities.getTypes();                       // Unique types ['reroll', 'flip']
abilities.getGrouped();                     // [{ type, total, unused }]

// Management
abilities.resetAll();                       // Reset all to unused
abilities.clear();                          // Remove all

// Serialization
const data = abilities.toJSON();
abilities.fromJSON(data);
AbilityManager.fromJSON(data);              // Static factory
```

## Scoring Tracks

BoardSmith provides abstract track classes for dice/roll-and-write games where players record values on scoring sheets.

### Track Types

| Class | Use Case | Example |
|-------|----------|---------|
| `Track` | Base class | - |
| `MonotonicTrack` | Increasing or decreasing sequences | Distillation, Fulminate |
| `UniqueTrack` | No duplicate values allowed | Yahtzee upper section |
| `CounterTrack` | Simple count/tally | Poison skulls, bonus boxes |

### MonotonicTrack

For tracks where values must increase or decrease:

```typescript
import { MonotonicTrack } from 'boardsmith';

// Increasing track (values must go up)
const fulminateTrack = new MonotonicTrack({
  id: 'fulminate',
  name: 'Fulminate',
  direction: 'increasing',
  maxEntries: 10,
  pointsPerEntry: [0, 1, 3, 6, 11, 16, 23, 30, 40, 50],
  completionBonus: 65,
});

// Decreasing track (values must go down)
const distillTrack = new MonotonicTrack({
  id: 'distill-1',
  name: 'Distillation Column 1',
  direction: 'decreasing',
  maxEntries: 5,
  pointsPerEntry: [0, -10, -5, -2, 10],
  completionBonus: 25,
  allowSpecialEntries: true,  // Special entries can equal previous
});
```

#### API

```typescript
// Check if a value can be added
track.canAdd(15);                    // Returns true/false
track.canAdd(15, isSpecial);         // With special entry flag

// Add a value (returns points earned)
const points = track.add(15);

// Query state
track.getEntries();                  // [{ value, points, special }]
track.isEmpty();
track.isComplete();
track.calculatePoints();             // Total including completion bonus

// Serialization
const data = track.toJSON();
track.fromJSON(data);
```

### UniqueTrack

For tracks where each value can only appear once:

```typescript
import { UniqueTrack } from 'boardsmith';

const upperSection = new UniqueTrack({
  id: 'ones',
  name: 'Ones',
  maxEntries: 1,
  pointsPerEntry: (value) => value,  // Function-based points
});

// Will reject if value already used
upperSection.canAdd(3);  // true (first time)
upperSection.add(3);
upperSection.canAdd(3);  // false (already used)
```

### CounterTrack

For simple counting/tallying:

```typescript
import { CounterTrack } from 'boardsmith';

const poisonTrack = new CounterTrack({
  id: 'poison',
  name: 'Poison',
  maxEntries: 6,
  pointsPerCount: 2,       // 2 points per mark
  completionBonus: 10,     // Bonus for filling all 6
});

// Increment the counter
poisonTrack.increment();
poisonTrack.increment();

// Query
poisonTrack.count;         // 2
poisonTrack.isComplete();  // false
poisonTrack.calculatePoints();  // 4 (2 * 2)
```

## Example: Dice Game Player

Here's a complete example combining dice, abilities, and tracks:

```typescript
import {
  Player,
  AbilityManager,
  MonotonicTrack,
  CounterTrack
} from 'boardsmith';

type PowerUp = 'reroll-2' | 'flip' | 'refresh' | 'adjust';

class DiceGamePlayer extends Player<DiceGame, DiceGamePlayer> {
  abilities: AbilityManager<PowerUp>;
  scoreTrack: MonotonicTrack;
  bonusTrack: CounterTrack;

  constructor(position: number, name: string) {
    super(position, name);

    // Initialize ability manager
    this.abilities = new AbilityManager<PowerUp>();
    this.abilities.add('reroll-2', 'starting');

    // Initialize scoring tracks
    this.scoreTrack = new MonotonicTrack({
      id: 'score',
      name: 'Score',
      direction: 'increasing',
      maxEntries: 10,
      pointsPerEntry: [1, 2, 3, 5, 8, 13, 21, 34, 55, 89],
    });

    this.bonusTrack = new CounterTrack({
      id: 'bonus',
      name: 'Bonus Stars',
      maxEntries: 5,
      pointsPerCount: 10,
    });
  }

  get totalScore(): number {
    return this.scoreTrack.calculatePoints() + this.bonusTrack.calculatePoints();
  }

  // Override needed for objects with toJSON() methods (AbilityManager, tracks)
  override toJSON() {
    const json = super.toJSON();
    json.attributes.totalScore = this.totalScore;
    json.attributes.abilities = this.abilities.toJSON();
    json.attributes.scoreTrack = this.scoreTrack.toJSON();
    json.attributes.bonusTrack = this.bonusTrack.toJSON();
    return json;
  }
}
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Element tree and game structure
- [UI Components](./ui-components.md) - Vue components and composables
- [Actions & Flow](./actions-and-flow.md) - Building game actions
- [Game Examples](./game-examples.md) - Complete game implementations
````

## File: docs/element-enrichment.md
````markdown
# Automatic Element Enrichment

When using element selections (`fromElements`, `chooseElement`), the `actionController` automatically enriches valid elements with full element data from the game view. This is the "pit of success" pattern - designers get everything they need without extra work.

## Recommended: Use `validElements` Computed

The `actionController` provides a **reactive `validElements` computed** that automatically updates when:
- The current selection changes
- Choices are fetched from the server
- The gameView updates

```typescript
// In your custom UI component
const { validElements, currentSelection } = props.actionController;

// Use the reactive computed directly - it updates automatically!
const selectableCards = computed(() => {
  if (currentSelection.value?.type !== 'element') return [];

  return validElements.value.map(ve => ({
    id: ve.id,
    name: ve.display,
    // Full element data is included:
    image: ve.element?.attributes?.image,
    description: ve.element?.attributes?.description,
  }));
});
```

## ValidElement Interface

Each item in `validElements` includes:

```typescript
interface ValidElement {
  id: number;                    // Element ID (for submitting selection)
  display?: string;              // Display text for UI
  ref?: { id: number };          // Reference for board highlighting
  element?: GameElement;         // Full element with all attributes!
}
```

## Common Patterns

### Check if an element is selectable

```typescript
function isCardSelectable(cardId: number): boolean {
  if (currentSelection.value?.type !== 'element') return false;

  // Use the reactive validElements computed
  return validElements.value.some(ve => ve.id === cardId);
}
```

### Render selection choices with full data

```typescript
const equipmentChoices = computed(() => {
  if (currentSelection.value?.name !== 'equipment') return [];

  return validElements.value.map(ve => ({
    id: ve.id,
    name: ve.display,
    image: ve.element?.attributes?.image,
    stats: ve.element?.attributes?.stats,
    description: ve.element?.attributes?.description,
  }));
});
```

### Fill a selection when user clicks

```typescript
async function handleCardClick(cardId: number) {
  if (!isCardSelectable(cardId)) return;
  await actionController.fill(currentSelection.value!.name, cardId);
}
```

## Why Use `validElements` Instead of `getValidElements()`?

The `getValidElements()` method reads from an internal Map which Vue can't track reactively. If you use it in a computed:

```typescript
// BAD - Not reactive! Will show empty until something else triggers re-render
const items = computed(() => {
  const sel = currentSelection.value;
  return actionController.getValidElements(sel);  // May be empty!
});
```

The `validElements` computed is designed to be reactive:

```typescript
// GOOD - Reactive! Updates automatically when choices load
const items = computed(() => {
  return validElements.value;  // Always current
});
```

## When `element` Might Be Undefined

The `element` property is optional because the element might not exist in the current game view:

- **Timing**: Element was removed after selection metadata was built
- **Visibility**: Element is hidden from this player's view
- **State change**: A capture/discard happened between server and client updates

When this happens, a console warning is logged (once per element):
```
[actionController] Element 43 (Sarge) not found in gameView.
This can happen if the element was removed after selection metadata was built.
```

## When You Still Need `findElementById`

The `findElementById` utility is still available for cases outside the action flow:

```typescript
import { findElementById } from 'boardsmith/ui';

// Finding container elements for animations
const deck = findElementById(gameView, deckId);

// Finding related elements not in a selection
const parentContainer = findElementById(gameView, parentId);
```

## Type Imports

```typescript
import type {
  UseActionControllerReturn,
  ValidElement,
  SelectionMetadata,
  GameViewElement  // Alias for GameElement
} from 'boardsmith/ui';
```
````

## File: docs/llm-overview.md
````markdown
# BoardSmith LLM Overview

This document provides a comprehensive overview of the BoardSmith framework optimized for LLM consumption. Use this to quickly understand the project architecture and key patterns.

## What is BoardSmith?

BoardSmith is a TypeScript framework for building turn-based multiplayer board and card games. It provides:

- **Element-based state management** - Games are trees of typed elements (Board, Deck, Hand, Piece, Card)
- **Declarative flow system** - Define game structure with composable flow nodes
- **Action builder API** - Fluent API for defining player actions with selections and validation
- **Event-sourced commands** - All state mutations are tracked and replayable
- **Automatic UI generation** - AutoUI can render any game without custom components
- **MCTS AI** - Game-agnostic AI opponents using Monte-Carlo Tree Search
- **Multiplayer networking** - WebSocket-based real-time game sessions

## Project Structure

```
BoardSmith/
├── packages/
│   ├── engine/       # Core framework (~15k lines)
│   ├── runtime/      # Game execution
│   ├── session/      # Session management
│   ├── ai/           # MCTS bot (~700 lines)
│   ├── ui/           # Vue 3 components (~15k lines)
│   ├── client/       # Browser networking
│   ├── server/       # Platform-agnostic server
│   ├── worker/       # Cloudflare Workers runtime
│   ├── cli/          # Dev tools
│   ├── testing/      # Test utilities
│   └── games/        # Example games
│       ├── hex/      # Simplest example
│       ├── go-fish/  # Card game patterns
│       ├── checkers/ # Grid + multi-step
│       └── cribbage/ # Complex multi-phase
└── docs/             # Documentation
```

## Key Concepts

### 1. Element Tree

Games are represented as a tree of `GameElement` objects:

```
Game (root)
├── Board (Space)
│   └── Cell (Space) → Piece
├── Deck (Space) → Card, Card, ...
├── Hand (Space) → Card (owner sees)
└── Pile (removed elements)
```

**Element types**: `Space` (container), `Deck`, `Hand`, `Grid`, `HexGrid`, `Piece`, `Card`

### 2. Actions vs Commands

**Actions** = What players do (high-level, game-specific)
```typescript
Action.create('move')
  .chooseElement('piece', { filter: p => p.player === ctx.player })
  .chooseElement('dest', { filter: c => c.isEmpty() })
  .execute((args) => args.piece.putInto(args.dest));
```

**Commands** = How state changes (low-level, generic, event-sourced)
```typescript
// Generated automatically by element methods
{ type: 'move', elementId: 42, targetId: 17 }
```

### 3. Flow System

Declarative game flow with composable nodes:

```typescript
const flow: FlowDefinition = {
  root: loop({
    while: () => !game.isFinished(),
    do: eachPlayer({
      do: actionStep({ actions: ['move'] }),
    }),
  }),
  isComplete: () => game.isFinished(),
  getWinners: () => game.getWinners(),
};
```

**Flow nodes**: `sequence`, `loop`, `repeat`, `eachPlayer`, `forEach`, `actionStep`, `simultaneousActionStep`, `phase`, `switchOn`, `ifThen`, `execute`, `setVar`

### 4. Visibility System

Control what players can see:

```typescript
deck.contentsHidden();           // Hidden from all
hand.contentsVisibleToOwner();   // Only owner sees
board.contentsVisible();         // Everyone sees
```

## Creating a Game

### 1. Initialize Project

```bash
npx boardsmith init my-game
cd my-game
npm install
boardsmith dev
```

### 2. Define Elements

```typescript
// elements.ts
export class Card extends BaseCard {
  suit!: 'H' | 'D' | 'C' | 'S';
  rank!: string;
}
export class Hand extends BaseHand {}
export class Deck extends BaseDeck {}
```

### 3. Define Actions

```typescript
// actions.ts
export function createPlayAction(game: MyGame): ActionDefinition {
  return Action.create('play')
    .chooseFrom<Card>('card', {
      choices: (ctx) => [...ctx.player.hand.all(Card)],
    })
    .execute((args) => {
      const card = args.card as Card;
      card.remove();
      ctx.player.score += 1;
    });
}
```

### 4. Define Flow

```typescript
// flow.ts
export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      while: () => !game.isFinished(),
      do: eachPlayer({
        do: actionStep({ actions: ['play'] }),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### 5. Game Class

```typescript
// game.ts
export class MyGame extends Game<MyGame, MyPlayer> {
  deck!: Deck;

  constructor(options: MyGameOptions) {
    super(options);
    this.registerElements([Card, Hand, Deck]);
    this.deck = this.create(Deck, 'deck');
    // ... setup ...
    this.registerAction(createPlayAction(this));
    this.setFlow(createGameFlow(this));
  }

  override isFinished(): boolean {
    return this.deck.count(Card) === 0;
  }
}
```

## Common Patterns

### Conditional Turns (Go Again)

```typescript
.execute((args, ctx) => {
  if (gotMatch) {
    return { success: true, data: { extraTurn: true } };
  }
  return { success: true, data: { extraTurn: false } };
});

// In flow
execute((ctx) => {
  if (!ctx.lastActionResult?.data?.extraTurn) {
    ctx.set('turnEnded', true);
  }
})
```

### Multi-Step Actions (Jump Chains)

```typescript
.execute((args, ctx) => {
  if (canContinueJumping) {
    game.pendingJumpPiece = piece;
    game.setPlayerGoesAgain(true);
  }
});
```

### Simultaneous Actions

```typescript
simultaneousActionStep({
  actions: ['discard'],
  playerDone: (ctx, player) => player.hand.count(Card) <= 4,
  allDone: (ctx) => game.allPlayersDiscarded(),
})
```

### Phase-Based Games

```typescript
sequence(
  phase('deal', { do: execute(() => game.deal()) }),
  phase('discard', { do: simultaneousActionStep({ actions: ['discard'] }) }),
  phase('play', { do: playLoop }),
  phase('score', { do: execute(() => game.score()) }),
)
```

## UI Components

**Core**: `GameShell`, `DebugPanel`, `PlayersPanel`, `GameHistory`

**Helpers**: `Draggable`, `DiceRoller`, `CardFan`, `DeckPile`, `FlyingCardsOverlay`

**Auto-UI**: `AutoUI`, `AutoGameBoard`, `AutoElement`, `ActionPanel`

**Composables**:
- `useBoardInteraction` - Board ↔ ActionPanel communication
- `useElementAnimation` - FLIP animations
- `useCardFlip`, `useFlyingCards` - Card animations
- `useGameViewHelpers` - Query game state
- `useGameGrid`, `useHexGrid` - Grid utilities
- `useCardDisplay` - Card formatting

## Dice & Scoring Systems

### Dice Elements

```typescript
// Die extends Piece with sides/value
class MyDie extends Die<MyGame, MyPlayer> {
  color?: 'red' | 'blue';
}

// DicePool is a Space for holding dice
this.shelf = this.create(DicePool, 'shelf');
this.shelf.create(MyDie, 'd6-1', { sides: 6 });
```

### Ability System

```typescript
import { AbilityManager } from 'boardsmith';

type PowerUp = 'reroll' | 'flip' | 'bonus';

class MyPlayer extends Player<MyGame, MyPlayer> {
  abilities = new AbilityManager<PowerUp>();

  constructor() {
    this.abilities.add('reroll', 'starting');
  }
}

// Usage
if (player.abilities.hasUnused('reroll')) {
  player.abilities.use('reroll');
}
```

### Scoring Tracks

```typescript
import { MonotonicTrack, UniqueTrack, CounterTrack } from 'boardsmith';

// Increasing/decreasing sequence tracks
const track = new MonotonicTrack({
  id: 'score',
  direction: 'increasing',  // or 'decreasing'
  maxEntries: 10,
  pointsPerEntry: [0, 1, 3, 6, 11, 16, 23, 30, 40, 50],
});

track.canAdd(15);   // Check if value fits sequence
track.add(15);      // Add value, returns points earned

// Simple counter tracks
const counter = new CounterTrack({
  id: 'bonus',
  maxEntries: 6,
  pointsPerCount: 10,
});

counter.increment();
counter.calculatePoints();  // Returns total points
```

## AI System

```typescript
import { createBot } from 'boardsmith/ai';

const bot = createBot(game, MyGame, 'my-game', 1, [], 'hard');
const move = await bot.play();
```

**Difficulty levels**: `easy` (3 iter), `medium` (5 iter), `hard` (8 iter)

**Custom objectives** for better play:
```typescript
const aiConfig = {
  objectives: (game, playerIndex) => ({
    materialAdvantage: {
      checker: (g, p) => myPieces > oppPieces,
      weight: 0.5,
    },
  }),
};
```

## CLI Commands

```bash
boardsmith init <name>    # Create new game
boardsmith dev            # Start dev server
boardsmith dev --ai 1     # Player 1 is AI
boardsmith test           # Run tests
boardsmith validate       # Validate before publish
boardsmith build          # Production build
boardsmith publish        # Publish to boardsmith.io
```

## Example Games Reference

| Game | File | Key Patterns |
|------|------|--------------|
| Hex | `packages/games/hex/rules/src/` | Simple flow, hex grid, single action |
| Go Fish | `packages/games/go-fish/rules/src/` | Cards, hidden info, conditional turns |
| Checkers | `packages/games/checkers/rules/src/` | Grid, multi-step jumps, promotion |
| Cribbage | `packages/games/cribbage/rules/src/` | Multi-phase, simultaneous, scoring |
| Polyhedral Potions | `packages/games/polyhedral-potions/rules/src/` | Dice, 3D rendering, abilities, scoring tracks |

## Key Files to Understand

1. **Engine core**: `packages/engine/src/`
   - `game.ts` - Game base class
   - `element/` - Element system
   - `action/` - Action builder
   - `flow/` - Flow system
   - `command/` - Command types

2. **Example game**: `packages/games/hex/rules/src/`
   - `game.ts` - Minimal game class
   - `elements.ts` - Custom elements
   - `actions.ts` - Action definitions
   - `flow.ts` - Simple flow

3. **UI**: `packages/ui/src/`
   - `components/GameShell.vue` - Main wrapper
   - `composables/` - Reusable logic

## Architecture Summary

```
User Action → Action System → Commands → State Change
                ↑                           ↓
            Flow System ←──────── Game State ←── Serialization
                                     ↓
                              Player Views → UI Render
```

- **Actions** validate and execute player intent
- **Commands** are event-sourced state mutations
- **Flow** controls game structure and turn order
- **State** is an element tree, serializable to JSON
- **Player Views** filter state by visibility rules
- **UI** renders views and submits actions

## Common Pitfalls

### Custom Player Properties - Auto-Serialization

Public properties on Player (and all GameElements) are **automatically serialized** to the game view:

```typescript
export class MyPlayer extends Player<MyGame, MyPlayer> {
  score: number = 0;  // Automatically appears in gameView
  abilities: Record<string, number> = { reroll: 1 };  // Automatically serialized
  _privateData: string = '';  // NOT serialized (underscore prefix)
}
```

You do NOT need to override `toJSON()` for simple properties. The UI accesses them via `player.attributes.score`.

### PlayerCollection Array Subclass Gotcha

`game.players` is a `PlayerCollection` (Array subclass). When mapping player data, **always spread to a plain Array**:

```typescript
// ❌ WRONG: map() returns PlayerCollection, which has its own toJSON()
const data = game.players.map(p => p.toJSON());

// ✅ CORRECT: Spread converts to plain Array
const data = [...game.players.map(p => p.toJSON())];
```

This is because JavaScript's `.map()` on an Array subclass returns an instance of the same subclass, and `PlayerCollection.toJSON()` will re-serialize the data, losing custom properties.

### chooseElement Args Are Objects, Not IDs

When using `chooseElement` in actions, the args passed to `execute()` contain the **full serialized element object**, not just the element ID:

```typescript
// ❌ WRONG: args.die is an object, not a number
.chooseElement<Die>('die', { ... })
.execute((args, ctx) => {
  const dieId = args.die as number;  // This is actually an object!
  const die = game.all(Die).find(d => d.id === dieId);  // Never finds it
});

// ✅ CORRECT: Extract the ID from the object
.execute((args, ctx) => {
  const dieId = typeof args.die === 'object' ? (args.die as any).id : args.die as number;
  const die = game.all(Die).find(d => d.id === dieId);
});
```

The args object looks like: `{ die: { className: "Die", id: 3, attributes: {...} } }`

### Action Closures and ctx.game

In action execute functions, always use `ctx.game` instead of a closure reference to the game:

```typescript
// ❌ WRONG: Closure reference can become stale
export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('myAction')
    .execute((args, ctx) => {
      game.doSomething();  // Uses closure - may be stale after hot-reload
    });
}

// ✅ CORRECT: Use ctx.game for the current game instance
export function createMyAction(game: MyGame): ActionDefinition {
  return Action.create('myAction')
    .execute((args, ctx) => {
      const currentGame = ctx.game as MyGame;
      currentGame.doSomething();  // Always uses current game
    });
}
```
````

## File: docs/nomenclature.md
````markdown
# BoardSmith Nomenclature

This document defines the standard terminology used throughout BoardSmith. Use these terms consistently in code, documentation, and communication.

## Quick Reference

| Term | Definition |
|------|------------|
| Action | A player operation with prompt, selections, and effects |
| Active Player | The player whose turn it is |
| AutoUI | Auto-generated game interface |
| Board | A Space containing the main game area |
| Card | A Piece with rank, suit, and face-up state |
| Choice | A selection from enumerated options |
| Command | Low-level state mutation (generated by element methods) |
| Condition | Prerequisites for an action to be available |
| Deck | A Space for stacked, usually hidden cards |
| DicePool | A Space containing dice |
| Die | A Piece with a rollable value |
| Element | Base unit in the game tree hierarchy |
| Execute | Running an action's effect after selections complete |
| Flow | The overall structure of game progression |
| GameShell | Top-level UI wrapper component |
| GameTable | Custom game visualization component (replaces GameBoard in v2.3) |
| Grid | A Space with row/column organization |
| Hand | A player's private Space |
| HexGrid | A Space with hexagonal cells |
| Owner | The player who owns an element |
| Phase | A named section of game flow |
| Pick | A choice required for an action (replaces "selection" in v2.3) |
| Piece | A movable element (cards, tokens) |
| Player | A participant in the game |
| Round | One complete cycle through all players |
| Rules | The game logic and setup (Game class) |
| Seat | A player's place at the table (replaces "position" in v2.3) |
| Session | A single game instance |
| Space | A container/location for pieces |
| Table | The visual game area where all components are displayed (replaces GameBoard in v2.3) |
| Turn | A player's opportunity to act |
| Zone | A logical area with visibility rules |

---

## Core Concepts

Core concepts represent the foundational building blocks of any BoardSmith game.

### Table

**Definition:** The visual game area where all game components are displayed and player interactions occur. The table contains the board, player hands, and all other zones.

**In Code:** `GameTable.vue` component (v2.3)
**Related Terms:** Board, Zone, GameShell, Space
**Usage:**
- "The table shows all player hands and the central play area"
- "Configure the table layout in GameTable.vue"

**Note:** Replaces "GameBoard" in v2.3. The board is a component ON the table, not the table itself.

### Board

**Definition:** A Space that represents the main shared game area. Typically contains cells, squares, or positions where pieces are placed during play.

**In Code:** Extends `Space` class; often a custom class like `Board` or `GameBoard`
**Related Terms:** Table, Space, Grid, HexGrid
**Usage:**
- "Place the stone on the board"
- "The board has 8x8 cells"

### Zone

**Definition:** A logical area within the game that groups related elements and can have visibility rules applied. Zones organize game state into meaningful regions.

**In Code:** Conceptual; implemented as `Space` with visibility settings
**Related Terms:** Space, Hand, Deck, Visibility
**Usage:**
- "The discard zone is visible to all players"
- "Each player has a private zone for their resources"

### Session

**Definition:** A single game instance from start to finish. A session tracks the complete state of one game being played.

**In Code:** `GameSession` class; manages game lifecycle
**Related Terms:** Rules, Flow, Player
**Usage:**
- "Start a new session with 4 players"
- "The session ended when Player 1 reached 100 points"

### Rules

**Definition:** The complete game logic including element creation, action definitions, and flow structure. Rules define how a game works.

**In Code:** Your custom `Game` class extending `Game<G, P>`
**Related Terms:** Flow, Action, Session, Element
**Usage:**
- "The rules specify each player starts with 7 cards"
- "Check the rules for valid move destinations"

---

## Players

Terms related to game participants and their roles.

### Player

**Definition:** A participant in the game, either human or AI. Each player has a position, name, and game-specific properties like score or hand.

**In Code:** `Player` base class; extend to `MyPlayer extends Player<MyGame, MyPlayer>`
**Related Terms:** Seat, Active Player, Owner, Hand
**Usage:**
- "Player 1 draws a card"
- "The current player must choose an action"

### Seat

**Definition:** A player's numbered place at the table. Seats are 1-indexed (Seat 1, Seat 2, etc.) and determine turn order.

**In Code:** `player.position` property (1-indexed)
**Related Terms:** Player, Turn, Active Player
**Usage:**
- "The player in Seat 1 goes first"
- "Clockwise order starts from Seat 1"

**Note:** Replaces "position" in external communication in v2.3. Code still uses `player.position`.

### Active Player

**Definition:** The player whose turn it is and who can currently take actions. Only one player is active at a time in turn-based games.

**In Code:** `game.players.current` or `ctx.player` in action context
**Related Terms:** Player, Turn, Action
**Usage:**
- "The active player may draw or pass"
- "Wait for the active player to complete their turn"

### Owner

**Definition:** The player who controls or possesses a game element. Elements like hands belong to their owner, and pieces may be owned for scoring or control purposes.

**In Code:** `element.player` property on elements
**Related Terms:** Player, Piece, Hand, Visibility
**Usage:**
- "Only the owner can see their hand contents"
- "The piece's owner scores 2 points"

---

## Game Flow

Terms describing the structure and progression of gameplay.

### Phase

**Definition:** A named section of game flow that groups related activities. Phases organize gameplay into distinct stages like "deal", "play", and "score".

**In Code:** `phase('name', { do: ... })` flow node
**Related Terms:** Flow, Round, Turn, Action
**Usage:**
- "During the deal phase, each player receives 5 cards"
- "The scoring phase happens at the end of each round"

### Round

**Definition:** One complete cycle through all players. A round ends when every player has had their turn (or passes/is skipped).

**In Code:** Implemented via `eachPlayer` or `loop` with player iteration
**Related Terms:** Turn, Phase, Flow, Player
**Usage:**
- "Each round consists of one turn per player"
- "The game lasts 10 rounds"

### Turn

**Definition:** A player's opportunity to take one or more actions. During their turn, a player makes decisions and affects game state.

**In Code:** `actionStep({ actions: [...] })` in flow
**Related Terms:** Action, Active Player, Round, Flow
**Usage:**
- "On your turn, you must play a card"
- "End your turn by clicking 'Done'"

### Flow

**Definition:** The complete structure of game progression, defining the sequence of phases, turns, and actions from start to finish.

**In Code:** `FlowDefinition` with `root` node; set via `game.setFlow()`
**Related Terms:** Phase, Turn, Action, Rules
**Usage:**
- "The flow defines turn order and phase sequence"
- "Create the flow in a separate function for clarity"

### Action

**Definition:** Something a player can do during the game. Actions have a prompt, optional selections (picks), conditions, and an execute function.

**In Code:** `Action.create('name').prompt(...).execute(...)`
**Related Terms:** Pick, Execute, Condition, Turn, Command
**Usage:**
- "The 'draw' action lets players take a card from the deck"
- "Register all actions in the game constructor"

---

## Elements

The building blocks that compose game state.

### Element

**Definition:** The base unit in the game tree hierarchy. All game objects (pieces, spaces, cards) are elements. Elements form a parent-child tree with the Game at the root.

**In Code:** `GameElement` base class; never instantiate directly
**Related Terms:** Piece, Space, Card, Die
**Usage:**
- "Every element has a unique ID"
- "Query elements with game.all(ElementClass)"

### Piece

**Definition:** A movable game element that players interact with directly. Pieces can be moved between spaces and typically represent physical game components.

**In Code:** `Piece` class; extend for custom pieces
**Related Terms:** Element, Card, Die, Space, Owner
**Usage:**
- "Move the piece to an empty cell"
- "Each player has 4 pieces of their color"

### Space

**Definition:** A container element that holds other elements. Spaces provide organization and can have visibility rules. All zones, decks, and hands are spaces.

**In Code:** `Space` class; base for `Deck`, `Hand`, `Grid`, `HexGrid`
**Related Terms:** Zone, Deck, Hand, Grid, Piece
**Usage:**
- "The discard pile is a space that holds played cards"
- "Check if the space is empty before placing"

### Card

**Definition:** A specialized piece with card-game properties: rank, suit, and face-up/face-down state. Cards are the primary element for card games.

**In Code:** `Card` class with `rank`, `suit`, `faceUp` properties
**Related Terms:** Piece, Deck, Hand, Element
**Usage:**
- "Draw the top card from the deck"
- "Flip the card face-up to reveal it"

### Die

**Definition:** A specialized piece representing a rollable die with a current value. Dice are used for random outcomes in games.

**In Code:** `Die` class with `value` and `roll()` method
**Related Terms:** Piece, DicePool, Element
**Usage:**
- "Roll the die and move that many spaces"
- "The die shows a value of 4"

---

## Zones and Spaces

Specialized containers for game elements.

### Deck

**Definition:** A space designed for stacked cards, typically hidden from view. Decks support shuffling and drawing from top/bottom.

**In Code:** `Deck` class with `shuffle()`, `draw()` methods
**Related Terms:** Space, Card, Hand, Zone
**Usage:**
- "Shuffle the deck before dealing"
- "Draw from the top of the deck"

### Hand

**Definition:** A player's private space for holding cards or pieces. Contents are typically only visible to the owning player.

**In Code:** `Hand` class; set `player` property and use `contentsVisibleToOwner()`
**Related Terms:** Space, Player, Owner, Card, Visibility
**Usage:**
- "Add the drawn card to your hand"
- "Your hand is hidden from other players"

### Grid

**Definition:** A space organized as a rectangular grid with rows and columns. Cells can be accessed by coordinates or notation.

**In Code:** `Grid` class with row/column access
**Related Terms:** Space, HexGrid, Board, Cell
**Usage:**
- "Place your piece on any empty grid cell"
- "The grid is 8 rows by 8 columns"

### HexGrid

**Definition:** A space organized as a hexagonal grid. Cells are addressed using axial coordinates (q, r) and support hex-specific operations.

**In Code:** `HexGrid` class with axial coordinate methods
**Related Terms:** Space, Grid, Board, Cell
**Usage:**
- "Click any hex to place a stone"
- "Hexes have 6 neighbors instead of 4"

### DicePool

**Definition:** A space specifically designed to contain dice. Used for games where dice are rolled as a group or managed together.

**In Code:** `DicePool` class
**Related Terms:** Space, Die, Zone
**Usage:**
- "Roll all dice in the pool"
- "Select dice from the pool to keep"

---

## Actions and Selections

Terms for player decisions and their execution.

### Pick

**Definition:** A choice that a player must make to complete an action. Picks can select from a list, choose an element, or enter a value.

**In Code:** Selection methods: `chooseFrom()`, `chooseElement()`, `fromElements()`, `enterNumber()`
**Related Terms:** Action, Choice, Execute, Condition
**Usage:**
- "Pick a card to discard"
- "The action requires two picks: source and destination"

**Note:** Replaces "selection" in user-facing communication in v2.3.

### Choice

**Definition:** A pick from a predefined list of options. Choices present named options for the player to select from.

**In Code:** `chooseFrom<T>('name', { choices: [...] })`
**Related Terms:** Pick, Action, Execute
**Usage:**
- "Choose a color: Red, Blue, or Green"
- "The choice determines which path you take"

### Execute

**Definition:** The function that runs when an action completes all its picks. Execute performs the actual game state changes.

**In Code:** `.execute((args, ctx) => { ... })` on actions
**Related Terms:** Action, Pick, Command
**Usage:**
- "Execute moves the piece and updates the score"
- "The execute function receives all pick values"

### Condition

**Definition:** A prerequisite that must be true for an action to be available. Conditions filter which actions appear in the action panel.

**In Code:** `.condition({ 'label': (ctx) => boolean })`
**Related Terms:** Action, Pick, Flow
**Usage:**
- "The 'buy' action has a condition: player must have enough gold"
- "Actions with failed conditions are hidden"

### Command

**Definition:** A low-level, generic state mutation. Commands are automatically generated when you call element methods like `putInto()` or `shuffle()`.

**In Code:** Internal; `MoveCommand`, `ShuffleCommand`, `SetAttributeCommand`, etc.
**Related Terms:** Action, Execute, Element
**Usage:**
- "Calling card.putInto(hand) generates a MoveCommand"
- "Commands enable undo/redo and replay"

---

## UI Components

Terms for the user interface layer.

### GameShell

**Definition:** The top-level UI wrapper component that provides the complete game structure: header, player panels, game area, action panel, and history.

**In Code:** `GameShell` Vue component from `boardsmith/ui`
**Related Terms:** GameTable, ActionPanel, AutoUI
**Usage:**
- "Wrap your game in GameShell for standard layout"
- "GameShell provides slot props for customization"

### GameTable

**Definition:** The custom game visualization component that renders the game board and interactive elements. Receives game state and action controller via props.

**In Code:** Custom Vue component in `#game-board` slot
**Related Terms:** GameShell, Table, Board, AutoUI
**Usage:**
- "Implement GameTable for custom game visuals"
- "GameTable receives gameView, actionController, and other props"

**Note:** Replaces "GameBoard" component naming in v2.3. The conceptual "table" is the play area, and "GameTable" is the component that renders it.

### ActionPanel

**Definition:** The UI component that displays available actions and handles player selections. Shows buttons, dropdowns, and selection prompts.

**In Code:** `ActionPanel` Vue component (built into GameShell)
**Related Terms:** Action, Pick, GameShell
**Usage:**
- "The action panel shows 'Draw' and 'Play' buttons"
- "Selections appear in the action panel"

### AutoUI

**Definition:** Auto-generated game interface that renders any game without custom UI code. Useful for prototyping and as a reference implementation.

**In Code:** `AutoUI` Vue component from `boardsmith/ui`
**Related Terms:** GameShell, GameTable, Element
**Usage:**
- "Use AutoUI to test rules before building custom UI"
- "AutoUI displays the element tree automatically"

---

## Related Documentation

- [Core Concepts](./core-concepts.md) - Detailed explanation of the element tree and game architecture
- [Actions & Flow](./actions-and-flow.md) - How to define actions and structure game flow
- [UI Components](./ui-components.md) - Building custom game interfaces
- [Game Examples](./game-examples.md) - Real game implementations demonstrating these concepts
````

## File: docs/README.md
````markdown
# BoardSmith Documentation

This folder contains documentation for the BoardSmith game framework.

## Documents

| Document | Description |
|----------|-------------|
| [Getting Started](./getting-started.md) | CLI setup, project creation, and basic development |
| [Core Concepts](./core-concepts.md) | Element tree, visibility, actions vs commands |
| [Actions & Flow](./actions-and-flow.md) | Action builder API and declarative flow system |
| [Dice & Scoring](./dice-and-scoring.md) | Dice elements, 3D rendering, abilities, and scoring tracks |
| [UI Components](./ui-components.md) | Vue components and composables |
| [AI System](./ai-system.md) | MCTS bot and AI integration |
| [Game Examples](./game-examples.md) | Analysis of example games with patterns |
| [LLM Overview](./llm-overview.md) | Quick-reference for LLMs |

## For LLMs

If you're an AI assistant reading this codebase:

1. **Start with** [`llm-overview.md`](./llm-overview.md) for a comprehensive summary
2. **Simplest example**: `packages/games/hex/` - minimal but complete game
3. **Complex example**: `packages/games/cribbage/` - multi-phase, simultaneous actions

## Generated LLM Context

The repository includes a `repomix.config.json` that generates `llms.txt` - a single file containing the entire relevant codebase optimized for LLM consumption.

To regenerate:
```bash
npx repomix
```

This produces a ~750KB file with:
- All documentation
- Core engine code
- Example game implementations
- CLI tools
- Excludes tests, type declarations, and node_modules

## Quick Links

- **CLI**: `boardsmith init`, `boardsmith dev`, `boardsmith test`
- **Key packages**: `boardsmith`, `boardsmith/ui`, `boardsmith/ai`
- **Example games**: `packages/games/{hex, go-fish, checkers, cribbage}`
````

## File: docs/component-showcase.md
````markdown
# Component Showcase

This document provides visual examples and code snippets for key BoardSmith UI components.

## GameShell

The main wrapper component that provides complete game UI structure.

```vue
<template>
  <GameShell
    game-type="my-game"
    display-name="My Game"
    :player-count="2"
  >
    <template #game-board="{ gameView, actionController, isMyTurn }">
      <MyGameTable
        :game-view="gameView"
        :action-controller="actionController"
        :is-my-turn="isMyTurn"
      />
    </template>
  </GameShell>
</template>
```

**What it provides:**
- Header with game title and player indicator
- Player panels showing names, scores, turn state
- Central game board area (your custom content)
- Action panel for selections
- Undo button (when available)
- WebSocket connection management

## ActionPanel

Auto-generated action UI from game metadata.

```
┌─────────────────────────────────────────┐
│  Your Turn                              │
├─────────────────────────────────────────┤
│  ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │  Draw   │ │  Play   │ │  Pass   │   │
│  └─────────┘ └─────────┘ └─────────┘   │
├─────────────────────────────────────────┤
│  Select a card to play:                 │
│  ┌────┐ ┌────┐ ┌────┐ ┌────┐          │
│  │ A♠ │ │ K♥ │ │ Q♦ │ │ J♣ │          │
│  └────┘ └────┘ └────┘ └────┘          │
├─────────────────────────────────────────┤
│  [ Cancel ]              [ Confirm ]    │
└─────────────────────────────────────────┘
```

**Features:**
- Action buttons for available actions
- Selection UI (cards, choices, numbers, text)
- Wizard mode for multi-step actions
- Optional selection skip button
- Board highlighting integration

## Die3D

3D dice with physics-based rolling animation.

```vue
<template>
  <Die3D
    v-for="die in dice"
    :key="die.id"
    :die-id="die.id"
    :value="die.attributes.value"
    :roll-count="die.attributes.rollCount"
    :sides="die.attributes.sides"
    :size="60"
  />
</template>

<script setup>
// Dice come from gameView in a real game
const dice = computed(() => {
  const pool = props.gameView?.children?.find(c => c.className === 'DicePool');
  return pool?.children?.filter(c => c.className === 'Die') || [];
});
</script>
```

**Props:**
- `dieId` - Unique identifier for animation tracking
- `value` - Current face value (1-indexed by default)
- `rollCount` - Increment to trigger roll animation
- `sides` - Die type: 4, 6, 8, 10, 12, or 20
- `size` - Size in pixels (default: 60)
- `color` - Custom die color (optional)

**Note:** Use `die.roll()` in game logic to roll dice. This increments `rollCount` automatically, triggering the animation.

**Supported die types:** d4, d6, d8, d10, d12, d20

## AutoUI

Automatic UI generation for prototyping.

```vue
<template>
  <AutoUI
    :game-view="gameView"
    :player-position="playerPosition"
    :flow-state="flowState"
  />
</template>
```

Renders the entire game state as a tree of elements. Useful for:
- Rapid prototyping
- Debugging game state
- Reference implementation

## Card Animations

### Flying Cards

```vue
<script setup>
import { useFlyingCards, FlyingCardsOverlay } from 'boardsmith/ui';

const { flyingCards, flyCard } = useFlyingCards();

async function dealCard() {
  await flyCard({
    startRect: deckRef.value.getBoundingClientRect(),
    endRect: () => handRef.value.getBoundingClientRect(),
    cardData: { rank: 'A', suit: 'S' },
    flip: true,
    duration: 400,
  });
}
</script>

<template>
  <FlyingCardsOverlay :flying-cards="flyingCards" />
</template>
```

### Auto Animations

```vue
<script setup>
import { useAutoAnimations, FlyingCardsOverlay } from 'boardsmith/ui';

const { flyingElements } = useAutoAnimations({
  gameView: () => props.gameView,
  containers: [
    { element: deck, ref: deckRef },
    { element: hand, ref: handRef },
    { element: discard, ref: discardRef },
  ],
  getElementData: (el) => ({
    rank: el.attributes?.rank,
    suit: el.attributes?.suit,
  }),
});
</script>
```

Automatically animates elements when they move between containers.

## Board Interaction

Bidirectional interaction between board and action panel.

```vue
<script setup>
import { useBoardInteraction } from 'boardsmith/ui';

const boardInteraction = useBoardInteraction();

// In template:
// :class="{
//   'highlighted': boardInteraction?.isHighlighted(element),
//   'selected': boardInteraction?.isSelected(element),
//   'selectable': boardInteraction?.isSelectableElement(element),
// }"
</script>
```

## Grid Utilities

### Square Grid (Chess-style)

```typescript
import { toAlgebraicNotation, fromAlgebraicNotation } from 'boardsmith/ui';

toAlgebraicNotation(0, 0);    // "a1"
toAlgebraicNotation(4, 3);    // "e4"
fromAlgebraicNotation('e4');  // { col: 4, row: 3 }
```

### Hex Grid

```typescript
import { hexToPixel, getHexPolygonPoints } from 'boardsmith/ui';

const { x, y } = hexToPixel(q, r, size, 'flat');
const points = getHexPolygonPoints(cx, cy, size, 'flat');
```

## Card Display

```typescript
import { getSuitSymbol, getSuitColor, isRedSuit } from 'boardsmith/ui';

getSuitSymbol('H');  // "♥"
getSuitSymbol('S');  // "♠"
getSuitColor('H');   // "#e74c3c" (red)
isRedSuit('D');      // true
```

## Theming

```typescript
import { applyTheme } from 'boardsmith/ui';

applyTheme({
  primary: '#00d9ff',
  secondary: '#00ff88',
  background: '#1a1a2e',
  surface: '#16213e',
  text: '#ffffff',
  error: '#e74c3c',
});
```

## Future: Interactive Storybook

For fully interactive component exploration, we recommend setting up Storybook:

```bash
npx storybook@latest init --type vue3-vite
```

This would provide:
- Live component playground
- Props documentation
- Visual regression testing
- Accessibility checks

See [Storybook for Vue](https://storybook.js.org/docs/vue/get-started/introduction) for setup instructions.

## See Also

- [UI Components](./ui-components.md) - Full API reference
- [Architecture](./architecture.md) - Package relationships
- [Common Patterns](./common-patterns.md) - Game implementation patterns
````

## File: docs/getting-started.md
````markdown
# Getting Started with BoardSmith

BoardSmith is a TypeScript framework for building turn-based board and card games with built-in multiplayer support, AI opponents, and automatic UI generation.

## Prerequisites

- Node.js 20+
- npm, pnpm, or yarn

## Quick Start

### 1. Create a New Game Project

```bash
npx boardsmith init my-game
cd my-game
npm install
```

This creates a new game project with the following structure:

```
my-game/
├── boardsmith.json          # Game configuration
├── package.json             # Dependencies
├── tsconfig.json            # TypeScript config
├── vite.config.ts           # Vite bundler config
├── index.html               # Entry HTML
├── public/                  # Static assets
├── src/
│   ├── main.ts              # App entry point
│   ├── rules/               # Game logic
│   │   ├── game.ts          # Main Game class
│   │   ├── elements.ts      # Custom element classes
│   │   ├── actions.ts       # Player action definitions
│   │   ├── flow.ts          # Game flow definition
│   │   └── index.ts         # Exports
│   └── ui/                  # Vue UI components
│       ├── App.vue          # Main app component
│       ├── components/      # Custom components
│       │   └── GameTable.vue
│       └── index.ts         # UI exports
└── tests/
    └── game.test.ts         # Game tests
```

### 2. Start Development Server

```bash
boardsmith dev
```

This starts:
- A Vite dev server on port 5173 (UI)
- A game server on port 8787 (API/WebSocket)
- Automatically opens browser tabs for each player

#### Dev Server Options

```bash
# Specify number of players
boardsmith dev --players 3

# Add AI opponents
boardsmith dev --ai 1              # Player 1 is AI
boardsmith dev --ai 0 2            # Players 0 and 2 are AI

# Set AI difficulty
boardsmith dev --ai 1 --ai-level hard    # easy, medium, hard, expert

# Custom ports
boardsmith dev --port 3000 --worker-port 9000
```

### 3. Run Tests

```bash
boardsmith test           # Run once
boardsmith test --watch   # Watch mode
```

### 4. Validate Before Publishing

```bash
boardsmith validate
```

This runs:
- TypeScript compilation checks
- Configuration validation
- Random game simulation to detect infinite loops or game-ending bugs

### 5. Build for Production

```bash
boardsmith build
```

### 6. Publish to boardsmith.io

```bash
boardsmith publish
```

## Understanding the Generated Code

### Game Configuration (boardsmith.json)

```json
{
  "$schema": "https://boardsmith.io/schemas/game.json",
  "name": "my-game",
  "displayName": "My Game",
  "description": "A fun game for 2-4 players",
  "playerCount": { "min": 2, "max": 4 },
  "estimatedDuration": "15-30 minutes",
  "complexity": 2,
  "categories": ["card-game"],
  "thumbnail": "./public/thumbnail.png",
  "scoreboard": { "stats": ["score"] }
}
```

### Game Class (src/rules/game.ts)

The Game class is the heart of your game. It:
- Extends `Game<YourGame, YourPlayer>`
- Registers element classes
- Creates the initial game state (deck, board, etc.)
- Registers actions players can take
- Defines the game flow

```typescript
export class MyGame extends Game<MyGame, MyPlayer> {
  deck!: Deck;

  constructor(options: MyGameOptions) {
    super(options);

    // Register element classes (required for serialization)
    this.registerElements([Card, Hand, Deck]);

    // Create game elements
    this.deck = this.create(Deck, 'deck');

    // Set up initial state
    this.deck.shuffle();
    for (const player of this.players) {
      // Deal cards...
    }

    // Register player actions
    this.registerAction(createDrawAction(this));
    this.registerAction(createPlayAction(this));

    // Set up game flow
    this.setFlow(createGameFlow(this));
  }

  override isFinished(): boolean {
    return this.deck.count(Card) === 0;
  }

  override getWinners(): MyPlayer[] {
    // Return winning player(s)
  }
}
```

### Element Classes (src/rules/elements.ts)

Elements are the building blocks of your game state. BoardSmith provides base classes:

- **Space** - Containers that hold other elements
  - **Deck** - Stackable card pile (can shuffle)
  - **Hand** - Player's private cards
  - **Grid** - Square grid (e.g., chess board)
  - **HexGrid** - Hexagonal grid
- **Piece** - Physical game pieces
- **Card** - Playing cards

```typescript
import { Card as BaseCard, Hand as BaseHand, Deck as BaseDeck } from 'boardsmith';

export type Suit = 'H' | 'D' | 'C' | 'S';
export type Rank = 'A' | '2' | '3' | ... | 'K';

export class Card extends BaseCard {
  suit!: Suit;
  rank!: Rank;
}

export class Hand extends BaseHand {}
export class Deck extends BaseDeck {}
```

### Actions (src/rules/actions.ts)

Actions define what players can do. Use the fluent builder API:

```typescript
import { Action, type ActionDefinition } from 'boardsmith';

export function createPlayAction(game: MyGame): ActionDefinition {
  return Action.create('play')
    .prompt('Play a card from your hand')
    .chooseFrom<Card>('card', {
      prompt: 'Select a card to play',
      choices: (ctx) => [...ctx.player.hand.all(Card)],
    })
    .execute((args, ctx) => {
      const card = args.card as Card;
      card.remove();
      ctx.player.score += 1;
      return { success: true };
    });
}
```

### Flow (src/rules/flow.ts)

The flow defines turn structure and game phases:

```typescript
import { loop, eachPlayer, actionStep, sequence, type FlowDefinition } from 'boardsmith';

export function createGameFlow(game: MyGame): FlowDefinition {
  return {
    root: loop({
      name: 'game-loop',
      while: () => !game.isFinished(),
      do: eachPlayer({
        name: 'player-turns',
        do: sequence(
          actionStep({ actions: ['draw'] }),
          actionStep({ actions: ['play'] }),
        ),
      }),
    }),
    isComplete: () => game.isFinished(),
    getWinners: () => game.getWinners(),
  };
}
```

### UI (src/ui/App.vue)

The UI uses Vue 3 and the `boardsmith/ui` package:

```vue
<template>
  <GameShell
    game-type="my-game"
    display-name="My Game"
    :player-count="2"
  >
    <template #game-board="{
      gameView,
      playerPosition,
      isMyTurn,
      availableActions,
      actionArgs,
      actionController,
      setBoardPrompt
    }">
      <GameTable
        :game-view="gameView"
        :player-position="playerPosition"
        :is-my-turn="isMyTurn"
        :available-actions="availableActions"
        :action-args="actionArgs"
        :action-controller="actionController"
        :set-board-prompt="setBoardPrompt"
      />
    </template>
  </GameShell>
</template>
```

The `actionController` is the recommended way to handle actions from custom UIs. See [UI Components](./ui-components.md#action-controller-api) for the full API.

## Important: Read Before You Start

Before diving into implementation, read [Common Pitfalls](./common-pitfalls.md) to avoid these critical issues:

1. **Object Reference Comparison** - Never use `.includes(element)` or `===` to compare elements. Always use `.some(e => e.id === element.id)` or `element.equals(other)`.

2. **Multi-Step Selection Filters** - When action B depends on selection A, handle `undefined` in your filter for availability checks.

3. **Dead Elements in Collections** - Element queries return all elements including "dead" ones. Filter explicitly with `.filter(e => !e.isDead)`.

These issues cause silent failures that are hard to debug. Five minutes reading the pitfalls guide will save hours of debugging.

## Next Steps

- **Start here**: [Common Pitfalls](./common-pitfalls.md) - Critical issues to avoid
- Read [Core Concepts](./core-concepts.md) to understand elements, actions, and commands
- Learn about [Actions & Flow](./actions-and-flow.md) for complex game logic
- Explore [UI Components](./ui-components.md) for building custom UIs
- See [Game Examples](./game-examples.md) for real implementations

## Example Games

BoardSmith includes several example games in `packages/games/`:

| Game | Complexity | Key Features |
|------|-----------|--------------|
| **Hex** | Simple | Hex grid, path-finding win condition |
| **Go Fish** | Medium | Cards, hidden information, player interaction |
| **Checkers** | Medium | Square grid, multi-step moves, piece promotion |
| **Cribbage** | Complex | Multi-phase flow, simultaneous actions, scoring |

Study these to learn common patterns and best practices.
````

## File: docs/ui-components.md
````markdown
# UI Components & Composables

BoardSmith provides Vue 3 components and composables for building game UIs. The `boardsmith/ui` package includes everything from high-level shells to low-level animation utilities.

## Core Components

### GameShell

The main wrapper component that provides the complete game UI structure: header, player panels, game board area, action panel, and game history.

```vue
<template>
  <GameShell
    game-type="my-game"
    display-name="My Game"
    :player-count="2"
  >
    <!-- Custom game board -->
    <template #game-board="{
      state,
      gameView,
      playerPosition,
      isMyTurn,
      availableActions,
      actionArgs,
      actionController,
      setBoardPrompt
    }">
      <GameTable
        :game-view="gameView"
        :player-position="playerPosition"
        :is-my-turn="isMyTurn"
        :available-actions="availableActions"
        :action-args="actionArgs"
        :action-controller="actionController"
        :set-board-prompt="setBoardPrompt"
      />
    </template>

    <!-- Custom player stats display -->
    <template #player-stats="{ player, gameView }">
      <div class="player-stat">
        <span class="label">Score:</span>
        <span class="value">{{ player.score }}</span>
      </div>
    </template>
  </GameShell>
</template>

<script setup lang="ts">
import { GameShell } from 'boardsmith/ui';
import GameTable from './components/GameTable.vue';
</script>
```

#### Slot Props

The `#game-board` slot receives:

| Prop | Type | Description |
|------|------|-------------|
| `state` | `GameState` | Full game state |
| `gameView` | `object` | Player-filtered view of game state |
| `playerPosition` | `number` | Current player's position |
| `isMyTurn` | `boolean` | Whether it's this player's turn |
| `availableActions` | `string[]` | Actions available to the player |
| `actionArgs` | `object` | Current action selections - **read-only for display**, use `actionController` methods to modify |
| `actionController` | `UseActionControllerReturn` | Unified action handling - execute, start, fill, cancel actions |
| `setBoardPrompt` | `function` | Set a prompt message: `(text) => void` |
| `canUndo` | `boolean` | Whether undo is available |
| `undo` | `function` | Undo to turn start: `() => Promise` |

#### Action State (actionArgs)

The `actionArgs` object contains the current action's selection values. **Use it for reading/display only** - all modifications should go through `actionController` methods.

**Reading actionArgs (safe)**
```vue
<template>
  <div
    v-for="card in cards"
    :key="card.id"
    class="card"
    :class="{ selected: actionArgs.card === card.id }"
  >
    <!-- Card shows selected state from ActionPanel selections -->
  </div>
</template>
```

**Modifying selections (use actionController)**
```typescript
// Starting an action with pre-filled values
actionController.start('move', { args: { piece: pieceId } });

// Filling a selection during an action
actionController.fill('destination', squareId);

// DON'T write directly to actionArgs - use fill() instead
// actionArgs.destination = squareId;  // Wrong!
```

**Why not write directly?**

The controller tracks which values it has set. When fetching choices from the server, it only sends values it knows about. Direct writes to `actionArgs` are ignored by the controller, preventing race conditions during async operations like `followUp` chains.

If you write to `actionArgs` directly, you'll see a development warning:
```
Detected unexpected keys in actionArgs during 'collectEquipment': equipment
  These were NOT set by the action controller (start/fill/startFollowUp).
  This usually means your custom UI is writing to actionArgs in a watcher/computed.
  The controller ignores these to prevent bugs - use actionController.fill() instead.
```

**Board interactions pattern**
```vue
<script setup lang="ts">
const props = defineProps<{
  actionArgs: Record<string, unknown>;
  actionController: UseActionControllerReturn;
}>();

// When user clicks a piece, start the action with that piece pre-selected
function onPieceClick(pieceId: number) {
  props.actionController.start('move', { args: { piece: pieceId } });
}

// When user clicks a destination during an active action
function onSquareClick(squareId: number) {
  if (props.actionController.currentAction.value === 'move') {
    props.actionController.fill('destination', squareId);
  }
}
</script>
```

### AutoUI

Automatic UI generation from game state. Useful for prototyping or as a reference implementation.

```vue
<template>
  <AutoUI
    :game-view="gameView"
    :player-position="playerPosition"
    :flow-state="flowState"
  />
</template>

<script setup lang="ts">
import { AutoUI } from 'boardsmith/ui';
</script>
```

The auto-generated UI includes:
- **AutoGameBoard**: Renders the game element tree
- **AutoElement**: Renders individual elements based on type
- **ActionPanel**: Displays available actions with selection UI

### DebugPanel

Development tool for inspecting game state, history, and debugging.

```vue
<template>
  <DebugPanel
    :state="state"
    :game-view="gameView"
    :action-history="actionHistory"
  />
</template>
```

## Lobby Components

BoardSmith provides a complete lobby system for configuring games before they start. The lobby dynamically renders controls based on game definition metadata.

### GameLobby

The main lobby component that fetches game definition metadata and renders configuration UI.

```vue
<template>
  <GameLobby
    :game-type="gameType"
    :player-count="playerCount"
    @create="handleCreate"
  />
</template>

<script setup lang="ts">
import { GameLobby } from 'boardsmith/ui';

const gameType = 'hex';
const playerCount = 2;

function handleCreate(config: { gameOptions: Record<string, unknown>; playerConfigs: PlayerConfig[] }) {
  // Create game with the configured options
}
</script>
```

The lobby automatically:
- Fetches game definition from `/games/definitions` endpoint
- Renders game options (number inputs, selects, toggles)
- Renders per-player configuration (name, AI toggle, color picker)
- Shows preset cards for quick setup
- Validates player count against game limits

### GameOptionsForm

Dynamic form that renders game-level options from metadata.

```vue
<template>
  <GameOptionsForm
    :options="gameDefinition.gameOptions"
    v-model="gameOptions"
  />
</template>
```

Supports three option types:

| Type | Control | Properties |
|------|---------|------------|
| `number` | Number input | `min`, `max`, `step`, `default` |
| `select` | Dropdown | `choices` (array of `{ value, label }`) |
| `boolean` | Toggle switch | `default` |

### PlayerConfigList

Per-player configuration with AI toggle and custom options.

```vue
<template>
  <PlayerConfigList
    :player-count="2"
    :has-ai="true"
    :player-options="gameDefinition.playerOptions"
    v-model="playerConfigs"
  />
</template>
```

Features:
- Player name input
- AI toggle with level selector (when game has AI)
- Dynamic rendering of per-player options (color picker, role select, etc.)
- Shows taken options as disabled with visual indicator
- Exclusive options render as radio buttons (exactly one player can be selected)

### PresetsPanel

Quick-start preset cards for common game configurations.

```vue
<template>
  <PresetsPanel
    :presets="gameDefinition.presets"
    @select="applyPreset"
  />
</template>

<script setup lang="ts">
function applyPreset(preset: GamePreset) {
  // Apply preset.options to gameOptions
  // Apply preset.players to playerConfigs
}
</script>
```

### Standard Color Picker

BoardSmith provides a standard color palette and utilities for player color selection.

```typescript
import {
  STANDARD_PLAYER_COLORS,
  DEFAULT_PLAYER_COLORS,
  createColorOption
} from 'boardsmith/session';

// Standard 8-color palette
STANDARD_PLAYER_COLORS
// [{ value: '#e74c3c', label: 'Red' }, { value: '#3498db', label: 'Blue' }, ...]

// Default 2-player colors (Red, Blue)
DEFAULT_PLAYER_COLORS
// ['#e74c3c', '#3498db']

// Create a color option for game definition
export const gameDefinition = {
  // ...
  playerOptions: {
    color: createColorOption(), // Uses standard colors
  },
};

// Or with custom colors
playerOptions: {
  color: createColorOption([
    { value: '#ff0000', label: 'Fire' },
    { value: '#0000ff', label: 'Ice' },
  ], 'Team Color'),
}
```

The color picker in PlayerConfigList:
- Shows color swatches with labels
- Disables already-selected colors with X overlay
- Automatically applies first available color as default

## Helper Components

### FlyingCardsOverlay

Overlay for card flight animations between positions.

```vue
<template>
  <FlyingCardsOverlay
    :flying-cards="flyingCards"
  />
</template>
```

## Composables

### useBoardInteraction

Bidirectional interaction between action panel and game board.

```typescript
import { useBoardInteraction, createBoardInteraction, provideBoardInteraction } from 'boardsmith/ui';

// In GameShell (provide)
const boardInteraction = createBoardInteraction();
provideBoardInteraction(boardInteraction);

// In GameTable or ActionPanel (inject)
const boardInteraction = useBoardInteraction();

// Check element states
boardInteraction.isHighlighted(element)  // Hovered in action panel
boardInteraction.isSelected(element)     // Currently selected
boardInteraction.isValidTarget(element)  // Valid drop/selection target
boardInteraction.isSelectableElement(element)  // Can be clicked to select

// Trigger selections
boardInteraction.triggerElementSelect(element)

// Drag and drop
boardInteraction.startDrag(element)
boardInteraction.endDrag()
boardInteraction.isDropTarget(element)
boardInteraction.isDraggedElement(element)
```

#### Action State Detection

Custom game boards can detect which action is currently being filled in. This is useful when:
- Showing visual feedback based on the active action
- Displaying on-demand choices (e.g., cards drawn when action clicked)
- Customizing the board based on current selection step

```typescript
import { useBoardInteraction } from 'boardsmith/ui';
import { computed, watch } from 'vue';

const boardInteraction = useBoardInteraction();

// Current action being filled in (null if none)
boardInteraction.currentAction         // string | null

// Which selection step the player is on (0-based)
boardInteraction.currentSelectionIndex // number

// Name of the current selection
boardInteraction.currentSelectionName  // string | null
```

**Example: Detecting when "Hire First MERC" is clicked**

```vue
<script setup lang="ts">
import { computed, watch } from 'vue';
import { useBoardInteraction } from 'boardsmith/ui';

const props = defineProps<{
  gameView: any;
}>();

const boardInteraction = useBoardInteraction();

// Detect when hiring action is active
const isHiringMerc = computed(() =>
  boardInteraction?.currentAction === 'hireFirstMerc'
);

// Get drawn mercs from game settings (stored by on-demand choices callback)
const drawnMercs = computed(() => {
  if (!isHiringMerc.value) return [];

  const ids = props.gameView.settings?._drawnMercsForHiring as number[] | undefined;
  if (!ids?.length) return [];

  // Find the elements by ID in the game view
  return ids.map(id => findElementById(props.gameView, id)).filter(Boolean);
});

// React to action changes
watch(() => boardInteraction?.currentAction, (action, prevAction) => {
  if (action === 'hireFirstMerc') {
    console.log('Player started hiring a MERC');
  }
  if (prevAction === 'hireFirstMerc' && !action) {
    console.log('Hiring action completed or cancelled');
  }
});
</script>

<template>
  <div class="game-board">
    <!-- Show drawn MERC cards when hiring -->
    <div v-if="isHiringMerc && drawnMercs.length" class="hiring-overlay">
      <h3>Choose a MERC to hire:</h3>
      <div class="drawn-mercs">
        <MercCard v-for="merc in drawnMercs" :key="merc.id" :merc="merc" />
      </div>
    </div>
  </div>
</template>
```

> **Note:** Action state is automatically cleared when the action completes, is cancelled, or the turn ends.

### useDragDrop

Composable for drag-and-drop in custom UIs. Call once at setup, get functions that work with any element. ActionPanel automatically orchestrates drag-drop by detecting when drag starts, finding matching actions, and executing on drop.

#### Quick Start (Recommended)

Use the pit-of-success API with the library's CSS for minimal boilerplate:

```vue
<script setup lang="ts">
import { useDragDrop } from 'boardsmith/ui';
import 'boardsmith/ui/animation/drag-drop.css';

const { drag, drop } = useDragDrop();

// Condition function determines when cards can be dragged
const canDragCard = (cardId: number) =>
  currentAction.value === 'moveCard' &&
  currentSelection.value?.name === 'card' &&
  isCardSelectable(cardId);
</script>

<template>
  <!-- Cards: drag with condition -->
  <div
    v-for="card in cards"
    :key="card.id"
    v-bind="drag({ id: card.id }, { when: canDragCard(card.id) }).props"
    :class="drag({ id: card.id }, { when: canDragCard(card.id) }).classes"
  >
    {{ card.name }}
  </div>

  <!-- Zones: always accept drops (when action is active) -->
  <div
    v-for="zone in zones"
    :key="zone.id"
    v-bind="drop({ name: zone.id }).props"
    :class="drop({ name: zone.id }).classes"
  >
    {{ zone.name }}
  </div>
</template>
```

The library CSS provides:
- `.bs-draggable` - cursor: grab, smooth transitions
- `.bs-dragging` - opacity: 0.5, scale(0.95), cursor: grabbing
- `.bs-drop-target` - green highlight with glow

#### Customizing Drag-Drop Styles

Override CSS variables in your game's stylesheet:

```css
:root {
  --bs-draggable-cursor: grab;
  --bs-dragging-opacity: 0.5;
  --bs-dragging-scale: 0.95;
  --bs-drop-target-bg: rgba(236, 72, 153, 0.15);  /* Pink instead of green */
  --bs-drop-target-border-color: rgba(236, 72, 153, 0.6);
  --bs-drop-target-shadow: 0 0 12px rgba(236, 72, 153, 0.4);
}
```

Or use your own class names alongside the library classes:

```css
/* Game-specific styling that extends the library's bs-* classes */
.card.bs-draggable {
  border-color: rgba(236, 72, 153, 0.6);
  animation: pulse-drag 1.5s ease-in-out infinite;
}

.zone.bs-drop-target {
  background: rgba(236, 72, 153, 0.15);
}
```

#### API Reference

| Function | Signature | Description |
|----------|-----------|-------------|
| `drag` | `(ref, options?) => { props, classes }` | **Recommended.** Combined helper for draggable elements |
| `drop` | `(ref) => { props, classes }` | **Recommended.** Combined helper for drop targets |
| `dragClasses` | `(ref, options?) => DragClasses` | Just the CSS classes for draggable elements |
| `dropClasses` | `(ref) => DropClasses` | Just the CSS classes for drop targets |
| `dragProps` | `(ref) => DragProps` | Low-level: just the drag props |
| `dropProps` | `(ref) => DropProps` | Low-level: just the drop props |
| `isDragging` | `(ref) => boolean` | Check if element is being dragged |
| `isDropTarget` | `(ref) => boolean` | Check if element is valid drop target |

**DragDropCondition:**
- `when?: boolean | (() => boolean)` - Condition for enabling drag. When false, props are empty and `.bs-draggable` is not applied.

**ElementRef:**
- Can include `id`, `name`, or `notation` to identify the element.

#### Migration from Verbose Pattern

**Before (verbose):**
```vue
<script setup>
const { dragProps, dropProps, isDragging, isDropTarget } = useDragDrop();

const isDragDropCardSelection = computed(() =>
  currentAction.value === 'moveCard' && currentSelection.value?.name === 'card'
);

function isCardDragging(cardId) { return isDragging({ id: cardId }); }
function isZoneDropTarget(zoneName) { return isDropTarget({ name: zoneName }); }
</script>

<template>
  <div
    v-bind="isDragDropCardSelection && isSelectable(card.id) ? dragProps({ id: card.id }) : {}"
    :class="{
      'is-dragging': isCardDragging(card.id),
      'draggable': isDragDropCardSelection && isSelectable(card.id),
    }"
  />
</template>

<style>
.draggable { cursor: grab; }
.is-dragging { opacity: 0.5; }
.drop-target { background: rgba(0, 255, 136, 0.3); }
</style>
```

**After (pit of success):**
```vue
<script setup>
import 'boardsmith/ui/animation/drag-drop.css';
const { drag, drop } = useDragDrop();

const canDrag = (cardId) =>
  currentAction.value === 'moveCard' &&
  currentSelection.value?.name === 'card' &&
  isSelectable(cardId);
</script>

<template>
  <div
    v-bind="drag({ id: card.id }, { when: canDrag(card.id) }).props"
    :class="drag({ id: card.id }, { when: canDrag(card.id) }).classes"
  />
</template>
```

**Lines reduced:** ~50 -> ~10 (80% reduction)

### Drag-and-Drop in Custom UIs

When building custom game boards with drag-and-drop, use `useDragDrop`. ActionPanel automatically:
1. Detects when drag starts (via `boardInteraction.isDragging`)
2. Finds matching actions for the dragged element
3. Sets up valid drop targets from filtered choices
4. Executes the action when dropped on a valid target

**Example: Assigning Combatants to Squads**

```vue
<script setup lang="ts">
import { useDragDrop } from 'boardsmith/ui';
import 'boardsmith/ui/animation/drag-drop.css';

const props = defineProps<{
  squads: Squad[];
}>();

const { drag, drop } = useDragDrop();

// Drag is always enabled for combatants in this simple example
const canDrag = () => true;
</script>

<template>
  <div class="squad-assignment">
    <div
      v-for="squad in squads"
      :key="squad.id"
      class="squad"
      v-bind="drop({ name: squad.id }).props"
      :class="drop({ name: squad.id }).classes"
    >
      <h3>{{ squad.name }}</h3>
      <div
        v-for="combatant in squad.combatants"
        :key="combatant.id"
        class="combatant"
        v-bind="drag({ name: combatant.name }, { when: canDrag() }).props"
        :class="drag({ name: combatant.name }, { when: canDrag() }).classes"
      >
        {{ combatant.name }}
      </div>
    </div>
  </div>
</template>
```

**Real Examples:**

1. **Demo: Complex UI Interactions** (`packages/games/demoComplexUiInteractions/`)

   A dedicated demo showing this feature with multiple simultaneous actions. The custom GameTable:
   - Shows an action status panel displaying the current action and selection step
   - Changes board color based on active action (blue for Collect, red for Discard, etc.)
   - Highlights cards with action-specific colors
   - Includes a debug panel showing raw `boardInteraction` state

2. **Go Fish** (`packages/games/go-fish/ui/src/components/GoFishBoard.vue`)

   Uses `boardInteraction.currentAction` to:
   - Show an "Asking:" indicator banner when the player clicks the Ask button
   - Display which selection step they're on (choosing player vs choosing rank)
   - Only highlight selectable elements after the action button is clicked (not just when available)

### useElementAnimation

FLIP animations for smooth element movement.

```typescript
import { useElementAnimation } from 'boardsmith/ui';

const { capturePositions, animateToCurrentPositions, cancelAll } = useElementAnimation();

// Before state changes
capturePositions(containerRef.value);

// After state changes (in nextTick or watch)
animateToCurrentPositions(containerRef.value, {
  duration: 300,
  selector: '[data-animatable="true"]',
});
```

Elements must have `data-animatable="true"` and `data-element-id="..."` attributes.

### useFlyingCards

Manually trigger card/element flight animations between positions.

```typescript
import { useFlyingCards, FlyingCardsOverlay } from 'boardsmith/ui';

const { flyingCards, flyCard, flyCards, cancelAll } = useFlyingCards();

// Fly a card from one element to another
await flyCard({
  id: 'draw-animation',
  startRect: deckElement.getBoundingClientRect(),
  endRect: () => handElement.getBoundingClientRect(),  // Function to track moving targets
  cardData: { rank: 'A', suit: 'S', faceUp: false },
  flip: true,           // Flip card during flight
  duration: 400,        // Animation duration in ms
  cardSize: { width: 60, height: 84 },
});

// Fly multiple cards with stagger
await flyCards([
  { id: 'card-1', startRect: deck, endRect: () => hand, cardData: { rank: 'K', suit: 'H' } },
  { id: 'card-2', startRect: deck, endRect: () => hand, cardData: { rank: 'Q', suit: 'H' } },
], 100);  // 100ms stagger between cards

// In template:
// <FlyingCardsOverlay :flying-cards="flyingCards" />
```

### useActionAnimations

Declarative animations triggered by action execution. Captures element positions before actions execute and animates to the new position after the DOM updates. Integrates with `actionController.registerBeforeAutoExecute()`.

**Key Feature: Flip-in-Place Auto-Detection**

When `elementSelector` equals `destinationSelector`, the composable auto-detects a "flip-in-place" animation and configures everything correctly:

```typescript
import { useActionAnimations, FlyingCardsOverlay } from 'boardsmith/ui';

const gameViewRef = ref(null);

const actionAnimations = useActionAnimations({
  gameView: gameViewRef,
  animations: [
    // Movement animation (element moves to a different destination)
    {
      action: 'assignToSquad',
      elementSelection: 'combatantName',
      elementSelector: '[data-combatant="{combatantName}"]',
      destinationSelector: '[data-squad="{targetSquad}"]',
      duration: 500,
    },
    // Flip-in-place (auto-detected: same selector = flip animation)
    {
      action: 'flipCard',
      elementSelection: 'card',
      elementSelector: '[data-card-id="{card}"]',
      destinationSelector: '[data-card-id="{card}"]', // Same = flip-in-place!
      duration: 400,
    },
  ],
});

// Register with actionController (in GameTable setup)
function setupAnimations(actionController, gameView) {
  gameViewRef.value = gameView;
  actionController.registerBeforeAutoExecute(actionAnimations.onBeforeAutoExecute);
}
```

In template:
```vue
<FlyingCardsOverlay :flying-cards="actionAnimations.flyingElements" />
```

**Flip-in-Place Behavior:**

When the composable detects a flip-in-place animation (`elementSelector === destinationSelector`), it automatically:
- Hides the element during animation (prevents "double card" effect)
- Enables 3D flip animation
- Uses instant reveal (no crossfade) to prevent visual artifacts
- Configures internal timing to avoid flash/flicker issues

You don't need to set `hideDestination`, `flip`, or `crossfadeDuration` - they're configured automatically.

**Animation Config Options:**

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `action` | `string` | required | Action name that triggers this animation |
| `elementSelection` | `string` | required | Selection name whose value identifies the element |
| `elementSelector` | `string` | required | CSS selector with `{placeholder}` for action args |
| `destinationSelector` | `string \| function` | required | Where element moves to (same as source = flip-in-place) |
| `duration` | `number` | 400 | Animation duration in ms |
| `elementSize` | `{ width, height }` | 60x84 | Size of flying element |
| `flip` | `boolean` | auto | Enable 3D flip (auto-enabled for flip-in-place) |
| `hideDestination` | `boolean` | auto | Hide destination during animation (auto-enabled for flip-in-place) |
| `getElementData` | `function` | innerHTML | Extract data for rendering flying element |

### useAutoAnimations

**Recommended for all games.** The unified animation system that combines flying between containers, FLIP animations within containers, and flying to player stats. One composable to rule them all.

```typescript
import { useAutoAnimations, FlyingCardsOverlay } from 'boardsmith/ui';

// 1. Create refs for DOM elements
const boardRef = ref<HTMLElement | null>(null);
const handRef = ref<HTMLElement | null>(null);
const discardRef = ref<HTMLElement | null>(null);

// 2. Create computed refs for game elements
const board = computed(() => findElement(gameView, { className: 'Board' }));
const myHand = computed(() => findPlayerHand(gameView, playerPosition));
const discardPile = computed(() => findElement(gameView, { className: 'DiscardPile' }));

// 3. Set up auto-animations
const { flyingElements, isAnimating } = useAutoAnimations({
  gameView: () => props.gameView,
  containers: [
    // Elements reorder within board with FLIP animation
    { element: board, ref: boardRef, flipWithin: '[data-piece-id]' },
    // Cards fly between hand and discard
    { element: myHand, ref: handRef, flipWithin: '[data-card-id]' },
    { element: discardPile, ref: discardRef },
  ],
  // Optional: fly elements to player stats when removed
  flyToStats: [
    {
      stat: 'captured',
      containerRef: boardRef,
      selector: '[data-piece-id]',
      player: (piece) => piece.playerPosition === 0 ? 1 : 0,
    },
  ],
  getElementData: (element) => ({
    rank: element.attributes?.rank,
    suit: element.attributes?.suit,
    playerPosition: element.attributes?.player?.position,
  }),
  duration: 400,
});

// 4. Use in template
// <FlyingCardsOverlay :flying-cards="flyingElements" />
```

**What useAutoAnimations provides:**

1. **Flying between containers** - Elements moving between registered containers animate automatically
2. **FLIP within containers** - Elements reordering within a container animate smoothly (use `flipWithin` option)
3. **Flying to stats** - Elements removed from a container fly to player stat displays

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `gameView` | `() => any` | Function returning current game view |
| `containers` | `ContainerConfig[] \| () => ContainerConfig[]` | Containers to track |
| `flyToStats` | `FlyToStatConfig[]` | Stats to fly elements to when removed |
| `getElementData` | `(element) => FlyingCardData` | Extract display data from game elements |
| `getDOMElementData` | `(el: Element) => Partial<FlyingCardData>` | Extract data from DOM elements (for flyToStats) |
| `duration` | `number` | Animation duration for flying (default: 400ms) |
| `flipDuration` | `number` | Animation duration for FLIP (default: 300ms) |
| `elementSize` | `{ width, height }` | Element dimensions (default: 60x84) |

**Container Config:**

| Property | Type | Description |
|----------|------|-------------|
| `element` | `ComputedRef<any> \| Ref<any>` | Game element for this container |
| `ref` | `Ref<HTMLElement \| null>` | DOM element ref |
| `flipWithin` | `string` | CSS selector for FLIP animations within this container |
| `elementSize` | `{ width, height }` | Optional custom element size |

**FlyToStat Config:**

| Property | Type | Description |
|----------|------|-------------|
| `stat` | `string` | Name of the stat (e.g., 'books', 'captured') |
| `containerRef` | `Ref<HTMLElement \| null>` | Container to track removals from |
| `selector` | `string` | CSS selector to find elements |
| `player` | `number \| ((elementData) => number)` | Target player position |
| `trackCount` | `() => number` | Only fly when this count increases |
| `filter` | `(elementData) => boolean` | Filter which elements fly |

**Example: Checkers with piece captures**

```typescript
const { flyingElements } = useAutoAnimations({
  gameView: () => props.gameView,
  containers: [
    { element: board, ref: boardRef, flipWithin: '[data-piece-id]' },
  ],
  flyToStats: [
    {
      stat: 'captured',
      containerRef: boardRef,
      selector: '[data-piece-id]',
      // Captured pieces fly to the opponent's captured stat
      player: (piece) => piece.playerPosition === 0 ? 1 : 0,
    },
  ],
  getDOMElementData: (el) => ({
    playerPosition: el.classList.contains('player-0') ? 0 : 1,
  }),
  elementSize: { width: 40, height: 40 },
});
```

**Example: Cribbage with card animations**

```typescript
const { flyingElements } = useAutoAnimations({
  gameView: () => props.gameView,
  containers: [
    { element: myHand, ref: handRef, flipWithin: '[data-card-id]' },
    { element: playArea, ref: playAreaRef, flipWithin: '[data-card-id]' },
    { element: crib, ref: cribRef },
    { element: deck, ref: deckRef },
  ],
  getElementData: (el) => ({
    rank: el.attributes?.rank,
    suit: el.attributes?.suit,
    faceImage: el.attributes?.$images?.face,
    backImage: el.attributes?.$images?.back,
  }),
});
```

### useAutoFlyingElements

Automatically animates elements (cards, pieces, tokens) when they move between registered containers. For new code, prefer `useAutoAnimations` which includes FLIP and fly-to-stat features.

```typescript
import { useAutoFlyingElements, FlyingCardsOverlay } from 'boardsmith/ui';

const { flyingElements } = useAutoFlyingElements({
  gameView: () => props.gameView,
  containers: [
    { element: deck, ref: deckRef },
    { element: myHand, ref: handRef },
    { element: discardPile, ref: discardRef },
  ],
  getElementData: (element) => ({
    rank: element.attributes?.rank,
    suit: element.attributes?.suit,
  }),
  duration: 400,
});

// In template:
// <FlyingCardsOverlay :flying-cards="flyingElements" />
```

### useFlyOnAppear

Animate elements flying in when they appear.

```typescript
import { useFlyOnAppear } from 'boardsmith/ui';

const { trackElement, getInitialPosition } = useFlyOnAppear({
  from: 'deck',  // Element ID to fly from
  duration: 400,
});
```

### usePlayerStatAnimation

Animate stat changes and fly elements to player stat displays.

```typescript
import { usePlayerStatAnimation, flyToPlayerStat } from 'boardsmith/ui';

// Fly a card to a player's score display
flyToPlayerStat({
  cardElement: cardEl,
  playerPosition: 0,
  statName: 'score',
  onComplete: () => updateScore(),
});
```

### useGameViewHelpers

Utilities for querying game state.

```typescript
import {
  useGameViewHelpers,
  findElement,
  findElements,
  findPlayerHand,
  getCards,
  getElementOwner,
  isMyElement,
} from 'boardsmith/ui';

// Find specific element
const deck = findElement(gameView, { type: 'deck' });

// Find player's hand
const myHand = findPlayerHand(gameView, playerPosition);

// Get all cards in an element
const cardsInHand = getCards(myHand);

// Check ownership
const owner = getElementOwner(card);
const isMine = isMyElement(card, playerPosition);
```

### useGameGrid

Utilities for square grids (chess notation, etc.).

```typescript
import { useGameGrid, toAlgebraicNotation, fromAlgebraicNotation } from 'boardsmith/ui';

const { getCellAt, getAlgebraic, pixelToCell } = useGameGrid({
  rows: 8,
  cols: 8,
  cellSize: 60,
});

// Convert coordinates
const notation = toAlgebraicNotation(0, 0);  // "a1"
const { col, row } = fromAlgebraicNotation('e4');  // { col: 4, row: 3 }
```

### useHexGrid

Utilities for hexagonal grids.

```typescript
import {
  useHexGrid,
  hexToPixel,
  getHexPolygonPoints,
  calculateHexDistance
} from 'boardsmith/ui';

const {
  hexToPixel,
  pixelToHex,
  getHexCorners,
  getNeighbors
} = useHexGrid({
  size: 30,
  orientation: 'flat',  // or 'pointy'
});

// Convert hex coords to pixel position
const { x, y } = hexToPixel(3, 2, 30, 'flat');

// Get SVG polygon points for a hex cell
const points = getHexPolygonPoints(cx, cy, size, 'flat');

// Calculate distance between hexes
const dist = calculateHexDistance(q1, r1, q2, r2);
```

### useCardDisplay

Card display formatting utilities.

```typescript
import {
  useCardDisplay,
  getSuitSymbol,
  getSuitColor,
  getRankName,
  isRedSuit
} from 'boardsmith/ui';

getSuitSymbol('H');  // "♥"
getSuitSymbol('D');  // "♦"
getSuitSymbol('C');  // "♣"
getSuitSymbol('S');  // "♠"

getSuitColor('H');   // "#e74c3c" (red)
getSuitColor('S');   // "#2c3e50" (black)

getRankName('K');    // "King"
isRedSuit('D');      // true
```

### useElementChangeTracker

Track element position and count changes for animations.

```typescript
import { useElementChangeTracker, useCountTracker } from 'boardsmith/ui';

const { trackElements, getChanges } = useElementChangeTracker();

// Track element movements
trackElements(gameView);
// ... state changes ...
const changes = getChanges(gameView);  // { added, removed, moved }

// Track count changes
const { track, getChange } = useCountTracker();
track('deckCount', deck.children.length);
const delta = getChange('deckCount');  // e.g., -3 (deck lost 3 cards)
```

### useFLIPAnimation

Low-level FLIP (First, Last, Invert, Play) animation utility.

```typescript
import { useFLIPAnimation, createFLIPSnapshot } from 'boardsmith/ui';

const { recordFirst, recordLast, play } = useFLIPAnimation({
  duration: 300,
  easing: 'ease-out',
});

// Before change
recordFirst(elements);

// After change
recordLast(elements);

// Animate
play();
```

## Theming

Customize the UI appearance with themes.

```typescript
import { applyTheme, type ThemeConfig } from 'boardsmith/ui';

const customTheme: ThemeConfig = {
  primary: '#00d9ff',
  secondary: '#00ff88',
  background: '#1a1a2e',
  surface: '#16213e',
  text: '#ffffff',
  textMuted: '#888888',
  error: '#e74c3c',
  success: '#00ff88',
};

applyTheme(customTheme);
```

## Action Controller API

The `actionController` (type: `UseActionControllerReturn`) is the unified interface for executing and managing game actions. It's provided via the `#game-board` slot and handles all action execution, wizard mode navigation, and auto-fill logic.

### Controller Methods

| Method | Signature | Description |
|--------|-----------|-------------|
| `execute` | `(name: string, args?: Record<string, unknown>) => Promise<void>` | Execute an action immediately with provided args |
| `start` | `(name: string, options?: StartOptions) => void` | Start wizard mode for a multi-selection action |
| `fill` | `(name: string, value: unknown) => void` | Fill a specific selection in wizard mode |
| `skip` | `() => void` | Skip an optional selection |
| `cancel` | `() => void` | Cancel wizard mode and clear selections |

**StartOptions:**

| Option | Type | Description |
|--------|------|-------------|
| `args` | `Record<string, unknown>` | Values applied immediately to matching selections |
| `prefill` | `Record<string, unknown>` | Values auto-filled when their selection becomes active |

Use `args` for selections that are already available. Use `prefill` for deferred auto-fill of future selections (e.g., when the first selection determines which options appear in the second).

### Controller State

| Property | Type | Description |
|----------|------|-------------|
| `pendingAction` | `string \| null` | Name of action currently in wizard mode |
| `currentSelection` | `SelectionMetadata \| null` | Metadata for the current selection step |
| `validElements` | `ComputedRef<ValidElement[]>` | **Reactive** list of valid elements for current selection |
| `isExecuting` | `boolean` | Whether an action is currently executing |
| `error` | `string \| null` | Error message from last failed execution |

### Element Selections with validElements

When building custom UIs for element selections (`fromElements`, `chooseElement`), use the **reactive `validElements` computed** instead of `getValidElements()`. This computed automatically updates when:
- The current selection changes
- Choices are fetched from the server
- The gameView updates

```typescript
const { validElements, currentSelection } = props.actionController;

// Use the reactive computed directly - it updates automatically!
const selectableCards = computed(() => {
  if (currentSelection.value?.type !== 'element') return [];

  return validElements.value.map(ve => ({
    id: ve.id,
    name: ve.display,
    // Full element data is included:
    image: ve.element?.attributes?.image,
    description: ve.element?.attributes?.description,
  }));
});
```

Each `ValidElement` includes:

| Property | Type | Description |
|----------|------|-------------|
| `id` | `number` | Element ID (for submitting selection) |
| `display` | `string?` | Display text for UI |
| `ref` | `{ id: number }?` | Reference for board highlighting |
| `element` | `GameElement?` | Full element with all attributes |

**Why not `getValidElements()`?** Maps aren't reactive in Vue, so `getValidElements()` won't trigger re-renders when choices load. The `validElements` computed has built-in reactivity tracking.

See [Element Enrichment](./element-enrichment.md) for full documentation.

### Usage Patterns

**Direct execution (single-step actions):**
```typescript
// Execute an action with all args provided
await actionController.execute('draw', { count: 3 });

// Execute an action that requires no selections
await actionController.execute('endTurn');
```

**Wizard mode (multi-step actions):**
```typescript
// Start wizard mode - ActionPanel shows selection UI
actionController.start('move');

// Pre-fill the first selection immediately
actionController.start('move', { args: { piece: pieceId } });

// Prefill a future selection (auto-filled when that step becomes active)
actionController.start('move', {
  args: { piece: pieceId },
  prefill: { destination: targetCellId }  // Applied when 'destination' selection activates
});

// Custom boards can fill selections programmatically
actionController.fill('destination', cellId);

// Skip optional selections
actionController.skip();

// Cancel and clear
actionController.cancel();
```

**Reading controller state:**
```typescript
// Check if an action is in progress
if (actionController.pendingAction === 'move') {
  // Show move-specific UI
}

// Show loading state during execution
<button :disabled="actionController.isExecuting">
  {{ actionController.isExecuting ? 'Working...' : 'Execute' }}
</button>

// Display errors
<div v-if="actionController.error" class="error">
  {{ actionController.error }}
</div>
```

## Error Handling in UI

The `actionController` provides error state that your UI should handle gracefully.

### Displaying Action Errors

```vue
<template>
  <div class="game-board">
    <!-- Error toast/banner -->
    <Transition name="fade">
      <div v-if="actionController.error" class="error-banner">
        {{ actionController.error }}
        <button @click="dismissError">×</button>
      </div>
    </Transition>

    <!-- Game content -->
    <GameTable ... />
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  actionController: UseActionControllerReturn;
}>();

// Error auto-dismisses after 5 seconds
watch(() => props.actionController.error, (error) => {
  if (error) {
    setTimeout(() => {
      // Error clears automatically on next successful action
      // Or clear manually if your UI needs it
    }, 5000);
  }
});
</script>

<style>
.error-banner {
  position: fixed;
  top: 1rem;
  left: 50%;
  transform: translateX(-50%);
  background: #e74c3c;
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 4px;
  z-index: 1000;
}
</style>
```

### Loading States During Execution

Show feedback while actions are processing:

```vue
<template>
  <!-- Disable board interactions while executing -->
  <div
    class="game-board"
    :class="{ 'is-loading': actionController.isExecuting }"
  >
    <!-- Loading overlay -->
    <div v-if="actionController.isExecuting" class="loading-overlay">
      <span class="spinner" />
    </div>

    <!-- Action buttons -->
    <button
      v-for="action in availableActions"
      :key="action"
      :disabled="actionController.isExecuting"
      @click="executeAction(action)"
    >
      {{ actionController.isExecuting ? 'Working...' : action }}
    </button>
  </div>
</template>

<style>
.game-board.is-loading {
  pointer-events: none;
  opacity: 0.7;
}

.loading-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.3);
}
</style>
```

### Handling Specific Error Types

Common error messages and how to handle them:

```typescript
async function handleAction(name: string, args: Record<string, unknown>) {
  try {
    await actionController.execute(name, args);
  } catch (e) {
    // actionController.error is already set, but you may want custom handling
  }

  // Check error after execution
  const error = actionController.error;
  if (error) {
    switch (true) {
      case error.includes('Not your turn'):
        // UI should already prevent this, but handle gracefully
        showToast('Please wait for your turn');
        break;

      case error.includes('not available'):
        // Action became unavailable (opponent moved, etc.)
        showToast('This action is no longer available');
        refreshAvailableActions();
        break;

      case error.includes('Invalid selection'):
        // Selection was rejected by the server
        showToast('Invalid selection - please try again');
        actionController.cancel();
        break;

      default:
        // Generic error display
        showToast(error);
    }
  }
}
```

### Preventing Errors with Validation

Check availability before showing interactive elements:

```vue
<template>
  <!-- Only show clickable cards that are valid selections -->
  <div
    v-for="card in myHand"
    :key="card.id"
    class="card"
    :class="{
      'clickable': isCardPlayable(card),
      'disabled': !isCardPlayable(card),
    }"
    @click="isCardPlayable(card) && playCard(card)"
  >
    {{ card.rank }}{{ card.suit }}
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  actionController: UseActionControllerReturn;
  availableActions: string[];
}>();

// Check if card can be played
function isCardPlayable(card: GameViewElement): boolean {
  // Must be our turn and action available
  if (!props.availableActions.includes('play')) return false;

  // If in wizard mode, check validElements
  const { currentSelection, validElements } = props.actionController;
  if (currentSelection.value?.name === 'card') {
    return validElements.value.some(ve => ve.id === card.id);
  }

  return true;
}
</script>
```

### Error Recovery Patterns

```typescript
// Retry failed actions
async function executeWithRetry(
  name: string,
  args: Record<string, unknown>,
  maxRetries = 2
) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    await actionController.execute(name, args);

    if (!actionController.error) return; // Success

    if (attempt < maxRetries) {
      // Wait before retry (connection issues)
      await new Promise(r => setTimeout(r, 1000));
    }
  }

  // All retries failed
  showToast('Action failed - please try again');
}

// Reset UI state on persistent errors
function handlePersistentError() {
  actionController.cancel();
  // Refresh game state from server
  refreshGameState();
}
```

## Building Custom UIs

## Game View Data Structure

The `gameView` prop contains serialized game state. Each element has this structure:

```typescript
interface GameViewElement {
  id: number;              // Unique element ID - use this for action args!
  className: string;       // Element class name (e.g., 'Merc', 'Card')
  name?: string;           // Optional element name
  attributes: {            // Game-specific properties
    rank?: string;
    suit?: string;
    health?: number;
    // ... your custom properties
  };
  children?: GameViewElement[];  // Child elements
}
```

**Key point:** The `id` is at the top level, NOT inside `attributes`.

```typescript
// Correct - ID is at top level
const mercId = merc.id;  // ✓

// Wrong - ID is not in attributes
const mercId = merc.attributes.id;  // ✗ undefined
```

### Finding Elements by ID vs by Attributes

A common pattern is having UI data (like a selected equipment name) and needing to find the element's numeric ID for API calls. The element data you display comes from `attributes`, but the ID you need for actions is at the top level.

**The Problem:**
```typescript
// You have equipment stats displayed in the UI
const selectedEquipment = { name: 'Laser Rifle', damage: 10 };

// But you need the element ID to drop it
// How do you find the ID?
```

**The Solution:** Use `findChildByAttribute` to search children:

```typescript
import { findChildByAttribute, getElementId } from 'boardsmith/ui';

// Find equipment element by its name attribute
const equipment = findChildByAttribute(merc, 'equipmentName', selectedEquipment.name);
const equipmentId = getElementId(equipment);

if (equipmentId) {
  await actionController.execute('dropEquipment', {
    actingMerc: merc.id,
    equipment: equipmentId
  });
}
```

### Helper Functions for Finding Elements

The `boardsmith/ui` package provides several helpers for finding elements:

| Function | Description | Use When |
|----------|-------------|----------|
| `findElement(view, { type, name, className })` | Find direct child by type/name/class | Finding top-level containers |
| `findChildByAttribute(parent, attrName, value)` | Find direct child by attribute | Finding element when you have attribute data |
| `findElementByAttribute(root, attrName, value)` | Recursive search by attribute | Finding element anywhere in tree |
| `findElementById(root, id)` | Recursive search by numeric ID | Finding element when you have its ID |
| `getElementId(element)` | Get numeric ID from element | Extracting ID for action calls |

**Example: Equipment Modal**

```typescript
// User selects equipment from a modal showing equipment data
const selectedEquipmentName = 'Plasma Cannon';

// Find the merc that has this equipment
const merc = findElement(gameView, { className: 'Merc' });

// Find the equipment element by searching merc's children
const equipment = findChildByAttribute(merc, 'equipmentName', selectedEquipmentName);

if (equipment) {
  console.log('Found equipment ID:', equipment.id);  // e.g., 42
  await actionController.execute('dropEquipment', {
    actingMerc: merc.id,
    equipment: equipment.id  // Use the numeric ID
  });
}
```

**Example: Finding Any Element by Unique Attribute**

```typescript
// Find a sector anywhere in the game by its unique sector ID
const sector = findElementByAttribute(gameView, 'sectorId', 'alpha-3');
if (sector) {
  await actionController.execute('moveTo', { destination: sector.id });
}
```

## Calling Actions from Custom UIs

### When to Use `execute()` vs `start()`

The `actionController` has two main ways to trigger actions. Choosing the right one depends on whether you have all the information needed upfront.

| Method | Use When | What Happens |
|--------|----------|--------------|
| `execute(name, args)` | You have all selection values ready | Action executes immediately |
| `start(name, options?)` | User needs to make selections via ActionPanel | Enters wizard mode, ActionPanel shows selection UI |

**Decision Guide:**

```
Do you have ALL required selection values?
├── YES → Use execute()
│   Example: await execute('draw', { count: 3 })
│
└── NO → Use start()
    │
    ├── Do you have SOME values to pre-fill?
    │   └── YES → start('action', { args: { known: value } })
    │
    └── Should later selections auto-fill when they become active?
        └── YES → start('action', { prefill: { later: value } })
```

**Common Patterns:**

```typescript
// Pattern 1: No selections required (e.g., endTurn, pass)
await actionController.execute('endTurn');

// Pattern 2: All selections known (direct board click)
await actionController.execute('move', {
  piece: clickedPiece.id,
  destination: clickedCell.id
});

// Pattern 3: Start wizard mode (let ActionPanel handle selections)
actionController.start('play');

// Pattern 4: Pre-fill first selection, let user choose rest
actionController.start('move', { args: { piece: clickedPiece.id } });

// Pattern 5: Pre-fill dependent selection (auto-fills when reached)
actionController.start('dropEquipment', {
  args: { actingMerc: merc.id },
  prefill: { equipment: equipmentId }  // Applied when 'equipment' step activates
});
```

**args vs prefill:**

- `args`: Applied immediately when `start()` is called. Use for selections that are available now.
- `prefill`: Applied later when that selection step becomes active. Use for dependent selections where the choice isn't visible until a prior selection is made.

When calling `actionController.execute()` or `actionController.fill()`, pass **numeric element IDs**:

```typescript
// For fromElements / chooseElement selections, pass the element ID
await actionController.execute('dropEquipment', {
  actingMerc: merc.id,       // number (e.g., 42)
  equipment: equipment.id,   // number (e.g., 17)
});

// For chooseFrom selections, pass the choice value
await actionController.execute('selectColor', {
  color: 'red',  // The actual choice value
});
```

The framework automatically converts element IDs to actual element objects before passing to the `execute()` handler.

### Complete Custom UI Flow Example

```typescript
// 1. Find elements in gameView
const myMercs = computed(() =>
  findElements(props.gameView, { className: 'Merc' })
    .filter(m => m.attributes?.player?.position === props.playerPosition)
);

// 2. User clicks a merc
async function onMercClick(merc: GameViewElement) {
  if (!props.availableActions.includes('dropEquipment')) return;

  // 3. Start wizard mode with merc pre-selected
  await props.actionController.start('dropEquipment', {
    args: { actingMerc: merc.id }  // Pass numeric ID
  });
}

// 4. User clicks equipment (using validElements from actionController)
async function onEquipmentClick(equipment: GameViewElement) {
  const { currentSelection, validElements } = props.actionController;

  // Check if this equipment is selectable
  if (currentSelection.value?.name !== 'equipment') return;
  if (!validElements.value.some(ve => ve.id === equipment.id)) return;

  // Fill the selection with the equipment ID
  await props.actionController.fill('equipment', equipment.id);
}
```

### Debugging Action Calls

To debug what's being sent to the server, add logging:

```typescript
async function executeAction(name: string, args: Record<string, unknown>) {
  console.log('[Action]', name, 'args:', JSON.stringify(args, null, 2));
  await props.actionController.execute(name, args);
}
```

Or check the Network tab in browser dev tools - look for WebSocket messages or `/action` API calls.

### Example: Custom Game Board

```vue
<script setup lang="ts">
import { computed, ref, watch, nextTick } from 'vue';
import {
  useBoardInteraction,
  useElementAnimation,
  findPlayerHand,
  getCards,
  type UseActionControllerReturn
} from 'boardsmith/ui';

const props = defineProps<{
  gameView: any;
  playerPosition: number;
  isMyTurn: boolean;
  availableActions: string[];
  actionController: UseActionControllerReturn;
}>();

const boardInteraction = useBoardInteraction();
const { capturePositions, animateToCurrentPositions } = useElementAnimation();
const containerRef = ref<HTMLElement>();

// Extract data from game view
const myHand = computed(() => {
  const hand = findPlayerHand(props.gameView, props.playerPosition);
  return hand ? getCards(hand) : [];
});

// Handle card click
async function onCardClick(card: any) {
  if (!props.isMyTurn) return;
  if (!props.availableActions.includes('play')) return;

  // Check if card is selectable via board interaction (wizard mode active)
  if (boardInteraction?.isSelectableElement(card)) {
    boardInteraction.triggerElementSelect(card);
  } else {
    // Direct action execution
    await props.actionController.execute('play', { card: card.id });
  }
}

// Animate state changes
watch(() => props.gameView, (newView, oldView) => {
  if (containerRef.value && oldView) {
    capturePositions(containerRef.value);
    nextTick(() => {
      animateToCurrentPositions(containerRef.value!);
    });
  }
});
</script>

<template>
  <div ref="containerRef" class="game-board">
    <div class="hand">
      <div
        v-for="card in myHand"
        :key="card.id"
        class="card"
        :class="{
          'highlighted': boardInteraction?.isHighlighted(card),
          'selected': boardInteraction?.isSelected(card),
          'selectable': boardInteraction?.isSelectableElement(card),
        }"
        data-animatable="true"
        :data-element-id="card.id"
        @click="onCardClick(card)"
      >
        {{ card.attributes?.rank }}{{ card.attributes?.suit }}
      </div>
    </div>
  </div>
</template>
```

## Related Documentation

- [Core Concepts](./core-concepts.md) - Understanding game state
- [Actions & Flow](./actions-and-flow.md) - How actions work
- [Element Enrichment](./element-enrichment.md) - Using validElements for custom selection UIs
- [Game Examples](./game-examples.md) - Real UI implementations
````
