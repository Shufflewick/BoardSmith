import type {
  TrainingResult,
  LearnedObjective,
  GameStructure,
  CandidateFeature,
} from './types.js';

/**
 * Options for code generation
 */
export interface CodeGeneratorOptions {
  /** Game class name (e.g., 'GoFishGame') */
  gameClassName: string;
  /** Player class name (e.g., 'GoFishPlayer') */
  playerClassName?: string;
  /** Include comments with training metadata */
  includeMetadata: boolean;
  /** Include action preferences as comments */
  includeActionHints: boolean;
  /** Game structure (for better code generation) */
  structure?: GameStructure;
  /** Original candidate features (for code generation) */
  features?: CandidateFeature[];
}

/**
 * Generate an ai.ts file from training results
 */
export function generateAICode(
  result: TrainingResult,
  options: CodeGeneratorOptions
): string {
  const lines: string[] = [];

  // Header
  lines.push(`// AUTO-GENERATED by boardsmith train-ai`);
  lines.push(`// Do not edit manually - regenerate with: npx boardsmith train-ai`);

  if (options.includeMetadata) {
    lines.push(`//`);
    lines.push(`// Training Statistics:`);
    lines.push(`//   Games played: ${result.metadata.gamesPlayed}`);
    lines.push(`//   Games completed: ${result.metadata.gamesCompleted}`);
    lines.push(`//   Total states analyzed: ${result.metadata.totalStates}`);
    lines.push(`//   Candidate features: ${result.metadata.candidateFeaturesGenerated}`);
    lines.push(`//   Features selected: ${result.metadata.featuresSelected}`);
    lines.push(`//   Training iterations: ${result.metadata.iterations}`);
    lines.push(`//   Estimated win rate vs random: ${(result.metadata.finalWinRate * 100).toFixed(1)}%`);
  }

  lines.push(``);

  // Imports
  lines.push(`import type { Game } from '@boardsmith/engine';`);
  lines.push(`import type { Objective } from '@boardsmith/ai';`);

  // Import game-specific types if provided
  if (options.gameClassName) {
    const imports = [`${options.gameClassName}`];
    if (options.playerClassName) {
      imports.push(options.playerClassName);
    }
    lines.push(`import type { ${imports.join(', ')} } from './game.js';`);
  }

  // Import element types if we have structure info
  if (options.structure) {
    const elementImports = getRequiredElementImports(result.objectives, options.structure);
    if (elementImports.length > 0) {
      lines.push(`import { ${elementImports.join(', ')} } from './elements.js';`);
    }
  }

  lines.push(``);

  // Action hints as comments
  if (options.includeActionHints && result.actionPreferences.length > 0) {
    lines.push(`/**`);
    lines.push(` * Action Preferences (learned from self-play):`);
    for (const pref of result.actionPreferences.slice(0, 5)) {
      const sign = pref.weight > 0 ? '+' : '';
      lines.push(` *   ${pref.actionName}: ${sign}${pref.weight.toFixed(1)} (${pref.weight > 0 ? 'prefer' : 'avoid'})`);
    }
    lines.push(` */`);
    lines.push(``);
  }

  // Main objectives function
  const funcName = `get${options.gameClassName.replace('Game', '')}Objectives`;
  const playerType = options.playerClassName || 'Player';

  lines.push(`/**`);
  lines.push(` * AI objectives for ${options.gameClassName.replace('Game', '')}`);
  lines.push(` * These guide the MCTS bot to prefer better positions during playouts`);
  lines.push(` * `);
  lines.push(` * Generated through self-play simulation and statistical analysis.`);
  lines.push(` * Higher weight = more important for winning.`);
  lines.push(` */`);
  lines.push(`export function ${funcName}(`);
  lines.push(`  game: Game,`);
  lines.push(`  playerIndex: number`);
  lines.push(`): Record<string, Objective> {`);

  // Game and player setup
  lines.push(`  const ${camelCase(options.gameClassName)} = game as ${options.gameClassName};`);
  lines.push(`  const player = ${camelCase(options.gameClassName)}.players[playerIndex] as ${playerType};`);

  // Only add opponent if we have 2-player objectives
  const needs2Player = result.objectives.some(o =>
    o.description.includes('opponent') ||
    o.description.includes('than opponent') ||
    o.featureId.includes('advantage') ||
    o.featureId.includes('lead')
  );
  if (needs2Player) {
    lines.push(`  const opponent = ${camelCase(options.gameClassName)}.players[1 - playerIndex] as ${playerType};`);
  }

  lines.push(``);
  lines.push(`  return {`);

  // Generate each objective
  for (let i = 0; i < result.objectives.length; i++) {
    const obj = result.objectives[i];
    const isLast = i === result.objectives.length - 1;

    lines.push(`    // ${obj.description}`);
    lines.push(`    // Correlation: ${obj.correlation > 0 ? '+' : ''}${obj.correlation.toFixed(3)}`);
    lines.push(`    '${obj.featureId}': {`);
    lines.push(`      checker: ${generateCheckerFunction(obj, options)},`);
    lines.push(`      weight: ${obj.weight},`);
    lines.push(`    }${isLast ? '' : ','}`);
    lines.push(``);
  }

  lines.push(`  };`);
  lines.push(`}`);
  lines.push(``);

  return lines.join('\n');
}

/**
 * Generate a checker function for an objective
 */
function generateCheckerFunction(
  obj: LearnedObjective,
  options: CodeGeneratorOptions
): string {
  const id = obj.featureId;
  const gameVar = camelCase(options.gameClassName);

  // Parse feature ID to generate appropriate code
  // Format: elementtype-property-comparison or player-property-comparison

  // Element count advantage
  if (id.includes('-count-advantage')) {
    const elementType = capitalize(id.split('-count-advantage')[0]);
    return `() => {
        const myCount = ${gameVar}.all(${elementType}, { player }).length;
        const theirCount = ${gameVar}.all(${elementType}, { player: opponent }).length;
        return myCount > theirCount;
      }`;
  }

  // Element count disadvantage
  if (id.includes('-count-disadvantage')) {
    const elementType = capitalize(id.split('-count-disadvantage')[0]);
    return `() => {
        const myCount = ${gameVar}.all(${elementType}, { player }).length;
        const theirCount = ${gameVar}.all(${elementType}, { player: opponent }).length;
        return myCount < theirCount;
      }`;
  }

  // Element count threshold
  if (id.includes('-count-gte-')) {
    const parts = id.split('-count-gte-');
    const elementType = capitalize(parts[0]);
    const threshold = parts[1];
    return `() => ${gameVar}.all(${elementType}, { player }).length >= ${threshold}`;
  }

  if (id.includes('-count-zero')) {
    const elementType = capitalize(id.split('-count-zero')[0]);
    return `() => ${gameVar}.all(${elementType}, { player }).length === 0`;
  }

  // Boolean property check
  if (id.includes('-has-')) {
    const parts = id.split('-has-');
    const elementType = capitalize(parts[0]);
    const property = parts[1];
    return `() => ${gameVar}.all(${elementType}, { player }).some(e => e.${property})`;
  }

  // Boolean property advantage
  if (id.match(/-\w+-advantage$/)) {
    const parts = id.split('-');
    const elementType = capitalize(parts[0]);
    const property = parts.slice(1, -1).join('-');
    return `() => {
        const myCount = ${gameVar}.all(${elementType}, { player }).filter(e => e.${property}).length;
        const theirCount = ${gameVar}.all(${elementType}, { player: opponent }).filter(e => e.${property}).length;
        return myCount > theirCount;
      }`;
  }

  // Player score lead
  if (id.startsWith('player-') && id.endsWith('-lead')) {
    const property = id.replace('player-', '').replace('-lead', '');
    return `() => player.${property} > opponent.${property}`;
  }

  // Player score threshold
  if (id.startsWith('player-') && id.includes('-gte-')) {
    const parts = id.replace('player-', '').split('-gte-');
    const property = parts[0];
    const threshold = parts[1];
    return `() => player.${property} >= ${threshold}`;
  }

  // Player near-max
  if (id.includes('-near-max')) {
    const property = id.replace('player-', '').replace('-near-max', '');
    return `() => {
        const maxScore = Math.max(...${gameVar}.players.map(p => p.${property} ?? 0));
        return maxScore > 0 && player.${property} >= maxScore * 0.75;
      }`;
  }

  // Spatial: center control
  if (id.includes('-center-control')) {
    const elementType = capitalize(id.split('-center-control')[0]);
    return `() => {
        const elements = ${gameVar}.all(${elementType}, { player });
        return elements.some(e => e.row !== undefined && e.column !== undefined);
      }`;
  }

  // Spatial: center advantage
  if (id.includes('-center-advantage')) {
    const elementType = capitalize(id.split('-center-advantage')[0]);
    return `() => {
        const myCenter = ${gameVar}.all(${elementType}, { player }).filter(e =>
          e.row !== undefined && e.row >= 2 && e.row <= 5
        ).length;
        const theirCenter = ${gameVar}.all(${elementType}, { player: opponent }).filter(e =>
          e.row !== undefined && e.row >= 2 && e.row <= 5
        ).length;
        return myCenter > theirCenter;
      }`;
  }

  // Spatial: advancement
  if (id.includes('-advanced')) {
    const elementType = capitalize(id.split('-advanced')[0]);
    return `() => {
        const elements = ${gameVar}.all(${elementType}, { player });
        if (elements.length === 0) return false;
        const advancedCount = elements.filter(e => {
          if (e.row === undefined) return false;
          return playerIndex === 0 ? e.row > 3 : e.row < 4;
        }).length;
        return advancedCount > elements.length / 2;
      }`;
  }

  // Spatial: back row
  if (id.includes('-back-row')) {
    const elementType = capitalize(id.split('-back-row')[0]);
    return `() => {
        const backRow = playerIndex === 0 ? 0 : 7;
        return ${gameVar}.all(${elementType}, { player }).some(e => e.row === backRow);
      }`;
  }

  // Majority
  if (id.includes('-majority')) {
    const elementType = capitalize(id.split('-majority')[0]);
    return `() => {
        const myCount = ${gameVar}.all(${elementType}, { player }).length;
        const total = ${gameVar}.all(${elementType}).length;
        return total > 0 && myCount > total / 2;
      }`;
  }

  // Dominance
  if (id.includes('-dominance')) {
    const elementType = capitalize(id.split('-dominance')[0]);
    return `() => {
        const myCount = ${gameVar}.all(${elementType}, { player }).length;
        const total = ${gameVar}.all(${elementType}).length;
        return total > 0 && myCount > total * 0.66;
      }`;
  }

  // Sum advantage
  if (id.includes('-sum-advantage')) {
    const parts = id.split('-');
    const elementType = capitalize(parts[0]);
    const property = parts[1];
    return `() => {
        const mySum = ${gameVar}.all(${elementType}, { player }).reduce((s, e) => s + (e.${property} ?? 0), 0);
        const theirSum = ${gameVar}.all(${elementType}, { player: opponent }).reduce((s, e) => s + (e.${property} ?? 0), 0);
        return mySum > theirSum;
      }`;
  }

  // Sum threshold
  if (id.includes('-sum-gte-')) {
    const parts = id.split('-sum-gte-');
    const [elementType, property] = parts[0].split('-');
    const threshold = parts[1];
    return `() => {
        const sum = ${gameVar}.all(${capitalize(elementType)}, { player }).reduce((s, e) => s + (e.${property} ?? 0), 0);
        return sum >= ${threshold};
      }`;
  }

  // String property match
  if (id.match(/^[a-z]+-[a-z]+-[a-z-]+$/)) {
    // Could be elementtype-property-value
    const parts = id.split('-');
    if (parts.length >= 3) {
      const elementType = capitalize(parts[0]);
      const property = parts[1];
      const value = parts.slice(2).join('-');
      return `() => ${gameVar}.all(${elementType}, { player }).some(e => e.${property} === '${value}')`;
    }
  }

  // Default fallback with description as comment
  console.warn(
    `[AI Code Generator] Unknown feature pattern: "${id}". ` +
    `Generated fallback checker that always returns true. ` +
    `Consider implementing custom logic for: ${obj.description}`
  );
  return `() => {
        // ${obj.description}
        // WARNING: Auto-generated fallback - always returns true
        // Implement game-specific logic for better AI performance
        return true;
      }`;
}

/**
 * Get required element type imports
 */
function getRequiredElementImports(
  objectives: LearnedObjective[],
  structure: GameStructure
): string[] {
  const imports = new Set<string>();

  for (const obj of objectives) {
    const id = obj.featureId;

    // Extract element type from feature ID
    for (const [className] of structure.elementTypes) {
      if (id.toLowerCase().startsWith(className.toLowerCase())) {
        imports.add(className);
      }
    }
  }

  return [...imports].sort();
}

/**
 * Convert to camelCase
 */
function camelCase(s: string): string {
  return s.charAt(0).toLowerCase() + s.slice(1);
}

/**
 * Capitalize first letter
 */
function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Save generated code to file
 */
export function saveAICode(
  code: string,
  outputPath: string
): void {
  // This would be called by the CLI
  // For now, just export the function
  // The actual file writing happens in the CLI command
}

/**
 * Options for updating AI weights
 */
export interface UpdateWeightsOptions {
  /** Add metadata comment about evolution */
  addMetadata?: boolean;
  /** Evolution statistics to include in metadata */
  evolutionStats?: {
    generations: number;
    population: number;
    initialWinRate: number;
    finalWinRate: number;
  };
}

/**
 * Update weights in an existing ai.ts file, preserving all other code.
 *
 * This function parses the existing file, finds weight assignments,
 * and updates them with new values from the evolved objectives.
 * All other code (checker functions, imports, comments) is preserved.
 *
 * @param originalCode - The original ai.ts file content
 * @param objectives - Updated objectives with new weights
 * @param options - Options for updating
 * @returns Updated code with new weights
 */
export function updateAIWeights(
  originalCode: string,
  objectives: LearnedObjective[],
  options: UpdateWeightsOptions = {}
): string {
  // Create a map of feature IDs to new weights
  const weightMap = new Map<string, number>();
  for (const obj of objectives) {
    weightMap.set(obj.featureId, obj.weight);
  }

  // Split into lines for processing
  const lines = originalCode.split('\n');
  const updatedLines: string[] = [];

  // Track which objective we're currently in using brace depth
  let currentObjectiveId: string | null = null;
  let braceDepth = 0;

  // Process each line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    let updatedLine = line;

    // Detect objective start: 'feature-id': {
    const objectiveMatch = line.match(/^\s*['"]([a-z0-9-]+)['"]\s*:\s*\{/);
    if (objectiveMatch && braceDepth === 0) {
      currentObjectiveId = objectiveMatch[1];
      braceDepth = 1;
    } else if (currentObjectiveId) {
      // Count braces to track nesting (checker functions have nested braces)
      const opens = (line.match(/\{/g) || []).length;
      const closes = (line.match(/\}/g) || []).length;
      braceDepth += opens - closes;

      // If brace depth returns to 0, we've exited the objective
      if (braceDepth <= 0) {
        currentObjectiveId = null;
        braceDepth = 0;
      }
    }

    // If we're inside an objective and this line has a weight assignment, update it
    if (currentObjectiveId && braceDepth > 0) {
      const weightMatch = line.match(/^(\s*)weight\s*:\s*(-?[\d.]+)\s*,?\s*(\/\/.*)?$/);
      if (weightMatch) {
        const newWeight = weightMap.get(currentObjectiveId);
        if (newWeight !== undefined) {
          const indent = weightMatch[1];
          const comment = weightMatch[3] || '';
          // Round to 1 decimal place
          const roundedWeight = Math.round(newWeight * 10) / 10;
          updatedLine = `${indent}weight: ${roundedWeight},${comment ? ' ' + comment : ''}`;
        }
      }
    }

    updatedLines.push(updatedLine);
  }

  let result = updatedLines.join('\n');

  // Add or update evolution metadata if requested
  if (options.addMetadata && options.evolutionStats) {
    const stats = options.evolutionStats;
    const metadataComment = [
      `//`,
      `// Weight Evolution (${new Date().toISOString().split('T')[0]}):`,
      `//   Generations: ${stats.generations}`,
      `//   Population: ${stats.population}`,
      `//   Initial win rate: ${(stats.initialWinRate * 100).toFixed(1)}%`,
      `//   Final win rate: ${(stats.finalWinRate * 100).toFixed(1)}%`,
      `//   Improvement: ${((stats.finalWinRate - stats.initialWinRate) * 100).toFixed(1)}%`,
      `//`,
    ].join('\n');

    // Find the right place to insert metadata (after the header comments, before imports)
    const importIndex = result.indexOf('import ');
    if (importIndex > 0) {
      // Find the last comment line before the import
      const beforeImport = result.slice(0, importIndex);
      const afterImport = result.slice(importIndex);

      // Check if there's already evolution metadata
      if (beforeImport.includes('Weight Evolution')) {
        // Replace existing evolution metadata
        result = beforeImport.replace(
          /\/\/\s*\n\/\/ Weight Evolution[^]*?\/\/\s*\n/,
          metadataComment + '\n'
        ) + afterImport;
      } else {
        // Insert new metadata before imports
        result = beforeImport + metadataComment + '\n' + afterImport;
      }
    }
  }

  return result;
}
