# BoardSmith AI Generation Instructions

You are helping the user generate custom AI evaluation functions for their BoardSmith game.

Before generating code, read these files to understand the patterns:
- `<BOARDSMITH_ROOT>/packages/ai-trainer/src/code-generator.ts` - AI code output format
- `<BOARDSMITH_ROOT>/packages/ai-trainer/src/feature-templates.ts` - Feature patterns

(Replace `<BOARDSMITH_ROOT>` with the path provided in the slash command)

## Phase 1: Project Validation

Verify we're in a valid BoardSmith game project:

1. **Check for boardsmith.json**:
   - If it doesn't exist, stop and inform the user: "This doesn't appear to be a BoardSmith game project. Please run this command from a directory containing boardsmith.json."

2. **Check for existing ai.ts**:
   - Look in `src/rules/ai.ts`
   - If it exists, ask: "An ai.ts file already exists. Should I overwrite it, or would you like to review and enhance the existing one?"

## Phase 2: Game Analysis

Understand the game structure:

1. **Run introspection**:
   ```bash
   npx boardsmith analyze --json
   ```
   This provides game structure including element types, actions, and complexity.

2. **Read game rules files**:
   - `src/rules/elements.ts` - Element classes, properties, and types
   - `src/rules/game.ts` - Main game class, setup, win conditions
   - `src/rules/actions.ts` - Available player actions
   - `src/rules/flow.ts` - Turn structure and game phases

3. **Identify key aspects**:
   - What are the win conditions?
   - How is scoring determined?
   - What element types exist?
   - What properties do elements have?
   - What actions can players take?

## Phase 3: Strategy Discussion

Engage the user to understand strategic concepts:

1. **Ask about strong positions**:
   "What board positions or game states are generally advantageous in this game?"

2. **Ask about priorities**:
   "What should the AI prioritize? (e.g., controlling the center, gathering resources, blocking opponents)"

3. **Ask about traps**:
   "Are there any common mistakes or traps the AI should avoid?"

4. **Identify game type** (affects feature selection):
   - **Connection games** (like Hex): Focus on path distance, blocking
   - **Capture games** (like Chess): Focus on material, piece safety, threats
   - **Racing games**: Focus on score lead, proximity to goal
   - **Collection games** (like Go Fish): Focus on set completion
   - **Territory games** (like Go): Focus on area control, influence
   - **Mixed**: Combine appropriate features

## Phase 4: Feature Design

Based on game structure and user input, design evaluation features:

### Feature Categories by Game Type

**For Connection Games:**
- Path distance to goal
- Number of connected groups
- Blocking opponent's shortest path
- Bridge/edge positions

**For Capture Games:**
- Material count (pieces owned)
- Material advantage over opponent
- Piece safety (threatened vs protected)
- Central control
- Mobility (available moves)

**For Racing/Scoring Games:**
- Score lead over opponent
- Progress toward target score
- Resource accumulation rate

**For Collection Games:**
- Sets completed
- Progress toward completing sets
- Cards/items needed for completion
- Blocking opponent's collections

**For Territory Games:**
- Territory controlled
- Influence over contested areas
- Border strength

### Feature Structure

Each feature needs:
- **id**: Unique identifier (kebab-case, e.g., `piece-count-advantage`)
- **description**: Human-readable explanation
- **weight**: Importance (-10 to +10, positive = maximize, negative = minimize)
- **checker**: Function returning boolean (true = good for player)

## Phase 5: Code Generation

Generate `ai.ts` following the established format:

### File Structure

```typescript
// AI evaluation functions for <GameName>
// Generated by /generate-ai slash command

import type { Game } from '@boardsmith/engine';
import type { Objective } from '@boardsmith/ai';
import type { <GameClass>, <PlayerClass> } from './game.js';
import { <ElementTypes> } from './elements.js';

/**
 * AI objectives for <GameName>
 * These guide the MCTS bot to prefer better positions during playouts
 */
export function get<GameName>Objectives(
  game: Game,
  playerIndex: number
): Record<string, Objective> {
  const <gameVar> = game as <GameClass>;
  const player = <gameVar>.players[playerIndex] as <PlayerClass>;
  // Add opponent if needed for comparative features
  const opponent = <gameVar>.players[1 - playerIndex] as <PlayerClass>;

  return {
    // Feature: <description>
    '<feature-id>': {
      checker: () => {
        // Implementation
        return true; // or false
      },
      weight: <number>,
    },
    // ... more features
  };
}
```

### Checker Function Patterns

**Element count advantage:**
```typescript
checker: () => {
  const myCount = game.all(Piece, { player }).length;
  const theirCount = game.all(Piece, { player: opponent }).length;
  return myCount > theirCount;
}
```

**Score lead:**
```typescript
checker: () => player.score > opponent.score
```

**Threshold check:**
```typescript
checker: () => player.score >= 10
```

**Property check on elements:**
```typescript
checker: () => game.all(Card, { player }).some(c => c.isWild)
```

**Spatial control:**
```typescript
checker: () => {
  const centerPieces = game.all(Piece, { player }).filter(p =>
    p.row >= 2 && p.row <= 5 && p.column >= 2 && p.column <= 5
  ).length;
  return centerPieces >= 2;
}
```

## Phase 6: Validation

After generating the code:

1. **Write the file**:
   Save to `src/rules/ai.ts`

2. **Verify TypeScript compiles**:
   ```bash
   npx tsc --noEmit
   ```

   If there are errors:
   - Read the error messages carefully
   - Fix type mismatches or import issues
   - Run tsc again until no errors

3. **Suggest testing**:
   "The AI is ready! Test it with:"
   ```bash
   boardsmith dev --ai 1
   ```
   This will have player 1 controlled by your new AI.

## Critical Rules

- **Read code-generator.ts first**: Understand the exact output format used by the automated trainer
- **Use introspector output**: Base features on actual element types and properties
- **Checker functions return boolean**: true means the condition is good for the player
- **Weight semantics**: Positive weight = AI tries to make checker return true; negative = tries to make it return false
- **Type safety**: Always use proper type imports from game.js and elements.js
- **Verify before done**: Always run `npx tsc --noEmit` to ensure no TypeScript errors
- **Don't over-engineer**: Start with 3-5 strong features; more isn't always better
- **Test iteratively**: Suggest the user test and provide feedback for refinement
