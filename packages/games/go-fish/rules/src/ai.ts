// AI evaluation functions for Go Fish
// Generated by /generate-ai slash command
//
// Game Type: Collection
// Win Condition: Collect the most books (sets of 4 cards of the same rank)
// Key Mechanics:
//   - Ask opponents for ranks you hold
//   - If they have cards of that rank, they give ALL of them to you
//   - If not, "Go Fish" (draw from pond)
//   - Drawing the requested rank grants another turn
//   - Form a book when you have 4 of a rank

import { Player, type Game } from '@boardsmith/engine';
import type { Objective, BotMove, ThreatResponse } from '@boardsmith/ai';
import type { GoFishGame } from './game.js';
import { Card, GoFishPlayer } from './elements.js';

// === HELPER FUNCTIONS ===

/**
 * Count cards by rank in a player's hand
 */
function getRankCounts(game: GoFishGame, player: GoFishPlayer): Map<string, number> {
  const hand = game.getPlayerHand(player);
  const counts = new Map<string, number>();
  for (const card of hand.all(Card)) {
    counts.set(card.rank, (counts.get(card.rank) ?? 0) + 1);
  }
  return counts;
}

/**
 * Get all opponents (all players except the given one)
 */
function getOpponents(game: GoFishGame, player: GoFishPlayer): GoFishPlayer[] {
  return [...game.all(Player)]
    .filter(p => p !== player) as GoFishPlayer[];
}

/**
 * Calculate the maximum book count among opponents
 */
function getMaxOpponentBooks(game: GoFishGame, player: GoFishPlayer): number {
  const opponents = getOpponents(game, player);
  if (opponents.length === 0) return 0;
  return Math.max(...opponents.map(p => p.bookCount));
}

/**
 * Count how many 3-of-a-kind sets a player has (1 card away from a book)
 */
function countNearBooks(game: GoFishGame, player: GoFishPlayer): number {
  const rankCounts = getRankCounts(game, player);
  let count = 0;
  for (const cardCount of rankCounts.values()) {
    if (cardCount === 3) count++;
  }
  return count;
}

/**
 * Count how many 2-of-a-kind sets a player has (2 cards away from a book)
 */
function countPairs(game: GoFishGame, player: GoFishPlayer): number {
  const rankCounts = getRankCounts(game, player);
  let count = 0;
  for (const cardCount of rankCounts.values()) {
    if (cardCount === 2) count++;
  }
  return count;
}

/**
 * Calculate total "set progress" score (weighted by how close to completing)
 * 3-of-a-kind = 3 points, pairs = 1 point, singles = 0.25 points
 */
function calculateSetProgressScore(game: GoFishGame, player: GoFishPlayer): number {
  const rankCounts = getRankCounts(game, player);
  let score = 0;
  for (const cardCount of rankCounts.values()) {
    if (cardCount === 3) score += 3;
    else if (cardCount === 2) score += 1;
    else if (cardCount === 1) score += 0.25;
  }
  return score;
}

/**
 * Count unique ranks in a player's hand (more ranks = more asking options)
 */
function countUniqueRanks(game: GoFishGame, player: GoFishPlayer): number {
  return game.getPlayerRanks(player).length;
}

/**
 * Get total cards in a player's hand
 */
function getHandSize(game: GoFishGame, player: GoFishPlayer): number {
  return game.getPlayerHand(player).count(Card);
}

// === HOOK 1: OBJECTIVES ===

/**
 * AI objectives for Go Fish
 * These guide the MCTS bot to prefer better positions during playouts
 *
 * All objectives return gradient values 0.0-1.0 (not boolean)
 * Weight semantics: positive = maximize, negative = avoid
 */
export function getGoFishObjectives(
  game: Game,
  playerSeat: number
): Record<string, Objective> {
  const goFishGame = game as GoFishGame;
  const player = goFishGame.getPlayer(playerSeat) as GoFishPlayer;
  const opponents = getOpponents(goFishGame, player);

  // Constants for normalization
  const TOTAL_BOOKS = 13; // Total possible books in a standard deck
  const MAX_HAND_SIZE = 20; // Reasonable max hand size for gradient
  const MAX_SET_PROGRESS = 10; // Reasonable max set progress score

  return {
    // PRIMARY: Book lead over opponents
    // Gradient: 0.5 = tied, 1.0 = max lead, 0.0 = max behind
    'book-lead': {
      checker: () => {
        const myBooks = player.bookCount;
        const maxOpponentBooks = getMaxOpponentBooks(goFishGame, player);
        const difference = myBooks - maxOpponentBooks;
        // Normalize to 0-1 range, centered at 0.5
        const maxDiff = 7; // Reasonable max lead
        return Math.max(0, Math.min(1, (difference + maxDiff) / (2 * maxDiff)));
      },
      weight: 10,
    },

    // Near-win: Player has 7+ books (majority of 13)
    // Gradient: 0.0 below 7, scales from 0.0 at 7 to 1.0 at 13
    'near-win': {
      checker: () => {
        const books = player.bookCount;
        if (books < 7) return 0.0;
        return (books - 6) / 7; // 7→0.14, 8→0.29, 9→0.43, 10→0.57, 11→0.71, 12→0.86, 13→1.0
      },
      weight: 8,
    },

    // Near-book count: Having 3-of-a-kind sets (1 card away from book)
    // Gradient: scales with number of near-books
    'near-book-count': {
      checker: () => {
        const nearBooks = countNearBooks(goFishGame, player);
        // Normalize: having 3+ near-books is excellent
        return Math.min(1, nearBooks / 3);
      },
      weight: 6,
    },

    // Set progress: Weighted score of how close cards are to forming books
    // Higher is better - encourages accumulating cards of same ranks
    'set-progress': {
      checker: () => {
        const myProgress = calculateSetProgressScore(goFishGame, player);
        // Normalize to 0-1
        return Math.min(1, myProgress / MAX_SET_PROGRESS);
      },
      weight: 4,
    },

    // Set progress advantage: Compare progress vs opponents
    // Gradient: 0.5 = tied, 1.0 = far ahead, 0.0 = far behind
    'set-progress-advantage': {
      checker: () => {
        const myProgress = calculateSetProgressScore(goFishGame, player);
        const opponentProgressScores = opponents.map(p =>
          calculateSetProgressScore(goFishGame, p)
        );
        const maxOpponentProgress = opponentProgressScores.length > 0
          ? Math.max(...opponentProgressScores)
          : 0;
        const difference = myProgress - maxOpponentProgress;
        const maxDiff = MAX_SET_PROGRESS;
        return Math.max(0, Math.min(1, (difference + maxDiff) / (2 * maxDiff)));
      },
      weight: 3,
    },

    // Hand size: Having cards means having options
    // Gradient: scales up to a reasonable max
    'hand-size': {
      checker: () => {
        const handSize = getHandSize(goFishGame, player);
        return Math.min(1, handSize / MAX_HAND_SIZE);
      },
      weight: 2,
    },

    // Rank diversity: More unique ranks = more asking options
    // Gradient: scales with number of unique ranks
    'rank-diversity': {
      checker: () => {
        const uniqueRanks = countUniqueRanks(goFishGame, player);
        // Max is 13 ranks
        return uniqueRanks / 13;
      },
      weight: 2,
    },

    // Opponent near-win threat (negative weight - we want to avoid this state)
    // High when any opponent is close to winning
    'opponent-near-win': {
      checker: () => {
        const maxOpponentBooks = getMaxOpponentBooks(goFishGame, player);
        if (maxOpponentBooks < 5) return 0.0;
        // Gradient increases sharply as opponent approaches 7 books
        const threat = (maxOpponentBooks - 4) / 9; // 5→0.11, 6→0.22, 7→0.33, 8→0.44...
        return threat * threat; // Squared for steeper penalty curve
      },
      weight: -8,
    },

    // Opponent has near-books (3-of-a-kind threatening to complete)
    // Negative weight - we want to disrupt their progress
    'opponent-near-book-threat': {
      checker: () => {
        let maxOpponentNearBooks = 0;
        for (const opp of opponents) {
          const nearBooks = countNearBooks(goFishGame, opp);
          maxOpponentNearBooks = Math.max(maxOpponentNearBooks, nearBooks);
        }
        return Math.min(1, maxOpponentNearBooks / 3);
      },
      weight: -4,
    },
  };
}

// === HOOK 2: THREAT RESPONSE ===

/**
 * Threat response moves for Go Fish
 *
 * In Go Fish, we can infer opponent holdings from what they ask for
 * (they must hold at least one card of that rank to ask).
 *
 * Returns moves that target opponents who have asked for ranks we hold,
 * potentially disrupting their progress toward books.
 *
 * @param game - Current game state
 * @param playerSeat - Which player the bot is (1-indexed)
 * @param availableMoves - All legal moves at this position
 * @returns ThreatResponse with priority moves and urgency flag
 */
export function getGoFishThreatResponseMoves(
  game: Game,
  playerSeat: number,
  availableMoves: BotMove[]
): ThreatResponse {
  const goFishGame = game as GoFishGame;
  const player = goFishGame.getPlayer(playerSeat) as GoFishPlayer;
  const opponents = getOpponents(goFishGame, player);

  // Check if any opponent is close to winning (has 5+ books)
  const maxOpponentBooks = getMaxOpponentBooks(goFishGame, player);

  if (maxOpponentBooks < 5) {
    // No immediate threat - return empty
    return { moves: [], urgent: false };
  }

  // Find opponents who are threats (have 5+ books)
  const threatOpponents = opponents.filter(p => p.bookCount >= 5);
  const threatPositions = new Set(threatOpponents.map(p => p.seat));

  // Prioritize asking threat opponents first
  // These moves target opponents who are close to winning
  const priorityMoves = availableMoves.filter(move => {
    const targetPosition = move.args.target as number | undefined;
    return targetPosition !== undefined && threatPositions.has(targetPosition);
  });

  if (priorityMoves.length === 0) {
    return { moves: [], urgent: false };
  }

  // Urgent if opponent has 6+ books (one book away from majority)
  const urgent = maxOpponentBooks >= 6;

  return { moves: priorityMoves, urgent };
}

// === HOOK 3: PLAYOUT POLICY ===

/**
 * Smart playout policy for Go Fish
 *
 * Prefer moves that:
 * 1. Ask for ranks where we have 3 cards (1 away from book)
 * 2. Ask for ranks where we have 2 cards (2 away from book)
 * 3. Target opponents who likely have cards we need
 *
 * Uses weighted random selection to maintain exploration diversity.
 *
 * @param game - Current game state
 * @param playerIndex - Which player is moving (1-indexed)
 * @param availableMoves - Legal moves to choose from
 * @param rng - Random number generator for weighted selection
 * @returns Selected move using weighted-random selection
 */
export function getGoFishPlayoutPolicy(
  game: Game,
  playerIndex: number,
  availableMoves: BotMove[],
  rng: () => number
): BotMove {
  if (availableMoves.length === 0) {
    throw new Error('No available moves for playout policy');
  }

  if (availableMoves.length === 1) {
    return availableMoves[0];
  }

  const goFishGame = game as GoFishGame;
  const player = goFishGame.getPlayer(playerIndex) as GoFishPlayer;
  const rankCounts = getRankCounts(goFishGame, player);

  // Score each move
  const scores: number[] = [];
  let maxScore = -Infinity;

  for (const move of availableMoves) {
    const rank = move.args.rank as string | undefined;
    const targetPosition = move.args.target as number | undefined;

    let score = 1; // Base score

    if (rank) {
      const cardCount = rankCounts.get(rank) ?? 0;

      // Heavy bonus for asking for ranks where we're close to a book
      if (cardCount === 3) {
        score += 5; // 1 card away from book - high priority
      } else if (cardCount === 2) {
        score += 2; // 2 cards away from book - medium priority
      } else if (cardCount === 1) {
        score += 0.5; // Just started collecting - low priority
      }
    }

    if (targetPosition !== undefined) {
      const target = goFishGame.getPlayer(targetPosition) as GoFishPlayer;
      const targetHandSize = getHandSize(goFishGame, target);

      // Prefer targeting opponents with larger hands (more likely to have what we need)
      score += Math.min(2, targetHandSize / 5);
    }

    scores.push(score);
    maxScore = Math.max(maxScore, score);
  }

  // Convert to weights using softmax
  const weights: number[] = [];
  let totalWeight = 0;

  for (const score of scores) {
    const weight = Math.exp(score - maxScore); // Shift to prevent overflow
    weights.push(weight);
    totalWeight += weight;
  }

  // Weighted random selection using rng()
  let target = rng() * totalWeight;
  for (let i = 0; i < availableMoves.length; i++) {
    target -= weights[i];
    if (target <= 0) {
      return availableMoves[i];
    }
  }

  // Fallback (shouldn't happen)
  return availableMoves[availableMoves.length - 1];
}

// === HOOK 4: MOVE ORDERING ===

/**
 * Order moves for MCTS exploration
 *
 * Prioritizes:
 * 1. Asking for ranks where we have 3 cards (immediate book potential)
 * 2. Asking for ranks where we have 2 cards (good progress)
 * 3. Targeting opponents with larger hands (more cards to give)
 * 4. Other moves
 *
 * This helps MCTS find strong moves faster by exploring promising actions first.
 *
 * @param game - Current game state
 * @param playerIndex - Which player the bot is (1-indexed)
 * @param moves - Available moves to order
 * @returns Moves sorted by exploration priority (best first)
 */
export function getGoFishMoveOrdering(
  game: Game,
  playerIndex: number,
  moves: BotMove[]
): BotMove[] {
  if (moves.length <= 1) return moves;

  const goFishGame = game as GoFishGame;
  const player = goFishGame.getPlayer(playerIndex) as GoFishPlayer;
  const rankCounts = getRankCounts(goFishGame, player);

  // Score each move
  const scoredMoves: Array<{ move: BotMove; score: number }> = [];

  for (const move of moves) {
    const rank = move.args.rank as string | undefined;
    const targetPosition = move.args.target as number | undefined;

    let score = 1; // Base score

    if (rank) {
      const cardCount = rankCounts.get(rank) ?? 0;

      // Priority based on how close we are to completing a book
      if (cardCount === 3) {
        score += 10; // 1 card away - highest priority
      } else if (cardCount === 2) {
        score += 5; // 2 cards away - good priority
      } else if (cardCount === 1) {
        score += 2; // Just started - low priority
      }
    }

    if (targetPosition !== undefined) {
      const target = goFishGame.getPlayer(targetPosition) as GoFishPlayer;
      const targetHandSize = getHandSize(goFishGame, target);

      // Bonus for targeting opponents with more cards
      score += Math.min(3, targetHandSize / 4);
    }

    scoredMoves.push({ move, score });
  }

  // Sort by score descending (highest priority first)
  scoredMoves.sort((a, b) => b.score - a.score);

  return scoredMoves.map(sm => sm.move);
}

// === HOOK 5: UCT CONSTANT ===

/**
 * Phase-based UCT exploration constant for Go Fish
 *
 * Adjusts exploration vs exploitation based on game progress:
 * - Early game (0-4 books formed): C=1.4 for moderate exploration
 * - Mid game (5-9 books formed): C=sqrt(2) for balanced play
 * - Late game (10+ books formed): C=1.0 for focused exploitation
 *
 * @param game - Current game state
 * @param playerIndex - Which player the bot is (1-indexed)
 * @returns UCT exploration constant
 */
export function getGoFishUctConstant(
  game: Game,
  playerIndex: number
): number {
  const goFishGame = game as GoFishGame;

  // Calculate game progress based on total books formed
  const totalBooks = goFishGame.getTotalBooks();
  const progress = totalBooks / 13;

  // Phase-based UCT constant
  if (progress < 0.35) {
    // Early game: explore different strategies
    return 1.4;
  }
  if (progress < 0.75) {
    // Mid game: balanced exploration/exploitation
    return Math.sqrt(2);
  }
  // Late game: focus on winning moves
  return 1.0;
}
