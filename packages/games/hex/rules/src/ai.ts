// AI evaluation functions for Hex
// Generated by /generate-ai slash command

import type { Game } from '@boardsmith/engine';
import type { Objective, BotMove, ThreatResponse } from '@boardsmith/ai';
import type { HexGame } from './game.js';
import { Cell, Stone, HexPlayer } from './elements.js';

/**
 * Hex direction offsets for axial coordinates (q, r)
 */
const HEX_DIRECTIONS = [
  { dq: 1, dr: 0 },   // East
  { dq: 1, dr: -1 },  // Northeast
  { dq: 0, dr: -1 },  // Northwest
  { dq: -1, dr: 0 },  // West
  { dq: -1, dr: 1 },  // Southwest
  { dq: 0, dr: 1 },   // Southeast
];

/**
 * Compute the shortest path length from a player's start edge to goal edge.
 * Uses Dijkstra's algorithm with costs:
 * - Friendly stone = 0 (free passage)
 * - Empty cell = 1 (need to place a stone)
 * - Enemy stone = Infinity (blocked)
 *
 * @returns Number of empty cells needed to complete path, or Infinity if blocked
 */
function computeShortestPathLength(
  game: HexGame,
  playerPosition: number
): number {
  const boardSize = game.boardSize;
  const players = [...game.all(HexPlayer)];
  // playerPosition is 1-indexed (1 or 2), find by position property
  const myPlayer = players.find(p => p.position === playerPosition);
  if (!myPlayer) return Infinity;

  // In Hex:
  // - Player 1 (Red, position 1, index 0) connects r=0 to r=boardSize-1
  // - Player 2 (Blue, position 2, index 1) connects q=0 to q=boardSize-1
  const isRed = myPlayer.position === 1;

  // Build lookup map of all cells
  const cells = new Map<string, Cell>();
  const cellKey = (q: number, r: number) => `${q},${r}`;

  for (const cell of game.board.all(Cell)) {
    cells.set(cellKey(cell.q, cell.r), cell);
  }

  // Determine start/goal edges
  const isStartCell = (q: number, r: number): boolean => {
    return isRed ? r === 0 : q === 0;
  };

  const isGoalCell = (q: number, r: number): boolean => {
    return isRed ? r === boardSize - 1 : q === boardSize - 1;
  };

  // Get cost to traverse a cell
  const getCellCost = (cell: Cell): number => {
    const stone = cell.getStone();
    if (!stone) return 1; // Empty - costs 1 move
    if (stone.player === myPlayer) return 0; // Ours - free
    return Infinity; // Opponent - blocked
  };

  // Initialize distances
  const distances = new Map<string, number>();
  const queue: Array<{ key: string; dist: number }> = [];

  // Start from all cells on start edge
  for (const [key, cell] of cells) {
    if (isStartCell(cell.q, cell.r)) {
      const cost = getCellCost(cell);
      if (cost !== Infinity) {
        distances.set(key, cost);
        queue.push({ key, dist: cost });
      }
    }
  }

  if (queue.length === 0) return Infinity;

  queue.sort((a, b) => a.dist - b.dist);
  const visited = new Set<string>();

  // Dijkstra's algorithm
  while (queue.length > 0) {
    const current = queue.shift()!;
    const { key, dist } = current;

    if (visited.has(key)) continue;
    visited.add(key);

    const [qStr, rStr] = key.split(',');
    const q = parseInt(qStr, 10);
    const r = parseInt(rStr, 10);

    // Check if we reached the goal
    if (isGoalCell(q, r)) {
      return dist;
    }

    // Explore neighbors
    for (const dir of HEX_DIRECTIONS) {
      const nq = q + dir.dq;
      const nr = r + dir.dr;
      const neighborKey = cellKey(nq, nr);

      if (visited.has(neighborKey)) continue;

      const neighborCell = cells.get(neighborKey);
      if (!neighborCell) continue;

      const moveCost = getCellCost(neighborCell);
      if (moveCost === Infinity) continue;

      const newDist = dist + moveCost;
      const currentDist = distances.get(neighborKey) ?? Infinity;

      if (newDist < currentDist) {
        distances.set(neighborKey, newDist);
        queue.push({ key: neighborKey, dist: newDist });
        queue.sort((a, b) => a.dist - b.dist);
      }
    }
  }

  return Infinity; // No path found
}

/**
 * Find empty cells on the opponent's shortest path that can be blocked.
 * Uses Dijkstra's algorithm with path tracking.
 *
 * @returns Array of cell IDs that are empty and on the shortest path
 */
function findBlockingCells(
  game: HexGame,
  opponentPosition: number
): number[] {
  const boardSize = game.boardSize;
  const players = [...game.all(HexPlayer)];
  const opponent = players.find(p => p.position === opponentPosition);
  if (!opponent) return [];

  // In Hex:
  // - Player 1 (Red, position 1) connects r=0 to r=boardSize-1
  // - Player 2 (Blue, position 2) connects q=0 to q=boardSize-1
  const isRed = opponent.position === 1;

  // Build lookup map of all cells
  const cells = new Map<string, Cell>();
  const cellKey = (q: number, r: number) => `${q},${r}`;

  for (const cell of game.board.all(Cell)) {
    cells.set(cellKey(cell.q, cell.r), cell);
  }

  // Determine start/goal edges for opponent
  const isStartCell = (q: number, r: number): boolean => {
    return isRed ? r === 0 : q === 0;
  };

  const isGoalCell = (q: number, r: number): boolean => {
    return isRed ? r === boardSize - 1 : q === boardSize - 1;
  };

  // Get cost to traverse a cell (from opponent's perspective)
  const getCellCost = (cell: Cell): number => {
    const stone = cell.getStone();
    if (!stone) return 1; // Empty - costs 1 move
    if (stone.player === opponent) return 0; // Opponent's stone - free
    return Infinity; // Our stone - blocked for opponent
  };

  // Initialize distances and predecessors for path reconstruction
  const distances = new Map<string, number>();
  const predecessors = new Map<string, string | null>();
  const queue: Array<{ key: string; dist: number }> = [];

  // Start from all cells on opponent's start edge
  for (const [key, cell] of cells) {
    if (isStartCell(cell.q, cell.r)) {
      const cost = getCellCost(cell);
      if (cost !== Infinity) {
        distances.set(key, cost);
        predecessors.set(key, null); // Start cells have no predecessor
        queue.push({ key, dist: cost });
      }
    }
  }

  if (queue.length === 0) return [];

  queue.sort((a, b) => a.dist - b.dist);
  const visited = new Set<string>();
  let goalKey: string | null = null;

  // Dijkstra's algorithm
  while (queue.length > 0) {
    const current = queue.shift()!;
    const { key, dist } = current;

    if (visited.has(key)) continue;
    visited.add(key);

    const [qStr, rStr] = key.split(',');
    const q = parseInt(qStr, 10);
    const r = parseInt(rStr, 10);

    // Check if we reached the goal
    if (isGoalCell(q, r)) {
      goalKey = key;
      break;
    }

    // Explore neighbors
    for (const dir of HEX_DIRECTIONS) {
      const nq = q + dir.dq;
      const nr = r + dir.dr;
      const neighborKey = cellKey(nq, nr);

      if (visited.has(neighborKey)) continue;

      const neighborCell = cells.get(neighborKey);
      if (!neighborCell) continue;

      const moveCost = getCellCost(neighborCell);
      if (moveCost === Infinity) continue;

      const newDist = dist + moveCost;
      const currentDist = distances.get(neighborKey) ?? Infinity;

      if (newDist < currentDist) {
        distances.set(neighborKey, newDist);
        predecessors.set(neighborKey, key);
        queue.push({ key: neighborKey, dist: newDist });
        queue.sort((a, b) => a.dist - b.dist);
      }
    }
  }

  // No path found
  if (!goalKey) return [];

  // Reconstruct path and find empty cells (blocking opportunities)
  const blockingCellIds: number[] = [];
  let current: string | null = goalKey;

  while (current !== null) {
    const cell = cells.get(current);
    if (cell) {
      const stone = cell.getStone();
      // If cell is empty, it's a blocking opportunity
      if (!stone) {
        blockingCellIds.push(cell.id);
      }
    }
    current = predecessors.get(current) ?? null;
  }

  return blockingCellIds;
}

/**
 * Get threat response moves for Hex.
 * When opponent has a short path, returns moves that block their shortest path.
 *
 * Returns { moves, urgent }:
 * - urgent=true when opponent is 1-2 moves from winning (MUST block)
 * - urgent=false when opponent is 3-5 moves from winning (should consider blocking)
 *
 * @param game - Current game state
 * @param playerPosition - Which player the bot is (1-indexed position)
 * @param availableMoves - All legal moves at this position
 * @returns ThreatResponse with blocking moves and urgency flag
 */
export function getHexThreatResponseMoves(
  game: Game,
  playerPosition: number,
  availableMoves: BotMove[]
): ThreatResponse {
  const hexGame = game as HexGame;
  const opponentPosition = 3 - playerPosition;

  // Check if opponent is close to winning
  const opponentPath = computeShortestPathLength(hexGame, opponentPosition);

  // Trigger threat response when opponent has a relatively short path
  // On an 11x11 board, a straight line from start to goal needs 11 cells
  // We want to start blocking once opponent has made real progress
  // Using boardSize/2 means we block when opponent is halfway to winning
  const threatThreshold = Math.floor(hexGame.boardSize / 2);
  if (opponentPath > threatThreshold) {
    return { moves: [], urgent: false };
  }

  // Find blocking cells on opponent's shortest path
  const blockingCellIds = findBlockingCells(hexGame, opponentPosition);

  if (blockingCellIds.length === 0) {
    return { moves: [], urgent: false };
  }

  // Convert to set for fast lookup
  const blockingIdSet = new Set(blockingCellIds);

  // Filter available moves to only those that place stones on blocking cells
  // Move args contain 'cell' which is the cell ID
  const blockingMoves = availableMoves.filter(move => {
    const cellId = move.args.cell as number | undefined;
    return cellId !== undefined && blockingIdSet.has(cellId);
  });

  // Determine urgency: opponent within 2 moves of winning = MUST block
  const urgent = opponentPath <= 2;

  return { moves: blockingMoves, urgent };
}

/**
 * Count connected groups of a player's stones using flood fill.
 * Fewer groups = more connected = closer to winning.
 */
function countConnectedGroups(game: HexGame, playerPosition: number): number {
  const players = [...game.all(HexPlayer)];
  // playerPosition is 1-indexed (1 or 2), find by position property
  const player = players.find(p => p.position === playerPosition);
  if (!player) return 0;

  // Build set of player's stone positions
  const playerPositions = new Set<string>();
  const posKey = (q: number, r: number) => `${q},${r}`;

  for (const cell of game.board.all(Cell)) {
    const stone = cell.getStone();
    if (stone && stone.player === player) {
      playerPositions.add(posKey(cell.q, cell.r));
    }
  }

  if (playerPositions.size === 0) return 0;

  const visited = new Set<string>();
  let groupCount = 0;

  for (const pos of playerPositions) {
    if (visited.has(pos)) continue;

    // BFS flood fill
    const queue = [pos];
    visited.add(pos);

    while (queue.length > 0) {
      const current = queue.shift()!;
      const [qStr, rStr] = current.split(',');
      const q = parseInt(qStr, 10);
      const r = parseInt(rStr, 10);

      for (const dir of HEX_DIRECTIONS) {
        const neighborKey = posKey(q + dir.dq, r + dir.dr);
        if (playerPositions.has(neighborKey) && !visited.has(neighborKey)) {
          visited.add(neighborKey);
          queue.push(neighborKey);
        }
      }
    }

    groupCount++;
  }

  return groupCount;
}

/**
 * AI objectives for Hex
 * These guide the MCTS bot to prefer better positions during playouts
 */
export function getHexObjectives(
  game: Game,
  playerPosition: number
): Record<string, Objective> {
  const hexGame = game as HexGame;
  const players = [...hexGame.all(HexPlayer)];
  // playerPosition is 1-indexed (1 or 2), find by position property
  const player = players.find(p => p.position === playerPosition);
  const opponentPosition = 3 - playerPosition; // If player is 1, opponent is 2; if player is 2, opponent is 1
  const opponent = players.find(p => p.position === opponentPosition);

  return {
    // KEY FEATURE: Player has shorter path to victory than opponent
    // This is the most important evaluation for connection games
    'path-distance-advantage': {
      checker: () => {
        const myPath = computeShortestPathLength(hexGame, playerPosition);
        const theirPath = computeShortestPathLength(hexGame, opponentPosition);
        return myPath < theirPath;
      },
      weight: 10,
    },

    // Near-win: Player is within 1 stone of winning
    'near-win-within-1': {
      checker: () => {
        const pathLength = computeShortestPathLength(hexGame, playerPosition);
        return pathLength <= 1;
      },
      weight: 8,
    },

    // Near-win: Player is within 2 stones of winning
    'near-win-within-2': {
      checker: () => {
        const pathLength = computeShortestPathLength(hexGame, playerPosition);
        return pathLength <= 2;
      },
      weight: 5,
    },

    // Near-win: Player is within 3 stones of winning
    'near-win-within-3': {
      checker: () => {
        const pathLength = computeShortestPathLength(hexGame, playerPosition);
        return pathLength <= 3;
      },
      weight: 3,
    },

    // Opponent path blocked: Opponent has no viable path to win
    // This is nearly a win condition
    'opponent-path-blocked': {
      checker: () => {
        const opponentPath = computeShortestPathLength(hexGame, opponentPosition);
        return opponentPath === Infinity;
      },
      weight: 9,
    },

    // Opponent threat: Opponent is close to winning (negative weight - we want to avoid this)
    // This encourages blocking behavior
    'opponent-near-win': {
      checker: () => {
        const opponentPath = computeShortestPathLength(hexGame, opponentPosition);
        return opponentPath <= 2;
      },
      weight: -6,
    },

    // Connectivity: Player has fewer disconnected groups (more connected)
    // In connection games, consolidating stones into one connected path is key
    'fewer-groups': {
      checker: () => {
        const myGroups = countConnectedGroups(hexGame, playerPosition);
        const theirGroups = countConnectedGroups(hexGame, opponentPosition);
        // Fewer groups is better, but only if we have stones
        if (myGroups === 0) return false;
        if (theirGroups === 0) return true;
        return myGroups < theirGroups;
      },
      weight: 2,
    },

    // Single connected group: All player's stones are connected
    'single-group': {
      checker: () => {
        const groups = countConnectedGroups(hexGame, playerPosition);
        const stoneCount = [...hexGame.board.all(Cell)]
          .filter(c => c.getStone()?.player === player)
          .length;
        // Must have stones and they must all be in one group
        return stoneCount > 0 && groups === 1;
      },
      weight: 1,
    },
  };
}
