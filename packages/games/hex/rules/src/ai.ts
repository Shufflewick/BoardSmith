// AI evaluation functions for Hex
// Generated by /generate-ai slash command

import type { Game } from '@boardsmith/engine';
import type { Objective, BotMove, ThreatResponse } from '@boardsmith/ai';
import type { HexGame } from './game.js';
import { Cell, Stone, HexPlayer } from './elements.js';

/**
 * Hex direction offsets for axial coordinates (q, r)
 */
const HEX_DIRECTIONS = [
  { dq: 1, dr: 0 },   // East
  { dq: 1, dr: -1 },  // Northeast
  { dq: 0, dr: -1 },  // Northwest
  { dq: -1, dr: 0 },  // West
  { dq: -1, dr: 1 },  // Southwest
  { dq: 0, dr: 1 },   // Southeast
];

/**
 * Compute the shortest path length from a player's start edge to goal edge.
 * Uses Dijkstra's algorithm with costs:
 * - Friendly stone = 0 (free passage)
 * - Empty cell = 1 (need to place a stone)
 * - Enemy stone = Infinity (blocked)
 *
 * @returns Number of empty cells needed to complete path, or Infinity if blocked
 */
function computeShortestPathLength(
  game: HexGame,
  playerPosition: number
): number {
  const boardSize = game.boardSize;
  const players = [...game.all(HexPlayer)];
  // playerPosition is 1-indexed (1 or 2), find by position property
  const myPlayer = players.find(p => p.position === playerPosition);
  if (!myPlayer) return Infinity;

  // In Hex:
  // - Player 1 (Red, position 1, index 0) connects r=0 to r=boardSize-1
  // - Player 2 (Blue, position 2, index 1) connects q=0 to q=boardSize-1
  const isRed = myPlayer.position === 1;

  // Build lookup map of all cells
  const cells = new Map<string, Cell>();
  const cellKey = (q: number, r: number) => `${q},${r}`;

  for (const cell of game.board.all(Cell)) {
    cells.set(cellKey(cell.q, cell.r), cell);
  }

  // Determine start/goal edges
  const isStartCell = (q: number, r: number): boolean => {
    return isRed ? r === 0 : q === 0;
  };

  const isGoalCell = (q: number, r: number): boolean => {
    return isRed ? r === boardSize - 1 : q === boardSize - 1;
  };

  // Get cost to traverse a cell
  const getCellCost = (cell: Cell): number => {
    const stone = cell.getStone();
    if (!stone) return 1; // Empty - costs 1 move
    if (stone.player === myPlayer) return 0; // Ours - free
    return Infinity; // Opponent - blocked
  };

  // Initialize distances
  const distances = new Map<string, number>();
  const queue: Array<{ key: string; dist: number }> = [];

  // Start from all cells on start edge
  for (const [key, cell] of cells) {
    if (isStartCell(cell.q, cell.r)) {
      const cost = getCellCost(cell);
      if (cost !== Infinity) {
        distances.set(key, cost);
        queue.push({ key, dist: cost });
      }
    }
  }

  if (queue.length === 0) return Infinity;

  queue.sort((a, b) => a.dist - b.dist);
  const visited = new Set<string>();

  // Dijkstra's algorithm
  while (queue.length > 0) {
    const current = queue.shift()!;
    const { key, dist } = current;

    if (visited.has(key)) continue;
    visited.add(key);

    const [qStr, rStr] = key.split(',');
    const q = parseInt(qStr, 10);
    const r = parseInt(rStr, 10);

    // Check if we reached the goal
    if (isGoalCell(q, r)) {
      return dist;
    }

    // Explore neighbors
    for (const dir of HEX_DIRECTIONS) {
      const nq = q + dir.dq;
      const nr = r + dir.dr;
      const neighborKey = cellKey(nq, nr);

      if (visited.has(neighborKey)) continue;

      const neighborCell = cells.get(neighborKey);
      if (!neighborCell) continue;

      const moveCost = getCellCost(neighborCell);
      if (moveCost === Infinity) continue;

      const newDist = dist + moveCost;
      const currentDist = distances.get(neighborKey) ?? Infinity;

      if (newDist < currentDist) {
        distances.set(neighborKey, newDist);
        queue.push({ key: neighborKey, dist: newDist });
        queue.sort((a, b) => a.dist - b.dist);
      }
    }
  }

  return Infinity; // No path found
}

/**
 * Find empty cells on ANY of the opponent's shortest paths that can be blocked.
 * Uses bidirectional Dijkstra to find ALL cells that lie on some optimal path.
 *
 * A cell is on a shortest path if:
 *   distFromStart[cell] + distToGoal[cell] == shortestPathLength
 *
 * This ensures we find blocking opportunities on ALL optimal paths,
 * not just the first one Dijkstra happens to find.
 *
 * @returns Array of cell IDs that are empty and on some shortest path
 */
function findBlockingCells(
  game: HexGame,
  opponentPosition: number
): number[] {
  const boardSize = game.boardSize;
  const players = [...game.all(HexPlayer)];
  const opponent = players.find(p => p.position === opponentPosition);
  if (!opponent) return [];

  // In Hex:
  // - Player 1 (Red, position 1) connects r=0 to r=boardSize-1
  // - Player 2 (Blue, position 2) connects q=0 to q=boardSize-1
  const isRed = opponent.position === 1;

  // Build lookup map of all cells
  const cells = new Map<string, Cell>();
  const cellKey = (q: number, r: number) => `${q},${r}`;

  for (const cell of game.board.all(Cell)) {
    cells.set(cellKey(cell.q, cell.r), cell);
  }

  // Determine start/goal edges for opponent
  const isStartCell = (q: number, r: number): boolean => {
    return isRed ? r === 0 : q === 0;
  };

  const isGoalCell = (q: number, r: number): boolean => {
    return isRed ? r === boardSize - 1 : q === boardSize - 1;
  };

  // Get cost to traverse a cell (from opponent's perspective)
  const getCellCost = (cell: Cell): number => {
    const stone = cell.getStone();
    if (!stone) return 1; // Empty - costs 1 move
    if (stone.player === opponent) return 0; // Opponent's stone - free
    return Infinity; // Our stone - blocked for opponent
  };

  // Run Dijkstra from start edge
  const distFromStart = new Map<string, number>();
  const queue: Array<{ key: string; dist: number }> = [];

  for (const [key, cell] of cells) {
    if (isStartCell(cell.q, cell.r)) {
      const cost = getCellCost(cell);
      if (cost !== Infinity) {
        distFromStart.set(key, cost);
        queue.push({ key, dist: cost });
      }
    }
  }

  if (queue.length === 0) return [];

  queue.sort((a, b) => a.dist - b.dist);
  const visitedFromStart = new Set<string>();

  while (queue.length > 0) {
    const current = queue.shift()!;
    const { key, dist } = current;

    if (visitedFromStart.has(key)) continue;
    visitedFromStart.add(key);

    const [qStr, rStr] = key.split(',');
    const q = parseInt(qStr, 10);
    const r = parseInt(rStr, 10);

    for (const dir of HEX_DIRECTIONS) {
      const nq = q + dir.dq;
      const nr = r + dir.dr;
      const neighborKey = cellKey(nq, nr);

      if (visitedFromStart.has(neighborKey)) continue;

      const neighborCell = cells.get(neighborKey);
      if (!neighborCell) continue;

      const moveCost = getCellCost(neighborCell);
      if (moveCost === Infinity) continue;

      const newDist = dist + moveCost;
      const currentDist = distFromStart.get(neighborKey) ?? Infinity;

      if (newDist < currentDist) {
        distFromStart.set(neighborKey, newDist);
        queue.push({ key: neighborKey, dist: newDist });
        queue.sort((a, b) => a.dist - b.dist);
      }
    }
  }

  // Run Dijkstra from goal edge (backwards)
  const distToGoal = new Map<string, number>();
  const goalQueue: Array<{ key: string; dist: number }> = [];

  for (const [key, cell] of cells) {
    if (isGoalCell(cell.q, cell.r)) {
      const cost = getCellCost(cell);
      if (cost !== Infinity) {
        distToGoal.set(key, cost);
        goalQueue.push({ key, dist: cost });
      }
    }
  }

  if (goalQueue.length === 0) return [];

  goalQueue.sort((a, b) => a.dist - b.dist);
  const visitedFromGoal = new Set<string>();

  while (goalQueue.length > 0) {
    const current = goalQueue.shift()!;
    const { key, dist } = current;

    if (visitedFromGoal.has(key)) continue;
    visitedFromGoal.add(key);

    const [qStr, rStr] = key.split(',');
    const q = parseInt(qStr, 10);
    const r = parseInt(rStr, 10);

    for (const dir of HEX_DIRECTIONS) {
      const nq = q + dir.dq;
      const nr = r + dir.dr;
      const neighborKey = cellKey(nq, nr);

      if (visitedFromGoal.has(neighborKey)) continue;

      const neighborCell = cells.get(neighborKey);
      if (!neighborCell) continue;

      const moveCost = getCellCost(neighborCell);
      if (moveCost === Infinity) continue;

      const newDist = dist + moveCost;
      const currentDist = distToGoal.get(neighborKey) ?? Infinity;

      if (newDist < currentDist) {
        distToGoal.set(neighborKey, newDist);
        goalQueue.push({ key: neighborKey, dist: newDist });
        goalQueue.sort((a, b) => a.dist - b.dist);
      }
    }
  }

  // Find shortest path length
  let shortestPath = Infinity;
  for (const [key] of cells) {
    const fromStart = distFromStart.get(key);
    const toGoal = distToGoal.get(key);
    if (fromStart !== undefined && toGoal !== undefined) {
      // The cell's cost is counted in both directions, so subtract it once
      const cell = cells.get(key)!;
      const cellCost = getCellCost(cell);
      const pathThrough = fromStart + toGoal - cellCost;
      shortestPath = Math.min(shortestPath, pathThrough);
    }
  }

  if (shortestPath === Infinity) return [];

  // Find all empty cells on any shortest path
  const blockingCellIds: number[] = [];

  for (const [key, cell] of cells) {
    const stone = cell.getStone();
    if (stone) continue; // Skip cells with stones

    const fromStart = distFromStart.get(key);
    const toGoal = distToGoal.get(key);
    if (fromStart === undefined || toGoal === undefined) continue;

    // Cell cost is 1 for empty cells
    const pathThrough = fromStart + toGoal - 1;
    if (pathThrough === shortestPath) {
      blockingCellIds.push(cell.id);
    }
  }

  return blockingCellIds;
}

/**
 * Get threat response moves for Hex.
 * When opponent has a short path, returns moves that block their shortest path.
 *
 * Returns { moves, urgent }:
 * - urgent=true when opponent is 1-2 moves from winning (MUST block)
 * - urgent=false when opponent is 3-5 moves from winning (should consider blocking)
 *
 * @param game - Current game state
 * @param playerPosition - Which player the bot is (1-indexed position)
 * @param availableMoves - All legal moves at this position
 * @returns ThreatResponse with blocking moves and urgency flag
 */
export function getHexThreatResponseMoves(
  game: Game,
  playerPosition: number,
  availableMoves: BotMove[]
): ThreatResponse {
  const hexGame = game as HexGame;
  const opponentPosition = 3 - playerPosition;

  // Check if opponent is close to winning
  const opponentPath = computeShortestPathLength(hexGame, opponentPosition);

  // Trigger threat response when opponent has a relatively short path
  // On an 11x11 board, a straight line from start to goal needs 11 cells
  // We want to start blocking once opponent has placed 2-3 stones and is building a real threat
  // Using boardSize - 3 means we block once opponent has placed ~3 stones
  // This gives us time to block before they're too close to winning
  const threatThreshold = hexGame.boardSize - 3;

  if (opponentPath > threatThreshold) {
    return { moves: [], urgent: false };
  }

  // Find blocking cells on opponent's shortest path
  const blockingCellIds = findBlockingCells(hexGame, opponentPosition);

  if (blockingCellIds.length === 0) {
    return { moves: [], urgent: false };
  }

  // Convert to set for fast lookup
  const blockingIdSet = new Set(blockingCellIds);

  // Filter available moves to only those that place stones on blocking cells
  const blockingMoves = availableMoves.filter(move => {
    const cellId = move.args.cell as number | undefined;
    return cellId !== undefined && blockingIdSet.has(cellId);
  });

  // Determine urgency: opponent within 4 moves of winning = MUST block
  const urgent = opponentPath <= 4;

  return { moves: blockingMoves, urgent };
}

/**
 * Count connected groups of a player's stones using flood fill.
 * Fewer groups = more connected = closer to winning.
 */
function countConnectedGroups(game: HexGame, playerPosition: number): number {
  const players = [...game.all(HexPlayer)];
  // playerPosition is 1-indexed (1 or 2), find by position property
  const player = players.find(p => p.position === playerPosition);
  if (!player) return 0;

  // Build set of player's stone positions
  const playerPositions = new Set<string>();
  const posKey = (q: number, r: number) => `${q},${r}`;

  for (const cell of game.board.all(Cell)) {
    const stone = cell.getStone();
    if (stone && stone.player === player) {
      playerPositions.add(posKey(cell.q, cell.r));
    }
  }

  if (playerPositions.size === 0) return 0;

  const visited = new Set<string>();
  let groupCount = 0;

  for (const pos of playerPositions) {
    if (visited.has(pos)) continue;

    // BFS flood fill
    const queue = [pos];
    visited.add(pos);

    while (queue.length > 0) {
      const current = queue.shift()!;
      const [qStr, rStr] = current.split(',');
      const q = parseInt(qStr, 10);
      const r = parseInt(rStr, 10);

      for (const dir of HEX_DIRECTIONS) {
        const neighborKey = posKey(q + dir.dq, r + dir.dr);
        if (playerPositions.has(neighborKey) && !visited.has(neighborKey)) {
          visited.add(neighborKey);
          queue.push(neighborKey);
        }
      }
    }

    groupCount++;
  }

  return groupCount;
}

/**
 * AI objectives for Hex
 * These guide the MCTS bot to prefer better positions during playouts
 */
export function getHexObjectives(
  game: Game,
  playerPosition: number
): Record<string, Objective> {
  const hexGame = game as HexGame;
  const players = [...hexGame.all(HexPlayer)];
  // playerPosition is 1-indexed (1 or 2), find by position property
  const player = players.find(p => p.position === playerPosition);
  const opponentPosition = 3 - playerPosition; // If player is 1, opponent is 2; if player is 2, opponent is 1
  const opponent = players.find(p => p.position === opponentPosition);

  return {
    // KEY FEATURE: Player has shorter path to victory than opponent
    // This is the most important evaluation for connection games
    // Gradient: 0.5 = tied, 1.0 = max advantage, 0.0 = max disadvantage
    'path-distance-advantage': {
      checker: () => {
        const myPath = computeShortestPathLength(hexGame, playerPosition);
        const theirPath = computeShortestPathLength(hexGame, opponentPosition);
        // Handle infinity cases
        if (myPath === Infinity && theirPath === Infinity) return 0.5;
        if (myPath === Infinity) return 0.0;
        if (theirPath === Infinity) return 1.0;
        // Gradient based on relative path lengths
        const advantage = theirPath - myPath;
        const maxAdvantage = hexGame.boardSize;
        return Math.max(0, Math.min(1, (advantage + maxAdvantage) / (2 * maxAdvantage)));
      },
      weight: 10,
    },

    // Near-win: Player is within 1 stone of winning
    // Gradient: 1.0 = won, 0.0 = boardSize away, linear in between
    'near-win-within-1': {
      checker: () => {
        const pathLength = computeShortestPathLength(hexGame, playerPosition);
        if (pathLength === Infinity) return 0.0;
        const maxPath = hexGame.boardSize;
        return Math.max(0, 1 - pathLength / maxPath);
      },
      weight: 8,
    },

    // Near-win: Player is within 2 stones of winning
    // Gradient: 1.0 = won, 0.0 = boardSize away, linear in between
    'near-win-within-2': {
      checker: () => {
        const pathLength = computeShortestPathLength(hexGame, playerPosition);
        if (pathLength === Infinity) return 0.0;
        const maxPath = hexGame.boardSize;
        return Math.max(0, 1 - pathLength / maxPath);
      },
      weight: 5,
    },

    // Near-win: Player is within 3 stones of winning
    // Gradient: 1.0 = won, 0.0 = boardSize away, linear in between
    'near-win-within-3': {
      checker: () => {
        const pathLength = computeShortestPathLength(hexGame, playerPosition);
        if (pathLength === Infinity) return 0.0;
        const maxPath = hexGame.boardSize;
        return Math.max(0, 1 - pathLength / maxPath);
      },
      weight: 3,
    },

    // Opponent path blocked: Opponent has no viable path to win
    // This is nearly a win condition
    // Gradient: 1.0 = blocked (Infinity), scales with how far opponent is from winning
    'opponent-path-blocked': {
      checker: () => {
        const opponentPath = computeShortestPathLength(hexGame, opponentPosition);
        if (opponentPath === Infinity) return 1.0;
        const maxPath = hexGame.boardSize;
        return Math.min(1, opponentPath / maxPath);
      },
      weight: 9,
    },

    // Opponent threat: Opponent is close to winning (negative weight - we want to avoid this)
    // This encourages blocking behavior
    // Gradient: 1.0 = opponent won, 0.0 = opponent far from winning
    // Negative weight makes high values bad for us
    'opponent-near-win': {
      checker: () => {
        const opponentPath = computeShortestPathLength(hexGame, opponentPosition);
        if (opponentPath === Infinity) return 0.0;
        const maxPath = hexGame.boardSize;
        return Math.max(0, 1 - opponentPath / maxPath);
      },
      weight: -6,
    },

    // Connectivity: Player has fewer disconnected groups (more connected)
    // In connection games, consolidating stones into one connected path is key
    // Gradient: 1.0 = opponent has many groups, 0.0 = we have many groups
    'fewer-groups': {
      checker: () => {
        const myGroups = countConnectedGroups(hexGame, playerPosition);
        const theirGroups = countConnectedGroups(hexGame, opponentPosition);
        if (myGroups === 0 && theirGroups === 0) return 0.5;
        if (myGroups === 0) return 0.0;
        if (theirGroups === 0) return 1.0;
        return theirGroups / (myGroups + theirGroups);
      },
      weight: 2,
    },

    // Single connected group: All player's stones are connected
    // Gradient: 1.0 for single group, 0.5 for two groups, etc.
    'single-group': {
      checker: () => {
        const groups = countConnectedGroups(hexGame, playerPosition);
        const stoneCount = [...hexGame.board.all(Cell)]
          .filter(c => c.getStone()?.player === player)
          .length;
        if (stoneCount === 0) return 0.0;
        return 1 / groups;
      },
      weight: 1,
    },
  };
}

/**
 * Smart playout policy for Hex.
 * Instead of random moves, prefer moves that:
 * - Shorten our winning path
 * - Lengthen opponent's winning path
 * - Are adjacent to our existing stones (connectivity)
 *
 * Uses weighted random selection (not deterministic) to maintain exploration.
 *
 * @param game - Current game state
 * @param playerIndex - Which player is moving (1-indexed position)
 * @param availableMoves - Legal moves to choose from
 * @param rng - Random number generator for weighted selection
 * @returns Selected move using weighted-random selection
 */
export function getHexPlayoutPolicy(
  game: Game,
  playerIndex: number,
  availableMoves: BotMove[],
  rng: () => number
): BotMove {
  if (availableMoves.length === 0) {
    throw new Error('No available moves for playout policy');
  }

  if (availableMoves.length === 1) {
    return availableMoves[0];
  }

  const hexGame = game as HexGame;
  const opponentIndex = 3 - playerIndex;

  // Get current path lengths
  const myPathBefore = computeShortestPathLength(hexGame, playerIndex);
  const theirPathBefore = computeShortestPathLength(hexGame, opponentIndex);

  // Build cell lookup for quick access
  const cellById = new Map<number, Cell>();
  for (const cell of hexGame.board.all(Cell)) {
    cellById.set(cell.id, cell);
  }

  // Get positions of our existing stones for connectivity bonus
  const myStonePositions = new Set<string>();
  const players = [...hexGame.all(HexPlayer)];
  const myPlayer = players.find(p => p.position === playerIndex);

  for (const cell of hexGame.board.all(Cell)) {
    const stone = cell.getStone();
    if (stone && stone.player === myPlayer) {
      myStonePositions.add(`${cell.q},${cell.r}`);
    }
  }

  // Score each move
  const scores: number[] = [];
  let maxScore = -Infinity;

  for (const move of availableMoves) {
    const cellId = move.args.cell as number | undefined;
    if (cellId === undefined) {
      scores.push(0);
      continue;
    }

    const cell = cellById.get(cellId);
    if (!cell) {
      scores.push(0);
      continue;
    }

    let score = 0;

    // Connectivity bonus: prefer moves adjacent to our existing stones
    // This helps build connected paths rather than scattered stones
    for (const dir of HEX_DIRECTIONS) {
      const neighborKey = `${cell.q + dir.dq},${cell.r + dir.dr}`;
      if (myStonePositions.has(neighborKey)) {
        score += 2;
      }
    }

    // Position bonus: prefer moves closer to center (early game diversity)
    const centerQ = Math.floor(hexGame.boardSize / 2);
    const centerR = Math.floor(hexGame.boardSize / 2);
    const distFromCenter = Math.abs(cell.q - centerQ) + Math.abs(cell.r - centerR);
    score += Math.max(0, hexGame.boardSize - distFromCenter) * 0.5;

    // Path-based scoring (simplified - don't simulate each move, too expensive)
    // Instead, prefer moves on our goal axis
    // Player 1 connects r=0 to r=boardSize-1, Player 2 connects q=0 to q=boardSize-1
    const isPlayer1 = playerIndex === 1;
    if (isPlayer1) {
      // Player 1 wants to advance in r direction
      // Prefer moves that are in the middle of our current r-range
      score += 1;
    } else {
      // Player 2 wants to advance in q direction
      score += 1;
    }

    // Blocking bonus: if opponent has a short path, prefer moves on their axis
    if (theirPathBefore < hexGame.boardSize / 2) {
      // Opponent is making progress - consider blocking
      if (isPlayer1) {
        // We're player 1, opponent connects q axis
        // Moves in middle q are more likely to block
        const qDistance = Math.abs(cell.q - centerQ);
        score += Math.max(0, (hexGame.boardSize / 2 - qDistance)) * 0.5;
      } else {
        // We're player 2, opponent connects r axis
        const rDistance = Math.abs(cell.r - centerR);
        score += Math.max(0, (hexGame.boardSize / 2 - rDistance)) * 0.5;
      }
    }

    scores.push(score);
    maxScore = Math.max(maxScore, score);
  }

  // Convert scores to weights using softmax-like transformation
  // Shift scores so max is 0, then exponentiate
  const weights: number[] = [];
  let totalWeight = 0;

  for (const score of scores) {
    // Use temperature of 1.0 - can adjust for more/less greediness
    const weight = Math.exp(score - maxScore);
    weights.push(weight);
    totalWeight += weight;
  }

  // Weighted random selection
  let target = rng() * totalWeight;
  for (let i = 0; i < availableMoves.length; i++) {
    target -= weights[i];
    if (target <= 0) {
      return availableMoves[i];
    }
  }

  // Fallback (shouldn't happen)
  return availableMoves[availableMoves.length - 1];
}

/**
 * Order moves for MCTS exploration.
 * Prioritizes:
 * 1. Moves adjacent to opponent's most recent stone (contest recent activity)
 * 2. Moves adjacent to own stones (build connectivity)
 * 3. Moves in central region (strategic positioning)
 * 4. Other moves (lower priority)
 *
 * This ordering helps MCTS find good moves faster by exploring promising
 * positions first, rather than randomly sampling the move space.
 *
 * @param game - Current game state
 * @param playerIndex - Which player the bot is (1-indexed position)
 * @param moves - Available moves to order
 * @returns Moves sorted by exploration priority (best first)
 */
export function getHexMoveOrdering(
  game: Game,
  playerIndex: number,
  moves: BotMove[]
): BotMove[] {
  if (moves.length <= 1) return moves;

  const hexGame = game as HexGame;
  const opponentIndex = 3 - playerIndex;

  // Build cell lookup
  const cellById = new Map<number, Cell>();
  for (const cell of hexGame.board.all(Cell)) {
    cellById.set(cell.id, cell);
  }

  // Find all player stones and their positions
  const players = [...hexGame.all(HexPlayer)];
  const myPlayer = players.find(p => p.position === playerIndex);
  const opponent = players.find(p => p.position === opponentIndex);

  const myStonePositions = new Set<string>();
  const opponentStonePositions = new Set<string>();
  const posKey = (q: number, r: number) => `${q},${r}`;

  // Track stones by placement order (highest id = most recent)
  let mostRecentOpponentStone: { q: number; r: number } | null = null;
  let maxOpponentStoneId = -1;

  for (const cell of hexGame.board.all(Cell)) {
    const stone = cell.getStone();
    if (!stone) continue;

    if (stone.player === myPlayer) {
      myStonePositions.add(posKey(cell.q, cell.r));
    } else if (stone.player === opponent) {
      opponentStonePositions.add(posKey(cell.q, cell.r));
      // Track most recent opponent stone by id (higher id = placed later)
      if (stone.id > maxOpponentStoneId) {
        maxOpponentStoneId = stone.id;
        mostRecentOpponentStone = { q: cell.q, r: cell.r };
      }
    }
  }

  // Center of the board for positioning bonus
  const centerQ = Math.floor(hexGame.boardSize / 2);
  const centerR = Math.floor(hexGame.boardSize / 2);
  const centerRadius = Math.floor(hexGame.boardSize / 4);

  // Score each move
  const scoredMoves: Array<{ move: BotMove; score: number }> = [];

  for (const move of moves) {
    const cellId = move.args.cell as number | undefined;
    if (cellId === undefined) {
      scoredMoves.push({ move, score: 0 });
      continue;
    }

    const cell = cellById.get(cellId);
    if (!cell) {
      scoredMoves.push({ move, score: 0 });
      continue;
    }

    let score = 1; // Base score

    // Check adjacencies to stones
    let adjacentToOpponentRecent = false;
    let adjacentToOpponent = false;
    let adjacentToOwn = false;

    for (const dir of HEX_DIRECTIONS) {
      const neighborKey = posKey(cell.q + dir.dq, cell.r + dir.dr);

      if (opponentStonePositions.has(neighborKey)) {
        adjacentToOpponent = true;
        // Check if adjacent to most recent opponent stone
        if (mostRecentOpponentStone &&
            cell.q + dir.dq === mostRecentOpponentStone.q &&
            cell.r + dir.dr === mostRecentOpponentStone.r) {
          adjacentToOpponentRecent = true;
        }
      }

      if (myStonePositions.has(neighborKey)) {
        adjacentToOwn = true;
      }
    }

    // Apply scoring bonuses
    if (adjacentToOpponentRecent) {
      score += 10; // Highest priority: contest opponent's most recent move
    }
    if (adjacentToOpponent) {
      score += 5; // Block/contest opponent territory
    }
    if (adjacentToOwn) {
      score += 3; // Build connectivity with own stones
    }

    // Center region bonus
    const distFromCenter = Math.abs(cell.q - centerQ) + Math.abs(cell.r - centerR);
    if (distFromCenter <= centerRadius) {
      score += 2; // Strategic central positioning
    }

    scoredMoves.push({ move, score });
  }

  // Sort by score descending (highest priority first)
  scoredMoves.sort((a, b) => b.score - a.score);

  return scoredMoves.map(sm => sm.move);
}
