import { readFileSync, existsSync } from 'node:fs';
import type { LearnedObjective } from './types.js';

/**
 * Parsed objective from an existing ai.ts file
 */
export interface ParsedObjective {
  id: string;
  description: string;
  weight: number;
  checkerCode: string;
}

/**
 * Parsed ai.ts file content
 */
export interface ParsedAIFile {
  /** Objectives found in the file */
  objectives: ParsedObjective[];
  /** Training metadata if present */
  metadata?: {
    gamesPlayed?: number;
    iterations?: number;
    winRate?: number;
  };
  /** Whether this was auto-generated or hand-written */
  isAutoGenerated: boolean;
}

/**
 * Parse an existing ai.ts file to extract objectives and metadata
 */
export function parseExistingAI(filePath: string): ParsedAIFile | null {
  if (!existsSync(filePath)) {
    return null;
  }

  try {
    const content = readFileSync(filePath, 'utf-8');
    return parseAIContent(content);
  } catch (error) {
    console.warn(`Warning: Could not parse existing ai.ts: ${error}`);
    return null;
  }
}

/**
 * Parse ai.ts file content
 */
function parseAIContent(content: string): ParsedAIFile {
  const objectives: ParsedObjective[] = [];
  const metadata: ParsedAIFile['metadata'] = {};

  // Check if auto-generated
  const isAutoGenerated = content.includes('AUTO-GENERATED by boardsmith');

  // Parse metadata from comments
  const gamesMatch = content.match(/Games played:\s*(\d+)/);
  if (gamesMatch) {
    metadata.gamesPlayed = parseInt(gamesMatch[1], 10);
  }

  const iterationsMatch = content.match(/Training iterations:\s*(\d+)/);
  if (iterationsMatch) {
    metadata.iterations = parseInt(iterationsMatch[1], 10);
  }

  const winRateMatch = content.match(/win rate.*?:\s*([\d.]+)%/i);
  if (winRateMatch) {
    metadata.winRate = parseFloat(winRateMatch[1]) / 100;
  }

  // Parse objectives from the return statement
  // Look for pattern: 'objective-id': { checker: ..., weight: N }
  const objectiveRegex = /'([^']+)':\s*\{[^}]*?checker:\s*(\([^)]*\)\s*(?:=>)?\s*(?:\{[\s\S]*?\}|[^,}]+))[^}]*?weight:\s*([-\d.]+)/g;

  let match;
  while ((match = objectiveRegex.exec(content)) !== null) {
    const id = match[1];
    const checkerCode = match[2].trim();
    const weight = parseFloat(match[3]);

    // Try to find description from comment above
    const beforeMatch = content.substring(0, match.index);
    const lines = beforeMatch.split('\n');
    let description = id;

    // Look for comment on previous lines
    for (let i = lines.length - 1; i >= Math.max(0, lines.length - 3); i--) {
      const line = lines[i].trim();
      if (line.startsWith('//') && !line.includes('Correlation')) {
        description = line.replace(/^\/\/\s*/, '');
        break;
      }
    }

    objectives.push({
      id,
      description,
      weight,
      checkerCode,
    });
  }

  return {
    objectives,
    metadata: Object.keys(metadata).length > 0 ? metadata : undefined,
    isAutoGenerated,
  };
}

/**
 * Convert parsed objectives to learned objectives format
 */
export function parsedToLearned(parsed: ParsedObjective[]): LearnedObjective[] {
  return parsed.map(p => ({
    featureId: p.id,
    description: p.description,
    weight: p.weight,
    checkerCode: p.checkerCode,
    correlation: 0, // Unknown from parsing
  }));
}

/**
 * Merge new objectives with existing ones
 * - Updates weights for existing objectives based on new training
 * - Adds new objectives that weren't in the original
 * - Keeps existing objectives that weren't re-discovered (with reduced weight)
 */
export function mergeObjectives(
  existing: LearnedObjective[],
  newObjectives: LearnedObjective[],
  options: {
    /** Weight for existing objectives that weren't re-discovered */
    decayFactor?: number;
    /** Blend ratio for objectives found in both (0 = all existing, 1 = all new) */
    blendRatio?: number;
  } = {}
): LearnedObjective[] {
  const { decayFactor = 0.8, blendRatio = 0.5 } = options;

  const merged = new Map<string, LearnedObjective>();
  const newIds = new Set(newObjectives.map(o => o.featureId));

  // Start with existing objectives
  for (const obj of existing) {
    if (newIds.has(obj.featureId)) {
      // Will be updated below
      continue;
    }
    // Decay weight for objectives not re-discovered
    merged.set(obj.featureId, {
      ...obj,
      weight: obj.weight * decayFactor,
    });
  }

  // Add/update with new objectives
  for (const newObj of newObjectives) {
    const existingObj = existing.find(e => e.featureId === newObj.featureId);

    if (existingObj) {
      // Blend weights
      const blendedWeight = existingObj.weight * (1 - blendRatio) + newObj.weight * blendRatio;
      merged.set(newObj.featureId, {
        ...newObj,
        weight: Math.round(blendedWeight * 10) / 10,
        // Use new correlation since it's from latest training
        correlation: newObj.correlation,
      });
    } else {
      // New objective
      merged.set(newObj.featureId, newObj);
    }
  }

  // Sort by absolute weight
  return [...merged.values()].sort((a, b) => Math.abs(b.weight) - Math.abs(a.weight));
}

/**
 * Get cumulative training stats
 */
export function getCumulativeStats(
  existingMetadata: ParsedAIFile['metadata'] | undefined,
  newStats: { gamesPlayed: number; iterations: number }
): { gamesPlayed: number; iterations: number } {
  return {
    gamesPlayed: (existingMetadata?.gamesPlayed ?? 0) + newStats.gamesPlayed,
    iterations: (existingMetadata?.iterations ?? 0) + newStats.iterations,
  };
}
