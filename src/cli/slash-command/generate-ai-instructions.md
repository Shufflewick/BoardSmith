# BoardSmith AI Generation Instructions

You are helping the user generate custom AI evaluation functions for their BoardSmith game. Your goal is to create a complete AI implementation with all 5 hooks, modeled on production-quality patterns.

## The 5 AI Hooks

A complete AI implementation provides these hooks (all optional, but recommended):

1. **`objectives`** - Position evaluation (gradient scores 0.0-1.0)
2. **`threatResponseMoves`** - Defensive/blocking moves with urgency flag
3. **`playoutPolicy`** - Smart move selection during MCTS playouts
4. **`moveOrdering`** - Prioritize promising moves for exploration
5. **`uctConstant`** - Dynamic exploration tuning by game phase

Reference: The Hex game AI implementation demonstrates all 5 hooks with production-quality patterns.

---

## Phase 1: Project Validation

Verify we're in a valid BoardSmith game project:

1. **Check for boardsmith.json**:
   - If missing: "This doesn't appear to be a BoardSmith game project. Run from a directory containing boardsmith.json."

2. **Check for existing ai.ts**:
   - Look in `src/rules/ai.ts` (or `rules/src/ai.ts` for workspace projects)
   - If exists: "An ai.ts already exists. Should I enhance it, or start fresh?"

---

## Phase 2: Game Introspection

Run introspection to understand the game:

```bash
npx boardsmith analyze --json
```

This provides:
- Element types and their properties
- Player properties and scoring
- Board structure (hex vs grid, dimensions)
- Win conditions and game type hints

**Read the game rules files:**
- `src/rules/elements.ts` - Element classes, properties
- `src/rules/game.ts` - Game class, setup, win conditions
- `src/rules/actions.ts` - Available player actions
- `src/rules/flow.ts` - Turn structure, game phases

---

## Phase 3: Game Type Classification

**CRITICAL**: Identify the game type to determine which patterns apply.

Ask the user: "What type of game is this?"

| Game Type | Examples | Key AI Pattern |
|-----------|----------|----------------|
| **Connection** | Hex, TwixT, Y | Shortest path to goal, blocking opponent's path |
| **Capture** | Chess, Checkers, Go | Material advantage, piece safety, threats |
| **Racing** | Backgammon, Parcheesi | Progress to goal, blocking opponent |
| **Collection** | Go Fish, Rummy | Set completion, blocking opponent's sets |
| **Territory** | Go, Othello | Area control, influence, borders |
| **Mixed** | Many games | Combine relevant patterns |

---

## Phase 4: Targeted Questions by Game Type

Ask game-type-specific questions to design the AI:

### Connection Games
1. "What edges/cells must the player connect to win?"
2. "How do you measure how close a player is to winning?" (usually shortest path)
3. "What makes a move 'blocking'?" (cells on opponent's path)

### Capture Games
1. "What pieces are most valuable?"
2. "How is a piece considered 'safe' vs 'threatened'?"
3. "What constitutes a 'forcing' move?"

### Racing Games
1. "How do you measure progress toward winning?"
2. "Can players block each other? How?"
3. "Are there safe zones or capture mechanics?"

### Collection Games
1. "What are players trying to collect?"
2. "How close is a player to completing a set?"
3. "Can players interfere with each other's collections?"

### Territory Games
1. "How is territory/influence measured?"
2. "What makes a position strong vs weak?"
3. "How do invasions/attacks work?"

---

## Phase 5: Generate All 5 AI Hooks

Create `ai.ts` with all 5 hooks following these patterns:

### File Structure

```typescript
// AI evaluation functions for <GameName>
// Generated by /generate-ai slash command

import type { Game } from '@boardsmith/engine';
import type { Objective, BotMove, ThreatResponse } from '@boardsmith/ai';
import type { <GameClass> } from './game.js';
import { <ElementTypes> } from './elements.js';

// === HELPER FUNCTIONS ===
// (pathfinding, connectivity analysis, threat detection, etc.)

// === HOOK 1: OBJECTIVES ===
export function get<GameName>Objectives(
  game: Game,
  playerSeat: number
): Record<string, Objective> { ... }

// === HOOK 2: THREAT RESPONSE ===
export function get<GameName>ThreatResponseMoves(
  game: Game,
  playerSeat: number,
  availableMoves: BotMove[]
): ThreatResponse { ... }

// === HOOK 3: PLAYOUT POLICY ===
export function get<GameName>PlayoutPolicy(
  game: Game,
  playerIndex: number,
  availableMoves: BotMove[],
  rng: () => number
): BotMove { ... }

// === HOOK 4: MOVE ORDERING ===
export function get<GameName>MoveOrdering(
  game: Game,
  playerIndex: number,
  moves: BotMove[]
): BotMove[] { ... }

// === HOOK 5: UCT CONSTANT ===
export function get<GameName>UctConstant(
  game: Game,
  playerIndex: number
): number { ... }
```

---

## Pattern Reference: Gradient Objectives

**CRITICAL**: Objectives return 0.0-1.0 gradients, NOT boolean true/false.

```typescript
// BAD - binary evaluation
'has-advantage': {
  checker: () => myScore > theirScore,  // Returns true/false
  weight: 5,
}

// GOOD - gradient evaluation
'score-advantage': {
  checker: () => {
    const diff = myScore - theirScore;
    const maxDiff = 10;  // Reasonable max advantage
    // Return 0.0 (max disadvantage) to 1.0 (max advantage)
    return Math.max(0, Math.min(1, (diff + maxDiff) / (2 * maxDiff)));
  },
  weight: 5,
}
```

**Handle infinity/edge cases:**
```typescript
'path-distance-advantage': {
  checker: () => {
    const myPath = computeShortestPath(game, playerSeat);
    const theirPath = computeShortestPath(game, opponentPosition);
    // Handle blocked paths
    if (myPath === Infinity && theirPath === Infinity) return 0.5;
    if (myPath === Infinity) return 0.0;
    if (theirPath === Infinity) return 1.0;
    // Gradient based on relative paths
    const advantage = theirPath - myPath;
    const maxAdvantage = boardSize;
    return Math.max(0, Math.min(1, (advantage + maxAdvantage) / (2 * maxAdvantage)));
  },
  weight: 10,
}
```

**Near-win detection with threshold:**
```typescript
'near-win-within-2': {
  checker: () => {
    const pathLength = computeShortestPath(game, playerSeat);
    if (pathLength === Infinity || pathLength > 2) return 0.0;
    return 1 - pathLength / 2;  // 1.0 at 0, 0.5 at 1, 0.0 at 2
  },
  weight: 8,
}
```

**Opponent threat with squared penalty:**
```typescript
'opponent-near-win': {
  checker: () => {
    const opponentPath = computeShortestPath(game, opponentPosition);
    if (opponentPath === Infinity) return 0.0;
    const linear = Math.max(0, 1 - opponentPath / maxPath);
    return linear * linear;  // Squared for steeper penalty when close
  },
  weight: -10,  // Negative weight = avoid this state
}
```

---

## Pattern Reference: Threat Response

**Returns** `{ moves: BotMove[], urgent: boolean }`

- **urgent=true**: MCTS ONLY considers these moves (forced defense)
- **urgent=false**: These moves are prioritized but not forced

```typescript
export function getThreatResponseMoves(
  game: Game,
  playerSeat: number,
  availableMoves: BotMove[]
): ThreatResponse {
  const opponentPosition = 3 - playerSeat;  // 2-player game

  // 1. Analyze opponent's threat level
  const opponentPath = computeShortestPath(game, opponentPosition);

  // 2. If no immediate threat, return empty
  if (opponentPath >= safeThreshold) {
    return { moves: [], urgent: false };
  }

  // 3. Find blocking moves
  const blockingCellIds = findBlockingCells(game, opponentPosition);
  const blockingIdSet = new Set(blockingCellIds);

  const blockingMoves = availableMoves.filter(move => {
    const cellId = move.args.cell as number | undefined;
    return cellId !== undefined && blockingIdSet.has(cellId);
  });

  // 4. Set urgency based on how close opponent is to winning
  const urgent = opponentPath <= 4;  // Adjust threshold per game

  return { moves: blockingMoves, urgent };
}
```

**For connection games, use bidirectional pathfinding to find ALL blocking cells:**

```typescript
// Find cells on ANY shortest path (not just the first one)
function findBlockingCells(game: GameClass, opponentPosition: number): number[] {
  // 1. Run Dijkstra from start edge → get distFromStart
  // 2. Run Dijkstra from goal edge → get distToGoal
  // 3. Find shortest path length
  // 4. Cell is on shortest path if: distFromStart + distToGoal - cellCost == shortestPath
  // 5. Return IDs of all empty cells on any shortest path
}
```

---

## Pattern Reference: Playout Policy

**CRITICAL**: MUST use weighted-random selection with provided `rng()`. NOT deterministic.

```typescript
export function getPlayoutPolicy(
  game: Game,
  playerIndex: number,
  availableMoves: BotMove[],
  rng: () => number  // MUST use this for random selection
): BotMove {
  if (availableMoves.length <= 1) {
    return availableMoves[0] ?? throw new Error('No moves');
  }

  // 1. Score each move based on heuristics
  const scores: number[] = [];
  let maxScore = -Infinity;

  for (const move of availableMoves) {
    let score = 0;

    // Add game-specific scoring:
    // - Connectivity to own pieces (+2 per neighbor)
    // - Center position bonus (+0.5 * distance)
    // - Path advancement (+1)
    // - Blocking potential (+0.5 * distance)

    scores.push(score);
    maxScore = Math.max(maxScore, score);
  }

  // 2. Convert to weights using softmax
  const weights: number[] = [];
  let totalWeight = 0;

  for (const score of scores) {
    const weight = Math.exp(score - maxScore);  // Shift to prevent overflow
    weights.push(weight);
    totalWeight += weight;
  }

  // 3. Weighted-random selection using rng()
  let target = rng() * totalWeight;
  for (let i = 0; i < availableMoves.length; i++) {
    target -= weights[i];
    if (target <= 0) {
      return availableMoves[i];
    }
  }

  return availableMoves[availableMoves.length - 1];  // Fallback
}
```

---

## Pattern Reference: Move Ordering

**Returns moves sorted by exploration priority (best first):**

```typescript
export function getMoveOrdering(
  game: Game,
  playerIndex: number,
  moves: BotMove[]
): BotMove[] {
  if (moves.length <= 1) return moves;

  // Score each move
  const scoredMoves = moves.map(move => {
    let score = 1;  // Base score

    // Game-specific scoring:
    // - Adjacent to opponent's recent move: +10 (contest)
    // - Adjacent to opponent's stones: +5 (block)
    // - Adjacent to own stones: +3 (connect)
    // - In center region: +2 (strategic)

    return { move, score };
  });

  // Sort by score descending
  scoredMoves.sort((a, b) => b.score - a.score);

  return scoredMoves.map(sm => sm.move);
}
```

---

## Pattern Reference: UCT Constant

**Phase-based exploration tuning:**

```typescript
export function getUctConstant(
  game: Game,
  playerIndex: number
): number {
  // Calculate game progress
  const totalCells = game.board.all(Cell).length;
  const filledCells = game.board.all(Cell).filter(c => c.hasPiece()).length;
  const progress = filledCells / totalCells;

  // Phase-based UCT constant
  if (progress < 0.3) {
    return 1.4;  // Early: moderate exploration
  }
  if (progress < 0.6) {
    return Math.sqrt(2);  // Mid: balanced (theoretical optimum)
  }
  return 1.0;  // Late: focused exploitation
}
```

**Alternative: difficulty-based tuning:**
```typescript
// More exploration for easy mode, less for hard mode
const C_BY_DIFFICULTY = {
  easy: 2.0,    // Very exploratory
  medium: 1.41, // Balanced
  hard: 1.0,    // Focused
};
```

---

## Phase 6: Validation

After generating the code:

1. **Write the file**:
   Save to `src/rules/ai.ts`

2. **Verify TypeScript compiles**:
   ```bash
   npx tsc --noEmit
   ```
   Fix any errors and re-run.

3. **Suggest testing**:
   ```bash
   boardsmith dev --ai 1
   ```

---

## Phase 7: Human Exploit Testing

**CRITICAL**: AI vs AI benchmarks miss obvious human exploits.

**Manual testing checklist:**
- [ ] Play 3-5 games against the AI
- [ ] Try simple, obvious strategies (straight lines, direct attacks)
- [ ] AI blocks obvious winning threats
- [ ] AI doesn't make random-looking moves late game
- [ ] AI responds to central/key position control

**If testing reveals exploits:**
1. Add/improve `threatResponseMoves` for blocking
2. Add/improve `playoutPolicy` for strategic selection
3. Add relevant objectives

---

## Game-Type Specific Guidance

### Connection Games (Hex, TwixT, Y)

**Key algorithms needed:**
- Dijkstra's algorithm for shortest path
- Bidirectional search for finding ALL blocking cells
- Flood fill for connected groups

**Key objectives:**
- `path-distance-advantage` (weight: 10) - Primary evaluation
- `near-win-within-N` (weight: 8/5/3) - Escalating near-win detection
- `opponent-near-win` (weight: -10) - Blocking urgency
- `fewer-groups` (weight: 2) - Connectivity preference

**Threat response:**
- Find empty cells on opponent's shortest path(s)
- urgent=true when opponent ≤4 moves from winning

**Playout policy:**
- Prefer moves adjacent to own stones (connectivity)
- Prefer moves closer to center (early game)
- Prefer moves that shorten own path or lengthen opponent's

### Capture Games (Chess, Checkers)

**Key algorithms needed:**
- Attacked/defended piece detection
- Material counting by piece type
- Mobility calculation

**Key objectives:**
- `material-advantage` (weight: 10) - Piece count
- `piece-safety` (weight: 5) - Protected vs hanging pieces
- `mobility-advantage` (weight: 3) - Available moves
- `central-control` (weight: 2) - Strategic positioning

**Threat response:**
- Identify hanging pieces (attacked but not defended)
- urgent=true for immediate capture threats

**Playout policy:**
- Prefer safe moves (not hanging)
- Prefer moves that create threats
- Avoid moves that allow captures

### Racing Games (Backgammon, Parcheesi)

**Key objectives:**
- `distance-to-goal` (weight: 10) - Progress
- `lead-over-opponent` (weight: 5) - Relative progress
- `safe-piece-count` (weight: 3) - Pieces not at risk

**Threat response:**
- Block opponent when they're close to goal
- urgent=true when opponent is 1-2 moves from winning

### Collection Games (Go Fish, Rummy)

**Key objectives:**
- `sets-completed` (weight: 10) - Winning progress
- `near-complete-sets` (weight: 5) - Cards needed
- `opponent-sets-blocked` (weight: 3) - Interference

**Threat response:**
- Block when opponent is one card from completing set
- urgent=true for immediate win threats

### Territory Games (Go, Othello)

**Key objectives:**
- `territory-control` (weight: 10) - Area owned
- `influence` (weight: 5) - Potential territory
- `border-strength` (weight: 3) - Secure boundaries

**Threat response:**
- Respond to invasions
- urgent=true for threats to large groups

---

## Critical Rules

1. **Gradient objectives** - Return 0.0-1.0, not boolean
2. **Handle infinity** - Path calculations can return Infinity
3. **Use rng()** - Playout policy MUST use weighted-random, not deterministic
4. **playerSeat is 1-indexed** - In 2-player games: 1 or 2
5. **Verify imports** - Check element types match actual class names
6. **Run tsc** - Always verify TypeScript compiles
7. **Test manually** - AI vs AI misses human exploits
8. **Weight semantics** - Positive = maximize, negative = minimize/avoid

---

## Weight Tuning

After creating the AI, weights can be optimized:

```bash
npx boardsmith evolve-ai-weights --generations 5 --population 20
```

This runs evolutionary optimization on the weights in your ai.ts file, preserving all code structure while tuning weight values for better win rates.
